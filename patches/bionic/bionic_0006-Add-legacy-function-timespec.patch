From a0943bd277ed9b5ecaf1c7c1ace7590b1b6da37d Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 20 Aug 2018 22:57:43 +0300
Subject: [PATCH] Add legacy function by accident.

 libc: Fix absolute_timespec_from_timespec overflow.

A legacy library has uncovered an overflow in this function.
absolute_timespec_from_timespec blindly adds a relative timespec to
the current one, ignoring the possibility of tv_sec overflowing.

This was produced by calling pthread_cond_timedwait_relative_np with a
filled (to maximum values) timespec to create a faux 'infinite timeout'.

This is fixed by clamping the value as high as we can determine is safe.

diff --git a/libc/bionic/bionic_time_conversions.cpp b/libc/bionic/bionic_time_conversions.cpp
index f3ca460..b0a41b2 100644
--- a/libc/bionic/bionic_time_conversions.cpp
+++ b/libc/bionic/bionic_time_conversions.cpp
@@ -51,3 +51,13 @@ void timeval_from_timespec(timeval& tv, const timespec& ts) {
   tv.tv_sec = ts.tv_sec;
   tv.tv_usec = ts.tv_nsec / 1000;
 }
+
+void absolute_timespec_from_timespec(timespec& abs_ts, const timespec& ts, clockid_t clock) {
+  clock_gettime(clock, &abs_ts);
+  abs_ts.tv_sec += ts.tv_sec;
+  abs_ts.tv_nsec += ts.tv_nsec;
+  if (abs_ts.tv_nsec >= NS_PER_S) {
+    abs_ts.tv_nsec -= NS_PER_S;
+    abs_ts.tv_sec++;
+  }
+}
diff --git a/libc/private/bionic_time_conversions.h b/libc/private/bionic_time_conversions.h
index f3ca461..b0a41b2 100644
--- a/libc/private/bionic_time_conversions.h
+++ b/libc/private/bionic_time_conversions.h
@@ -42,6 +42,9 @@ __LIBC_HIDDEN__ void timespec_from_ms(timespec& ts, const int ms);
 
 __LIBC_HIDDEN__ void timeval_from_timespec(timeval& tv, const timespec& ts);
 
+__LIBC_HIDDEN__ void absolute_timespec_from_timespec(timespec& abs_ts, const timespec& ts,
+                                                     clockid_t clock);
+
 __END_DECLS
 
 static inline int check_timespec(const timespec* ts, bool null_allowed) {
@@ -59,16 +62,4 @@ static inline int check_timespec(const timespec* ts, bool null_allowed) {
   return 0;
 }
 
-#if !defined(__LP64__)
-static inline void absolute_timespec_from_timespec(timespec& abs_ts, const timespec& ts, clockid_t clock) {
-  clock_gettime(clock, &abs_ts);
-  abs_ts.tv_sec += ts.tv_sec;
-  abs_ts.tv_nsec += ts.tv_nsec;
-  if (abs_ts.tv_nsec >= NS_PER_S) {
-    abs_ts.tv_nsec -= NS_PER_S;
-    abs_ts.tv_sec++;
-  }
-}
-#endif
-
 #endif
diff --git a/libc/bionic/bionic_time_conversions.cpp b/libc/bionic/bionic_time_conversions.cpp
index f3ca46a..b0a41b2 100644
--- a/libc/bionic/bionic_time_conversions.cpp
+++ b/libc/bionic/bionic_time_conversions.cpp
@@ -26,6 +26,9 @@
  * SUCH DAMAGE.
  */
 
+#include <stdint.h>
+#include <sys/param.h>
+
 #include "private/bionic_time_conversions.h"
 
 #include "private/bionic_constants.h"
@@ -54,10 +57,23 @@
 
 void absolute_timespec_from_timespec(timespec& abs_ts, const timespec& ts, clockid_t clock) {
   clock_gettime(clock, &abs_ts);
+  time_t clock_tv_sec = abs_ts.tv_sec;
   abs_ts.tv_sec += ts.tv_sec;
   abs_ts.tv_nsec += ts.tv_nsec;
   if (abs_ts.tv_nsec >= NS_PER_S) {
     abs_ts.tv_nsec -= NS_PER_S;
     abs_ts.tv_sec++;
   }
+  // With a large relative timespec we might overflow.
+  // Because time_t is arbitrary, we should be fancy handling this.
+  if (abs_ts.tv_sec < clock_tv_sec) {
+    if (sizeof(time_t) == sizeof(int32_t)) {
+      abs_ts.tv_sec = INT32_MAX;
+    } else if (sizeof(time_t) == sizeof(int64_t)) {
+      abs_ts.tv_sec = INT64_MAX;
+    } else {
+      // Just take the largest of the two initial values and hope for the best.
+      abs_ts.tv_sec = MAX(clock_tv_sec, ts.tv_sec);
+    }
+  }
 }
