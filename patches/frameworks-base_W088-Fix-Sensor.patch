sensors: reset to 7.1.2 
SensorManager: compilation fixes 

diff --git a/core/jni/android_hardware_SensorManager.cpp b/core/jni/android_hardware_SensorManager.cpp
index dae96523f88c..f254a81a1892 100644
--- a/core/jni/android_hardware_SensorManager.cpp
+++ b/core/jni/android_hardware_SensorManager.cpp
@@ -15,20 +15,17 @@
  */
 #define LOG_TAG "SensorManager"
 
-#include <nativehelper/JNIHelp.h>
+#include "JNIHelp.h"
 #include "android_os_MessageQueue.h"
 #include "core_jni_helpers.h"
 #include "jni.h"
 
-#include <nativehelper/ScopedUtfChars.h>
-#include <nativehelper/ScopedLocalRef.h>
+#include <ScopedUtfChars.h>
+#include <ScopedLocalRef.h>
 #include <android_runtime/AndroidRuntime.h>
-#include <android_runtime/android_hardware_HardwareBuffer.h>
-#include <vndk/hardware_buffer.h>
 #include <sensor/Sensor.h>
 #include <sensor/SensorEventQueue.h>
 #include <sensor/SensorManager.h>
-#include <cutils/native_handle.h>
 #include <utils/Log.h>
 #include <utils/Looper.h>
 #include <utils/Vector.h>
@@ -75,12 +72,6 @@ struct ListOffsets {
     jmethodID   add;
 } gListOffsets;
 
-struct StringOffsets {
-    jclass      clazz;
-    jmethodID   intern;
-    jstring     emptyString;
-} gStringOffsets;
-
 /*
  * nativeClassInit is not inteneded to be thread-safe. It should be called before other native...
  * functions (except nativeCreate).
@@ -90,55 +81,75 @@ nativeClassInit (JNIEnv *_env, jclass _this)
 {
     //android.hardware.Sensor
     SensorOffsets& sensorOffsets = gSensorOffsets;
-    jclass sensorClass = (jclass)
-            MakeGlobalRefOrDie(_env, FindClassOrDie(_env, "android/hardware/Sensor"));
-    sensorOffsets.clazz = sensorClass;
-    sensorOffsets.name = GetFieldIDOrDie(_env, sensorClass, "mName", "Ljava/lang/String;");
-    sensorOffsets.vendor = GetFieldIDOrDie(_env, sensorClass, "mVendor", "Ljava/lang/String;");
-    sensorOffsets.version = GetFieldIDOrDie(_env, sensorClass, "mVersion", "I");
-    sensorOffsets.handle = GetFieldIDOrDie(_env, sensorClass, "mHandle", "I");
-    sensorOffsets.range = GetFieldIDOrDie(_env, sensorClass, "mMaxRange", "F");
-    sensorOffsets.resolution = GetFieldIDOrDie(_env, sensorClass, "mResolution","F");
-    sensorOffsets.power = GetFieldIDOrDie(_env, sensorClass, "mPower", "F");
-    sensorOffsets.minDelay = GetFieldIDOrDie(_env, sensorClass, "mMinDelay", "I");
+    jclass sensorClass = (jclass) _env->NewGlobalRef(_env->FindClass("android/hardware/Sensor"));
+    sensorOffsets.clazz       = sensorClass;
+    sensorOffsets.name        = _env->GetFieldID(sensorClass, "mName",      "Ljava/lang/String;");
+    sensorOffsets.vendor      = _env->GetFieldID(sensorClass, "mVendor",    "Ljava/lang/String;");
+    sensorOffsets.version     = _env->GetFieldID(sensorClass, "mVersion",   "I");
+    sensorOffsets.handle      = _env->GetFieldID(sensorClass, "mHandle",    "I");
+    sensorOffsets.range       = _env->GetFieldID(sensorClass, "mMaxRange",  "F");
+    sensorOffsets.resolution  = _env->GetFieldID(sensorClass, "mResolution","F");
+    sensorOffsets.power       = _env->GetFieldID(sensorClass, "mPower",     "F");
+    sensorOffsets.minDelay    = _env->GetFieldID(sensorClass, "mMinDelay",  "I");
     sensorOffsets.fifoReservedEventCount =
-            GetFieldIDOrDie(_env,sensorClass, "mFifoReservedEventCount", "I");
-    sensorOffsets.fifoMaxEventCount = GetFieldIDOrDie(_env,sensorClass, "mFifoMaxEventCount", "I");
-    sensorOffsets.stringType =
-            GetFieldIDOrDie(_env,sensorClass, "mStringType", "Ljava/lang/String;");
-    sensorOffsets.requiredPermission =
-            GetFieldIDOrDie(_env,sensorClass, "mRequiredPermission", "Ljava/lang/String;");
-    sensorOffsets.maxDelay = GetFieldIDOrDie(_env,sensorClass, "mMaxDelay", "I");
-    sensorOffsets.flags = GetFieldIDOrDie(_env,sensorClass, "mFlags", "I");
-
-    sensorOffsets.setType = GetMethodIDOrDie(_env,sensorClass, "setType", "(I)Z");
-    sensorOffsets.setUuid = GetMethodIDOrDie(_env,sensorClass, "setUuid", "(JJ)V");
-    sensorOffsets.init = GetMethodIDOrDie(_env,sensorClass, "<init>", "()V");
+            _env->GetFieldID(sensorClass, "mFifoReservedEventCount",  "I");
+    sensorOffsets.fifoMaxEventCount = _env->GetFieldID(sensorClass, "mFifoMaxEventCount",  "I");
+    sensorOffsets.stringType = _env->GetFieldID(sensorClass, "mStringType", "Ljava/lang/String;");
+    sensorOffsets.requiredPermission = _env->GetFieldID(sensorClass, "mRequiredPermission",
+                                                        "Ljava/lang/String;");
+    sensorOffsets.maxDelay    = _env->GetFieldID(sensorClass, "mMaxDelay",  "I");
+    sensorOffsets.flags = _env->GetFieldID(sensorClass, "mFlags",  "I");
+
+    sensorOffsets.setType = _env->GetMethodID(sensorClass, "setType", "(I)Z");
+    sensorOffsets.setUuid = _env->GetMethodID(sensorClass, "setUuid", "(JJ)V");
+    sensorOffsets.init = _env->GetMethodID(sensorClass, "<init>", "()V");
 
     // java.util.List;
     ListOffsets& listOffsets = gListOffsets;
-    jclass listClass = (jclass) MakeGlobalRefOrDie(_env, FindClassOrDie(_env, "java/util/List"));
+    jclass listClass = (jclass) _env->NewGlobalRef(_env->FindClass("java/util/List"));
     listOffsets.clazz = listClass;
-    listOffsets.add = GetMethodIDOrDie(_env,listClass, "add", "(Ljava/lang/Object;)Z");
-
-    // initialize java.lang.String and empty string intern
-    StringOffsets& stringOffsets = gStringOffsets;
-    stringOffsets.clazz = MakeGlobalRefOrDie(_env, FindClassOrDie(_env, "java/lang/String"));
-    stringOffsets.intern =
-            GetMethodIDOrDie(_env, stringOffsets.clazz, "intern", "()Ljava/lang/String;");
-    ScopedLocalRef<jstring> empty(_env, _env->NewStringUTF(""));
-    stringOffsets.emptyString = (jstring)
-            MakeGlobalRefOrDie(_env, _env->CallObjectMethod(empty.get(), stringOffsets.intern));
+    listOffsets.add = _env->GetMethodID(listClass, "add", "(Ljava/lang/Object;)Z");
 }
 
-static jstring getJavaInternedString(JNIEnv *env, const String8 &string) {
-    if (string == "") {
-        return gStringOffsets.emptyString;
+/**
+ * A key comparator predicate.
+ * It is used to intern strings associated with Sensor data.
+ * It defines a 'Strict weak ordering' for the interned strings.
+ */
+class InternedStringCompare {
+public:
+    bool operator()(const String8* string1, const String8* string2) const {
+        if (string1 == NULL) {
+            return string2 != NULL;
+        }
+        if (string2 == NULL) {
+            return false;
+        }
+        return string1->compare(*string2) < 0;
     }
+};
 
-    ScopedLocalRef<jstring> javaString(env, env->NewStringUTF(string.string()));
-    jstring internedString = (jstring)
-            env->CallObjectMethod(javaString.get(), gStringOffsets.intern);
+/**
+ * A localized interning mechanism for Sensor strings.
+ * We implement our own interning to avoid the overhead of using java.lang.String#intern().
+ * It is common that Vendor, StringType, and RequirePermission data is common between many of the
+ * Sensors, by interning the memory usage to represent Sensors is optimized.
+ */
+static jstring
+getInternedString(JNIEnv *env, const String8* string) {
+    static std::map<const String8*, jstring, InternedStringCompare> internedStrings;
+
+    jstring internedString;
+    std::map<const String8*, jstring>::iterator iterator = internedStrings.find(string);
+    if (iterator != internedStrings.end()) {
+        internedString = iterator->second;
+    } else {
+        jstring localString = env->NewStringUTF(string->string());
+        // we are implementing our own interning so expect these strings to be backed by global refs
+        internedString = (jstring) env->NewGlobalRef(localString);
+        internedStrings.insert(std::make_pair(string, internedString));
+        env->DeleteLocalRef(localString);
+    }
     return internedString;
 }
 
@@ -160,10 +171,10 @@ translateNativeSensorToJavaSensor(JNIEnv *env, jobject sensor, const Sensor& nat
     }
 
     if (sensor != NULL) {
-        jstring name = getJavaInternedString(env, nativeSensor.getName());
-        jstring vendor = getJavaInternedString(env, nativeSensor.getVendor());
+        jstring name = env->NewStringUTF(nativeSensor.getName().string());
+        jstring vendor = env->NewStringUTF(nativeSensor.getVendor().string());
         jstring requiredPermission =
-                getJavaInternedString(env, nativeSensor.getRequiredPermission());
+                env->NewStringUTF(nativeSensor.getRequiredPermission().string());
 
         env->SetObjectField(sensor, sensorOffsets.name,      name);
         env->SetObjectField(sensor, sensorOffsets.vendor,    vendor);
@@ -184,7 +195,7 @@ translateNativeSensorToJavaSensor(JNIEnv *env, jobject sensor, const Sensor& nat
 
         if (env->CallBooleanMethod(sensor, sensorOffsets.setType, nativeSensor.getType())
                 == JNI_FALSE) {
-            jstring stringType = getJavaInternedString(env, nativeSensor.getStringType());
+            jstring stringType = getInternedString(env, &nativeSensor.getStringType());
             env->SetObjectField(sensor, sensorOffsets.stringType, stringType);
         }
 
@@ -201,11 +212,7 @@ nativeGetSensorAtIndex(JNIEnv *env, jclass clazz, jlong sensorManager, jobject s
     SensorManager* mgr = reinterpret_cast<SensorManager*>(sensorManager);
 
     Sensor const* const* sensorList;
-#ifdef COMPAT_SENSORS_M
-    const ssize_t count = mgr->getSensorList(&sensorList);
-#else
     ssize_t count = mgr->getSensorList(&sensorList);
-#endif
     if (ssize_t(index) >= count) {
         return false;
     }
@@ -223,7 +230,7 @@ nativeGetDynamicSensors(JNIEnv *env, jclass clazz, jlong sensorManager, jobject
 
     mgr->getDynamicSensorList(nativeList);
 
-    ALOGI("DYNS native SensorManager.getDynamicSensorList return %zu sensors", nativeList.size());
+    ALOGI("DYNS native SensorManager.getDynamicSensorList return %d sensors", nativeList.size());
     for (size_t i = 0; i < nativeList.size(); ++i) {
         jobject sensor = translateNativeSensorToJavaSensor(env, NULL, nativeList[i]);
         // add to list
@@ -236,62 +243,6 @@ static jboolean nativeIsDataInjectionEnabled(JNIEnv *_env, jclass _this, jlong s
     return mgr->isDataInjectionEnabled();
 }
 
-static jint nativeCreateDirectChannel(JNIEnv *_env, jclass _this, jlong sensorManager,
-        jlong size, jint channelType, jint fd, jobject hardwareBufferObj) {
-    const native_handle_t *nativeHandle = nullptr;
-    NATIVE_HANDLE_DECLARE_STORAGE(ashmemHandle, 1, 0);
-
-    if (channelType == SENSOR_DIRECT_MEM_TYPE_ASHMEM) {
-        native_handle_t *handle = native_handle_init(ashmemHandle, 1, 0);
-        handle->data[0] = fd;
-        nativeHandle = handle;
-    } else if (channelType == SENSOR_DIRECT_MEM_TYPE_GRALLOC) {
-        AHardwareBuffer *hardwareBuffer =
-                android_hardware_HardwareBuffer_getNativeHardwareBuffer(_env, hardwareBufferObj);
-        if (hardwareBuffer != nullptr) {
-            nativeHandle = AHardwareBuffer_getNativeHandle(hardwareBuffer);
-        }
-    }
-
-    if (nativeHandle == nullptr) {
-        return BAD_VALUE;
-    }
-
-    SensorManager* mgr = reinterpret_cast<SensorManager*>(sensorManager);
-    return mgr->createDirectChannel(size, channelType, nativeHandle);
-}
-
-static void nativeDestroyDirectChannel(JNIEnv *_env, jclass _this, jlong sensorManager,
-        jint channelHandle) {
-    SensorManager* mgr = reinterpret_cast<SensorManager*>(sensorManager);
-    mgr->destroyDirectChannel(channelHandle);
-}
-
-static jint nativeConfigDirectChannel(JNIEnv *_env, jclass _this, jlong sensorManager,
-        jint channelHandle, jint sensorHandle, jint rate) {
-    SensorManager* mgr = reinterpret_cast<SensorManager*>(sensorManager);
-    return mgr->configureDirectChannel(channelHandle, sensorHandle, rate);
-}
-
-static jint nativeSetOperationParameter(JNIEnv *_env, jclass _this, jlong sensorManager,
-        jint handle, jint type, jfloatArray floats, jintArray ints) {
-    SensorManager* mgr = reinterpret_cast<SensorManager*>(sensorManager);
-    Vector<float> floatVector;
-    Vector<int32_t> int32Vector;
-
-    if (floats != nullptr) {
-        floatVector.resize(_env->GetArrayLength(floats));
-        _env->GetFloatArrayRegion(floats, 0, _env->GetArrayLength(floats), floatVector.editArray());
-    }
-
-    if (ints != nullptr) {
-        int32Vector.resize(_env->GetArrayLength(ints));
-        _env->GetIntArrayRegion(ints, 0, _env->GetArrayLength(ints), int32Vector.editArray());
-    }
-
-    return mgr->setOperationParameter(handle, type, floatVector, int32Vector);
-}
-
 //----------------------------------------------------------------------------
 
 class Receiver : public LooperCallback {
@@ -431,11 +382,6 @@ static jlong nativeInitSensorEventQueue(JNIEnv *env, jclass clazz, jlong sensorM
     String8 clientName(packageUtf.c_str());
     sp<SensorEventQueue> queue(mgr->createEventQueue(clientName, mode));
 
-    if (queue == NULL) {
-        jniThrowRuntimeException(env, "Cannot construct native SensorEventQueue.");
-        return 0;
-    }
-
     sp<MessageQueue> messageQueue = android_os_MessageQueue_getMessageQueue(env, msgQ);
     if (messageQueue == NULL) {
         jniThrowRuntimeException(env, "MessageQueue is not initialized.");
@@ -501,23 +447,7 @@ static const JNINativeMethod gSystemSensorManagerMethods[] = {
 
     {"nativeIsDataInjectionEnabled",
             "(J)Z",
-            (void*)nativeIsDataInjectionEnabled },
-
-    {"nativeCreateDirectChannel",
-            "(JJIILandroid/hardware/HardwareBuffer;)I",
-            (void*)nativeCreateDirectChannel },
-
-    {"nativeDestroyDirectChannel",
-            "(JI)V",
-            (void*)nativeDestroyDirectChannel },
-
-    {"nativeConfigDirectChannel",
-            "(JIII)I",
-            (void*)nativeConfigDirectChannel },
-
-    {"nativeSetOperationParameter",
-            "(JII[F[I)I",
-            (void*)nativeSetOperationParameter },
+            (void*)nativeIsDataInjectionEnabled},
 };
 
 static const JNINativeMethod gBaseEventQueueMethods[] = {
diff --git a/native/android/Android.bp b/native/android/Android.bp
index 00fe6382fc17..d6f27f7b1704 100644
--- a/native/android/Android.bp
+++ b/native/android/Android.bp
@@ -22,12 +22,6 @@ ndk_library {
 
 cc_defaults {
     name: "libandroid_defaults",
-    cflags: [
-        "-Wall",
-        "-Werror",
-        "-Wunused",
-        "-Wunreachable-code",
-    ],
 }
 
 cc_library_shared {
diff --git a/native/android/sensor.cpp b/native/android/sensor.cpp
index 8e5821024cee..b2cb18fa42e4 100644
--- a/native/android/sensor.cpp
+++ b/native/android/sensor.cpp
@@ -19,15 +19,14 @@
 
 #include <android/looper.h>
 #include <android/sensor.h>
-#include <android/sharedmem.h>
-#include <cutils/native_handle.h>
+
+#include <utils/RefBase.h>
+#include <utils/Looper.h>
+#include <utils/Timers.h>
+
 #include <sensor/Sensor.h>
 #include <sensor/SensorManager.h>
 #include <sensor/SensorEventQueue.h>
-#include <utils/Looper.h>
-#include <utils/RefBase.h>
-#include <utils/Timers.h>
-#include <vndk/hardware_buffer.h>
 
 #include <poll.h>
 
@@ -39,33 +38,13 @@ using android::String8;
 using android::String16;
 
 /*****************************************************************************/
-#define ERROR_INVALID_PARAMETER(message) ALOGE("%s: " message, __func__)
-
-// frequently used checks
-#define RETURN_IF_MANAGER_IS_NULL(retval) do {\
-        if (manager == nullptr) { \
-            ERROR_INVALID_PARAMETER("manager cannot be NULL"); \
-            return retval; \
-        } \
-    } while (false)
-#define RETURN_IF_SENSOR_IS_NULL(retval) do {\
-        if (sensor == nullptr) { \
-            ERROR_INVALID_PARAMETER("sensor cannot be NULL"); \
-            return retval; \
-        } \
-    } while (false)
-#define RETURN_IF_QUEUE_IS_NULL(retval) do {\
-        if (queue == nullptr) { \
-            ERROR_INVALID_PARAMETER("queue cannot be NULL"); \
-            return retval; \
-        } \
-    } while (false)
-
-ASensorManager* ASensorManager_getInstance() {
-    return ASensorManager_getInstanceForPackage(nullptr);
+ASensorManager* ASensorManager_getInstance()
+{
+    return ASensorManager_getInstanceForPackage(NULL);
 }
 
-ASensorManager* ASensorManager_getInstanceForPackage(const char* packageName) {
+ASensorManager* ASensorManager_getInstanceForPackage(const char* packageName)
+{
     if (packageName) {
         return &SensorManager::getInstanceForPackage(String16(packageName));
     } else {
@@ -73,8 +52,9 @@ ASensorManager* ASensorManager_getInstanceForPackage(const char* packageName) {
     }
 }
 
-int ASensorManager_getSensorList(ASensorManager* manager, ASensorList* list) {
-    RETURN_IF_MANAGER_IS_NULL(android::BAD_VALUE);
+int ASensorManager_getSensorList(ASensorManager* manager,
+        ASensorList* list)
+{
     Sensor const* const* l;
     int c = static_cast<SensorManager*>(manager)->getSensorList(&l);
     if (list) {
@@ -83,13 +63,13 @@ int ASensorManager_getSensorList(ASensorManager* manager, ASensorList* list) {
     return c;
 }
 
-ASensor const* ASensorManager_getDefaultSensor(ASensorManager* manager, int type) {
-    RETURN_IF_MANAGER_IS_NULL(nullptr);
+ASensor const* ASensorManager_getDefaultSensor(ASensorManager* manager, int type)
+{
     return static_cast<SensorManager*>(manager)->getDefaultSensor(type);
 }
 
-ASensor const* ASensorManager_getDefaultSensorEx(ASensorManager* manager, int type, bool wakeUp) {
-    RETURN_IF_MANAGER_IS_NULL(nullptr);
+ASensor const* ASensorManager_getDefaultSensorEx(ASensorManager* manager,
+        int type, bool wakeUp) {
     Sensor const* const* sensorList;
     size_t size = static_cast<SensorManager*>(manager)->getSensorList(&sensorList);
     for (size_t i = 0; i < size; ++i) {
@@ -98,18 +78,12 @@ ASensor const* ASensorManager_getDefaultSensorEx(ASensorManager* manager, int ty
             return reinterpret_cast<ASensor const *>(sensorList[i]);
        }
     }
-    return nullptr;
+    return NULL;
 }
 
 ASensorEventQueue* ASensorManager_createEventQueue(ASensorManager* manager,
-        ALooper* looper, int ident, ALooper_callbackFunc callback, void* data) {
-    RETURN_IF_MANAGER_IS_NULL(nullptr);
-
-    if (looper == nullptr) {
-        ERROR_INVALID_PARAMETER("looper cannot be NULL");
-        return nullptr;
-    }
-
+        ALooper* looper, int ident, ALooper_callbackFunc callback, void* data)
+{
     sp<SensorEventQueue> queue =
             static_cast<SensorManager*>(manager)->createEventQueue();
     if (queue != 0) {
@@ -120,137 +94,46 @@ ASensorEventQueue* ASensorManager_createEventQueue(ASensorManager* manager,
     return static_cast<ASensorEventQueue*>(queue.get());
 }
 
-int ASensorManager_destroyEventQueue(ASensorManager* manager, ASensorEventQueue* queue) {
-    RETURN_IF_MANAGER_IS_NULL(android::BAD_VALUE);
-    RETURN_IF_QUEUE_IS_NULL(android::BAD_VALUE);
-
-    sp<SensorEventQueue> q = static_cast<SensorEventQueue*>(queue);
-    ALooper_removeFd(q->looper, q->getFd());
-    q->decStrong(manager);
+int ASensorManager_destroyEventQueue(ASensorManager* manager,
+        ASensorEventQueue* inQueue)
+{
+    sp<SensorEventQueue> queue = static_cast<SensorEventQueue*>(inQueue);
+    ALooper_removeFd(queue->looper, queue->getFd());
+    queue->decStrong(manager);
     return 0;
 }
 
-int ASensorManager_createSharedMemoryDirectChannel(ASensorManager *manager, int fd, size_t size) {
-    RETURN_IF_MANAGER_IS_NULL(android::BAD_VALUE);
-
-    if (fd < 0) {
-        ERROR_INVALID_PARAMETER("fd is invalid.");
-        return android::BAD_VALUE;
-    }
-
-    if (size < sizeof(ASensorEvent)) {
-        ERROR_INVALID_PARAMETER("size has to be greater or equal to sizeof(ASensorEvent).");
-        return android::BAD_VALUE;
-    }
-
-    native_handle_t *resourceHandle = native_handle_create(1 /* nFd */, 0 /* nInt */);
-    if (!resourceHandle) {
-        return android::NO_MEMORY;
-    }
-
-    resourceHandle->data[0] = fd;
-    int ret = static_cast<SensorManager *>(manager)->createDirectChannel(
-            size, ASENSOR_DIRECT_CHANNEL_TYPE_SHARED_MEMORY, resourceHandle);
-    native_handle_delete(resourceHandle);
-    return ret;
-}
-
-int ASensorManager_createHardwareBufferDirectChannel(
-        ASensorManager *manager, AHardwareBuffer const *buffer, size_t size) {
-    RETURN_IF_MANAGER_IS_NULL(android::BAD_VALUE);
-
-    if (buffer == nullptr) {
-        ERROR_INVALID_PARAMETER("buffer cannot be NULL");
-        return android::BAD_VALUE;
-    }
-
-    if (size < sizeof(ASensorEvent)) {
-        ERROR_INVALID_PARAMETER("size has to be greater or equal to sizeof(ASensorEvent).");
-        return android::BAD_VALUE;
-    }
-
-    const native_handle_t *resourceHandle = AHardwareBuffer_getNativeHandle(buffer);
-    if (!resourceHandle) {
-        return android::NO_MEMORY;
-    }
-
-    return static_cast<SensorManager *>(manager)->createDirectChannel(
-            size, ASENSOR_DIRECT_CHANNEL_TYPE_HARDWARE_BUFFER, resourceHandle);
-}
-
-void ASensorManager_destroyDirectChannel(ASensorManager *manager, int channelId) {
-    RETURN_IF_MANAGER_IS_NULL(void());
-
-    static_cast<SensorManager *>(manager)->destroyDirectChannel(channelId);
-}
-
-int ASensorManager_configureDirectReport(
-        ASensorManager *manager, ASensor const *sensor, int channelId, int rate) {
-    RETURN_IF_MANAGER_IS_NULL(android::BAD_VALUE);
-
-    int sensorHandle;
-    if (sensor == nullptr) {
-        if (rate != ASENSOR_DIRECT_RATE_STOP) {
-            ERROR_INVALID_PARAMETER(
-                "sensor cannot be null when rate is not ASENSOR_DIRECT_RATE_STOP");
-            return android::BAD_VALUE;
-        }
-        sensorHandle = -1;
-    } else {
-        sensorHandle = static_cast<Sensor const *>(sensor)->getHandle();
-    }
-    return static_cast<SensorManager *>(manager)->configureDirectChannel(
-            channelId, sensorHandle, rate);
-}
-
 /*****************************************************************************/
 
 int ASensorEventQueue_registerSensor(ASensorEventQueue* queue, ASensor const* sensor,
-        int32_t samplingPeriodUs, int64_t maxBatchReportLatencyUs) {
-    RETURN_IF_QUEUE_IS_NULL(android::BAD_VALUE);
-    RETURN_IF_SENSOR_IS_NULL(android::BAD_VALUE);
-    if (samplingPeriodUs < 0 || maxBatchReportLatencyUs < 0) {
-        ERROR_INVALID_PARAMETER("samplingPeriodUs and maxBatchReportLatencyUs cannot be negative");
-        return android::BAD_VALUE;
-    }
-
+        int32_t samplingPeriodUs, int maxBatchReportLatencyUs)
+{
     return static_cast<SensorEventQueue*>(queue)->enableSensor(
             static_cast<Sensor const*>(sensor)->getHandle(), samplingPeriodUs,
                     maxBatchReportLatencyUs, 0);
 }
 
-int ASensorEventQueue_enableSensor(ASensorEventQueue* queue, ASensor const* sensor) {
-    RETURN_IF_QUEUE_IS_NULL(android::BAD_VALUE);
-    RETURN_IF_SENSOR_IS_NULL(android::BAD_VALUE);
-
+int ASensorEventQueue_enableSensor(ASensorEventQueue* queue, ASensor const* sensor)
+{
     return static_cast<SensorEventQueue*>(queue)->enableSensor(
             static_cast<Sensor const*>(sensor));
 }
 
-int ASensorEventQueue_disableSensor(ASensorEventQueue* queue, ASensor const* sensor) {
-    RETURN_IF_QUEUE_IS_NULL(android::BAD_VALUE);
-    RETURN_IF_SENSOR_IS_NULL(android::BAD_VALUE);
-
+int ASensorEventQueue_disableSensor(ASensorEventQueue* queue, ASensor const* sensor)
+{
     return static_cast<SensorEventQueue*>(queue)->disableSensor(
             static_cast<Sensor const*>(sensor));
 }
 
-int ASensorEventQueue_setEventRate(ASensorEventQueue* queue, ASensor const* sensor, int32_t usec) {
-    RETURN_IF_QUEUE_IS_NULL(android::BAD_VALUE);
-    RETURN_IF_SENSOR_IS_NULL(android::BAD_VALUE);
-
-    if (usec < 0) {
-        ERROR_INVALID_PARAMETER("usec cannot be negative");
-        return android::BAD_VALUE;
-    }
-
+int ASensorEventQueue_setEventRate(ASensorEventQueue* queue, ASensor const* sensor,
+        int32_t usec)
+{
     return static_cast<SensorEventQueue*>(queue)->setEventRate(
             static_cast<Sensor const*>(sensor), us2ns(usec));
 }
 
-int ASensorEventQueue_hasEvents(ASensorEventQueue* queue) {
-    RETURN_IF_QUEUE_IS_NULL(android::BAD_VALUE);
-
+int ASensorEventQueue_hasEvents(ASensorEventQueue* queue)
+{
     struct pollfd pfd;
     pfd.fd = static_cast<SensorEventQueue*>(queue)->getFd();
     pfd.events = POLLIN;
@@ -267,13 +150,9 @@ int ASensorEventQueue_hasEvents(ASensorEventQueue* queue) {
     return (nfd == 0) ? 0 : 1;
 }
 
-ssize_t ASensorEventQueue_getEvents(ASensorEventQueue* queue, ASensorEvent* events, size_t count) {
-    RETURN_IF_QUEUE_IS_NULL(android::BAD_VALUE);
-    if (events == nullptr) {
-        ERROR_INVALID_PARAMETER("events cannot be NULL");
-        return android::BAD_VALUE;
-    }
-
+ssize_t ASensorEventQueue_getEvents(ASensorEventQueue* queue,
+                ASensorEvent* events, size_t count)
+{
     ssize_t actual = static_cast<SensorEventQueue*>(queue)->read(events, count);
     if (actual > 0) {
         static_cast<SensorEventQueue*>(queue)->sendAck(events, actual);
@@ -283,62 +162,52 @@ ssize_t ASensorEventQueue_getEvents(ASensorEventQueue* queue, ASensorEvent* even
 
 /*****************************************************************************/
 
-const char* ASensor_getName(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(nullptr);
+const char* ASensor_getName(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getName().string();
 }
 
-const char* ASensor_getVendor(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(nullptr);
+const char* ASensor_getVendor(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getVendor().string();
 }
 
-int ASensor_getType(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(ASENSOR_TYPE_INVALID);
+int ASensor_getType(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getType();
 }
 
-float ASensor_getResolution(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(ASENSOR_RESOLUTION_INVALID);
+float ASensor_getResolution(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getResolution();
 }
 
-int ASensor_getMinDelay(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(ASENSOR_DELAY_INVALID);
+int ASensor_getMinDelay(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getMinDelay();
 }
 
-int ASensor_getFifoMaxEventCount(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(ASENSOR_FIFO_COUNT_INVALID);
+int ASensor_getFifoMaxEventCount(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getFifoMaxEventCount();
 }
 
-int ASensor_getFifoReservedEventCount(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(ASENSOR_FIFO_COUNT_INVALID);
+int ASensor_getFifoReservedEventCount(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getFifoReservedEventCount();
 }
 
-const char* ASensor_getStringType(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(nullptr);
+const char* ASensor_getStringType(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getStringType().string();
 }
 
-int ASensor_getReportingMode(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(AREPORTING_MODE_INVALID);
+int ASensor_getReportingMode(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getReportingMode();
 }
 
-bool ASensor_isWakeUpSensor(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(false);
+bool ASensor_isWakeUpSensor(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->isWakeUpSensor();
 }
-
-bool ASensor_isDirectChannelTypeSupported(ASensor const *sensor, int channelType) {
-    RETURN_IF_SENSOR_IS_NULL(false);
-    return static_cast<Sensor const *>(sensor)->isDirectChannelTypeSupported(channelType);
-}
-
-int ASensor_getHighestDirectReportRateLevel(ASensor const *sensor) {
-    RETURN_IF_SENSOR_IS_NULL(ASENSOR_DIRECT_RATE_STOP);
-    return static_cast<Sensor const *>(sensor)->getHighestDirectReportRateLevel();
-}
diff --git a/services/core/jni/Android.mk b/services/core/jni/Android.mk
index bf9f941ad9a3..ab72e207696a 100644
--- a/services/core/jni/Android.mk
+++ b/services/core/jni/Android.mk
@@ -77,7 +77,6 @@ LOCAL_SHARED_LIBRARIES += \
     libinputservice \
     libschedulerservicehidl \
     libsensorservice \
-    libsensorservicehidl \
     libskia \
     libgui \
     libusbhost \
diff --git a/services/core/jni/com_android_server_SystemServer.cpp b/services/core/jni/com_android_server_SystemServer.cpp
index 3901cebcc787..87bfb9297c1e 100644
--- a/services/core/jni/com_android_server_SystemServer.cpp
+++ b/services/core/jni/com_android_server_SystemServer.cpp
@@ -21,7 +21,7 @@
 
 #include <schedulerservice/SchedulingPolicyService.h>
 #include <sensorservice/SensorService.h>
-#include <sensorservicehidl/SensorManager.h>
+//#include <sensorservicehidl/SensorManager.h>
 
 #include <cutils/properties.h>
 #include <utils/Log.h>
@@ -39,27 +39,7 @@ static void android_server_SystemServer_startSensorService(JNIEnv* /* env */, jo
 
 }
 
-static void android_server_SystemServer_startHidlServices(JNIEnv* env, jobject /* clazz */) {
-    using ::android::frameworks::schedulerservice::V1_0::ISchedulingPolicyService;
-    using ::android::frameworks::schedulerservice::V1_0::implementation::SchedulingPolicyService;
-    using ::android::frameworks::sensorservice::V1_0::ISensorManager;
-    using ::android::frameworks::sensorservice::V1_0::implementation::SensorManager;
-    using ::android::hardware::configureRpcThreadpool;
-
-    status_t err;
-
-    configureRpcThreadpool(5, false /* callerWillJoin */);
-
-    JavaVM *vm;
-    LOG_ALWAYS_FATAL_IF(env->GetJavaVM(&vm) != JNI_OK, "Cannot get Java VM");
-
-    sp<ISensorManager> sensorService = new SensorManager(vm);
-    err = sensorService->registerAsService();
-    ALOGE_IF(err != OK, "Cannot register %s: %d", ISensorManager::descriptor, err);
-
-    sp<ISchedulingPolicyService> schedulingService = new SchedulingPolicyService();
-    err = schedulingService->registerAsService();
-    ALOGE_IF(err != OK, "Cannot register %s: %d", ISchedulingPolicyService::descriptor, err);
+static void android_server_SystemServer_startHidlServices(JNIEnv* /* env */, jobject /* clazz */) {
 }
 
 /*
diff --git a/core/java/android/hardware/SystemSensorManager.java b/core/java/android/hardware/SystemSensorManager.java
index 607788d3effc..0dab5d7b1453 100644
--- a/core/java/android/hardware/SystemSensorManager.java
+++ b/core/java/android/hardware/SystemSensorManager.java
@@ -68,7 +68,7 @@ private static native int nativeConfigDirectChannel(
             long nativeInstance, int channelHandle, int sensorHandle, int rate);
 
     private static native int nativeSetOperationParameter(
-            long nativeInstance, int handle, int type, float[] floatValues, int[] intValues);
+            long nativeInstance, int type, float[] floatValues, int[] intValues);
 
     private static final Object sLock = new Object();
     @GuardedBy("sLock")
@@ -956,9 +956,7 @@ protected void removeSensorEvent(Sensor sensor) {
     }
 
     protected boolean setOperationParameterImpl(SensorAdditionalInfo parameter) {
-        int handle = -1;
-        if (parameter.sensor != null) handle = parameter.sensor.getHandle();
         return nativeSetOperationParameter(
-                mNativeInstance, handle, parameter.type, parameter.floatValues, parameter.intValues) == 0;
+                mNativeInstance, parameter.type, parameter.floatValues, parameter.intValues) == 0;
     }
 }
diff --git a/core/jni/android_hardware_SensorManager.cpp b/core/jni/android_hardware_SensorManager.cpp
index f254a81a1892..bba233035fcf 100644
--- a/core/jni/android_hardware_SensorManager.cpp
+++ b/core/jni/android_hardware_SensorManager.cpp
@@ -23,9 +23,12 @@
 #include <ScopedUtfChars.h>
 #include <ScopedLocalRef.h>
 #include <android_runtime/AndroidRuntime.h>
+#include <android_runtime/android_hardware_HardwareBuffer.h>
+#include <vndk/hardware_buffer.h>
 #include <sensor/Sensor.h>
 #include <sensor/SensorEventQueue.h>
 #include <sensor/SensorManager.h>
+#include <cutils/native_handle.h>
 #include <utils/Log.h>
 #include <utils/Looper.h>
 #include <utils/Vector.h>
@@ -72,6 +75,12 @@ struct ListOffsets {
     jmethodID   add;
 } gListOffsets;
 
+struct StringOffsets {
+    jclass      clazz;
+    jmethodID   intern;
+    jstring     emptyString;
+} gStringOffsets;
+
 /*
  * nativeClassInit is not inteneded to be thread-safe. It should be called before other native...
  * functions (except nativeCreate).
@@ -81,75 +90,55 @@ nativeClassInit (JNIEnv *_env, jclass _this)
 {
     //android.hardware.Sensor
     SensorOffsets& sensorOffsets = gSensorOffsets;
-    jclass sensorClass = (jclass) _env->NewGlobalRef(_env->FindClass("android/hardware/Sensor"));
-    sensorOffsets.clazz       = sensorClass;
-    sensorOffsets.name        = _env->GetFieldID(sensorClass, "mName",      "Ljava/lang/String;");
-    sensorOffsets.vendor      = _env->GetFieldID(sensorClass, "mVendor",    "Ljava/lang/String;");
-    sensorOffsets.version     = _env->GetFieldID(sensorClass, "mVersion",   "I");
-    sensorOffsets.handle      = _env->GetFieldID(sensorClass, "mHandle",    "I");
-    sensorOffsets.range       = _env->GetFieldID(sensorClass, "mMaxRange",  "F");
-    sensorOffsets.resolution  = _env->GetFieldID(sensorClass, "mResolution","F");
-    sensorOffsets.power       = _env->GetFieldID(sensorClass, "mPower",     "F");
-    sensorOffsets.minDelay    = _env->GetFieldID(sensorClass, "mMinDelay",  "I");
+    jclass sensorClass = (jclass)
+            MakeGlobalRefOrDie(_env, FindClassOrDie(_env, "android/hardware/Sensor"));
+    sensorOffsets.clazz = sensorClass;
+    sensorOffsets.name = GetFieldIDOrDie(_env, sensorClass, "mName", "Ljava/lang/String;");
+    sensorOffsets.vendor = GetFieldIDOrDie(_env, sensorClass, "mVendor", "Ljava/lang/String;");
+    sensorOffsets.version = GetFieldIDOrDie(_env, sensorClass, "mVersion", "I");
+    sensorOffsets.handle = GetFieldIDOrDie(_env, sensorClass, "mHandle", "I");
+    sensorOffsets.range = GetFieldIDOrDie(_env, sensorClass, "mMaxRange", "F");
+    sensorOffsets.resolution = GetFieldIDOrDie(_env, sensorClass, "mResolution","F");
+    sensorOffsets.power = GetFieldIDOrDie(_env, sensorClass, "mPower", "F");
+    sensorOffsets.minDelay = GetFieldIDOrDie(_env, sensorClass, "mMinDelay", "I");
     sensorOffsets.fifoReservedEventCount =
-            _env->GetFieldID(sensorClass, "mFifoReservedEventCount",  "I");
-    sensorOffsets.fifoMaxEventCount = _env->GetFieldID(sensorClass, "mFifoMaxEventCount",  "I");
-    sensorOffsets.stringType = _env->GetFieldID(sensorClass, "mStringType", "Ljava/lang/String;");
-    sensorOffsets.requiredPermission = _env->GetFieldID(sensorClass, "mRequiredPermission",
-                                                        "Ljava/lang/String;");
-    sensorOffsets.maxDelay    = _env->GetFieldID(sensorClass, "mMaxDelay",  "I");
-    sensorOffsets.flags = _env->GetFieldID(sensorClass, "mFlags",  "I");
-
-    sensorOffsets.setType = _env->GetMethodID(sensorClass, "setType", "(I)Z");
-    sensorOffsets.setUuid = _env->GetMethodID(sensorClass, "setUuid", "(JJ)V");
-    sensorOffsets.init = _env->GetMethodID(sensorClass, "<init>", "()V");
+            GetFieldIDOrDie(_env,sensorClass, "mFifoReservedEventCount", "I");
+    sensorOffsets.fifoMaxEventCount = GetFieldIDOrDie(_env,sensorClass, "mFifoMaxEventCount", "I");
+    sensorOffsets.stringType =
+            GetFieldIDOrDie(_env,sensorClass, "mStringType", "Ljava/lang/String;");
+    sensorOffsets.requiredPermission =
+            GetFieldIDOrDie(_env,sensorClass, "mRequiredPermission", "Ljava/lang/String;");
+    sensorOffsets.maxDelay = GetFieldIDOrDie(_env,sensorClass, "mMaxDelay", "I");
+    sensorOffsets.flags = GetFieldIDOrDie(_env,sensorClass, "mFlags", "I");
+
+    sensorOffsets.setType = GetMethodIDOrDie(_env,sensorClass, "setType", "(I)Z");
+    sensorOffsets.setUuid = GetMethodIDOrDie(_env,sensorClass, "setUuid", "(JJ)V");
+    sensorOffsets.init = GetMethodIDOrDie(_env,sensorClass, "<init>", "()V");
 
     // java.util.List;
     ListOffsets& listOffsets = gListOffsets;
-    jclass listClass = (jclass) _env->NewGlobalRef(_env->FindClass("java/util/List"));
+    jclass listClass = (jclass) MakeGlobalRefOrDie(_env, FindClassOrDie(_env, "java/util/List"));
     listOffsets.clazz = listClass;
-    listOffsets.add = _env->GetMethodID(listClass, "add", "(Ljava/lang/Object;)Z");
+    listOffsets.add = GetMethodIDOrDie(_env,listClass, "add", "(Ljava/lang/Object;)Z");
+
+    // initialize java.lang.String and empty string intern
+    StringOffsets& stringOffsets = gStringOffsets;
+    stringOffsets.clazz = MakeGlobalRefOrDie(_env, FindClassOrDie(_env, "java/lang/String"));
+    stringOffsets.intern =
+            GetMethodIDOrDie(_env, stringOffsets.clazz, "intern", "()Ljava/lang/String;");
+    ScopedLocalRef<jstring> empty(_env, _env->NewStringUTF(""));
+    stringOffsets.emptyString = (jstring)
+            MakeGlobalRefOrDie(_env, _env->CallObjectMethod(empty.get(), stringOffsets.intern));
 }
 
-/**
- * A key comparator predicate.
- * It is used to intern strings associated with Sensor data.
- * It defines a 'Strict weak ordering' for the interned strings.
- */
-class InternedStringCompare {
-public:
-    bool operator()(const String8* string1, const String8* string2) const {
-        if (string1 == NULL) {
-            return string2 != NULL;
-        }
-        if (string2 == NULL) {
-            return false;
-        }
-        return string1->compare(*string2) < 0;
+static jstring getJavaInternedString(JNIEnv *env, const String8 &string) {
+    if (string == "") {
+        return gStringOffsets.emptyString;
     }
-};
 
-/**
- * A localized interning mechanism for Sensor strings.
- * We implement our own interning to avoid the overhead of using java.lang.String#intern().
- * It is common that Vendor, StringType, and RequirePermission data is common between many of the
- * Sensors, by interning the memory usage to represent Sensors is optimized.
- */
-static jstring
-getInternedString(JNIEnv *env, const String8* string) {
-    static std::map<const String8*, jstring, InternedStringCompare> internedStrings;
-
-    jstring internedString;
-    std::map<const String8*, jstring>::iterator iterator = internedStrings.find(string);
-    if (iterator != internedStrings.end()) {
-        internedString = iterator->second;
-    } else {
-        jstring localString = env->NewStringUTF(string->string());
-        // we are implementing our own interning so expect these strings to be backed by global refs
-        internedString = (jstring) env->NewGlobalRef(localString);
-        internedStrings.insert(std::make_pair(string, internedString));
-        env->DeleteLocalRef(localString);
-    }
+    ScopedLocalRef<jstring> javaString(env, env->NewStringUTF(string.string()));
+    jstring internedString = (jstring)
+            env->CallObjectMethod(javaString.get(), gStringOffsets.intern);
     return internedString;
 }
 
@@ -171,10 +160,10 @@ translateNativeSensorToJavaSensor(JNIEnv *env, jobject sensor, const Sensor& nat
     }
 
     if (sensor != NULL) {
-        jstring name = env->NewStringUTF(nativeSensor.getName().string());
-        jstring vendor = env->NewStringUTF(nativeSensor.getVendor().string());
+        jstring name = getJavaInternedString(env, nativeSensor.getName());
+        jstring vendor = getJavaInternedString(env, nativeSensor.getVendor());
         jstring requiredPermission =
-                env->NewStringUTF(nativeSensor.getRequiredPermission().string());
+                getJavaInternedString(env, nativeSensor.getRequiredPermission());
 
         env->SetObjectField(sensor, sensorOffsets.name,      name);
         env->SetObjectField(sensor, sensorOffsets.vendor,    vendor);
@@ -195,7 +184,7 @@ translateNativeSensorToJavaSensor(JNIEnv *env, jobject sensor, const Sensor& nat
 
         if (env->CallBooleanMethod(sensor, sensorOffsets.setType, nativeSensor.getType())
                 == JNI_FALSE) {
-            jstring stringType = getInternedString(env, &nativeSensor.getStringType());
+            jstring stringType = getJavaInternedString(env, nativeSensor.getStringType());
             env->SetObjectField(sensor, sensorOffsets.stringType, stringType);
         }
 
@@ -212,7 +201,11 @@ nativeGetSensorAtIndex(JNIEnv *env, jclass clazz, jlong sensorManager, jobject s
     SensorManager* mgr = reinterpret_cast<SensorManager*>(sensorManager);
 
     Sensor const* const* sensorList;
+#ifdef COMPAT_SENSORS_M
+    const ssize_t count = mgr->getSensorList(&sensorList);
+#else
     ssize_t count = mgr->getSensorList(&sensorList);
+#endif
     if (ssize_t(index) >= count) {
         return false;
     }
@@ -230,7 +223,7 @@ nativeGetDynamicSensors(JNIEnv *env, jclass clazz, jlong sensorManager, jobject
 
     mgr->getDynamicSensorList(nativeList);
 
-    ALOGI("DYNS native SensorManager.getDynamicSensorList return %d sensors", nativeList.size());
+    ALOGI("DYNS native SensorManager.getDynamicSensorList return %zu sensors", nativeList.size());
     for (size_t i = 0; i < nativeList.size(); ++i) {
         jobject sensor = translateNativeSensorToJavaSensor(env, NULL, nativeList[i]);
         // add to list
@@ -243,6 +236,25 @@ static jboolean nativeIsDataInjectionEnabled(JNIEnv *_env, jclass _this, jlong s
     return mgr->isDataInjectionEnabled();
 }
 
+static jint nativeCreateDirectChannel(JNIEnv *_env, jclass _this, jlong sensorManager,
+        jlong size, jint channelType, jint fd, jobject hardwareBufferObj) {
+    return BAD_VALUE;
+}
+
+static void nativeDestroyDirectChannel(JNIEnv *_env, jclass _this, jlong sensorManager,
+        jint channelHandle) {
+}
+
+static jint nativeConfigDirectChannel(JNIEnv *_env, jclass _this, jlong sensorManager,
+        jint channelHandle, jint sensorHandle, jint rate) {
+    return BAD_VALUE;
+}
+
+static jint nativeSetOperationParameter(JNIEnv *_env, jclass _this, jlong sensorManager,
+        jint type, jfloatArray floats, jintArray ints) {
+    return BAD_VALUE;
+}
+
 //----------------------------------------------------------------------------
 
 class Receiver : public LooperCallback {
@@ -382,6 +394,11 @@ static jlong nativeInitSensorEventQueue(JNIEnv *env, jclass clazz, jlong sensorM
     String8 clientName(packageUtf.c_str());
     sp<SensorEventQueue> queue(mgr->createEventQueue(clientName, mode));
 
+    if (queue == NULL) {
+        jniThrowRuntimeException(env, "Cannot construct native SensorEventQueue.");
+        return 0;
+    }
+
     sp<MessageQueue> messageQueue = android_os_MessageQueue_getMessageQueue(env, msgQ);
     if (messageQueue == NULL) {
         jniThrowRuntimeException(env, "MessageQueue is not initialized.");
@@ -447,7 +464,23 @@ static const JNINativeMethod gSystemSensorManagerMethods[] = {
 
     {"nativeIsDataInjectionEnabled",
             "(J)Z",
-            (void*)nativeIsDataInjectionEnabled},
+            (void*)nativeIsDataInjectionEnabled },
+
+    {"nativeCreateDirectChannel",
+            "(JJIILandroid/hardware/HardwareBuffer;)I",
+            (void*)nativeCreateDirectChannel },
+
+    {"nativeDestroyDirectChannel",
+            "(JI)V",
+            (void*)nativeDestroyDirectChannel },
+
+    {"nativeConfigDirectChannel",
+            "(JIII)I",
+            (void*)nativeConfigDirectChannel },
+
+    {"nativeSetOperationParameter",
+            "(JI[F[I)I",
+            (void*)nativeSetOperationParameter },
 };
 
 static const JNINativeMethod gBaseEventQueueMethods[] = {
diff --git a/services/core/java/com/android/server/pm/PackageManagerServiceCompilerMapping.java b/services/core/java/com/android/server/pm/PackageManagerServiceCompilerMapping.java
index 19b0d9bc4b90..20d5c9fb10e0 100644
--- a/services/core/java/com/android/server/pm/PackageManagerServiceCompilerMapping.java
+++ b/services/core/java/com/android/server/pm/PackageManagerServiceCompilerMapping.java
@@ -88,10 +88,12 @@ static void checkProperties() {
                 // Check validity, ignore result.
                 getAndCheckValidity(reason);
             } catch (Exception exc) {
+/*
                 if (toThrow == null) {
                     toThrow = new IllegalStateException("PMS compiler filter settings are bad.");
                 }
                 toThrow.addSuppressed(exc);
+*/
             }
         }
 
