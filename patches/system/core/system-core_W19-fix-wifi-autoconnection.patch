From a0943bd277ed9b5ecaf1c7c1ace7590b1b6da37d Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 20 Aug 2018 22:57:43 +0300
Hack: fix wifi autoconnection [1/3] 

diff --git a/libutils/include/utils/SystemClock.h b/libutils/include/utils/SystemClock.h
index 01d6de7..ccbe0b0 100644
--- a/libutils/include/utils/SystemClock.h
+++ b/libutils/include/utils/SystemClock.h
@@ -24,7 +24,9 @@ namespace android {
 
 int64_t uptimeMillis();
 int64_t elapsedRealtime();
+int64_t elapsedRealtime1();
 int64_t elapsedRealtimeNano();
+int64_t elapsedRealtimeNano1();
 
 }; // namespace android
 
diff --git a/libutils/SystemClock.cpp b/libutils/SystemClock.cpp
index 03d6de7..ccbe0b0 100644
--- a/libutils/SystemClock.cpp
+++ b/libutils/SystemClock.cpp
@@ -41,6 +41,10 @@
 
 namespace android {
 
+static int clock_method = -1;
+
+static int debug_time = 0;
+
 /*
  * native public static long uptimeMillis();
  */
@@ -58,6 +62,60 @@ int64_t elapsedRealtime()
 	return nanoseconds_to_milliseconds(elapsedRealtimeNano());
 }
 
+/*
+ * native public static long elapsedRealtime1();
+ */
+int64_t elapsedRealtime1()
+{
+	return nanoseconds_to_milliseconds(elapsedRealtimeNano1());
+}
+
+#define METHOD_CLOCK_GETTIME    0
+#define METHOD_IOCTL            1
+#define METHOD_SYSTEMTIME       2
+
+/*
+ * To debug/verify the timestamps returned by the kernel, change
+ * DEBUG_TIMESTAMP to 1 and call the timestamp routine from a single thread
+ * in the test program. b/10899829
+ */
+#define DEBUG_TIMESTAMP         0
+
+#if DEBUG_TIMESTAMP && defined(__arm__)
+static inline void checkTimeStamps(int64_t timestamp,
+                                   int64_t volatile *prevTimestampPtr,
+                                   int volatile *prevMethodPtr,
+                                   int curMethod)
+{
+    /*
+     * Disable the check for SDK since the prebuilt toolchain doesn't contain
+     * gettid, and int64_t is different on the ARM platform
+     * (ie long vs long long).
+     */
+    int64_t prevTimestamp = *prevTimestampPtr;
+    int prevMethod = *prevMethodPtr;
+
+    if (timestamp < prevTimestamp) {
+        static const char *gettime_method_names[] = {
+            "clock_gettime",
+            "ioctl",
+            "systemTime",
+        };
+
+        ALOGW("time going backwards: prev %lld(%s) vs now %lld(%s), tid=%d",
+              prevTimestamp, gettime_method_names[prevMethod],
+              timestamp, gettime_method_names[curMethod],
+              gettid());
+    }
+    // NOTE - not atomic and may generate spurious warnings if the 64-bit
+    // write is interrupted or not observed as a whole.
+    *prevTimestampPtr = timestamp;
+    *prevMethodPtr = curMethod;
+}
+#else
+#define checkTimeStamps(timestamp, prevTimestampPtr, prevMethodPtr, curMethod)
+#endif
+
 /*
  * native public static long elapsedRealtimeNano();
  */
@@ -92,4 +150,36 @@ int64_t elapsedRealtimeNano()
 #endif
 }
 
+
+/*
+ * native public static long elapsedRealtimeNano1();
+ */
+int64_t elapsedRealtimeNano1()
+{
+    struct timespec ts;
+    int result;
+    int64_t timestamp;
+#if DEBUG_TIMESTAMP
+    static volatile int64_t prevTimestamp;
+    static volatile int prevMethod;
+#endif
+
+    static int s_fd = -1;
+
+    //pthread_mutex_lock(&clock_lock);
+
+    // /dev/alarm doesn't exist, fallback to CLOCK_BOOTTIME
+    result = clock_gettime(CLOCK_BOOTTIME, &ts);
+    if (result == 0) {
+        timestamp = seconds_to_nanoseconds(ts.tv_sec) + ts.tv_nsec;
+        checkTimeStamps(timestamp, &prevTimestamp, &prevMethod,
+                        METHOD_CLOCK_GETTIME);
+	if (debug_time)
+	        ALOGI("elapsedRealtimeNano: using METHOD_CLOCK_GETTIME");
+    }
+    //pthread_mutex_unlock(&clock_lock);
+
+    return timestamp;
+}
+
 }; // namespace android
