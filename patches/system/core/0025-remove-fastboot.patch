From 3d1f61046e3f26a315bcd9d5fbc396bce849c7a1 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Tue, 16 May 2017 22:37:15 +0300
Subject: [PATCH 25/25] remove fastboot

Change-Id: I937da3f3d6b9f360a309a059c1b2409e07f21f22
---
 fastboot/.clang-format         |   15 -
 fastboot/Android.mk            |  136 ---
 fastboot/bootimg_utils.cpp     |   77 --
 fastboot/bootimg_utils.h       |   43 -
 fastboot/engine.cpp            |  379 ---------
 fastboot/fastboot.cpp          | 1804 ----------------------------------------
 fastboot/fastboot.h            |   80 --
 fastboot/fastboot_protocol.txt |  442 ----------
 fastboot/fs.cpp                |   64 --
 fastboot/fs.h                  |   13 -
 fastboot/protocol.cpp          |  277 ------
 fastboot/socket.cpp            |  290 -------
 fastboot/socket.h              |  129 ---
 fastboot/socket_mock.cpp       |  151 ----
 fastboot/socket_mock.h         |  101 ---
 fastboot/socket_test.cpp       |  385 ---------
 fastboot/tcp.cpp               |  199 -----
 fastboot/tcp.h                 |   59 --
 fastboot/tcp_test.cpp          |  227 -----
 fastboot/transport.h           |   48 --
 fastboot/udp.cpp               |  391 ---------
 fastboot/udp.h                 |   81 --
 fastboot/udp_test.cpp          |  531 ------------
 fastboot/usb.h                 |   60 --
 fastboot/usb_linux.cpp         |  498 -----------
 fastboot/usb_osx.cpp           |  593 -------------
 fastboot/usb_windows.cpp       |  370 --------
 fastboot/usbtest.cpp           |  212 -----
 fastboot/util.cpp              |   69 --
 fastboot/util_linux.cpp        |   54 --
 fastboot/util_osx.cpp          |   49 --
 fastboot/util_windows.cpp      |   51 --
 32 files changed, 7878 deletions(-)
 delete mode 100644 fastboot/.clang-format
 delete mode 100644 fastboot/Android.mk
 delete mode 100644 fastboot/bootimg_utils.cpp
 delete mode 100644 fastboot/bootimg_utils.h
 delete mode 100644 fastboot/engine.cpp
 delete mode 100644 fastboot/fastboot.cpp
 delete mode 100644 fastboot/fastboot.h
 delete mode 100644 fastboot/fastboot_protocol.txt
 delete mode 100644 fastboot/fs.cpp
 delete mode 100644 fastboot/fs.h
 delete mode 100644 fastboot/protocol.cpp
 delete mode 100644 fastboot/socket.cpp
 delete mode 100644 fastboot/socket.h
 delete mode 100644 fastboot/socket_mock.cpp
 delete mode 100644 fastboot/socket_mock.h
 delete mode 100644 fastboot/socket_test.cpp
 delete mode 100644 fastboot/tcp.cpp
 delete mode 100644 fastboot/tcp.h
 delete mode 100644 fastboot/tcp_test.cpp
 delete mode 100644 fastboot/transport.h
 delete mode 100644 fastboot/udp.cpp
 delete mode 100644 fastboot/udp.h
 delete mode 100644 fastboot/udp_test.cpp
 delete mode 100644 fastboot/usb.h
 delete mode 100644 fastboot/usb_linux.cpp
 delete mode 100644 fastboot/usb_osx.cpp
 delete mode 100644 fastboot/usb_windows.cpp
 delete mode 100644 fastboot/usbtest.cpp
 delete mode 100644 fastboot/util.cpp
 delete mode 100644 fastboot/util_linux.cpp
 delete mode 100644 fastboot/util_osx.cpp
 delete mode 100644 fastboot/util_windows.cpp

diff --git a/fastboot/.clang-format b/fastboot/.clang-format
deleted file mode 100644
index bcb8d8a..0000000
--- a/fastboot/.clang-format
+++ /dev/null
@@ -1,15 +0,0 @@
-BasedOnStyle: Google
-AllowShortBlocksOnASingleLine: false
-AllowShortFunctionsOnASingleLine: Inline
-
-ColumnLimit: 100
-CommentPragmas: NOLINT:.*
-DerivePointerAlignment: false
-IndentWidth: 4
-ContinuationIndentWidth: 8
-ConstructorInitializerIndentWidth: 8
-AccessModifierOffset: -2
-PointerAlignment: Left
-TabWidth: 4
-UseTab: Never
-PenaltyExcessCharacter: 32
diff --git a/fastboot/Android.mk b/fastboot/Android.mk
deleted file mode 100644
index 728a414..0000000
--- a/fastboot/Android.mk
+++ /dev/null
@@ -1,136 +0,0 @@
-# Copyright (C) 2007 Google Inc.
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-LOCAL_PATH:= $(call my-dir)
-
-fastboot_version := $(shell git -C $(LOCAL_PATH) rev-parse --short=12 HEAD 2>/dev/null)-android
-
-include $(CLEAR_VARS)
-
-LOCAL_C_INCLUDES := \
-  $(LOCAL_PATH)/../adb \
-  $(LOCAL_PATH)/../mkbootimg \
-  $(LOCAL_PATH)/../../extras/ext4_utils \
-  $(LOCAL_PATH)/../../extras/f2fs_utils \
-
-LOCAL_SRC_FILES := \
-    bootimg_utils.cpp \
-    engine.cpp \
-    fastboot.cpp \
-    fs.cpp\
-    protocol.cpp \
-    socket.cpp \
-    tcp.cpp \
-    udp.cpp \
-    util.cpp \
-
-LOCAL_MODULE := fastboot
-LOCAL_MODULE_TAGS := debug
-LOCAL_MODULE_HOST_OS := darwin linux windows
-LOCAL_CONLYFLAGS += -std=gnu99
-LOCAL_CFLAGS += -Wall -Wextra -Werror -Wunreachable-code
-
-LOCAL_CFLAGS += -DFASTBOOT_REVISION='"$(fastboot_version)"'
-
-LOCAL_SRC_FILES_linux := usb_linux.cpp util_linux.cpp
-LOCAL_STATIC_LIBRARIES_linux := libselinux
-
-LOCAL_SRC_FILES_darwin := usb_osx.cpp util_osx.cpp
-LOCAL_STATIC_LIBRARIES_darwin := libselinux
-LOCAL_LDLIBS_darwin := -lpthread -framework CoreFoundation -framework IOKit -framework Carbon
-LOCAL_CFLAGS_darwin := -Wno-unused-parameter
-
-LOCAL_SRC_FILES_windows := usb_windows.cpp util_windows.cpp
-LOCAL_STATIC_LIBRARIES_windows := AdbWinApi
-LOCAL_REQUIRED_MODULES_windows := AdbWinApi
-LOCAL_LDLIBS_windows := -lws2_32
-LOCAL_C_INCLUDES_windows := development/host/windows/usb/api
-
-LOCAL_STATIC_LIBRARIES := \
-    libziparchive-host \
-    libext4_utils_host \
-    libsparse_host \
-    libutils \
-    liblog \
-    libz \
-    libdiagnose_usb \
-    libbase \
-    libcutils \
-    libgtest_host \
-
-ifneq (,$(filter linux darwin,$(HOST_OS)))
-# libf2fs_dlutils_host will dlopen("libf2fs_fmt_host_dyn")
-LOCAL_CFLAGS += -DUSE_F2FS
-LOCAL_LDFLAGS += -ldl -rdynamic -Wl,-rpath,.
-LOCAL_REQUIRED_MODULES := libf2fs_fmt_host_dyn
-# The following libf2fs_* are from system/extras/f2fs_utils,
-# and do not use code in external/f2fs-tools.
-LOCAL_STATIC_LIBRARIES += libf2fs_utils_host libf2fs_dlutils_host
-endif
-
-LOCAL_CXX_STL := libc++_static
-
-# Don't add anything here, we don't want additional shared dependencies
-# on the host fastboot tool, and shared libraries that link against libc++
-# will violate ODR
-LOCAL_SHARED_LIBRARIES :=
-
-include $(BUILD_HOST_EXECUTABLE)
-
-my_dist_files := $(LOCAL_BUILT_MODULE)
-ifneq (,$(filter linux darwin,$(HOST_OS)))
-my_dist_files += $(HOST_LIBRARY_PATH)/libf2fs_fmt_host_dyn$(HOST_SHLIB_SUFFIX)
-endif
-$(call dist-for-goals,dist_files sdk win_sdk,$(my_dist_files))
-ifdef HOST_CROSS_OS
-# Archive fastboot.exe for win_sdk build.
-$(call dist-for-goals,win_sdk,$(ALL_MODULES.host_cross_fastboot.BUILT))
-endif
-my_dist_files :=
-
-ifeq ($(HOST_OS),linux)
-include $(CLEAR_VARS)
-LOCAL_SRC_FILES := usbtest.cpp usb_linux.cpp util.cpp
-LOCAL_MODULE := usbtest
-LOCAL_CFLAGS := -Werror
-LOCAL_STATIC_LIBRARIES := libbase
-include $(BUILD_HOST_EXECUTABLE)
-endif
-
-# fastboot_test
-# =========================================================
-include $(CLEAR_VARS)
-
-LOCAL_MODULE := fastboot_test
-LOCAL_MODULE_HOST_OS := darwin linux windows
-
-LOCAL_SRC_FILES := \
-    socket.cpp \
-    socket_mock.cpp \
-    socket_test.cpp \
-    tcp.cpp \
-    tcp_test.cpp \
-    udp.cpp \
-    udp_test.cpp \
-
-LOCAL_STATIC_LIBRARIES := libbase libcutils
-
-LOCAL_CFLAGS += -Wall -Wextra -Werror -Wunreachable-code
-
-LOCAL_LDLIBS_darwin := -lpthread -framework CoreFoundation -framework IOKit -framework Carbon
-LOCAL_CFLAGS_darwin := -Wno-unused-parameter
-
-LOCAL_LDLIBS_windows := -lws2_32
-
-include $(BUILD_HOST_NATIVE_TEST)
diff --git a/fastboot/bootimg_utils.cpp b/fastboot/bootimg_utils.cpp
deleted file mode 100644
index c1028ef..0000000
--- a/fastboot/bootimg_utils.cpp
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "bootimg_utils.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-void bootimg_set_cmdline(boot_img_hdr* h, const char* cmdline)
-{
-    strcpy((char*) h->cmdline, cmdline);
-}
-
-boot_img_hdr* mkbootimg(void* kernel, int64_t kernel_size, off_t kernel_offset,
-                        void* ramdisk, int64_t ramdisk_size, off_t ramdisk_offset,
-                        void* second, int64_t second_size, off_t second_offset,
-                        size_t page_size, size_t base, off_t tags_offset,
-                        int64_t* bootimg_size)
-{
-    size_t page_mask = page_size - 1;
-
-    int64_t kernel_actual = (kernel_size + page_mask) & (~page_mask);
-    int64_t ramdisk_actual = (ramdisk_size + page_mask) & (~page_mask);
-    int64_t second_actual = (second_size + page_mask) & (~page_mask);
-
-    *bootimg_size = page_size + kernel_actual + ramdisk_actual + second_actual;
-
-    boot_img_hdr* hdr = reinterpret_cast<boot_img_hdr*>(calloc(*bootimg_size, 1));
-    if (hdr == nullptr) {
-        return hdr;
-    }
-
-    memcpy(hdr->magic, BOOT_MAGIC, BOOT_MAGIC_SIZE);
-
-    hdr->kernel_size =  kernel_size;
-    hdr->ramdisk_size = ramdisk_size;
-    hdr->second_size =  second_size;
-
-    hdr->kernel_addr =  base + kernel_offset;
-    hdr->ramdisk_addr = base + ramdisk_offset;
-    hdr->second_addr =  base + second_offset;
-    hdr->tags_addr =    base + tags_offset;
-
-    hdr->page_size =    page_size;
-
-    memcpy(hdr->magic + page_size, kernel, kernel_size);
-    memcpy(hdr->magic + page_size + kernel_actual, ramdisk, ramdisk_size);
-    memcpy(hdr->magic + page_size + kernel_actual + ramdisk_actual, second, second_size);
-
-    return hdr;
-}
diff --git a/fastboot/bootimg_utils.h b/fastboot/bootimg_utils.h
deleted file mode 100644
index fcc8662..0000000
--- a/fastboot/bootimg_utils.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#ifndef _FASTBOOT_BOOTIMG_UTILS_H_
-#define _FASTBOOT_BOOTIMG_UTILS_H_
-
-#include <bootimg.h>
-#include <inttypes.h>
-#include <sys/types.h>
-
-void bootimg_set_cmdline(boot_img_hdr* h, const char* cmdline);
-boot_img_hdr* mkbootimg(void* kernel, int64_t kernel_size, off_t kernel_offset,
-                        void* ramdisk, int64_t ramdisk_size, off_t ramdisk_offset,
-                        void* second, int64_t second_size, off_t second_offset,
-                        size_t page_size, size_t base, off_t tags_offset,
-                        int64_t* bootimg_size);
-
-#endif
diff --git a/fastboot/engine.cpp b/fastboot/engine.cpp
deleted file mode 100644
index 47567c0..0000000
--- a/fastboot/engine.cpp
+++ /dev/null
@@ -1,379 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "fastboot.h"
-#include "fs.h"
-
-#include <errno.h>
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <unistd.h>
-
-#define ARRAY_SIZE(x)           (sizeof(x)/sizeof(x[0]))
-
-#define OP_DOWNLOAD   1
-#define OP_COMMAND    2
-#define OP_QUERY      3
-#define OP_NOTICE     4
-#define OP_DOWNLOAD_SPARSE 5
-#define OP_WAIT_FOR_DISCONNECT 6
-
-typedef struct Action Action;
-
-#define CMD_SIZE 64
-
-struct Action {
-    unsigned op;
-    Action* next;
-
-    char cmd[CMD_SIZE];
-    const char* prod;
-    void* data;
-
-    // The protocol only supports 32-bit sizes, so you'll have to break
-    // anything larger into chunks.
-    uint32_t size;
-
-    const char *msg;
-    int (*func)(Action* a, int status, const char* resp);
-
-    double start;
-};
-
-static Action *action_list = 0;
-static Action *action_last = 0;
-
-
-
-
-bool fb_getvar(Transport* transport, const std::string& key, std::string* value) {
-    std::string cmd = "getvar:";
-    cmd += key;
-
-    char buf[FB_RESPONSE_SZ + 1];
-    memset(buf, 0, sizeof(buf));
-    if (fb_command_response(transport, cmd.c_str(), buf)) {
-      return false;
-    }
-    *value = buf;
-    return true;
-}
-
-static int cb_default(Action* a, int status, const char* resp) {
-    if (status) {
-        fprintf(stderr,"FAILED (%s)\n", resp);
-    } else {
-        double split = now();
-        fprintf(stderr,"OKAY [%7.3fs]\n", (split - a->start));
-        a->start = split;
-    }
-    return status;
-}
-
-static Action *queue_action(unsigned op, const char *fmt, ...)
-{
-    va_list ap;
-    size_t cmdsize;
-
-    Action* a = reinterpret_cast<Action*>(calloc(1, sizeof(Action)));
-    if (a == nullptr) die("out of memory");
-
-    va_start(ap, fmt);
-    cmdsize = vsnprintf(a->cmd, sizeof(a->cmd), fmt, ap);
-    va_end(ap);
-
-    if (cmdsize >= sizeof(a->cmd)) {
-        free(a);
-        die("Command length (%d) exceeds maximum size (%d)", cmdsize, sizeof(a->cmd));
-    }
-
-    if (action_last) {
-        action_last->next = a;
-    } else {
-        action_list = a;
-    }
-    action_last = a;
-    a->op = op;
-    a->func = cb_default;
-
-    a->start = -1;
-
-    return a;
-}
-
-void fb_set_active(const char *slot)
-{
-    Action *a;
-    a = queue_action(OP_COMMAND, "set_active:%s", slot);
-    a->msg = mkmsg("Setting current slot to '%s'", slot);
-}
-
-void fb_queue_erase(const char *ptn)
-{
-    Action *a;
-    a = queue_action(OP_COMMAND, "erase:%s", ptn);
-    a->msg = mkmsg("erasing '%s'", ptn);
-}
-
-void fb_queue_flash(const char *ptn, void *data, unsigned sz)
-{
-    Action *a;
-
-    a = queue_action(OP_DOWNLOAD, "");
-    a->data = data;
-    a->size = sz;
-    a->msg = mkmsg("sending '%s' (%d KB)", ptn, sz / 1024);
-
-    a = queue_action(OP_COMMAND, "flash:%s", ptn);
-    a->msg = mkmsg("writing '%s'", ptn);
-}
-
-void fb_queue_flash_sparse(const char* ptn, struct sparse_file* s, unsigned sz, size_t current,
-                           size_t total) {
-    Action *a;
-
-    a = queue_action(OP_DOWNLOAD_SPARSE, "");
-    a->data = s;
-    a->size = 0;
-    a->msg = mkmsg("sending sparse '%s' %zu/%zu (%d KB)", ptn, current, total, sz / 1024);
-
-    a = queue_action(OP_COMMAND, "flash:%s", ptn);
-    a->msg = mkmsg("writing '%s' %zu/%zu", ptn, current, total);
-}
-
-static int match(const char* str, const char** value, unsigned count) {
-    unsigned n;
-
-    for (n = 0; n < count; n++) {
-        const char *val = value[n];
-        int len = strlen(val);
-        int match;
-
-        if ((len > 1) && (val[len-1] == '*')) {
-            len--;
-            match = !strncmp(val, str, len);
-        } else {
-            match = !strcmp(val, str);
-        }
-
-        if (match) return 1;
-    }
-
-    return 0;
-}
-
-
-
-static int cb_check(Action* a, int status, const char* resp, int invert)
-{
-    const char** value = reinterpret_cast<const char**>(a->data);
-    unsigned count = a->size;
-    unsigned n;
-    int yes;
-
-    if (status) {
-        fprintf(stderr,"FAILED (%s)\n", resp);
-        return status;
-    }
-
-    if (a->prod) {
-        if (strcmp(a->prod, cur_product) != 0) {
-            double split = now();
-            fprintf(stderr,"IGNORE, product is %s required only for %s [%7.3fs]\n",
-                    cur_product, a->prod, (split - a->start));
-            a->start = split;
-            return 0;
-        }
-    }
-
-    yes = match(resp, value, count);
-    if (invert) yes = !yes;
-
-    if (yes) {
-        double split = now();
-        fprintf(stderr,"OKAY [%7.3fs]\n", (split - a->start));
-        a->start = split;
-        return 0;
-    }
-
-    fprintf(stderr,"FAILED\n\n");
-    fprintf(stderr,"Device %s is '%s'.\n", a->cmd + 7, resp);
-    fprintf(stderr,"Update %s '%s'",
-            invert ? "rejects" : "requires", value[0]);
-    for (n = 1; n < count; n++) {
-        fprintf(stderr," or '%s'", value[n]);
-    }
-    fprintf(stderr,".\n\n");
-    return -1;
-}
-
-static int cb_require(Action*a, int status, const char* resp) {
-    return cb_check(a, status, resp, 0);
-}
-
-static int cb_reject(Action* a, int status, const char* resp) {
-    return cb_check(a, status, resp, 1);
-}
-
-void fb_queue_require(const char *prod, const char *var,
-                      bool invert, size_t nvalues, const char **value)
-{
-    Action *a;
-    a = queue_action(OP_QUERY, "getvar:%s", var);
-    a->prod = prod;
-    a->data = value;
-    a->size = nvalues;
-    a->msg = mkmsg("checking %s", var);
-    a->func = invert ? cb_reject : cb_require;
-    if (a->data == nullptr) die("out of memory");
-}
-
-static int cb_display(Action* a, int status, const char* resp) {
-    if (status) {
-        fprintf(stderr, "%s FAILED (%s)\n", a->cmd, resp);
-        return status;
-    }
-    fprintf(stderr, "%s: %s\n", (char*) a->data, resp);
-    return 0;
-}
-
-void fb_queue_display(const char *var, const char *prettyname)
-{
-    Action *a;
-    a = queue_action(OP_QUERY, "getvar:%s", var);
-    a->data = strdup(prettyname);
-    if (a->data == nullptr) die("out of memory");
-    a->func = cb_display;
-}
-
-static int cb_save(Action* a, int status, const char* resp) {
-    if (status) {
-        fprintf(stderr, "%s FAILED (%s)\n", a->cmd, resp);
-        return status;
-    }
-    strncpy(reinterpret_cast<char*>(a->data), resp, a->size);
-    return 0;
-}
-
-void fb_queue_query_save(const char *var, char *dest, unsigned dest_size)
-{
-    Action *a;
-    a = queue_action(OP_QUERY, "getvar:%s", var);
-    a->data = (void *)dest;
-    a->size = dest_size;
-    a->func = cb_save;
-}
-
-static int cb_do_nothing(Action*, int , const char*) {
-    fprintf(stderr,"\n");
-    return 0;
-}
-
-void fb_queue_reboot(void)
-{
-    Action *a = queue_action(OP_COMMAND, "reboot");
-    a->func = cb_do_nothing;
-    a->msg = "rebooting";
-}
-
-void fb_queue_command(const char *cmd, const char *msg)
-{
-    Action *a = queue_action(OP_COMMAND, cmd);
-    a->msg = msg;
-}
-
-void fb_queue_download(const char *name, void *data, unsigned size)
-{
-    Action *a = queue_action(OP_DOWNLOAD, "");
-    a->data = data;
-    a->size = size;
-    a->msg = mkmsg("downloading '%s'", name);
-}
-
-void fb_queue_notice(const char *notice)
-{
-    Action *a = queue_action(OP_NOTICE, "");
-    a->data = (void*) notice;
-}
-
-void fb_queue_wait_for_disconnect(void)
-{
-    queue_action(OP_WAIT_FOR_DISCONNECT, "");
-}
-
-int fb_execute_queue(Transport* transport)
-{
-    Action *a;
-    char resp[FB_RESPONSE_SZ+1];
-    int status = 0;
-
-    a = action_list;
-    if (!a)
-        return status;
-    resp[FB_RESPONSE_SZ] = 0;
-
-    double start = -1;
-    for (a = action_list; a; a = a->next) {
-        a->start = now();
-        if (start < 0) start = a->start;
-        if (a->msg) {
-            // fprintf(stderr,"%30s... ",a->msg);
-            fprintf(stderr,"%s...\n",a->msg);
-        }
-        if (a->op == OP_DOWNLOAD) {
-            status = fb_download_data(transport, a->data, a->size);
-            status = a->func(a, status, status ? fb_get_error() : "");
-            if (status) break;
-        } else if (a->op == OP_COMMAND) {
-            status = fb_command(transport, a->cmd);
-            status = a->func(a, status, status ? fb_get_error() : "");
-            if (status) break;
-        } else if (a->op == OP_QUERY) {
-            status = fb_command_response(transport, a->cmd, resp);
-            status = a->func(a, status, status ? fb_get_error() : resp);
-            if (status) break;
-        } else if (a->op == OP_NOTICE) {
-            fprintf(stderr,"%s\n",(char*)a->data);
-        } else if (a->op == OP_DOWNLOAD_SPARSE) {
-            status = fb_download_data_sparse(transport, reinterpret_cast<sparse_file*>(a->data));
-            status = a->func(a, status, status ? fb_get_error() : "");
-            if (status) break;
-        } else if (a->op == OP_WAIT_FOR_DISCONNECT) {
-            transport->WaitForDisconnect();
-        } else {
-            die("bogus action");
-        }
-    }
-
-    fprintf(stderr,"finished. total time: %.3fs\n", (now() - start));
-    return status;
-}
diff --git a/fastboot/fastboot.cpp b/fastboot/fastboot.cpp
deleted file mode 100644
index f43f18e..0000000
--- a/fastboot/fastboot.cpp
+++ /dev/null
@@ -1,1804 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#define _LARGEFILE64_SOURCE
-
-#include <ctype.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <getopt.h>
-#include <inttypes.h>
-#include <limits.h>
-#include <stdint.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <unistd.h>
-
-#include <functional>
-#include <utility>
-#include <vector>
-
-#include <android-base/parseint.h>
-#include <android-base/parsenetaddress.h>
-#include <android-base/stringprintf.h>
-#include <android-base/strings.h>
-#include <sparse/sparse.h>
-#include <ziparchive/zip_archive.h>
-
-#include "bootimg_utils.h"
-#include "diagnose_usb.h"
-#include "fastboot.h"
-#include "fs.h"
-#include "tcp.h"
-#include "transport.h"
-#include "udp.h"
-#include "usb.h"
-
-#ifndef O_BINARY
-#define O_BINARY 0
-#endif
-
-#define ARRAY_SIZE(a) (sizeof(a)/sizeof(*(a)))
-
-char cur_product[FB_RESPONSE_SZ + 1];
-
-static const char* serial = nullptr;
-static const char* product = nullptr;
-static const char* cmdline = nullptr;
-static unsigned short vendor_id = 0;
-static int long_listing = 0;
-static int64_t sparse_limit = -1;
-static int64_t target_sparse_limit = -1;
-
-static unsigned page_size = 2048;
-static unsigned base_addr      = 0x10000000;
-static unsigned kernel_offset  = 0x00008000;
-static unsigned ramdisk_offset = 0x01000000;
-static unsigned second_offset  = 0x00f00000;
-static unsigned tags_offset    = 0x00000100;
-
-static const std::string convert_fbe_marker_filename("convert_fbe");
-
-enum fb_buffer_type {
-    FB_BUFFER,
-    FB_BUFFER_SPARSE,
-};
-
-struct fastboot_buffer {
-    enum fb_buffer_type type;
-    void* data;
-    int64_t sz;
-};
-
-static struct {
-    char img_name[17];
-    char sig_name[17];
-    char part_name[9];
-    bool is_optional;
-    bool is_secondary;
-} images[] = {
-    {"boot.img", "boot.sig", "boot", false, false},
-    {"boot_other.img", "boot.sig", "boot", true, true},
-    {"recovery.img", "recovery.sig", "recovery", true, false},
-    {"system.img", "system.sig", "system", false, false},
-    {"system_other.img", "system.sig", "system", true, true},
-    {"vendor.img", "vendor.sig", "vendor", true, false},
-    {"vendor_other.img", "vendor.sig", "vendor", true, true},
-};
-
-static std::string find_item_given_name(const char* img_name, const char* product) {
-    char path_c_str[PATH_MAX + 128];
-
-    if(product) {
-        get_my_path(path_c_str);
-        std::string path = path_c_str;
-        path.erase(path.find_last_of('/'));
-        return android::base::StringPrintf("%s/../../../target/product/%s/%s",
-                                           path.c_str(), product, img_name);
-    }
-
-    char *dir = getenv("ANDROID_PRODUCT_OUT");
-    if (dir == nullptr || dir[0] == '\0') {
-        die("neither -p product specified nor ANDROID_PRODUCT_OUT set");
-    }
-
-    return android::base::StringPrintf("%s/%s", dir, img_name);
-}
-
-std::string find_item(const char* item, const char* product) {
-    const char *fn;
-
-    if(!strcmp(item,"boot")) {
-        fn = "boot.img";
-    } else if(!strcmp(item,"recovery")) {
-        fn = "recovery.img";
-    } else if(!strcmp(item,"system")) {
-        fn = "system.img";
-    } else if(!strcmp(item,"vendor")) {
-        fn = "vendor.img";
-    } else if(!strcmp(item,"userdata")) {
-        fn = "userdata.img";
-    } else if(!strcmp(item,"cache")) {
-        fn = "cache.img";
-    } else if(!strcmp(item,"info")) {
-        fn = "android-info.txt";
-    } else {
-        fprintf(stderr,"unknown partition '%s'\n", item);
-        return "";
-    }
-
-    return find_item_given_name(fn, product);
-}
-
-static int64_t get_file_size(int fd) {
-    struct stat sb;
-    return fstat(fd, &sb) == -1 ? -1 : sb.st_size;
-}
-
-static void* load_fd(int fd, int64_t* sz) {
-    int errno_tmp;
-    char* data = nullptr;
-
-    *sz = get_file_size(fd);
-    if (*sz < 0) {
-        goto oops;
-    }
-
-    data = (char*) malloc(*sz);
-    if (data == nullptr) goto oops;
-
-    if(read(fd, data, *sz) != *sz) goto oops;
-    close(fd);
-
-    return data;
-
-oops:
-    errno_tmp = errno;
-    close(fd);
-    if(data != 0) free(data);
-    errno = errno_tmp;
-    return 0;
-}
-
-static void* load_file(const char* fn, int64_t* sz) {
-    int fd = open(fn, O_RDONLY | O_BINARY);
-    if (fd == -1) return nullptr;
-    return load_fd(fd, sz);
-}
-
-static int match_fastboot_with_serial(usb_ifc_info* info, const char* local_serial) {
-    // Require a matching vendor id if the user specified one with -i.
-    if (vendor_id != 0 && info->dev_vendor != vendor_id) {
-        return -1;
-    }
-
-    if (info->ifc_class != 0xff || info->ifc_subclass != 0x42 || info->ifc_protocol != 0x03) {
-        return -1;
-    }
-
-    // require matching serial number or device path if requested
-    // at the command line with the -s option.
-    if (local_serial && (strcmp(local_serial, info->serial_number) != 0 &&
-                   strcmp(local_serial, info->device_path) != 0)) return -1;
-    return 0;
-}
-
-static int match_fastboot(usb_ifc_info* info) {
-    return match_fastboot_with_serial(info, serial);
-}
-
-static int list_devices_callback(usb_ifc_info* info) {
-    if (match_fastboot_with_serial(info, nullptr) == 0) {
-        std::string serial = info->serial_number;
-        if (!info->writable) {
-            serial = UsbNoPermissionsShortHelpText();
-        }
-        if (!serial[0]) {
-            serial = "????????????";
-        }
-        // output compatible with "adb devices"
-        if (!long_listing) {
-            printf("%s\tfastboot", serial.c_str());
-        } else {
-            printf("%-22s fastboot", serial.c_str());
-            if (strlen(info->device_path) > 0) printf(" %s", info->device_path);
-        }
-        putchar('\n');
-    }
-
-    return -1;
-}
-
-// Opens a new Transport connected to a device. If |serial| is non-null it will be used to identify
-// a specific device, otherwise the first USB device found will be used.
-//
-// If |serial| is non-null but invalid, this prints an error message to stderr and returns nullptr.
-// Otherwise it blocks until the target is available.
-//
-// The returned Transport is a singleton, so multiple calls to this function will return the same
-// object, and the caller should not attempt to delete the returned Transport.
-static Transport* open_device() {
-    static Transport* transport = nullptr;
-    bool announce = true;
-
-    if (transport != nullptr) {
-        return transport;
-    }
-
-    Socket::Protocol protocol = Socket::Protocol::kTcp;
-    std::string host;
-    int port = 0;
-    if (serial != nullptr) {
-        const char* net_address = nullptr;
-
-        if (android::base::StartsWith(serial, "tcp:")) {
-            protocol = Socket::Protocol::kTcp;
-            port = tcp::kDefaultPort;
-            net_address = serial + strlen("tcp:");
-        } else if (android::base::StartsWith(serial, "udp:")) {
-            protocol = Socket::Protocol::kUdp;
-            port = udp::kDefaultPort;
-            net_address = serial + strlen("udp:");
-        }
-
-        if (net_address != nullptr) {
-            std::string error;
-            if (!android::base::ParseNetAddress(net_address, &host, &port, nullptr, &error)) {
-                fprintf(stderr, "error: Invalid network address '%s': %s\n", net_address,
-                        error.c_str());
-                return nullptr;
-            }
-        }
-    }
-
-    while (true) {
-        if (!host.empty()) {
-            std::string error;
-            if (protocol == Socket::Protocol::kTcp) {
-                transport = tcp::Connect(host, port, &error).release();
-            } else if (protocol == Socket::Protocol::kUdp) {
-                transport = udp::Connect(host, port, &error).release();
-            }
-
-            if (transport == nullptr && announce) {
-                fprintf(stderr, "error: %s\n", error.c_str());
-            }
-        } else {
-            transport = usb_open(match_fastboot);
-        }
-
-        if (transport != nullptr) {
-            return transport;
-        }
-
-        if (announce) {
-            announce = false;
-            fprintf(stderr, "< waiting for %s >\n", serial ? serial : "any device");
-        }
-        usleep(1000);
-    }
-}
-
-static void list_devices() {
-    // We don't actually open a USB device here,
-    // just getting our callback called so we can
-    // list all the connected devices.
-    usb_open(list_devices_callback);
-}
-
-static void usage() {
-    fprintf(stderr,
-/*           1234567890123456789012345678901234567890123456789012345678901234567890123456 */
-            "usage: fastboot [ <option> ] <command>\n"
-            "\n"
-            "commands:\n"
-            "  update <filename>                        Reflash device from update.zip.\n"
-            "                                           Sets the flashed slot as active.\n"
-            "  flashall                                 Flash boot, system, vendor, and --\n"
-            "                                           if found -- recovery. If the device\n"
-            "                                           supports slots, the slot that has\n"
-            "                                           been flashed to is set as active.\n"
-            "                                           Secondary images may be flashed to\n"
-            "                                           an inactive slot.\n"
-            "  flash <partition> [ <filename> ]         Write a file to a flash partition.\n"
-            "  flashing lock                            Locks the device. Prevents flashing.\n"
-            "  flashing unlock                          Unlocks the device. Allows flashing\n"
-            "                                           any partition except\n"
-            "                                           bootloader-related partitions.\n"
-            "  flashing lock_critical                   Prevents flashing bootloader-related\n"
-            "                                           partitions.\n"
-            "  flashing unlock_critical                 Enables flashing bootloader-related\n"
-            "                                           partitions.\n"
-            "  flashing get_unlock_ability              Queries bootloader to see if the\n"
-            "                                           device is unlocked.\n"
-            "  flashing get_unlock_bootloader_nonce     Queries the bootloader to get the\n"
-            "                                           unlock nonce.\n"
-            "  flashing unlock_bootloader <request>     Issue unlock bootloader using request.\n"
-            "  flashing lock_bootloader                 Locks the bootloader to prevent\n"
-            "                                           bootloader version rollback.\n"
-            "  erase <partition>                        Erase a flash partition.\n"
-            "  format[:[<fs type>][:[<size>]] <partition>\n"
-            "                                           Format a flash partition. Can\n"
-            "                                           override the fs type and/or size\n"
-            "                                           the bootloader reports.\n"
-            "  getvar <variable>                        Display a bootloader variable.\n"
-            "  set_active <slot>                        Sets the active slot. If slots are\n"
-            "                                           not supported, this does nothing.\n"
-            "  boot <kernel> [ <ramdisk> [ <second> ] ] Download and boot kernel.\n"
-            "  flash:raw boot <kernel> [ <ramdisk> [ <second> ] ]\n"
-            "                                           Create bootimage and flash it.\n"
-            "  devices [-l]                             List all connected devices [with\n"
-            "                                           device paths].\n"
-            "  continue                                 Continue with autoboot.\n"
-            "  reboot [bootloader]                      Reboot device [into bootloader].\n"
-            "  reboot-bootloader                        Reboot device into bootloader.\n"
-            "  help                                     Show this help message.\n"
-            "\n"
-            "options:\n"
-            "  -w                                       Erase userdata and cache (and format\n"
-            "                                           if supported by partition type).\n"
-            "  -u                                       Do not erase partition before\n"
-            "                                           formatting.\n"
-            "  -s <specific device>                     Specify a device. For USB, provide either\n"
-            "                                           a serial number or path to device port.\n"
-            "                                           For ethernet, provide an address in the\n"
-            "                                           form <protocol>:<hostname>[:port] where\n"
-            "                                           <protocol> is either tcp or udp.\n"
-            "  -p <product>                             Specify product name.\n"
-            "  -c <cmdline>                             Override kernel commandline.\n"
-            "  -i <vendor id>                           Specify a custom USB vendor id.\n"
-            "  -b, --base <base_addr>                   Specify a custom kernel base\n"
-            "                                           address (default: 0x10000000).\n"
-            "  --kernel-offset                          Specify a custom kernel offset.\n"
-            "                                           (default: 0x00008000)\n"
-            "  --ramdisk-offset                         Specify a custom ramdisk offset.\n"
-            "                                           (default: 0x01000000)\n"
-            "  --tags-offset                            Specify a custom tags offset.\n"
-            "                                           (default: 0x00000100)\n"
-            "  -n, --page-size <page size>              Specify the nand page size\n"
-            "                                           (default: 2048).\n"
-            "  -S <size>[K|M|G]                         Automatically sparse files greater\n"
-            "                                           than 'size'. 0 to disable.\n"
-            "  --slot <slot>                            Specify slot name to be used if the\n"
-            "                                           device supports slots. All operations\n"
-            "                                           on partitions that support slots will\n"
-            "                                           be done on the slot specified.\n"
-            "                                           'all' can be given to refer to all slots.\n"
-            "                                           'other' can be given to refer to a\n"
-            "                                           non-current slot. If this flag is not\n"
-            "                                           used, slotted partitions will default\n"
-            "                                           to the current active slot.\n"
-            "  -a, --set-active[=<slot>]                Sets the active slot. If no slot is\n"
-            "                                           provided, this will default to the value\n"
-            "                                           given by --slot. If slots are not\n"
-            "                                           supported, this sets the current slot\n"
-            "                                           to be active. This will run after all\n"
-            "                                           non-reboot commands.\n"
-            "  --skip-secondary                         Will not flash secondary slots when\n"
-            "                                           performing a flashall or update. This\n"
-            "                                           will preserve data on other slots.\n"
-#if !defined(_WIN32)
-            "  --wipe-and-use-fbe                       On devices which support it,\n"
-            "                                           erase userdata and cache, and\n"
-            "                                           enable file-based encryption\n"
-#endif
-            "  --unbuffered                             Do not buffer input or output.\n"
-            "  --version                                Display version.\n"
-            "  -R                                       reboot device (e.g. after flash)\n"
-            "  -h, --help                               show this message.\n"
-        );
-}
-
-static void* load_bootable_image(const char* kernel, const char* ramdisk,
-                                 const char* secondstage, int64_t* sz,
-                                 const char* cmdline) {
-    if (kernel == nullptr) {
-        fprintf(stderr, "no image specified\n");
-        return 0;
-    }
-
-    int64_t ksize;
-    void* kdata = load_file(kernel, &ksize);
-    if (kdata == nullptr) {
-        fprintf(stderr, "cannot load '%s': %s\n", kernel, strerror(errno));
-        return 0;
-    }
-
-    // Is this actually a boot image?
-    if(!memcmp(kdata, BOOT_MAGIC, BOOT_MAGIC_SIZE)) {
-        if (cmdline) bootimg_set_cmdline((boot_img_hdr*) kdata, cmdline);
-
-        if (ramdisk) {
-            fprintf(stderr, "cannot boot a boot.img *and* ramdisk\n");
-            return 0;
-        }
-
-        *sz = ksize;
-        return kdata;
-    }
-
-    void* rdata = nullptr;
-    int64_t rsize = 0;
-    if (ramdisk) {
-        rdata = load_file(ramdisk, &rsize);
-        if (rdata == nullptr) {
-            fprintf(stderr,"cannot load '%s': %s\n", ramdisk, strerror(errno));
-            return  0;
-        }
-    }
-
-    void* sdata = nullptr;
-    int64_t ssize = 0;
-    if (secondstage) {
-        sdata = load_file(secondstage, &ssize);
-        if (sdata == nullptr) {
-            fprintf(stderr,"cannot load '%s': %s\n", secondstage, strerror(errno));
-            return  0;
-        }
-    }
-
-    fprintf(stderr,"creating boot image...\n");
-    int64_t bsize = 0;
-    void* bdata = mkbootimg(kdata, ksize, kernel_offset,
-                      rdata, rsize, ramdisk_offset,
-                      sdata, ssize, second_offset,
-                      page_size, base_addr, tags_offset, &bsize);
-    if (bdata == nullptr) {
-        fprintf(stderr,"failed to create boot.img\n");
-        return 0;
-    }
-    if (cmdline) bootimg_set_cmdline((boot_img_hdr*) bdata, cmdline);
-    fprintf(stderr, "creating boot image - %" PRId64 " bytes\n", bsize);
-    *sz = bsize;
-
-    return bdata;
-}
-
-static void* unzip_file(ZipArchiveHandle zip, const char* entry_name, int64_t* sz)
-{
-    ZipString zip_entry_name(entry_name);
-    ZipEntry zip_entry;
-    if (FindEntry(zip, zip_entry_name, &zip_entry) != 0) {
-        fprintf(stderr, "archive does not contain '%s'\n", entry_name);
-        return 0;
-    }
-
-    *sz = zip_entry.uncompressed_length;
-
-    uint8_t* data = reinterpret_cast<uint8_t*>(malloc(zip_entry.uncompressed_length));
-    if (data == nullptr) {
-        fprintf(stderr, "failed to allocate %" PRId64 " bytes for '%s'\n", *sz, entry_name);
-        return 0;
-    }
-
-    int error = ExtractToMemory(zip, &zip_entry, data, zip_entry.uncompressed_length);
-    if (error != 0) {
-        fprintf(stderr, "failed to extract '%s': %s\n", entry_name, ErrorCodeString(error));
-        free(data);
-        return 0;
-    }
-
-    return data;
-}
-
-#if defined(_WIN32)
-
-// TODO: move this to somewhere it can be shared.
-
-#include <windows.h>
-
-// Windows' tmpfile(3) requires administrator rights because
-// it creates temporary files in the root directory.
-static FILE* win32_tmpfile() {
-    char temp_path[PATH_MAX];
-    DWORD nchars = GetTempPath(sizeof(temp_path), temp_path);
-    if (nchars == 0 || nchars >= sizeof(temp_path)) {
-        fprintf(stderr, "GetTempPath failed, error %ld\n", GetLastError());
-        return nullptr;
-    }
-
-    char filename[PATH_MAX];
-    if (GetTempFileName(temp_path, "fastboot", 0, filename) == 0) {
-        fprintf(stderr, "GetTempFileName failed, error %ld\n", GetLastError());
-        return nullptr;
-    }
-
-    return fopen(filename, "w+bTD");
-}
-
-#define tmpfile win32_tmpfile
-
-static std::string make_temporary_directory() {
-    fprintf(stderr, "make_temporary_directory not supported under Windows, sorry!");
-    return "";
-}
-
-#else
-
-static std::string make_temporary_directory() {
-    const char *tmpdir = getenv("TMPDIR");
-    if (tmpdir == nullptr) {
-        tmpdir = P_tmpdir;
-    }
-    std::string result = std::string(tmpdir) + "/fastboot_userdata_XXXXXX";
-    if (mkdtemp(&result[0]) == NULL) {
-        fprintf(stderr, "Unable to create temporary directory: %s\n",
-            strerror(errno));
-        return "";
-    }
-    return result;
-}
-
-#endif
-
-static std::string create_fbemarker_tmpdir() {
-    std::string dir = make_temporary_directory();
-    if (dir.empty()) {
-        fprintf(stderr, "Unable to create local temp directory for FBE marker\n");
-        return "";
-    }
-    std::string marker_file = dir + "/" + convert_fbe_marker_filename;
-    int fd = open(marker_file.c_str(), O_CREAT | O_WRONLY | O_CLOEXEC, 0666);
-    if (fd == -1) {
-        fprintf(stderr, "Unable to create FBE marker file %s locally: %d, %s\n",
-            marker_file.c_str(), errno, strerror(errno));
-        return "";
-    }
-    close(fd);
-    return dir;
-}
-
-static void delete_fbemarker_tmpdir(const std::string& dir) {
-    std::string marker_file = dir + "/" + convert_fbe_marker_filename;
-    if (unlink(marker_file.c_str()) == -1) {
-        fprintf(stderr, "Unable to delete FBE marker file %s locally: %d, %s\n",
-            marker_file.c_str(), errno, strerror(errno));
-        return;
-    }
-    if (rmdir(dir.c_str()) == -1) {
-        fprintf(stderr, "Unable to delete FBE marker directory %s locally: %d, %s\n",
-            dir.c_str(), errno, strerror(errno));
-        return;
-    }
-}
-
-static int unzip_to_file(ZipArchiveHandle zip, char* entry_name) {
-    FILE* fp = tmpfile();
-    if (fp == nullptr) {
-        fprintf(stderr, "failed to create temporary file for '%s': %s\n",
-                entry_name, strerror(errno));
-        return -1;
-    }
-
-    ZipString zip_entry_name(entry_name);
-    ZipEntry zip_entry;
-    if (FindEntry(zip, zip_entry_name, &zip_entry) != 0) {
-        fprintf(stderr, "archive does not contain '%s'\n", entry_name);
-        return -1;
-    }
-
-    int fd = fileno(fp);
-    int error = ExtractEntryToFile(zip, &zip_entry, fd);
-    if (error != 0) {
-        fprintf(stderr, "failed to extract '%s': %s\n", entry_name, ErrorCodeString(error));
-        return -1;
-    }
-
-    lseek(fd, 0, SEEK_SET);
-    return fd;
-}
-
-static char *strip(char *s)
-{
-    int n;
-    while(*s && isspace(*s)) s++;
-    n = strlen(s);
-    while(n-- > 0) {
-        if(!isspace(s[n])) break;
-        s[n] = 0;
-    }
-    return s;
-}
-
-#define MAX_OPTIONS 32
-static int setup_requirement_line(char *name)
-{
-    char *val[MAX_OPTIONS];
-    char *prod = nullptr;
-    unsigned n, count;
-    char *x;
-    int invert = 0;
-
-    if (!strncmp(name, "reject ", 7)) {
-        name += 7;
-        invert = 1;
-    } else if (!strncmp(name, "require ", 8)) {
-        name += 8;
-        invert = 0;
-    } else if (!strncmp(name, "require-for-product:", 20)) {
-        // Get the product and point name past it
-        prod = name + 20;
-        name = strchr(name, ' ');
-        if (!name) return -1;
-        *name = 0;
-        name += 1;
-        invert = 0;
-    }
-
-    x = strchr(name, '=');
-    if (x == 0) return 0;
-    *x = 0;
-    val[0] = x + 1;
-
-    for(count = 1; count < MAX_OPTIONS; count++) {
-        x = strchr(val[count - 1],'|');
-        if (x == 0) break;
-        *x = 0;
-        val[count] = x + 1;
-    }
-
-    name = strip(name);
-    for(n = 0; n < count; n++) val[n] = strip(val[n]);
-
-    name = strip(name);
-    if (name == 0) return -1;
-
-    const char* var = name;
-    // Work around an unfortunate name mismatch.
-    if (!strcmp(name,"board")) var = "product";
-
-    const char** out = reinterpret_cast<const char**>(malloc(sizeof(char*) * count));
-    if (out == 0) return -1;
-
-    for(n = 0; n < count; n++) {
-        out[n] = strdup(strip(val[n]));
-        if (out[n] == 0) {
-            for(size_t i = 0; i < n; ++i) {
-                free((char*) out[i]);
-            }
-            free(out);
-            return -1;
-        }
-    }
-
-    fb_queue_require(prod, var, invert, n, out);
-    return 0;
-}
-
-static void setup_requirements(char* data, int64_t sz) {
-    char* s = data;
-    while (sz-- > 0) {
-        if (*s == '\n') {
-            *s++ = 0;
-            if (setup_requirement_line(data)) {
-                die("out of memory");
-            }
-            data = s;
-        } else {
-            s++;
-        }
-    }
-}
-
-static void queue_info_dump() {
-    fb_queue_notice("--------------------------------------------");
-    fb_queue_display("version-bootloader", "Bootloader Version...");
-    fb_queue_display("version-baseband",   "Baseband Version.....");
-    fb_queue_display("serialno",           "Serial Number........");
-    fb_queue_notice("--------------------------------------------");
-}
-
-static struct sparse_file **load_sparse_files(int fd, int max_size)
-{
-    struct sparse_file* s = sparse_file_import_auto(fd, false, true);
-    if (!s) {
-        die("cannot sparse read file\n");
-    }
-
-    int files = sparse_file_resparse(s, max_size, nullptr, 0);
-    if (files < 0) {
-        die("Failed to resparse\n");
-    }
-
-    sparse_file** out_s = reinterpret_cast<sparse_file**>(calloc(sizeof(struct sparse_file *), files + 1));
-    if (!out_s) {
-        die("Failed to allocate sparse file array\n");
-    }
-
-    files = sparse_file_resparse(s, max_size, out_s, files);
-    if (files < 0) {
-        die("Failed to resparse\n");
-    }
-
-    return out_s;
-}
-
-static int64_t get_target_sparse_limit(Transport* transport) {
-    std::string max_download_size;
-    if (!fb_getvar(transport, "max-download-size", &max_download_size) ||
-            max_download_size.empty()) {
-        fprintf(stderr, "target didn't report max-download-size\n");
-        return 0;
-    }
-
-    // Some bootloaders (angler, for example) send spurious whitespace too.
-    max_download_size = android::base::Trim(max_download_size);
-
-    uint64_t limit;
-    if (!android::base::ParseUint(max_download_size.c_str(), &limit)) {
-        fprintf(stderr, "couldn't parse max-download-size '%s'\n", max_download_size.c_str());
-        return 0;
-    }
-    if (limit > 0) {
-        fprintf(stderr, "target reported max download size of %" PRId64 " bytes\n", limit);
-    }
-    return limit;
-}
-
-static int64_t get_sparse_limit(Transport* transport, int64_t size) {
-    int64_t limit;
-
-    if (sparse_limit == 0) {
-        return 0;
-    } else if (sparse_limit > 0) {
-        limit = sparse_limit;
-    } else {
-        if (target_sparse_limit == -1) {
-            target_sparse_limit = get_target_sparse_limit(transport);
-        }
-        if (target_sparse_limit > 0) {
-            limit = target_sparse_limit;
-        } else {
-            return 0;
-        }
-    }
-
-    if (size > limit) {
-        return limit;
-    }
-
-    return 0;
-}
-
-// Until we get lazy inode table init working in make_ext4fs, we need to
-// erase partitions of type ext4 before flashing a filesystem so no stale
-// inodes are left lying around.  Otherwise, e2fsck gets very upset.
-static bool needs_erase(Transport* transport, const char* partition) {
-    std::string partition_type;
-    if (!fb_getvar(transport, std::string("partition-type:") + partition, &partition_type)) {
-        return false;
-    }
-    return partition_type == "ext4";
-}
-
-static int load_buf_fd(Transport* transport, int fd, struct fastboot_buffer* buf) {
-    int64_t sz = get_file_size(fd);
-    if (sz == -1) {
-        return -1;
-    }
-
-    lseek64(fd, 0, SEEK_SET);
-    int64_t limit = get_sparse_limit(transport, sz);
-    if (limit) {
-        sparse_file** s = load_sparse_files(fd, limit);
-        if (s == nullptr) {
-            return -1;
-        }
-        buf->type = FB_BUFFER_SPARSE;
-        buf->data = s;
-    } else {
-        void* data = load_fd(fd, &sz);
-        if (data == nullptr) return -1;
-        buf->type = FB_BUFFER;
-        buf->data = data;
-        buf->sz = sz;
-    }
-
-    return 0;
-}
-
-static int load_buf(Transport* transport, const char *fname, struct fastboot_buffer *buf)
-{
-    int fd;
-
-    fd = open(fname, O_RDONLY | O_BINARY);
-    if (fd < 0) {
-        return -1;
-    }
-
-    return load_buf_fd(transport, fd, buf);
-}
-
-static void flash_buf(const char *pname, struct fastboot_buffer *buf)
-{
-    sparse_file** s;
-
-    switch (buf->type) {
-        case FB_BUFFER_SPARSE: {
-            std::vector<std::pair<sparse_file*, int64_t>> sparse_files;
-            s = reinterpret_cast<sparse_file**>(buf->data);
-            while (*s) {
-                int64_t sz = sparse_file_len(*s, true, false);
-                sparse_files.emplace_back(*s, sz);
-                ++s;
-            }
-
-            for (size_t i = 0; i < sparse_files.size(); ++i) {
-                const auto& pair = sparse_files[i];
-                fb_queue_flash_sparse(pname, pair.first, pair.second, i + 1, sparse_files.size());
-            }
-            break;
-        }
-
-        case FB_BUFFER:
-            fb_queue_flash(pname, buf->data, buf->sz);
-            break;
-        default:
-            die("unknown buffer type: %d", buf->type);
-    }
-}
-
-static std::string get_current_slot(Transport* transport)
-{
-    std::string current_slot;
-    if (fb_getvar(transport, "current-slot", &current_slot)) {
-        if (current_slot == "_a") return "a"; // Legacy support
-        if (current_slot == "_b") return "b"; // Legacy support
-        return current_slot;
-    }
-    return "";
-}
-
-// Legacy support
-static std::vector<std::string> get_suffixes_obsolete(Transport* transport) {
-    std::vector<std::string> suffixes;
-    std::string suffix_list;
-    if (!fb_getvar(transport, "slot-suffixes", &suffix_list)) {
-        return suffixes;
-    }
-    suffixes = android::base::Split(suffix_list, ",");
-    // Unfortunately some devices will return an error message in the
-    // guise of a valid value. If we only see only one suffix, it's probably
-    // not real.
-    if (suffixes.size() == 1) {
-        suffixes.clear();
-    }
-    return suffixes;
-}
-
-// Legacy support
-static bool supports_AB_obsolete(Transport* transport) {
-  return !get_suffixes_obsolete(transport).empty();
-}
-
-static int get_slot_count(Transport* transport) {
-    std::string var;
-    int count;
-    if (!fb_getvar(transport, "slot-count", &var)) {
-        if (supports_AB_obsolete(transport)) return 2; // Legacy support
-    }
-    if (!android::base::ParseInt(var.c_str(), &count)) return 0;
-    return count;
-}
-
-static bool supports_AB(Transport* transport) {
-  return get_slot_count(transport) >= 2;
-}
-
-// Given a current slot, this returns what the 'other' slot is.
-static std::string get_other_slot(const std::string& current_slot, int count) {
-    if (count == 0) return "";
-
-    char next = (current_slot[0] - 'a' + 1)%count + 'a';
-    return std::string(1, next);
-}
-
-static std::string get_other_slot(Transport* transport, const std::string& current_slot) {
-    return get_other_slot(current_slot, get_slot_count(transport));
-}
-
-static std::string get_other_slot(Transport* transport, int count) {
-    return get_other_slot(get_current_slot(transport), count);
-}
-
-static std::string get_other_slot(Transport* transport) {
-    return get_other_slot(get_current_slot(transport), get_slot_count(transport));
-}
-
-static std::string verify_slot(Transport* transport, const std::string& slot_name, bool allow_all) {
-    std::string slot = slot_name;
-    if (slot == "_a") slot = "a"; // Legacy support
-    if (slot == "_b") slot = "b"; // Legacy support
-    if (slot == "all") {
-        if (allow_all) {
-            return "all";
-        } else {
-            int count = get_slot_count(transport);
-            if (count > 0) {
-                return "a";
-            } else {
-                die("No known slots.");
-            }
-        }
-    }
-
-    int count = get_slot_count(transport);
-    if (count == 0) die("Device does not support slots.\n");
-
-    if (slot == "other") {
-        std::string other = get_other_slot(transport, count);
-        if (other == "") {
-           die("No known slots.");
-        }
-        return other;
-    }
-
-    if (slot.size() == 1 && (slot[0]-'a' >= 0 && slot[0]-'a' < count)) return slot;
-
-    fprintf(stderr, "Slot %s does not exist. supported slots are:\n", slot.c_str());
-    for (int i=0; i<count; i++) {
-        fprintf(stderr, "%c\n", (char)(i + 'a'));
-    }
-
-    exit(1);
-}
-
-static std::string verify_slot(Transport* transport, const std::string& slot) {
-   return verify_slot(transport, slot, true);
-}
-
-static void do_for_partition(Transport* transport, const std::string& part, const std::string& slot,
-                             const std::function<void(const std::string&)>& func, bool force_slot) {
-    std::string has_slot;
-    std::string current_slot;
-
-    if (!fb_getvar(transport, "has-slot:" + part, &has_slot)) {
-        /* If has-slot is not supported, the answer is no. */
-        has_slot = "no";
-    }
-    if (has_slot == "yes") {
-        if (slot == "") {
-            current_slot = get_current_slot(transport);
-            if (current_slot == "") {
-                die("Failed to identify current slot.\n");
-            }
-            func(part + "_" + current_slot);
-        } else {
-            func(part + '_' + slot);
-        }
-    } else {
-        if (force_slot && slot != "") {
-             fprintf(stderr, "Warning: %s does not support slots, and slot %s was requested.\n",
-                     part.c_str(), slot.c_str());
-        }
-        func(part);
-    }
-}
-
-/* This function will find the real partition name given a base name, and a slot. If slot is NULL or
- * empty, it will use the current slot. If slot is "all", it will return a list of all possible
- * partition names. If force_slot is true, it will fail if a slot is specified, and the given
- * partition does not support slots.
- */
-static void do_for_partitions(Transport* transport, const std::string& part, const std::string& slot,
-                              const std::function<void(const std::string&)>& func, bool force_slot) {
-    std::string has_slot;
-
-    if (slot == "all") {
-        if (!fb_getvar(transport, "has-slot:" + part, &has_slot)) {
-            die("Could not check if partition %s has slot.", part.c_str());
-        }
-        if (has_slot == "yes") {
-            for (int i=0; i < get_slot_count(transport); i++) {
-                do_for_partition(transport, part, std::string(1, (char)(i + 'a')), func, force_slot);
-            }
-        } else {
-            do_for_partition(transport, part, "", func, force_slot);
-        }
-    } else {
-        do_for_partition(transport, part, slot, func, force_slot);
-    }
-}
-
-static void do_flash(Transport* transport, const char* pname, const char* fname) {
-    struct fastboot_buffer buf;
-
-    if (load_buf(transport, fname, &buf)) {
-        die("cannot load '%s'", fname);
-    }
-    flash_buf(pname, &buf);
-}
-
-static void do_update_signature(ZipArchiveHandle zip, char* fn) {
-    int64_t sz;
-    void* data = unzip_file(zip, fn, &sz);
-    if (data == nullptr) return;
-    fb_queue_download("signature", data, sz);
-    fb_queue_command("signature", "installing signature");
-}
-
-// Sets slot_override as the active slot. If slot_override is blank,
-// set current slot as active instead. This clears slot-unbootable.
-static void set_active(Transport* transport, const std::string& slot_override) {
-    std::string separator = "";
-    if (!supports_AB(transport)) {
-        if (supports_AB_obsolete(transport)) {
-            separator = "_"; // Legacy support
-        } else {
-            return;
-        }
-    }
-    if (slot_override != "") {
-        fb_set_active((separator + slot_override).c_str());
-    } else {
-        std::string current_slot = get_current_slot(transport);
-        if (current_slot != "") {
-            fb_set_active((separator + current_slot).c_str());
-        }
-    }
-}
-
-static void do_update(Transport* transport, const char* filename, const std::string& slot_override, bool erase_first, bool skip_secondary) {
-    queue_info_dump();
-
-    fb_queue_query_save("product", cur_product, sizeof(cur_product));
-
-    ZipArchiveHandle zip;
-    int error = OpenArchive(filename, &zip);
-    if (error != 0) {
-        CloseArchive(zip);
-        die("failed to open zip file '%s': %s", filename, ErrorCodeString(error));
-    }
-
-    int64_t sz;
-    void* data = unzip_file(zip, "android-info.txt", &sz);
-    if (data == nullptr) {
-        CloseArchive(zip);
-        die("update package '%s' has no android-info.txt", filename);
-    }
-
-    setup_requirements(reinterpret_cast<char*>(data), sz);
-
-    std::string secondary;
-    if (!skip_secondary) {
-        if (slot_override != "") {
-            secondary = get_other_slot(transport, slot_override);
-        } else {
-            secondary = get_other_slot(transport);
-        }
-        if (secondary == "") {
-            if (supports_AB(transport)) {
-                fprintf(stderr, "Warning: Could not determine slot for secondary images. Ignoring.\n");
-            }
-            skip_secondary = true;
-        }
-    }
-    for (size_t i = 0; i < ARRAY_SIZE(images); ++i) {
-        const char* slot = slot_override.c_str();
-        if (images[i].is_secondary) {
-            if (!skip_secondary) {
-                slot = secondary.c_str();
-            } else {
-                continue;
-            }
-        }
-
-        int fd = unzip_to_file(zip, images[i].img_name);
-        if (fd == -1) {
-            if (images[i].is_optional) {
-                continue;
-            }
-            CloseArchive(zip);
-            exit(1); // unzip_to_file already explained why.
-        }
-        fastboot_buffer buf;
-        int rc = load_buf_fd(transport, fd, &buf);
-        if (rc) die("cannot load %s from flash", images[i].img_name);
-
-        auto update = [&](const std::string &partition) {
-            do_update_signature(zip, images[i].sig_name);
-            if (erase_first && needs_erase(transport, partition.c_str())) {
-                fb_queue_erase(partition.c_str());
-            }
-            flash_buf(partition.c_str(), &buf);
-            /* not closing the fd here since the sparse code keeps the fd around
-             * but hasn't mmaped data yet. The tmpfile will get cleaned up when the
-             * program exits.
-             */
-        };
-        do_for_partitions(transport, images[i].part_name, slot, update, false);
-    }
-
-    CloseArchive(zip);
-    if (slot_override == "all") {
-        set_active(transport, "a");
-    } else {
-        set_active(transport, slot_override);
-    }
-}
-
-static void do_send_signature(const std::string& fn) {
-    std::size_t extension_loc = fn.find(".img");
-    if (extension_loc == std::string::npos) return;
-
-    std::string fs_sig = fn.substr(0, extension_loc) + ".sig";
-
-    int64_t sz;
-    void* data = load_file(fs_sig.c_str(), &sz);
-    if (data == nullptr) return;
-    fb_queue_download("signature", data, sz);
-    fb_queue_command("signature", "installing signature");
-}
-
-static void do_flashall(Transport* transport, const std::string& slot_override, int erase_first, bool skip_secondary) {
-    std::string fname;
-    queue_info_dump();
-
-    fb_queue_query_save("product", cur_product, sizeof(cur_product));
-
-    fname = find_item("info", product);
-    if (fname == "") die("cannot find android-info.txt");
-
-    int64_t sz;
-    void* data = load_file(fname.c_str(), &sz);
-    if (data == nullptr) die("could not load android-info.txt: %s", strerror(errno));
-
-    setup_requirements(reinterpret_cast<char*>(data), sz);
-
-    std::string secondary;
-    if (!skip_secondary) {
-        if (slot_override != "") {
-            secondary = get_other_slot(transport, slot_override);
-        } else {
-            secondary = get_other_slot(transport);
-        }
-        if (secondary == "") {
-            if (supports_AB(transport)) {
-                fprintf(stderr, "Warning: Could not determine slot for secondary images. Ignoring.\n");
-            }
-            skip_secondary = true;
-        }
-    }
-
-    for (size_t i = 0; i < ARRAY_SIZE(images); i++) {
-        const char* slot = NULL;
-        if (images[i].is_secondary) {
-            if (!skip_secondary) slot = secondary.c_str();
-        } else {
-            slot = slot_override.c_str();
-        }
-        if (!slot) continue;
-        fname = find_item_given_name(images[i].img_name, product);
-        fastboot_buffer buf;
-        if (load_buf(transport, fname.c_str(), &buf)) {
-            if (images[i].is_optional) continue;
-            die("could not load %s\n", images[i].img_name);
-        }
-
-        auto flashall = [&](const std::string &partition) {
-            do_send_signature(fname);
-            if (erase_first && needs_erase(transport, partition.c_str())) {
-                fb_queue_erase(partition.c_str());
-            }
-            flash_buf(partition.c_str(), &buf);
-        };
-        do_for_partitions(transport, images[i].part_name, slot, flashall, false);
-    }
-
-    if (slot_override == "all") {
-        set_active(transport, "a");
-    } else {
-        set_active(transport, slot_override);
-    }
-}
-
-#define skip(n) do { argc -= (n); argv += (n); } while (0)
-#define require(n) do { if (argc < (n)) {usage(); exit(1);}} while (0)
-
-static int do_bypass_unlock_command(int argc, char **argv)
-{
-    if (argc <= 2) return 0;
-    skip(2);
-
-    /*
-     * Process unlock_bootloader, we have to load the message file
-     * and send that to the remote device.
-     */
-    require(1);
-
-    int64_t sz;
-    void* data = load_file(*argv, &sz);
-    if (data == nullptr) die("could not load '%s': %s", *argv, strerror(errno));
-    fb_queue_download("unlock_message", data, sz);
-    fb_queue_command("flashing unlock_bootloader", "unlocking bootloader");
-    skip(1);
-    return 0;
-}
-
-static int do_oem_command(int argc, char **argv)
-{
-    char command[256];
-    if (argc <= 1) return 0;
-
-    command[0] = 0;
-    while(1) {
-        strcat(command,*argv);
-        skip(1);
-        if(argc == 0) break;
-        strcat(command," ");
-    }
-
-    fb_queue_command(command,"");
-    return 0;
-}
-
-static int64_t parse_num(const char *arg)
-{
-    char *endptr;
-    unsigned long long num;
-
-    num = strtoull(arg, &endptr, 0);
-    if (endptr == arg) {
-        return -1;
-    }
-
-    if (*endptr == 'k' || *endptr == 'K') {
-        if (num >= (-1ULL) / 1024) {
-            return -1;
-        }
-        num *= 1024LL;
-        endptr++;
-    } else if (*endptr == 'm' || *endptr == 'M') {
-        if (num >= (-1ULL) / (1024 * 1024)) {
-            return -1;
-        }
-        num *= 1024LL * 1024LL;
-        endptr++;
-    } else if (*endptr == 'g' || *endptr == 'G') {
-        if (num >= (-1ULL) / (1024 * 1024 * 1024)) {
-            return -1;
-        }
-        num *= 1024LL * 1024LL * 1024LL;
-        endptr++;
-    }
-
-    if (*endptr != '\0') {
-        return -1;
-    }
-
-    if (num > INT64_MAX) {
-        return -1;
-    }
-
-    return num;
-}
-
-static void fb_perform_format(Transport* transport,
-                              const char* partition, int skip_if_not_supported,
-                              const char* type_override, const char* size_override,
-                              const std::string& initial_dir) {
-    std::string partition_type, partition_size;
-
-    struct fastboot_buffer buf;
-    const char* errMsg = nullptr;
-    const struct fs_generator* gen = nullptr;
-    int fd;
-
-    unsigned int limit = INT_MAX;
-    if (target_sparse_limit > 0 && target_sparse_limit < limit) {
-        limit = target_sparse_limit;
-    }
-    if (sparse_limit > 0 && sparse_limit < limit) {
-        limit = sparse_limit;
-    }
-
-    if (!fb_getvar(transport, std::string("partition-type:") + partition, &partition_type)) {
-        errMsg = "Can't determine partition type.\n";
-        goto failed;
-    }
-    if (type_override) {
-        if (partition_type != type_override) {
-            fprintf(stderr, "Warning: %s type is %s, but %s was requested for formatting.\n",
-                    partition, partition_type.c_str(), type_override);
-        }
-        partition_type = type_override;
-    }
-
-    if (!fb_getvar(transport, std::string("partition-size:") + partition, &partition_size)) {
-        errMsg = "Unable to get partition size\n";
-        goto failed;
-    }
-    if (size_override) {
-        if (partition_size != size_override) {
-            fprintf(stderr, "Warning: %s size is %s, but %s was requested for formatting.\n",
-                    partition, partition_size.c_str(), size_override);
-        }
-        partition_size = size_override;
-    }
-    // Some bootloaders (angler, for example), send spurious leading whitespace.
-    partition_size = android::base::Trim(partition_size);
-    // Some bootloaders (hammerhead, for example) use implicit hex.
-    // This code used to use strtol with base 16.
-    if (!android::base::StartsWith(partition_size, "0x")) partition_size = "0x" + partition_size;
-
-    gen = fs_get_generator(partition_type);
-    if (!gen) {
-        if (skip_if_not_supported) {
-            fprintf(stderr, "Erase successful, but not automatically formatting.\n");
-            fprintf(stderr, "File system type %s not supported.\n", partition_type.c_str());
-            return;
-        }
-        fprintf(stderr, "Formatting is not supported for file system with type '%s'.\n",
-                partition_type.c_str());
-        return;
-    }
-
-    int64_t size;
-    if (!android::base::ParseInt(partition_size.c_str(), &size)) {
-        fprintf(stderr, "Couldn't parse partition size '%s'.\n", partition_size.c_str());
-        return;
-    }
-
-    fd = fileno(tmpfile());
-    if (fs_generator_generate(gen, fd, size, initial_dir)) {
-        fprintf(stderr, "Cannot generate image: %s\n", strerror(errno));
-        close(fd);
-        return;
-    }
-
-    if (load_buf_fd(transport, fd, &buf)) {
-        fprintf(stderr, "Cannot read image: %s\n", strerror(errno));
-        close(fd);
-        return;
-    }
-    flash_buf(partition, &buf);
-    return;
-
-failed:
-    if (skip_if_not_supported) {
-        fprintf(stderr, "Erase successful, but not automatically formatting.\n");
-        if (errMsg) fprintf(stderr, "%s", errMsg);
-    }
-    fprintf(stderr,"FAILED (%s)\n", fb_get_error());
-}
-
-int main(int argc, char **argv)
-{
-    bool wants_wipe = false;
-    bool wants_reboot = false;
-    bool wants_reboot_bootloader = false;
-    bool wants_set_active = false;
-    bool skip_secondary = false;
-    bool erase_first = true;
-    bool set_fbe_marker = false;
-    void *data;
-    int64_t sz;
-    int longindex;
-    std::string slot_override;
-    std::string next_active;
-
-    const struct option longopts[] = {
-        {"base", required_argument, 0, 'b'},
-        {"kernel_offset", required_argument, 0, 'k'},
-        {"kernel-offset", required_argument, 0, 'k'},
-        {"page_size", required_argument, 0, 'n'},
-        {"page-size", required_argument, 0, 'n'},
-        {"ramdisk_offset", required_argument, 0, 'r'},
-        {"ramdisk-offset", required_argument, 0, 'r'},
-        {"tags_offset", required_argument, 0, 't'},
-        {"tags-offset", required_argument, 0, 't'},
-        {"help", no_argument, 0, 'h'},
-        {"unbuffered", no_argument, 0, 0},
-        {"version", no_argument, 0, 0},
-        {"slot", required_argument, 0, 0},
-        {"set_active", optional_argument, 0, 'a'},
-        {"set-active", optional_argument, 0, 'a'},
-        {"skip-secondary", no_argument, 0, 0},
-#if !defined(_WIN32)
-        {"wipe-and-use-fbe", no_argument, 0, 0},
-#endif
-        {"reboot", no_argument, 0, 'R'},
-        {0, 0, 0, 0}
-    };
-
-    serial = getenv("ANDROID_SERIAL");
-
-    while (1) {
-        int c = getopt_long(argc, argv, "wub:k:n:r:t:s:S:lp:c:i:m:hRa::", longopts, &longindex);
-        if (c < 0) {
-            break;
-        }
-        /* Alphabetical cases */
-        switch (c) {
-        case 'a':
-            wants_set_active = true;
-            if (optarg)
-                next_active = optarg;
-            break;
-        case 'b':
-            base_addr = strtoul(optarg, 0, 16);
-            break;
-        case 'c':
-            cmdline = optarg;
-            break;
-        case 'h':
-            usage();
-            return 1;
-        case 'i': {
-                char *endptr = nullptr;
-                unsigned long val;
-
-                val = strtoul(optarg, &endptr, 0);
-                if (!endptr || *endptr != '\0' || (val & ~0xffff))
-                    die("invalid vendor id '%s'", optarg);
-                vendor_id = (unsigned short)val;
-                break;
-            }
-        case 'k':
-            kernel_offset = strtoul(optarg, 0, 16);
-            break;
-        case 'l':
-            long_listing = 1;
-            break;
-        case 'n':
-            page_size = (unsigned)strtoul(optarg, nullptr, 0);
-            if (!page_size) die("invalid page size");
-            break;
-        case 'p':
-            product = optarg;
-            break;
-        case 'r':
-            ramdisk_offset = strtoul(optarg, 0, 16);
-            break;
-        case 'R':
-            wants_reboot = 1;
-            break;
-        case 't':
-            tags_offset = strtoul(optarg, 0, 16);
-            break;
-        case 's':
-            serial = optarg;
-            break;
-        case 'S':
-            sparse_limit = parse_num(optarg);
-            if (sparse_limit < 0) {
-                    die("invalid sparse limit");
-            }
-            break;
-        case 'u':
-            erase_first = false;
-            break;
-        case 'w':
-            wants_wipe = true;
-            break;
-        case '?':
-            return 1;
-        case 0:
-            if (strcmp("unbuffered", longopts[longindex].name) == 0) {
-                setvbuf(stdout, nullptr, _IONBF, 0);
-                setvbuf(stderr, nullptr, _IONBF, 0);
-            } else if (strcmp("version", longopts[longindex].name) == 0) {
-                fprintf(stdout, "fastboot version %s\n", FASTBOOT_REVISION);
-                return 0;
-            } else if (strcmp("slot", longopts[longindex].name) == 0) {
-                slot_override = std::string(optarg);
-            } else if (strcmp("skip-secondary", longopts[longindex].name) == 0 ) {
-                skip_secondary = true;
-#if !defined(_WIN32)
-            } else if (strcmp("wipe-and-use-fbe", longopts[longindex].name) == 0) {
-                wants_wipe = true;
-                set_fbe_marker = true;
-#endif
-            } else {
-                fprintf(stderr, "Internal error in options processing for %s\n",
-                    longopts[longindex].name);
-                return 1;
-            }
-            break;
-        default:
-            abort();
-        }
-    }
-
-    argc -= optind;
-    argv += optind;
-
-    if (argc == 0 && !wants_wipe && !wants_set_active) {
-        usage();
-        return 1;
-    }
-
-    if (argc > 0 && !strcmp(*argv, "devices")) {
-        skip(1);
-        list_devices();
-        return 0;
-    }
-
-    if (argc > 0 && !strcmp(*argv, "help")) {
-        usage();
-        return 0;
-    }
-
-    Transport* transport = open_device();
-    if (transport == nullptr) {
-        return 1;
-    }
-
-    if (!supports_AB(transport) && supports_AB_obsolete(transport)) {
-        fprintf(stderr, "Warning: Device A/B support is outdated. Bootloader update required.\n");
-    }
-    if (slot_override != "") slot_override = verify_slot(transport, slot_override);
-    if (next_active != "") next_active = verify_slot(transport, next_active, false);
-
-    if (wants_set_active) {
-        if (next_active == "") {
-            if (slot_override == "") {
-                std::string current_slot;
-                if (fb_getvar(transport, "current-slot", &current_slot)) {
-                    next_active = verify_slot(transport, current_slot, false);
-                } else {
-                    wants_set_active = false;
-                }
-            } else {
-                next_active = verify_slot(transport, slot_override, false);
-            }
-        }
-    }
-
-    while (argc > 0) {
-        if (!strcmp(*argv, "getvar")) {
-            require(2);
-            fb_queue_display(argv[1], argv[1]);
-            skip(2);
-        } else if(!strcmp(*argv, "erase")) {
-            require(2);
-
-            auto erase = [&](const std::string &partition) {
-                std::string partition_type;
-                if (fb_getvar(transport, std::string("partition-type:") + argv[1], &partition_type) &&
-                    fs_get_generator(partition_type) != nullptr) {
-                    fprintf(stderr, "******** Did you mean to fastboot format this %s partition?\n",
-                            partition_type.c_str());
-                }
-
-                fb_queue_erase(partition.c_str());
-            };
-            do_for_partitions(transport, argv[1], slot_override, erase, true);
-            skip(2);
-        } else if(!strncmp(*argv, "format", strlen("format"))) {
-            char *overrides;
-            char *type_override = nullptr;
-            char *size_override = nullptr;
-            require(2);
-            /*
-             * Parsing for: "format[:[type][:[size]]]"
-             * Some valid things:
-             *  - select ontly the size, and leave default fs type:
-             *    format::0x4000000 userdata
-             *  - default fs type and size:
-             *    format userdata
-             *    format:: userdata
-             */
-            overrides = strchr(*argv, ':');
-            if (overrides) {
-                overrides++;
-                size_override = strchr(overrides, ':');
-                if (size_override) {
-                    size_override[0] = '\0';
-                    size_override++;
-                }
-                type_override = overrides;
-            }
-            if (type_override && !type_override[0]) type_override = nullptr;
-            if (size_override && !size_override[0]) size_override = nullptr;
-
-            auto format = [&](const std::string &partition) {
-                if (erase_first && needs_erase(transport, partition.c_str())) {
-                    fb_queue_erase(partition.c_str());
-                }
-                fb_perform_format(transport, partition.c_str(), 0,
-                    type_override, size_override, "");
-            };
-            do_for_partitions(transport, argv[1], slot_override, format, true);
-            skip(2);
-        } else if(!strcmp(*argv, "signature")) {
-            require(2);
-            data = load_file(argv[1], &sz);
-            if (data == nullptr) die("could not load '%s': %s", argv[1], strerror(errno));
-            if (sz != 256) die("signature must be 256 bytes");
-            fb_queue_download("signature", data, sz);
-            fb_queue_command("signature", "installing signature");
-            skip(2);
-        } else if(!strcmp(*argv, "reboot")) {
-            wants_reboot = true;
-            skip(1);
-            if (argc > 0) {
-                if (!strcmp(*argv, "bootloader")) {
-                    wants_reboot = false;
-                    wants_reboot_bootloader = true;
-                    skip(1);
-                }
-            }
-            require(0);
-        } else if(!strcmp(*argv, "reboot-bootloader")) {
-            wants_reboot_bootloader = true;
-            skip(1);
-        } else if (!strcmp(*argv, "continue")) {
-            fb_queue_command("continue", "resuming boot");
-            skip(1);
-        } else if(!strcmp(*argv, "boot")) {
-            char *kname = 0;
-            char *rname = 0;
-            char *sname = 0;
-            skip(1);
-            if (argc > 0) {
-                kname = argv[0];
-                skip(1);
-            }
-            if (argc > 0) {
-                rname = argv[0];
-                skip(1);
-            }
-            if (argc > 0) {
-                sname = argv[0];
-                skip(1);
-            }
-            data = load_bootable_image(kname, rname, sname, &sz, cmdline);
-            if (data == 0) return 1;
-            fb_queue_download("boot.img", data, sz);
-            fb_queue_command("boot", "booting");
-        } else if(!strcmp(*argv, "flash")) {
-            char *pname = argv[1];
-            std::string fname;
-            require(2);
-            if (argc > 2) {
-                fname = argv[2];
-                skip(3);
-            } else {
-                fname = find_item(pname, product);
-                skip(2);
-            }
-            if (fname == "") die("cannot determine image filename for '%s'", pname);
-
-            auto flash = [&](const std::string &partition) {
-                if (erase_first && needs_erase(transport, partition.c_str())) {
-                    fb_queue_erase(partition.c_str());
-                }
-                do_flash(transport, partition.c_str(), fname.c_str());
-            };
-            do_for_partitions(transport, pname, slot_override, flash, true);
-        } else if(!strcmp(*argv, "flash:raw")) {
-            char *kname = argv[2];
-            char *rname = 0;
-            char *sname = 0;
-            require(3);
-            skip(3);
-            if (argc > 0) {
-                rname = argv[0];
-                skip(1);
-            }
-            if (argc > 0) {
-                sname = argv[0];
-                skip(1);
-            }
-            data = load_bootable_image(kname, rname, sname, &sz, cmdline);
-            if (data == 0) die("cannot load bootable image");
-            auto flashraw = [&](const std::string &partition) {
-                fb_queue_flash(partition.c_str(), data, sz);
-            };
-            do_for_partitions(transport, argv[1], slot_override, flashraw, true);
-        } else if(!strcmp(*argv, "flashall")) {
-            skip(1);
-            if (slot_override == "all") {
-                fprintf(stderr, "Warning: slot set to 'all'. Secondary slots will not be flashed.\n");
-                do_flashall(transport, slot_override, erase_first, true);
-            } else {
-                do_flashall(transport, slot_override, erase_first, skip_secondary);
-            }
-            wants_reboot = true;
-        } else if(!strcmp(*argv, "update")) {
-            bool slot_all = (slot_override == "all");
-            if (slot_all) {
-                fprintf(stderr, "Warning: slot set to 'all'. Secondary slots will not be flashed.\n");
-            }
-            if (argc > 1) {
-                do_update(transport, argv[1], slot_override, erase_first, skip_secondary || slot_all);
-                skip(2);
-            } else {
-                do_update(transport, "update.zip", slot_override, erase_first, skip_secondary || slot_all);
-                skip(1);
-            }
-            wants_reboot = 1;
-        } else if(!strcmp(*argv, "set_active")) {
-            require(2);
-            std::string slot = verify_slot(transport, std::string(argv[1]), false);
-            fb_set_active(slot.c_str());
-            skip(2);
-        } else if(!strcmp(*argv, "oem")) {
-            argc = do_oem_command(argc, argv);
-        } else if(!strcmp(*argv, "flashing")) {
-            if (argc == 2 && (!strcmp(*(argv+1), "unlock") ||
-                              !strcmp(*(argv+1), "lock") ||
-                              !strcmp(*(argv+1), "unlock_critical") ||
-                              !strcmp(*(argv+1), "lock_critical") ||
-                              !strcmp(*(argv+1), "get_unlock_ability") ||
-                              !strcmp(*(argv+1), "get_unlock_bootloader_nonce") ||
-                              !strcmp(*(argv+1), "lock_bootloader"))) {
-                argc = do_oem_command(argc, argv);
-            } else
-            if (argc == 3 && !strcmp(*(argv+1), "unlock_bootloader")) {
-                argc = do_bypass_unlock_command(argc, argv);
-            } else {
-              usage();
-              return 1;
-            }
-        } else {
-            usage();
-            return 1;
-        }
-    }
-
-    if (wants_wipe) {
-        fprintf(stderr, "wiping userdata...\n");
-        fb_queue_erase("userdata");
-        if (set_fbe_marker) {
-            fprintf(stderr, "setting FBE marker...\n");
-            std::string initial_userdata_dir = create_fbemarker_tmpdir();
-            if (initial_userdata_dir.empty()) {
-                return 1;
-            }
-            fb_perform_format(transport, "userdata", 1, nullptr, nullptr, initial_userdata_dir);
-            delete_fbemarker_tmpdir(initial_userdata_dir);
-        } else {
-            fb_perform_format(transport, "userdata", 1, nullptr, nullptr, "");
-        }
-
-        std::string cache_type;
-        if (fb_getvar(transport, "partition-type:cache", &cache_type) && !cache_type.empty()) {
-            fprintf(stderr, "wiping cache...\n");
-            fb_queue_erase("cache");
-            fb_perform_format(transport, "cache", 1, nullptr, nullptr, "");
-        }
-    }
-    if (wants_set_active) {
-        fb_set_active(next_active.c_str());
-    }
-    if (wants_reboot) {
-        fb_queue_reboot();
-        fb_queue_wait_for_disconnect();
-    } else if (wants_reboot_bootloader) {
-        fb_queue_command("reboot-bootloader", "rebooting into bootloader");
-        fb_queue_wait_for_disconnect();
-    }
-
-    return fb_execute_queue(transport) ? EXIT_FAILURE : EXIT_SUCCESS;
-}
diff --git a/fastboot/fastboot.h b/fastboot/fastboot.h
deleted file mode 100644
index 1932bab..0000000
--- a/fastboot/fastboot.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#ifndef _FASTBOOT_H_
-#define _FASTBOOT_H_
-
-#include <inttypes.h>
-#include <stdlib.h>
-
-#include <string>
-
-#include "transport.h"
-
-struct sparse_file;
-
-/* protocol.c - fastboot protocol */
-int fb_command(Transport* transport, const char* cmd);
-int fb_command_response(Transport* transport, const char* cmd, char* response);
-int fb_download_data(Transport* transport, const void* data, uint32_t size);
-int fb_download_data_sparse(Transport* transport, struct sparse_file* s);
-char *fb_get_error(void);
-
-#define FB_COMMAND_SZ 64
-#define FB_RESPONSE_SZ 64
-
-/* engine.c - high level command queue engine */
-bool fb_getvar(Transport* transport, const std::string& key, std::string* value);
-void fb_queue_flash(const char *ptn, void *data, uint32_t sz);
-void fb_queue_flash_sparse(const char* ptn, struct sparse_file* s, uint32_t sz, size_t current,
-                           size_t total);
-void fb_queue_erase(const char *ptn);
-void fb_queue_format(const char *ptn, int skip_if_not_supported, int32_t max_chunk_sz);
-void fb_queue_require(const char *prod, const char *var, bool invert,
-                      size_t nvalues, const char **value);
-void fb_queue_display(const char *var, const char *prettyname);
-void fb_queue_query_save(const char *var, char *dest, uint32_t dest_size);
-void fb_queue_reboot(void);
-void fb_queue_command(const char *cmd, const char *msg);
-void fb_queue_download(const char *name, void *data, uint32_t size);
-void fb_queue_notice(const char *notice);
-void fb_queue_wait_for_disconnect(void);
-int fb_execute_queue(Transport* transport);
-void fb_set_active(const char *slot);
-
-/* util stuff */
-double now();
-char *mkmsg(const char *fmt, ...);
-__attribute__((__noreturn__)) void die(const char *fmt, ...);
-
-void get_my_path(char *path);
-
-/* Current product */
-extern char cur_product[FB_RESPONSE_SZ + 1];
-
-#endif
diff --git a/fastboot/fastboot_protocol.txt b/fastboot/fastboot_protocol.txt
deleted file mode 100644
index 2801703..0000000
--- a/fastboot/fastboot_protocol.txt
+++ /dev/null
@@ -1,442 +0,0 @@
-FastBoot  Version  0.4
-----------------------
-
-The fastboot protocol is a mechanism for communicating with bootloaders
-over USB or ethernet.  It is designed to be very straightforward to implement,
-to allow it to be used across a wide range of devices and from hosts running
-Linux, Windows, or OSX.
-
-
-Basic Requirements
-------------------
-
-* USB
-  * Two bulk endpoints (in, out) are required
-  * Max packet size must be 64 bytes for full-speed, 512 bytes for
-    high-speed and 1024 bytes for Super Speed USB.
-  * The protocol is entirely host-driven and synchronous (unlike the
-    multi-channel, bi-directional, asynchronous ADB protocol)
-
-* TCP or UDP
-  * Device must be reachable via IP.
-  * Device will act as the server, fastboot will be the client.
-  * Fastboot data is wrapped in a simple protocol; see below for details.
-
-
-Transport and Framing
----------------------
-
-1. Host sends a command, which is an ascii string in a single
-   packet no greater than 64 bytes.
-
-2. Client response with a single packet no greater than 64 bytes.
-   The first four bytes of the response are "OKAY", "FAIL", "DATA", 
-   or "INFO".  Additional bytes may contain an (ascii) informative
-   message.
-
-   a. INFO -> the remaining 60 bytes are an informative message
-      (providing progress or diagnostic messages).  They should 
-      be displayed and then step #2 repeats
-
-   b. FAIL -> the requested command failed.  The remaining 60 bytes 
-      of the response (if present) provide a textual failure message 
-      to present to the user.  Stop.
-
-   c. OKAY -> the requested command completed successfully.  Go to #5
-
-   d. DATA -> the requested command is ready for the data phase.
-      A DATA response packet will be 12 bytes long, in the form of
-      DATA00000000 where the 8 digit hexadecimal number represents
-      the total data size to transfer.
-
-3. Data phase.  Depending on the command, the host or client will 
-   send the indicated amount of data.  Short packets are always 
-   acceptable and zero-length packets are ignored.  This phase continues
-   until the client has sent or received the number of bytes indicated
-   in the "DATA" response above.
-
-4. Client responds with a single packet no greater than 64 bytes.  
-   The first four bytes of the response are "OKAY", "FAIL", or "INFO".  
-   Similar to #2:
-
-   a. INFO -> display the remaining 60 bytes and return to #4
-   
-   b. FAIL -> display the remaining 60 bytes (if present) as a failure
-      reason and consider the command failed.  Stop.
-
-   c. OKAY -> success.  Go to #5
-
-5. Success.  Stop.
-
-
-Example Session
----------------
-
-Host:    "getvar:version"        request version variable
-
-Client:  "OKAY0.4"               return version "0.4"
-
-Host:    "getvar:nonexistant"    request some undefined variable
-
-Client:  "OKAY"                  return value ""
-
-Host:    "download:00001234"     request to send 0x1234 bytes of data
-
-Client:  "DATA00001234"          ready to accept data
-
-Host:    < 0x1234 bytes >        send data
-
-Client:  "OKAY"                  success
-
-Host:    "flash:bootloader"      request to flash the data to the bootloader
-
-Client:  "INFOerasing flash"     indicate status / progress
-         "INFOwriting flash"
-         "OKAY"                  indicate success
-
-Host:    "powerdown"             send a command
-
-Client:  "FAILunknown command"   indicate failure
-
-
-Command Reference
------------------
-
-* Command parameters are indicated by printf-style escape sequences.
-
-* Commands are ascii strings and sent without the quotes (which are
-  for illustration only here) and without a trailing 0 byte.
-
-* Commands that begin with a lowercase letter are reserved for this
-  specification.  OEM-specific commands should not begin with a 
-  lowercase letter, to prevent incompatibilities with future specs.
-
- "getvar:%s"           Read a config/version variable from the bootloader.
-                       The variable contents will be returned after the
-                       OKAY response.
-
- "download:%08x"       Write data to memory which will be later used
-                       by "boot", "ramdisk", "flash", etc.  The client
-                       will reply with "DATA%08x" if it has enough 
-                       space in RAM or "FAIL" if not.  The size of
-                       the download is remembered.
-
-  "verify:%08x"        Send a digital signature to verify the downloaded
-                       data.  Required if the bootloader is "secure"
-                       otherwise "flash" and "boot" will be ignored.
-
-  "flash:%s"           Write the previously downloaded image to the
-                       named partition (if possible).
-
-  "erase:%s"           Erase the indicated partition (clear to 0xFFs)
-
-  "boot"               The previously downloaded data is a boot.img
-                       and should be booted according to the normal
-                       procedure for a boot.img
-
-  "continue"           Continue booting as normal (if possible)
-
-  "reboot"             Reboot the device.
-
-  "reboot-bootloader"  Reboot back into the bootloader.
-                       Useful for upgrade processes that require upgrading
-                       the bootloader and then upgrading other partitions
-                       using the new bootloader.
-
-  "powerdown"          Power off the device.
-
-
-
-Client Variables
-----------------
-
-The "getvar:%s" command is used to read client variables which
-represent various information about the device and the software
-on it.
-
-The various currently defined names are:
-
-  version             Version of FastBoot protocol supported.
-                      It should be "0.4" for this document.
-
-  version-bootloader  Version string for the Bootloader.
-
-  version-baseband    Version string of the Baseband Software
-
-  product             Name of the product
-
-  serialno            Product serial number
-
-  secure              If the value is "yes", this is a secure
-                      bootloader requiring a signature before
-                      it will install or boot images.
-
-Names starting with a lowercase character are reserved by this
-specification.  OEM-specific names should not start with lowercase
-characters.
-
-
-TCP Protocol v1
----------------
-
-The TCP protocol is designed to be a simple way to use the fastboot protocol
-over ethernet if USB is not available.
-
-The device will open a TCP server on port 5554 and wait for a fastboot client
-to connect.
-
--- Handshake --
-Upon connecting, both sides will send a 4-byte handshake message to ensure they
-are speaking the same protocol. This consists of the ASCII characters "FB"
-followed by a 2-digit base-10 ASCII version number. For example, the version 1
-handshake message will be [FB01].
-
-If either side detects a malformed handshake, it should disconnect.
-
-The protocol version to use must be the minimum of the versions sent by each
-side; if either side cannot speak this protocol version, it should disconnect.
-
--- Fastboot Data --
-Once the handshake is complete, fastboot data will be sent as follows:
-
-  [data_size][data]
-
-Where data_size is an unsigned 8-byte big-endian binary value, and data is the
-fastboot packet. The 8-byte length is intended to provide future-proofing even
-though currently fastboot packets have a 4-byte maximum length.
-
--- Example --
-In this example the fastboot host queries the device for two variables,
-"version" and "none".
-
-Host    <connect to the device on port 5555>
-Host    FB01
-Device  FB01
-Host    [0x00][0x00][0x00][0x00][0x00][0x00][0x00][0x0E]getvar:version
-Device  [0x00][0x00][0x00][0x00][0x00][0x00][0x00][0x07]OKAY0.4
-Host    [0x00][0x00][0x00][0x00][0x00][0x00][0x00][0x0B]getvar:none
-Device  [0x00][0x00][0x00][0x00][0x00][0x00][0x00][0x04]OKAY
-Host    <disconnect>
-
-
-UDP Protocol v1
----------------
-
-The UDP protocol is more complex than TCP since we must implement reliability
-to ensure no packets are lost, but the general concept of wrapping the fastboot
-protocol is the same.
-
-Overview:
-  1. As with TCP, the device will listen on UDP port 5554.
-  2. Maximum UDP packet size is negotiated during initialization.
-  3. The host drives all communication; the device may only send a packet as a
-     response to a host packet.
-  4. If the host does not receive a response in 500ms it will re-transmit.
-
--- UDP Packet format --
-  +----------+----+-------+-------+--------------------+
-  | Byte #   | 0  |   1   | 2 - 3 |  4+                |
-  +----------+----+-------+-------+--------------------+
-  | Contents | ID | Flags | Seq # | Data               |
-  +----------+----+-------+-------+--------------------+
-
-  ID      Packet ID:
-            0x00: Error.
-            0x01: Query.
-            0x02: Initialization.
-            0x03: Fastboot.
-
-          Packet types are described in more detail below.
-
-  Flags   Packet flags: 0 0 0 0 0 0 0 C
-            C=1 indicates a continuation packet; the data is too large and will
-                continue in the next packet.
-
-            Remaining bits are reserved for future use and must be set to 0.
-
-  Seq #   2-byte packet sequence number (big-endian). The host will increment
-          this by 1 with each new packet, and the device must provide the
-          corresponding sequence number in the response packets.
-
-  Data    Packet data, not present in all packets.
-
--- Packet Types --
-Query     The host sends a query packet once on startup to sync with the device.
-          The host will not know the current sequence number, so the device must
-          respond to all query packets regardless of sequence number.
-
-          The response data field should contain a 2-byte big-endian value
-          giving the next expected sequence number.
-
-Init      The host sends an init packet once the query response is returned. The
-          device must abort any in-progress operation and prepare for a new
-          fastboot session. This message is meant to allow recovery if a
-          previous session failed, e.g. due to network error or user Ctrl+C.
-
-          The data field contains two big-endian 2-byte values, a protocol
-          version and the max UDP packet size (including the 4-byte header).
-          Both the host and device will send these values, and in each case
-          the minimum of the sent values must be used.
-
-Fastboot  These packets wrap the fastboot protocol. To write, the host will
-          send a packet with fastboot data, and the device will reply with an
-          empty packet as an ACK. To read, the host will send an empty packet,
-          and the device will reply with fastboot data. The device may not give
-          any data in the ACK packet.
-
-Error     The device may respond to any packet with an error packet to indicate
-          a UDP protocol error. The data field should contain an ASCII string
-          describing the error. This is the only case where a device is allowed
-          to return a packet ID other than the one sent by the host.
-
--- Packet Size --
-The maximum packet size is negotiated by the host and device in the Init packet.
-Devices must support at least 512-byte packets, but packet size has a direct
-correlation with download speed, so devices are strongly suggested to support at
-least 1024-byte packets. On a local network with 0.5ms round-trip time this will
-provide transfer rates of ~2MB/s. Over WiFi it will likely be significantly
-less.
-
-Query and Initialization packets, which are sent before size negotiation is
-complete, must always be 512 bytes or less.
-
--- Packet Re-Transmission --
-The host will re-transmit any packet that does not receive a response. The
-requirement of exactly one device response packet per host packet is how we
-achieve reliability and in-order delivery of packets.
-
-For simplicity of implementation, there is no windowing of multiple
-unacknowledged packets in this version of the protocol. The host will continue
-to send the same packet until a response is received. Windowing functionality
-may be implemented in future versions if necessary to increase performance.
-
-The first Query packet will only be attempted a small number of times, but
-subsequent packets will attempt to retransmit for at least 1 minute before
-giving up. This means a device may safely ignore host UDP packets for up to 1
-minute during long operations, e.g. writing to flash.
-
--- Continuation Packets --
-Any packet may set the continuation flag to indicate that the data is
-incomplete. Large data such as downloading an image may require many
-continuation packets. The receiver should respond to a continuation packet with
-an empty packet to acknowledge receipt. See examples below.
-
--- Summary --
-The host starts with a Query packet, then an Initialization packet, after
-which only Fastboot packets are sent. Fastboot packets may contain data from
-the host for writes, or from the device for reads, but not both.
-
-Given a next expected sequence number S and a received packet P, the device
-behavior should be:
-  if P is a Query packet:
-    * respond with a Query packet with S in the data field
-  else if P has sequence == S:
-    * process P and take any required action
-    * create a response packet R with the same ID and sequence as P, containing
-      any response data required.
-    * transmit R and save it in case of re-transmission
-    * increment S
-  else if P has sequence == S - 1:
-    * re-transmit the saved response packet R from above
-  else:
-    * ignore the packet
-
--- Examples --
-In the examples below, S indicates the starting client sequence number.
-
-Host                                    Client
-======================================================================
-[Initialization, S = 0x55AA]
-[Host: version 1, 2048-byte packets. Client: version 2, 1024-byte packets.]
-[Resulting values to use: version = 1, max packet size = 1024]
-ID   Flag SeqH SeqL Data                ID   Flag SeqH SeqL Data
-----------------------------------------------------------------------
-0x01 0x00 0x00 0x00
-                                        0x01 0x00 0x00 0x00 0x55 0xAA
-0x02 0x00 0x55 0xAA 0x00 0x01 0x08 0x00
-                                        0x02 0x00 0x55 0xAA 0x00 0x02 0x04 0x00
-
-----------------------------------------------------------------------
-[fastboot "getvar" commands, S = 0x0001]
-ID    Flags SeqH  SeqL  Data            ID    Flags SeqH  SeqL  Data
-----------------------------------------------------------------------
-0x03  0x00  0x00  0x01  getvar:version
-                                        0x03  0x00  0x00  0x01
-0x03  0x00  0x00  0x02
-                                        0x03  0x00  0x00  0x02  OKAY0.4
-0x03  0x00  0x00  0x03  getvar:foo
-                                        0x03  0x00  0x00  0x03
-0x03  0x00  0x00  0x04
-                                        0x03  0x00  0x00  0x04  OKAY
-
-----------------------------------------------------------------------
-[fastboot "INFO" responses, S = 0x0000]
-ID    Flags SeqH  SeqL  Data            ID    Flags SeqH  SeqL  Data
-----------------------------------------------------------------------
-0x03  0x00  0x00  0x00  <command>
-                                        0x03  0x00  0x00  0x00
-0x03  0x00  0x00  0x01
-                                        0x03  0x00  0x00  0x01  INFOWait1
-0x03  0x00  0x00  0x02
-                                        0x03  0x00  0x00  0x02  INFOWait2
-0x03  0x00  0x00  0x03
-                                        0x03  0x00  0x00  0x03  OKAY
-
-----------------------------------------------------------------------
-[Chunking 2100 bytes of data, max packet size = 1024, S = 0xFFFF]
-ID   Flag SeqH SeqL Data                ID   Flag SeqH SeqL Data
-----------------------------------------------------------------------
-0x03 0x00 0xFF 0xFF download:0000834
-                                        0x03 0x00 0xFF 0xFF
-0x03 0x00 0x00 0x00
-                                        0x03 0x00 0x00 0x00 DATA0000834
-0x03 0x01 0x00 0x01 <1020 bytes>
-                                        0x03 0x00 0x00 0x01
-0x03 0x01 0x00 0x02 <1020 bytes>
-                                        0x03 0x00 0x00 0x02
-0x03 0x00 0x00 0x03 <60 bytes>
-                                        0x03 0x00 0x00 0x03
-0x03 0x00 0x00 0x04
-                                        0x03 0x00 0x00 0x04 OKAY
-
-----------------------------------------------------------------------
-[Unknown ID error, S = 0x0000]
-ID    Flags SeqH  SeqL  Data            ID    Flags SeqH  SeqL  Data
-----------------------------------------------------------------------
-0x10  0x00  0x00  0x00
-                                        0x00  0x00  0x00  0x00  <error message>
-
-----------------------------------------------------------------------
-[Host packet loss and retransmission, S = 0x0000]
-ID    Flags SeqH  SeqL  Data            ID    Flags SeqH  SeqL  Data
-----------------------------------------------------------------------
-0x03  0x00  0x00  0x00  getvar:version [lost]
-0x03  0x00  0x00  0x00  getvar:version [lost]
-0x03  0x00  0x00  0x00  getvar:version
-                                        0x03  0x00  0x00  0x00
-0x03  0x00  0x00  0x01
-                                        0x03  0x00  0x00  0x01  OKAY0.4
-
-----------------------------------------------------------------------
-[Client packet loss and retransmission, S = 0x0000]
-ID    Flags SeqH  SeqL  Data            ID    Flags SeqH  SeqL  Data
-----------------------------------------------------------------------
-0x03  0x00  0x00  0x00  getvar:version
-                                        0x03  0x00  0x00  0x00 [lost]
-0x03  0x00  0x00  0x00  getvar:version
-                                        0x03  0x00  0x00  0x00 [lost]
-0x03  0x00  0x00  0x00  getvar:version
-                                        0x03  0x00  0x00  0x00
-0x03  0x00  0x00  0x01
-                                        0x03  0x00  0x00  0x01  OKAY0.4
-
-----------------------------------------------------------------------
-[Host packet delayed, S = 0x0000]
-ID    Flags SeqH  SeqL  Data            ID    Flags SeqH  SeqL  Data
-----------------------------------------------------------------------
-0x03  0x00  0x00  0x00  getvar:version [delayed]
-0x03  0x00  0x00  0x00  getvar:version
-                                        0x03  0x00  0x00  0x00
-0x03  0x00  0x00  0x01
-                                        0x03  0x00  0x00  0x01  OKAY0.4
-0x03  0x00  0x00  0x00  getvar:version [arrives late with old seq#, is ignored]
diff --git a/fastboot/fs.cpp b/fastboot/fs.cpp
deleted file mode 100644
index 8539e23..0000000
--- a/fastboot/fs.cpp
+++ /dev/null
@@ -1,64 +0,0 @@
-#include "fs.h"
-
-#include "fastboot.h"
-#include "make_ext4fs.h"
-#include "make_f2fs.h"
-
-#include <errno.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <unistd.h>
-
-#include <sparse/sparse.h>
-
-static int generate_ext4_image(int fd, long long partSize, const std::string& initial_dir)
-{
-    if (initial_dir.empty()) {
-        make_ext4fs_sparse_fd(fd, partSize, NULL, NULL);
-    } else {
-        make_ext4fs_sparse_fd_directory(fd, partSize, NULL, NULL, initial_dir.c_str());
-    }
-    return 0;
-}
-
-#ifdef USE_F2FS
-static int generate_f2fs_image(int fd, long long partSize, const std::string& initial_dir)
-{
-    if (!initial_dir.empty()) {
-        fprintf(stderr, "Unable to set initial directory on F2FS filesystem\n");
-        return -1;
-    }
-    return make_f2fs_sparse_fd(fd, partSize, NULL, NULL);
-}
-#endif
-
-static const struct fs_generator {
-    const char* fs_type;  //must match what fastboot reports for partition type
-
-    //returns 0 or error value
-    int (*generate)(int fd, long long partSize, const std::string& initial_dir);
-
-} generators[] = {
-    { "ext4", generate_ext4_image},
-#ifdef USE_F2FS
-    { "f2fs", generate_f2fs_image},
-#endif
-};
-
-const struct fs_generator* fs_get_generator(const std::string& fs_type) {
-    for (size_t i = 0; i < sizeof(generators) / sizeof(*generators); i++) {
-        if (fs_type == generators[i].fs_type) {
-            return generators + i;
-        }
-    }
-    return nullptr;
-}
-
-int fs_generator_generate(const struct fs_generator* gen, int tmpFileNo, long long partSize,
-    const std::string& initial_dir)
-{
-    return gen->generate(tmpFileNo, partSize, initial_dir);
-}
diff --git a/fastboot/fs.h b/fastboot/fs.h
deleted file mode 100644
index 0a68507..0000000
--- a/fastboot/fs.h
+++ /dev/null
@@ -1,13 +0,0 @@
-#ifndef _FS_H_
-#define _FS_H_
-
-#include <string>
-#include <stdint.h>
-
-struct fs_generator;
-
-const struct fs_generator* fs_get_generator(const std::string& fs_type);
-int fs_generator_generate(const struct fs_generator* gen, int tmpFileNo, long long partSize,
-    const std::string& initial_dir);
-
-#endif
diff --git a/fastboot/protocol.cpp b/fastboot/protocol.cpp
deleted file mode 100644
index 4850b4a..0000000
--- a/fastboot/protocol.cpp
+++ /dev/null
@@ -1,277 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#define round_down(a, b) \
-    ({ typeof(a) _a = (a); typeof(b) _b = (b); _a - (_a % _b); })
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-
-#include <algorithm>
-
-#include <sparse/sparse.h>
-
-#include "fastboot.h"
-#include "transport.h"
-
-static char ERROR[128];
-
-char *fb_get_error(void)
-{
-    return ERROR;
-}
-
-static int check_response(Transport* transport, uint32_t size, char* response) {
-    char status[65];
-
-    while (true) {
-        int r = transport->Read(status, 64);
-        if (r < 0) {
-            sprintf(ERROR, "status read failed (%s)", strerror(errno));
-            transport->Close();
-            return -1;
-        }
-        status[r] = 0;
-
-        if (r < 4) {
-            sprintf(ERROR, "status malformed (%d bytes)", r);
-            transport->Close();
-            return -1;
-        }
-
-        if (!memcmp(status, "INFO", 4)) {
-            fprintf(stderr,"(bootloader) %s\n", status + 4);
-            continue;
-        }
-
-        if (!memcmp(status, "OKAY", 4)) {
-            if (response) {
-                strcpy(response, (char*) status + 4);
-            }
-            return 0;
-        }
-
-        if (!memcmp(status, "FAIL", 4)) {
-            if (r > 4) {
-                sprintf(ERROR, "remote: %s", status + 4);
-            } else {
-                strcpy(ERROR, "remote failure");
-            }
-            return -1;
-        }
-
-        if (!memcmp(status, "DATA", 4) && size > 0){
-            uint32_t dsize = strtol(status + 4, 0, 16);
-            if (dsize > size) {
-                strcpy(ERROR, "data size too large");
-                transport->Close();
-                return -1;
-            }
-            return dsize;
-        }
-
-        strcpy(ERROR,"unknown status code");
-        transport->Close();
-        break;
-    }
-
-    return -1;
-}
-
-static int _command_start(Transport* transport, const char* cmd, uint32_t size, char* response) {
-    size_t cmdsize = strlen(cmd);
-    if (cmdsize > 64) {
-        sprintf(ERROR, "command too large");
-        return -1;
-    }
-
-    if (response) {
-        response[0] = 0;
-    }
-
-    if (transport->Write(cmd, cmdsize) != static_cast<int>(cmdsize)) {
-        sprintf(ERROR, "command write failed (%s)", strerror(errno));
-        transport->Close();
-        return -1;
-    }
-
-    return check_response(transport, size, response);
-}
-
-static int _command_data(Transport* transport, const void* data, uint32_t size) {
-    int r = transport->Write(data, size);
-    if (r < 0) {
-        sprintf(ERROR, "data transfer failure (%s)", strerror(errno));
-        transport->Close();
-        return -1;
-    }
-    if (r != ((int) size)) {
-        sprintf(ERROR, "data transfer failure (short transfer)");
-        transport->Close();
-        return -1;
-    }
-    return r;
-}
-
-static int _command_end(Transport* transport) {
-    return check_response(transport, 0, 0) < 0 ? -1 : 0;
-}
-
-static int _command_send(Transport* transport, const char* cmd, const void* data, uint32_t size,
-                         char* response) {
-    if (size == 0) {
-        return -1;
-    }
-
-    int r = _command_start(transport, cmd, size, response);
-    if (r < 0) {
-        return -1;
-    }
-
-    r = _command_data(transport, data, size);
-    if (r < 0) {
-        return -1;
-    }
-
-    r = _command_end(transport);
-    if (r < 0) {
-        return -1;
-    }
-
-    return size;
-}
-
-static int _command_send_no_data(Transport* transport, const char* cmd, char* response) {
-    return _command_start(transport, cmd, 0, response);
-}
-
-int fb_command(Transport* transport, const char* cmd) {
-    return _command_send_no_data(transport, cmd, 0);
-}
-
-int fb_command_response(Transport* transport, const char* cmd, char* response) {
-    return _command_send_no_data(transport, cmd, response);
-}
-
-int fb_download_data(Transport* transport, const void* data, uint32_t size) {
-    char cmd[64];
-    sprintf(cmd, "download:%08x", size);
-    return _command_send(transport, cmd, data, size, 0) < 0 ? -1 : 0;
-}
-
-#define TRANSPORT_BUF_SIZE 1024
-static char transport_buf[TRANSPORT_BUF_SIZE];
-static int transport_buf_len;
-
-static int fb_download_data_sparse_write(void *priv, const void *data, int len)
-{
-    int r;
-    Transport* transport = reinterpret_cast<Transport*>(priv);
-    int to_write;
-    const char* ptr = reinterpret_cast<const char*>(data);
-
-    if (transport_buf_len) {
-        to_write = std::min(TRANSPORT_BUF_SIZE - transport_buf_len, len);
-
-        memcpy(transport_buf + transport_buf_len, ptr, to_write);
-        transport_buf_len += to_write;
-        ptr += to_write;
-        len -= to_write;
-    }
-
-    if (transport_buf_len == TRANSPORT_BUF_SIZE) {
-        r = _command_data(transport, transport_buf, TRANSPORT_BUF_SIZE);
-        if (r != TRANSPORT_BUF_SIZE) {
-            return -1;
-        }
-        transport_buf_len = 0;
-    }
-
-    if (len > TRANSPORT_BUF_SIZE) {
-        if (transport_buf_len > 0) {
-            sprintf(ERROR, "internal error: transport_buf not empty\n");
-            return -1;
-        }
-        to_write = round_down(len, TRANSPORT_BUF_SIZE);
-        r = _command_data(transport, ptr, to_write);
-        if (r != to_write) {
-            return -1;
-        }
-        ptr += to_write;
-        len -= to_write;
-    }
-
-    if (len > 0) {
-        if (len > TRANSPORT_BUF_SIZE) {
-            sprintf(ERROR, "internal error: too much left for transport_buf\n");
-            return -1;
-        }
-        memcpy(transport_buf, ptr, len);
-        transport_buf_len = len;
-    }
-
-    return 0;
-}
-
-static int fb_download_data_sparse_flush(Transport* transport) {
-    if (transport_buf_len > 0) {
-        if (_command_data(transport, transport_buf, transport_buf_len) != transport_buf_len) {
-            return -1;
-        }
-        transport_buf_len = 0;
-    }
-    return 0;
-}
-
-int fb_download_data_sparse(Transport* transport, struct sparse_file* s) {
-    int size = sparse_file_len(s, true, false);
-    if (size <= 0) {
-        return -1;
-    }
-
-    char cmd[64];
-    sprintf(cmd, "download:%08x", size);
-    int r = _command_start(transport, cmd, size, 0);
-    if (r < 0) {
-        return -1;
-    }
-
-    r = sparse_file_callback(s, true, false, fb_download_data_sparse_write, transport);
-    if (r < 0) {
-        return -1;
-    }
-
-    r = fb_download_data_sparse_flush(transport);
-    if (r < 0) {
-        return -1;
-    }
-
-    return _command_end(transport);
-}
diff --git a/fastboot/socket.cpp b/fastboot/socket.cpp
deleted file mode 100644
index 14ecd93..0000000
--- a/fastboot/socket.cpp
+++ /dev/null
@@ -1,290 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "socket.h"
-
-#include <android-base/errors.h>
-#include <android-base/stringprintf.h>
-
-Socket::Socket(cutils_socket_t sock) : sock_(sock) {}
-
-Socket::~Socket() {
-    Close();
-}
-
-int Socket::Close() {
-    int ret = 0;
-
-    if (sock_ != INVALID_SOCKET) {
-        ret = socket_close(sock_);
-        sock_ = INVALID_SOCKET;
-    }
-
-    return ret;
-}
-
-ssize_t Socket::ReceiveAll(void* data, size_t length, int timeout_ms) {
-    size_t total = 0;
-
-    while (total < length) {
-        ssize_t bytes = Receive(reinterpret_cast<char*>(data) + total, length - total, timeout_ms);
-
-        if (bytes == -1) {
-            if (total == 0) {
-                return -1;
-            }
-            break;
-        }
-        total += bytes;
-    }
-
-    return total;
-}
-
-int Socket::GetLocalPort() {
-    return socket_get_local_port(sock_);
-}
-
-// According to Windows setsockopt() documentation, if a Windows socket times out during send() or
-// recv() the state is indeterminate and should not be used. Our UDP protocol relies on being able
-// to re-send after a timeout, so we must use select() rather than SO_RCVTIMEO.
-// See https://msdn.microsoft.com/en-us/library/windows/desktop/ms740476(v=vs.85).aspx.
-bool Socket::WaitForRecv(int timeout_ms) {
-    receive_timed_out_ = false;
-
-    // In our usage |timeout_ms| <= 0 means block forever, so just return true immediately and let
-    // the subsequent recv() do the blocking.
-    if (timeout_ms <= 0) {
-        return true;
-    }
-
-    // select() doesn't always check this case and will block for |timeout_ms| if we let it.
-    if (sock_ == INVALID_SOCKET) {
-        return false;
-    }
-
-    fd_set read_set;
-    FD_ZERO(&read_set);
-    FD_SET(sock_, &read_set);
-
-    timeval timeout;
-    timeout.tv_sec = timeout_ms / 1000;
-    timeout.tv_usec = (timeout_ms % 1000) * 1000;
-
-    int result = TEMP_FAILURE_RETRY(select(sock_ + 1, &read_set, nullptr, nullptr, &timeout));
-
-    if (result == 0) {
-        receive_timed_out_ = true;
-    }
-    return result == 1;
-}
-
-// Implements the Socket interface for UDP.
-class UdpSocket : public Socket {
-  public:
-    enum class Type { kClient, kServer };
-
-    UdpSocket(Type type, cutils_socket_t sock);
-
-    bool Send(const void* data, size_t length) override;
-    bool Send(std::vector<cutils_socket_buffer_t> buffers) override;
-    ssize_t Receive(void* data, size_t length, int timeout_ms) override;
-
-  private:
-    std::unique_ptr<sockaddr_storage> addr_;
-    socklen_t addr_size_ = 0;
-
-    DISALLOW_COPY_AND_ASSIGN(UdpSocket);
-};
-
-UdpSocket::UdpSocket(Type type, cutils_socket_t sock) : Socket(sock) {
-    // Only servers need to remember addresses; clients are connected to a server in NewClient()
-    // so will send to that server without needing to specify the address again.
-    if (type == Type::kServer) {
-        addr_.reset(new sockaddr_storage);
-        addr_size_ = sizeof(*addr_);
-        memset(addr_.get(), 0, addr_size_);
-    }
-}
-
-bool UdpSocket::Send(const void* data, size_t length) {
-    return TEMP_FAILURE_RETRY(sendto(sock_, reinterpret_cast<const char*>(data), length, 0,
-                                     reinterpret_cast<sockaddr*>(addr_.get()), addr_size_)) ==
-           static_cast<ssize_t>(length);
-}
-
-bool UdpSocket::Send(std::vector<cutils_socket_buffer_t> buffers) {
-    size_t total_length = 0;
-    for (const auto& buffer : buffers) {
-        total_length += buffer.length;
-    }
-
-    return TEMP_FAILURE_RETRY(socket_send_buffers_function_(
-                   sock_, buffers.data(), buffers.size())) == static_cast<ssize_t>(total_length);
-}
-
-ssize_t UdpSocket::Receive(void* data, size_t length, int timeout_ms) {
-    if (!WaitForRecv(timeout_ms)) {
-        return -1;
-    }
-
-    socklen_t* addr_size_ptr = nullptr;
-    if (addr_ != nullptr) {
-        // Reset addr_size as it may have been modified by previous recvfrom() calls.
-        addr_size_ = sizeof(*addr_);
-        addr_size_ptr = &addr_size_;
-    }
-
-    return TEMP_FAILURE_RETRY(recvfrom(sock_, reinterpret_cast<char*>(data), length, 0,
-                                       reinterpret_cast<sockaddr*>(addr_.get()), addr_size_ptr));
-}
-
-// Implements the Socket interface for TCP.
-class TcpSocket : public Socket {
-  public:
-    TcpSocket(cutils_socket_t sock) : Socket(sock) {}
-
-    bool Send(const void* data, size_t length) override;
-    bool Send(std::vector<cutils_socket_buffer_t> buffers) override;
-    ssize_t Receive(void* data, size_t length, int timeout_ms) override;
-
-    std::unique_ptr<Socket> Accept() override;
-
-  private:
-    DISALLOW_COPY_AND_ASSIGN(TcpSocket);
-};
-
-bool TcpSocket::Send(const void* data, size_t length) {
-    while (length > 0) {
-        ssize_t sent =
-                TEMP_FAILURE_RETRY(send(sock_, reinterpret_cast<const char*>(data), length, 0));
-
-        if (sent == -1) {
-            return false;
-        }
-        length -= sent;
-    }
-
-    return true;
-}
-
-bool TcpSocket::Send(std::vector<cutils_socket_buffer_t> buffers) {
-    while (!buffers.empty()) {
-        ssize_t sent = TEMP_FAILURE_RETRY(
-                socket_send_buffers_function_(sock_, buffers.data(), buffers.size()));
-
-        if (sent == -1) {
-            return false;
-        }
-
-        // Adjust the buffers to skip past the bytes we've just sent.
-        auto iter = buffers.begin();
-        while (sent > 0) {
-            if (iter->length > static_cast<size_t>(sent)) {
-                // Incomplete buffer write; adjust the buffer to point to the next byte to send.
-                iter->length -= sent;
-                iter->data = reinterpret_cast<const char*>(iter->data) + sent;
-                break;
-            }
-
-            // Complete buffer write; move on to the next buffer.
-            sent -= iter->length;
-            ++iter;
-        }
-
-        // Shortcut the common case: we've written everything remaining.
-        if (iter == buffers.end()) {
-            break;
-        }
-        buffers.erase(buffers.begin(), iter);
-    }
-
-    return true;
-}
-
-ssize_t TcpSocket::Receive(void* data, size_t length, int timeout_ms) {
-    if (!WaitForRecv(timeout_ms)) {
-        return -1;
-    }
-
-    return TEMP_FAILURE_RETRY(recv(sock_, reinterpret_cast<char*>(data), length, 0));
-}
-
-std::unique_ptr<Socket> TcpSocket::Accept() {
-    cutils_socket_t handler = accept(sock_, nullptr, nullptr);
-    if (handler == INVALID_SOCKET) {
-        return nullptr;
-    }
-    return std::unique_ptr<TcpSocket>(new TcpSocket(handler));
-}
-
-std::unique_ptr<Socket> Socket::NewClient(Protocol protocol, const std::string& host, int port,
-                                          std::string* error) {
-    if (protocol == Protocol::kUdp) {
-        cutils_socket_t sock = socket_network_client(host.c_str(), port, SOCK_DGRAM);
-        if (sock != INVALID_SOCKET) {
-            return std::unique_ptr<UdpSocket>(new UdpSocket(UdpSocket::Type::kClient, sock));
-        }
-    } else {
-        cutils_socket_t sock = socket_network_client(host.c_str(), port, SOCK_STREAM);
-        if (sock != INVALID_SOCKET) {
-            return std::unique_ptr<TcpSocket>(new TcpSocket(sock));
-        }
-    }
-
-    if (error) {
-        *error = android::base::StringPrintf("Failed to connect to %s:%d", host.c_str(), port);
-    }
-    return nullptr;
-}
-
-// This functionality is currently only used by tests so we don't need any error messages.
-std::unique_ptr<Socket> Socket::NewServer(Protocol protocol, int port) {
-    if (protocol == Protocol::kUdp) {
-        cutils_socket_t sock = socket_inaddr_any_server(port, SOCK_DGRAM);
-        if (sock != INVALID_SOCKET) {
-            return std::unique_ptr<UdpSocket>(new UdpSocket(UdpSocket::Type::kServer, sock));
-        }
-    } else {
-        cutils_socket_t sock = socket_inaddr_any_server(port, SOCK_STREAM);
-        if (sock != INVALID_SOCKET) {
-            return std::unique_ptr<TcpSocket>(new TcpSocket(sock));
-        }
-    }
-
-    return nullptr;
-}
-
-std::string Socket::GetErrorMessage() {
-#if defined(_WIN32)
-    DWORD error_code = WSAGetLastError();
-#else
-    int error_code = errno;
-#endif
-    return android::base::SystemErrorCodeToString(error_code);
-}
diff --git a/fastboot/socket.h b/fastboot/socket.h
deleted file mode 100644
index de543db..0000000
--- a/fastboot/socket.h
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-// This file provides a class interface for cross-platform socket functionality. The main fastboot
-// engine should not be using this interface directly, but instead should use a higher-level
-// interface that enforces the fastboot protocol.
-
-#ifndef SOCKET_H_
-#define SOCKET_H_
-
-#include <functional>
-#include <memory>
-#include <string>
-#include <utility>
-#include <vector>
-
-#include <android-base/macros.h>
-#include <cutils/sockets.h>
-#include <gtest/gtest_prod.h>
-
-// Socket interface to be implemented for each platform.
-class Socket {
-  public:
-    enum class Protocol { kTcp, kUdp };
-
-    // Returns the socket error message. This must be called immediately after a socket failure
-    // before any other system calls are made.
-    static std::string GetErrorMessage();
-
-    // Creates a new client connection. Clients are connected to a specific hostname/port and can
-    // only send to that destination.
-    // On failure, |error| is filled (if non-null) and nullptr is returned.
-    static std::unique_ptr<Socket> NewClient(Protocol protocol, const std::string& hostname,
-                                             int port, std::string* error);
-
-    // Creates a new server bound to local |port|. This is only meant for testing, during normal
-    // fastboot operation the device acts as the server.
-    // A UDP server saves sender addresses in Receive(), and uses the most recent address during
-    // calls to Send().
-    static std::unique_ptr<Socket> NewServer(Protocol protocol, int port);
-
-    // Destructor closes the socket if it's open.
-    virtual ~Socket();
-
-    // Sends |length| bytes of |data|. For TCP sockets this will continue trying to send until all
-    // bytes are transmitted. Returns true on success.
-    virtual bool Send(const void* data, size_t length) = 0;
-
-    // Sends |buffers| using multi-buffer write, which can be significantly faster than making
-    // multiple calls. For UDP sockets |buffers| are all combined into a single datagram; for
-    // TCP sockets this will continue sending until all buffers are fully transmitted. Returns true
-    // on success.
-    //
-    // Note: This is non-functional for UDP server Sockets because it's not currently needed and
-    // would require an additional sendto() variation of multi-buffer write.
-    virtual bool Send(std::vector<cutils_socket_buffer_t> buffers) = 0;
-
-    // Waits up to |timeout_ms| to receive up to |length| bytes of data. |timout_ms| of 0 will
-    // block forever. Returns the number of bytes received or -1 on error/timeout; see
-    // ReceiveTimedOut() to distinguish between the two.
-    virtual ssize_t Receive(void* data, size_t length, int timeout_ms) = 0;
-
-    // Calls Receive() until exactly |length| bytes have been received or an error occurs.
-    virtual ssize_t ReceiveAll(void* data, size_t length, int timeout_ms);
-
-    // Returns true if the last Receive() call timed out normally and can be retried; fatal errors
-    // or successful reads will return false.
-    bool ReceiveTimedOut() { return receive_timed_out_; }
-
-    // Closes the socket. Returns 0 on success, -1 on error.
-    virtual int Close();
-
-    // Accepts an incoming TCP connection. No effect for UDP sockets. Returns a new Socket
-    // connected to the client on success, nullptr on failure.
-    virtual std::unique_ptr<Socket> Accept() { return nullptr; }
-
-    // Returns the local port the Socket is bound to or -1 on error.
-    int GetLocalPort();
-
-  protected:
-    // Protected constructor to force factory function use.
-    Socket(cutils_socket_t sock);
-
-    // Blocks up to |timeout_ms| until a read is possible on |sock_|, and sets |receive_timed_out_|
-    // as appropriate to help distinguish between normal timeouts and fatal errors. Returns true if
-    // a subsequent recv() on |sock_| will complete without blocking or if |timeout_ms| <= 0.
-    bool WaitForRecv(int timeout_ms);
-
-    cutils_socket_t sock_ = INVALID_SOCKET;
-    bool receive_timed_out_ = false;
-
-    // Non-class functions we want to override during tests to verify functionality. Implementation
-    // should call this rather than using socket_send_buffers() directly.
-    std::function<ssize_t(cutils_socket_t, cutils_socket_buffer_t*, size_t)>
-            socket_send_buffers_function_ = &socket_send_buffers;
-
-  private:
-    FRIEND_TEST(SocketTest, TestTcpSendBuffers);
-    FRIEND_TEST(SocketTest, TestUdpSendBuffers);
-
-    DISALLOW_COPY_AND_ASSIGN(Socket);
-};
-
-#endif  // SOCKET_H_
diff --git a/fastboot/socket_mock.cpp b/fastboot/socket_mock.cpp
deleted file mode 100644
index 2531b53..0000000
--- a/fastboot/socket_mock.cpp
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "socket_mock.h"
-
-#include <gtest/gtest.h>
-
-SocketMock::SocketMock() : Socket(INVALID_SOCKET) {}
-
-SocketMock::~SocketMock() {
-    if (!events_.empty()) {
-        ADD_FAILURE() << events_.size() << " event(s) were not handled";
-    }
-}
-
-bool SocketMock::Send(const void* data, size_t length) {
-    if (events_.empty()) {
-        ADD_FAILURE() << "Send() was called when no message was expected";
-        return false;
-    }
-
-    if (events_.front().type != EventType::kSend) {
-        ADD_FAILURE() << "Send() was called out-of-order";
-        return false;
-    }
-
-    std::string message(reinterpret_cast<const char*>(data), length);
-    if (events_.front().message != message) {
-        ADD_FAILURE() << "Send() expected " << events_.front().message << ", but got " << message;
-        return false;
-    }
-
-    bool return_value = events_.front().status;
-    events_.pop();
-    return return_value;
-}
-
-// Mock out multi-buffer send to be one large send, since that's what it should looks like from
-// the user's perspective.
-bool SocketMock::Send(std::vector<cutils_socket_buffer_t> buffers) {
-    std::string data;
-    for (const auto& buffer : buffers) {
-        data.append(reinterpret_cast<const char*>(buffer.data), buffer.length);
-    }
-    return Send(data.data(), data.size());
-}
-
-ssize_t SocketMock::Receive(void* data, size_t length, int /*timeout_ms*/) {
-    if (events_.empty()) {
-        ADD_FAILURE() << "Receive() was called when no message was ready";
-        return -1;
-    }
-
-    const Event& event = events_.front();
-    if (event.type != EventType::kReceive) {
-        ADD_FAILURE() << "Receive() was called out-of-order";
-        return -1;
-    }
-
-    const std::string& message = event.message;
-    if (message.length() > length) {
-        ADD_FAILURE() << "Receive(): not enough bytes (" << length << ") for " << message;
-        return -1;
-    }
-
-    receive_timed_out_ = event.status;
-    ssize_t return_value = message.length();
-
-    // Empty message indicates failure.
-    if (message.empty()) {
-        return_value = -1;
-    } else {
-        memcpy(data, message.data(), message.length());
-    }
-
-    events_.pop();
-    return return_value;
-}
-
-int SocketMock::Close() {
-    return 0;
-}
-
-std::unique_ptr<Socket> SocketMock::Accept() {
-    if (events_.empty()) {
-        ADD_FAILURE() << "Accept() was called when no socket was ready";
-        return nullptr;
-    }
-
-    if (events_.front().type != EventType::kAccept) {
-        ADD_FAILURE() << "Accept() was called out-of-order";
-        return nullptr;
-    }
-
-    std::unique_ptr<Socket> sock = std::move(events_.front().sock);
-    events_.pop();
-    return sock;
-}
-
-void SocketMock::ExpectSend(std::string message) {
-    events_.push(Event(EventType::kSend, std::move(message), true, nullptr));
-}
-
-void SocketMock::ExpectSendFailure(std::string message) {
-    events_.push(Event(EventType::kSend, std::move(message), false, nullptr));
-}
-
-void SocketMock::AddReceive(std::string message) {
-    events_.push(Event(EventType::kReceive, std::move(message), false, nullptr));
-}
-
-void SocketMock::AddReceiveTimeout() {
-    events_.push(Event(EventType::kReceive, "", true, nullptr));
-}
-
-void SocketMock::AddReceiveFailure() {
-    events_.push(Event(EventType::kReceive, "", false, nullptr));
-}
-
-void SocketMock::AddAccept(std::unique_ptr<Socket> sock) {
-    events_.push(Event(EventType::kAccept, "", false, std::move(sock)));
-}
-
-SocketMock::Event::Event(EventType _type, std::string _message, ssize_t _status,
-                         std::unique_ptr<Socket> _sock)
-        : type(_type), message(_message), status(_status), sock(std::move(_sock)) {}
diff --git a/fastboot/socket_mock.h b/fastboot/socket_mock.h
deleted file mode 100644
index eacd6bb..0000000
--- a/fastboot/socket_mock.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#ifndef SOCKET_MOCK_H_
-#define SOCKET_MOCK_H_
-
-#include <memory>
-#include <queue>
-#include <string>
-
-#include <android-base/macros.h>
-
-#include "socket.h"
-
-// A mock Socket implementation to be used for testing. Tests can set expectations for messages
-// to be sent and provide messages to be received in order to verify protocol behavior.
-//
-// Example: testing sending "foo" and receiving "bar".
-//   SocketMock mock;
-//   mock.ExpectSend("foo");
-//   mock.AddReceive("bar");
-//   EXPECT_TRUE(DoFooBar(&mock));
-//
-// Example: testing sending "foo" and expecting "bar", but receiving "baz" instead.
-//   SocketMock mock;
-//   mock.ExpectSend("foo");
-//   mock.AddReceive("baz");
-//   EXPECT_FALSE(DoFooBar(&mock));
-class SocketMock : public Socket {
-  public:
-    SocketMock();
-    ~SocketMock() override;
-
-    bool Send(const void* data, size_t length) override;
-    bool Send(std::vector<cutils_socket_buffer_t> buffers) override;
-    ssize_t Receive(void* data, size_t length, int timeout_ms) override;
-    int Close() override;
-    virtual std::unique_ptr<Socket> Accept();
-
-    // Adds an expectation for Send().
-    void ExpectSend(std::string message);
-
-    // Adds an expectation for Send() that returns false.
-    void ExpectSendFailure(std::string message);
-
-    // Adds data to provide for Receive().
-    void AddReceive(std::string message);
-
-    // Adds a Receive() timeout after which ReceiveTimedOut() will return true.
-    void AddReceiveTimeout();
-
-    // Adds a Receive() failure after which ReceiveTimedOut() will return false.
-    void AddReceiveFailure();
-
-    // Adds a Socket to return from Accept().
-    void AddAccept(std::unique_ptr<Socket> sock);
-
-  private:
-    enum class EventType { kSend, kReceive, kAccept };
-
-    struct Event {
-        Event(EventType _type, std::string _message, ssize_t _status,
-              std::unique_ptr<Socket> _sock);
-
-        EventType type;
-        std::string message;
-        bool status;  // Return value for Send() or timeout status for Receive().
-        std::unique_ptr<Socket> sock;
-    };
-
-    std::queue<Event> events_;
-
-    DISALLOW_COPY_AND_ASSIGN(SocketMock);
-};
-
-#endif  // SOCKET_MOCK_H_
diff --git a/fastboot/socket_test.cpp b/fastboot/socket_test.cpp
deleted file mode 100644
index 373abc3..0000000
--- a/fastboot/socket_test.cpp
+++ /dev/null
@@ -1,385 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-// Tests socket functionality using loopback connections. The UDP tests assume that no packets are
-// lost, which should be the case for loopback communication, but is not guaranteed.
-//
-// Also tests our SocketMock class to make sure it works as expected and reports errors properly
-// if the mock expectations aren't met during a test.
-
-#include "socket.h"
-#include "socket_mock.h"
-
-#include <list>
-
-#include <gtest/gtest-spi.h>
-#include <gtest/gtest.h>
-
-static constexpr int kShortTimeoutMs = 10;
-static constexpr int kTestTimeoutMs = 3000;
-
-// Creates connected sockets |server| and |client|. Returns true on success.
-bool MakeConnectedSockets(Socket::Protocol protocol, std::unique_ptr<Socket>* server,
-                          std::unique_ptr<Socket>* client,
-                          const std::string& hostname = "localhost") {
-    *server = Socket::NewServer(protocol, 0);
-    if (*server == nullptr) {
-        ADD_FAILURE() << "Failed to create server.";
-        return false;
-    }
-
-    *client = Socket::NewClient(protocol, hostname, (*server)->GetLocalPort(), nullptr);
-    if (*client == nullptr) {
-        ADD_FAILURE() << "Failed to create client.";
-        return false;
-    }
-
-    // TCP passes the client off to a new socket.
-    if (protocol == Socket::Protocol::kTcp) {
-        *server = (*server)->Accept();
-        if (*server == nullptr) {
-            ADD_FAILURE() << "Failed to accept client connection.";
-            return false;
-        }
-    }
-
-    return true;
-}
-
-// Sends a string over a Socket. Returns true if the full string (without terminating char)
-// was sent.
-static bool SendString(Socket* sock, const std::string& message) {
-    return sock->Send(message.c_str(), message.length());
-}
-
-// Receives a string from a Socket. Returns true if the full string (without terminating char)
-// was received.
-static bool ReceiveString(Socket* sock, const std::string& message) {
-    std::string received(message.length(), '\0');
-    ssize_t bytes = sock->ReceiveAll(&received[0], received.length(), kTestTimeoutMs);
-    return static_cast<size_t>(bytes) == received.length() && received == message;
-}
-
-// Tests sending packets client -> server, then server -> client.
-TEST(SocketTest, TestSendAndReceive) {
-    std::unique_ptr<Socket> server, client;
-
-    for (Socket::Protocol protocol : {Socket::Protocol::kUdp, Socket::Protocol::kTcp}) {
-        ASSERT_TRUE(MakeConnectedSockets(protocol, &server, &client));
-
-        EXPECT_TRUE(SendString(client.get(), "foo"));
-        EXPECT_TRUE(ReceiveString(server.get(), "foo"));
-
-        EXPECT_TRUE(SendString(server.get(), "bar baz"));
-        EXPECT_TRUE(ReceiveString(client.get(), "bar baz"));
-    }
-}
-
-TEST(SocketTest, TestReceiveTimeout) {
-    std::unique_ptr<Socket> server, client;
-    char buffer[16];
-
-    for (Socket::Protocol protocol : {Socket::Protocol::kUdp, Socket::Protocol::kTcp}) {
-        ASSERT_TRUE(MakeConnectedSockets(protocol, &server, &client));
-
-        EXPECT_EQ(-1, server->Receive(buffer, sizeof(buffer), kShortTimeoutMs));
-        EXPECT_TRUE(server->ReceiveTimedOut());
-
-        EXPECT_EQ(-1, client->Receive(buffer, sizeof(buffer), kShortTimeoutMs));
-        EXPECT_TRUE(client->ReceiveTimedOut());
-    }
-
-    // UDP will wait for timeout if the other side closes.
-    ASSERT_TRUE(MakeConnectedSockets(Socket::Protocol::kUdp, &server, &client));
-    EXPECT_EQ(0, server->Close());
-    EXPECT_EQ(-1, client->Receive(buffer, sizeof(buffer), kShortTimeoutMs));
-    EXPECT_TRUE(client->ReceiveTimedOut());
-}
-
-TEST(SocketTest, TestReceiveFailure) {
-    std::unique_ptr<Socket> server, client;
-    char buffer[16];
-
-    for (Socket::Protocol protocol : {Socket::Protocol::kUdp, Socket::Protocol::kTcp}) {
-        ASSERT_TRUE(MakeConnectedSockets(protocol, &server, &client));
-
-        EXPECT_EQ(0, server->Close());
-        EXPECT_EQ(-1, server->Receive(buffer, sizeof(buffer), kTestTimeoutMs));
-        EXPECT_FALSE(server->ReceiveTimedOut());
-
-        EXPECT_EQ(0, client->Close());
-        EXPECT_EQ(-1, client->Receive(buffer, sizeof(buffer), kTestTimeoutMs));
-        EXPECT_FALSE(client->ReceiveTimedOut());
-    }
-
-    // TCP knows right away when the other side closes and returns 0 to indicate EOF.
-    ASSERT_TRUE(MakeConnectedSockets(Socket::Protocol::kTcp, &server, &client));
-    EXPECT_EQ(0, server->Close());
-    EXPECT_EQ(0, client->Receive(buffer, sizeof(buffer), kTestTimeoutMs));
-    EXPECT_FALSE(client->ReceiveTimedOut());
-}
-
-// Tests sending and receiving large packets.
-TEST(SocketTest, TestLargePackets) {
-    std::string message(1024, '\0');
-    std::unique_ptr<Socket> server, client;
-
-    for (Socket::Protocol protocol : {Socket::Protocol::kUdp, Socket::Protocol::kTcp}) {
-        ASSERT_TRUE(MakeConnectedSockets(protocol, &server, &client));
-
-        // Run through the test a few times.
-        for (int i = 0; i < 10; ++i) {
-            // Use a different message each iteration to prevent false positives.
-            for (size_t j = 0; j < message.length(); ++j) {
-                message[j] = static_cast<char>(i + j);
-            }
-
-            EXPECT_TRUE(SendString(client.get(), message));
-            EXPECT_TRUE(ReceiveString(server.get(), message));
-        }
-    }
-}
-
-// Tests UDP receive overflow when the UDP packet is larger than the receive buffer.
-TEST(SocketTest, TestUdpReceiveOverflow) {
-    std::unique_ptr<Socket> server, client;
-    ASSERT_TRUE(MakeConnectedSockets(Socket::Protocol::kUdp, &server, &client));
-
-    EXPECT_TRUE(SendString(client.get(), "1234567890"));
-
-    // This behaves differently on different systems, either truncating the packet or returning -1.
-    char buffer[5];
-    ssize_t bytes = server->Receive(buffer, 5, kTestTimeoutMs);
-    if (bytes == 5) {
-        EXPECT_EQ(0, memcmp(buffer, "12345", 5));
-    } else {
-        EXPECT_EQ(-1, bytes);
-    }
-}
-
-// Tests UDP multi-buffer send.
-TEST(SocketTest, TestUdpSendBuffers) {
-    std::unique_ptr<Socket> sock = Socket::NewServer(Socket::Protocol::kUdp, 0);
-    std::vector<std::string> data{"foo", "bar", "12345"};
-    std::vector<cutils_socket_buffer_t> buffers{{data[0].data(), data[0].length()},
-                                                {data[1].data(), data[1].length()},
-                                                {data[2].data(), data[2].length()}};
-    ssize_t mock_return_value = 0;
-
-    // Mock out socket_send_buffers() to verify we're sending in the correct buffers and
-    // return |mock_return_value|.
-    sock->socket_send_buffers_function_ = [&buffers, &mock_return_value](
-            cutils_socket_t /*cutils_sock*/, cutils_socket_buffer_t* sent_buffers,
-            size_t num_sent_buffers) -> ssize_t {
-        EXPECT_EQ(buffers.size(), num_sent_buffers);
-        for (size_t i = 0; i < num_sent_buffers; ++i) {
-            EXPECT_EQ(buffers[i].data, sent_buffers[i].data);
-            EXPECT_EQ(buffers[i].length, sent_buffers[i].length);
-        }
-        return mock_return_value;
-    };
-
-    mock_return_value = strlen("foobar12345");
-    EXPECT_TRUE(sock->Send(buffers));
-
-    mock_return_value -= 1;
-    EXPECT_FALSE(sock->Send(buffers));
-
-    mock_return_value = 0;
-    EXPECT_FALSE(sock->Send(buffers));
-
-    mock_return_value = -1;
-    EXPECT_FALSE(sock->Send(buffers));
-}
-
-// Tests TCP re-sending until socket_send_buffers() sends all data. This is a little complicated,
-// but the general idea is that we intercept calls to socket_send_buffers() using a lambda mock
-// function that simulates partial writes.
-TEST(SocketTest, TestTcpSendBuffers) {
-    std::unique_ptr<Socket> sock = Socket::NewServer(Socket::Protocol::kTcp, 0);
-    std::vector<std::string> data{"foo", "bar", "12345"};
-    std::vector<cutils_socket_buffer_t> buffers{{data[0].data(), data[0].length()},
-                                                {data[1].data(), data[1].length()},
-                                                {data[2].data(), data[2].length()}};
-
-    // Test breaking up the buffered send at various points.
-    std::list<std::string> test_sends[] = {
-            // Successes.
-            {"foobar12345"},
-            {"f", "oob", "ar12345"},
-            {"fo", "obar12", "345"},
-            {"foo", "bar12345"},
-            {"foob", "ar123", "45"},
-            {"f", "o", "o", "b", "a", "r", "1", "2", "3", "4", "5"},
-
-            // Failures.
-            {},
-            {"f"},
-            {"foo", "bar"},
-            {"fo", "obar12"},
-            {"foobar1234"}
-    };
-
-    for (auto& test : test_sends) {
-        ssize_t bytes_sent = 0;
-        bool expect_success = true;
-
-        // Create a mock function for custom socket_send_buffers() behavior. This function will
-        // check to make sure the input buffers start at the next unsent byte, then return the
-        // number of bytes indicated by the next entry in |test|.
-        sock->socket_send_buffers_function_ = [&bytes_sent, &data, &expect_success, &test](
-                cutils_socket_t /*cutils_sock*/, cutils_socket_buffer_t* buffers,
-                size_t num_buffers) -> ssize_t {
-            EXPECT_TRUE(num_buffers > 0);
-
-            // Failure case - pretend we errored out before sending all the buffers.
-            if (test.empty()) {
-                expect_success = false;
-                return -1;
-            }
-
-            // Count the bytes we've sent to find where the next buffer should start and how many
-            // bytes should be left in it.
-            size_t byte_count = bytes_sent, data_index = 0;
-            while (data_index < data.size()) {
-                if (byte_count >= data[data_index].length()) {
-                    byte_count -= data[data_index].length();
-                    ++data_index;
-                } else {
-                    break;
-                }
-            }
-            void* expected_next_byte = &data[data_index][byte_count];
-            size_t expected_next_size = data[data_index].length() - byte_count;
-
-            EXPECT_EQ(data.size() - data_index, num_buffers);
-            EXPECT_EQ(expected_next_byte, buffers[0].data);
-            EXPECT_EQ(expected_next_size, buffers[0].length);
-
-            std::string to_send = std::move(test.front());
-            test.pop_front();
-            bytes_sent += to_send.length();
-            return to_send.length();
-        };
-
-        EXPECT_EQ(expect_success, sock->Send(buffers));
-        EXPECT_TRUE(test.empty());
-    }
-}
-
-TEST(SocketMockTest, TestSendSuccess) {
-    SocketMock mock;
-
-    mock.ExpectSend("foo");
-    EXPECT_TRUE(SendString(&mock, "foo"));
-
-    mock.ExpectSend("abc");
-    mock.ExpectSend("123");
-    EXPECT_TRUE(SendString(&mock, "abc"));
-    EXPECT_TRUE(SendString(&mock, "123"));
-}
-
-TEST(SocketMockTest, TestSendFailure) {
-    SocketMock* mock = new SocketMock;
-
-    mock->ExpectSendFailure("foo");
-    EXPECT_FALSE(SendString(mock, "foo"));
-
-    EXPECT_NONFATAL_FAILURE(SendString(mock, "foo"), "no message was expected");
-
-    mock->ExpectSend("foo");
-    EXPECT_NONFATAL_FAILURE(SendString(mock, "bar"), "expected foo, but got bar");
-    EXPECT_TRUE(SendString(mock, "foo"));
-
-    mock->AddReceive("foo");
-    EXPECT_NONFATAL_FAILURE(SendString(mock, "foo"), "called out-of-order");
-    EXPECT_TRUE(ReceiveString(mock, "foo"));
-
-    mock->ExpectSend("foo");
-    EXPECT_NONFATAL_FAILURE(delete mock, "1 event(s) were not handled");
-}
-
-TEST(SocketMockTest, TestReceiveSuccess) {
-    SocketMock mock;
-
-    mock.AddReceive("foo");
-    EXPECT_TRUE(ReceiveString(&mock, "foo"));
-
-    mock.AddReceive("abc");
-    mock.AddReceive("123");
-    EXPECT_TRUE(ReceiveString(&mock, "abc"));
-    EXPECT_TRUE(ReceiveString(&mock, "123"));
-
-    // Make sure ReceiveAll() can piece together multiple receives.
-    mock.AddReceive("foo");
-    mock.AddReceive("bar");
-    mock.AddReceive("123");
-    EXPECT_TRUE(ReceiveString(&mock, "foobar123"));
-}
-
-TEST(SocketMockTest, TestReceiveFailure) {
-    SocketMock* mock = new SocketMock;
-
-    mock->AddReceiveFailure();
-    EXPECT_FALSE(ReceiveString(mock, "foo"));
-    EXPECT_FALSE(mock->ReceiveTimedOut());
-
-    mock->AddReceiveTimeout();
-    EXPECT_FALSE(ReceiveString(mock, "foo"));
-    EXPECT_TRUE(mock->ReceiveTimedOut());
-
-    mock->AddReceive("foo");
-    mock->AddReceiveFailure();
-    EXPECT_FALSE(ReceiveString(mock, "foobar"));
-
-    EXPECT_NONFATAL_FAILURE(ReceiveString(mock, "foo"), "no message was ready");
-
-    mock->ExpectSend("foo");
-    EXPECT_NONFATAL_FAILURE(ReceiveString(mock, "foo"), "called out-of-order");
-    EXPECT_TRUE(SendString(mock, "foo"));
-
-    char c;
-    mock->AddReceive("foo");
-    EXPECT_NONFATAL_FAILURE(mock->Receive(&c, 1, 0), "not enough bytes (1) for foo");
-    EXPECT_TRUE(ReceiveString(mock, "foo"));
-
-    mock->AddReceive("foo");
-    EXPECT_NONFATAL_FAILURE(delete mock, "1 event(s) were not handled");
-}
-
-TEST(SocketMockTest, TestAcceptSuccess) {
-    SocketMock mock;
-
-    SocketMock* mock_handler = new SocketMock;
-    mock.AddAccept(std::unique_ptr<SocketMock>(mock_handler));
-    EXPECT_EQ(mock_handler, mock.Accept().get());
-
-    mock.AddAccept(nullptr);
-    EXPECT_EQ(nullptr, mock.Accept().get());
-}
-
-TEST(SocketMockTest, TestAcceptFailure) {
-    SocketMock* mock = new SocketMock;
-
-    EXPECT_NONFATAL_FAILURE(mock->Accept(), "no socket was ready");
-
-    mock->ExpectSend("foo");
-    EXPECT_NONFATAL_FAILURE(mock->Accept(), "called out-of-order");
-    EXPECT_TRUE(SendString(mock, "foo"));
-
-    mock->AddAccept(nullptr);
-    EXPECT_NONFATAL_FAILURE(delete mock, "1 event(s) were not handled");
-}
diff --git a/fastboot/tcp.cpp b/fastboot/tcp.cpp
deleted file mode 100644
index e42c4e1..0000000
--- a/fastboot/tcp.cpp
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "tcp.h"
-
-#include <android-base/parseint.h>
-#include <android-base/stringprintf.h>
-
-namespace tcp {
-
-static constexpr int kProtocolVersion = 1;
-static constexpr size_t kHandshakeLength = 4;
-static constexpr int kHandshakeTimeoutMs = 2000;
-
-// Extract the big-endian 8-byte message length into a 64-bit number.
-static uint64_t ExtractMessageLength(const void* buffer) {
-    uint64_t ret = 0;
-    for (int i = 0; i < 8; ++i) {
-        ret |= uint64_t{reinterpret_cast<const uint8_t*>(buffer)[i]} << (56 - i * 8);
-    }
-    return ret;
-}
-
-// Encode the 64-bit number into a big-endian 8-byte message length.
-static void EncodeMessageLength(uint64_t length, void* buffer) {
-    for (int i = 0; i < 8; ++i) {
-        reinterpret_cast<uint8_t*>(buffer)[i] = length >> (56 - i * 8);
-    }
-}
-
-class TcpTransport : public Transport {
-  public:
-    // Factory function so we can return nullptr if initialization fails.
-    static std::unique_ptr<TcpTransport> NewTransport(std::unique_ptr<Socket> socket,
-                                                      std::string* error);
-
-    ~TcpTransport() override = default;
-
-    ssize_t Read(void* data, size_t length) override;
-    ssize_t Write(const void* data, size_t length) override;
-    int Close() override;
-
-  private:
-    TcpTransport(std::unique_ptr<Socket> sock) : socket_(std::move(sock)) {}
-
-    // Connects to the device and performs the initial handshake. Returns false and fills |error|
-    // on failure.
-    bool InitializeProtocol(std::string* error);
-
-    std::unique_ptr<Socket> socket_;
-    uint64_t message_bytes_left_ = 0;
-
-    DISALLOW_COPY_AND_ASSIGN(TcpTransport);
-};
-
-std::unique_ptr<TcpTransport> TcpTransport::NewTransport(std::unique_ptr<Socket> socket,
-                                                         std::string* error) {
-    std::unique_ptr<TcpTransport> transport(new TcpTransport(std::move(socket)));
-
-    if (!transport->InitializeProtocol(error)) {
-        return nullptr;
-    }
-
-    return transport;
-}
-
-// These error strings are checked in tcp_test.cpp and should be kept in sync.
-bool TcpTransport::InitializeProtocol(std::string* error) {
-    std::string handshake_message(android::base::StringPrintf("FB%02d", kProtocolVersion));
-
-    if (!socket_->Send(handshake_message.c_str(), kHandshakeLength)) {
-        *error = android::base::StringPrintf("Failed to send initialization message (%s)",
-                                             Socket::GetErrorMessage().c_str());
-        return false;
-    }
-
-    char buffer[kHandshakeLength + 1];
-    buffer[kHandshakeLength] = '\0';
-    if (socket_->ReceiveAll(buffer, kHandshakeLength, kHandshakeTimeoutMs) != kHandshakeLength) {
-        *error = android::base::StringPrintf(
-                "No initialization message received (%s). Target may not support TCP fastboot",
-                Socket::GetErrorMessage().c_str());
-        return false;
-    }
-
-    if (memcmp(buffer, "FB", 2) != 0) {
-        *error = "Unrecognized initialization message. Target may not support TCP fastboot";
-        return false;
-    }
-
-    int version = 0;
-    if (!android::base::ParseInt(buffer + 2, &version) || version < kProtocolVersion) {
-        *error = android::base::StringPrintf("Unknown TCP protocol version %s (host version %02d)",
-                                             buffer + 2, kProtocolVersion);
-        return false;
-    }
-
-    error->clear();
-    return true;
-}
-
-ssize_t TcpTransport::Read(void* data, size_t length) {
-    if (socket_ == nullptr) {
-        return -1;
-    }
-
-    // Unless we're mid-message, read the next 8-byte message length.
-    if (message_bytes_left_ == 0) {
-        char buffer[8];
-        if (socket_->ReceiveAll(buffer, 8, 0) != 8) {
-            Close();
-            return -1;
-        }
-        message_bytes_left_ = ExtractMessageLength(buffer);
-    }
-
-    // Now read the message (up to |length| bytes).
-    if (length > message_bytes_left_) {
-        length = message_bytes_left_;
-    }
-    ssize_t bytes_read = socket_->ReceiveAll(data, length, 0);
-    if (bytes_read == -1) {
-        Close();
-    } else {
-        message_bytes_left_ -= bytes_read;
-    }
-    return bytes_read;
-}
-
-ssize_t TcpTransport::Write(const void* data, size_t length) {
-    if (socket_ == nullptr) {
-        return -1;
-    }
-
-    // Use multi-buffer writes for better performance.
-    char header[8];
-    EncodeMessageLength(length, header);
-    if (!socket_->Send(std::vector<cutils_socket_buffer_t>{{header, 8}, {data, length}})) {
-        Close();
-        return -1;
-    }
-
-    return length;
-}
-
-int TcpTransport::Close() {
-    if (socket_ == nullptr) {
-        return 0;
-    }
-
-    int result = socket_->Close();
-    socket_.reset();
-    return result;
-}
-
-std::unique_ptr<Transport> Connect(const std::string& hostname, int port, std::string* error) {
-    return internal::Connect(Socket::NewClient(Socket::Protocol::kTcp, hostname, port, error),
-                             error);
-}
-
-namespace internal {
-
-std::unique_ptr<Transport> Connect(std::unique_ptr<Socket> sock, std::string* error) {
-    if (sock == nullptr) {
-        // If Socket creation failed |error| is already set.
-        return nullptr;
-    }
-
-    return TcpTransport::NewTransport(std::move(sock), error);
-}
-
-}  // namespace internal
-
-}  // namespace tcp
diff --git a/fastboot/tcp.h b/fastboot/tcp.h
deleted file mode 100644
index aa3ef13..0000000
--- a/fastboot/tcp.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#ifndef TCP_H_
-#define TCP_H_
-
-#include <memory>
-#include <string>
-
-#include <android-base/macros.h>
-
-#include "socket.h"
-#include "transport.h"
-
-namespace tcp {
-
-constexpr int kDefaultPort = 5554;
-
-// Returns a newly allocated Transport object connected to |hostname|:|port|. On failure, |error| is
-// filled and nullptr is returned.
-std::unique_ptr<Transport> Connect(const std::string& hostname, int port, std::string* error);
-
-// Internal namespace for test use only.
-namespace internal {
-
-// Creates a TCP Transport object but using a given Socket instead of connecting to a hostname.
-// Used for unit tests to create a Transport object that uses a SocketMock.
-std::unique_ptr<Transport> Connect(std::unique_ptr<Socket> sock, std::string* error);
-
-}  // namespace internal
-
-}  // namespace tcp
-
-#endif  // TCP_H_
diff --git a/fastboot/tcp_test.cpp b/fastboot/tcp_test.cpp
deleted file mode 100644
index 6e867ae..0000000
--- a/fastboot/tcp_test.cpp
+++ /dev/null
@@ -1,227 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "tcp.h"
-
-#include <gtest/gtest.h>
-
-#include "socket_mock.h"
-
-TEST(TcpConnectTest, TestSuccess) {
-    std::unique_ptr<SocketMock> mock(new SocketMock);
-    mock->ExpectSend("FB01");
-    mock->AddReceive("FB01");
-
-    std::string error;
-    EXPECT_NE(nullptr, tcp::internal::Connect(std::move(mock), &error));
-    EXPECT_EQ("", error);
-}
-
-TEST(TcpConnectTest, TestNewerVersionSuccess) {
-    std::unique_ptr<SocketMock> mock(new SocketMock);
-    mock->ExpectSend("FB01");
-    mock->AddReceive("FB99");
-
-    std::string error;
-    EXPECT_NE(nullptr, tcp::internal::Connect(std::move(mock), &error));
-    EXPECT_EQ("", error);
-}
-
-TEST(TcpConnectTest, TestSendFailure) {
-    std::unique_ptr<SocketMock> mock(new SocketMock);
-    mock->ExpectSendFailure("FB01");
-
-    std::string error;
-    EXPECT_EQ(nullptr, tcp::internal::Connect(std::move(mock), &error));
-    EXPECT_NE(std::string::npos, error.find("Failed to send initialization message"));
-}
-
-TEST(TcpConnectTest, TestNoResponseFailure) {
-    std::unique_ptr<SocketMock> mock(new SocketMock);
-    mock->ExpectSend("FB01");
-    mock->AddReceiveFailure();
-
-    std::string error;
-    EXPECT_EQ(nullptr, tcp::internal::Connect(std::move(mock), &error));
-    EXPECT_NE(std::string::npos, error.find("No initialization message received"));
-}
-
-TEST(TcpConnectTest, TestBadResponseFailure) {
-    std::unique_ptr<SocketMock> mock(new SocketMock);
-    mock->ExpectSend("FB01");
-    mock->AddReceive("XX01");
-
-    std::string error;
-    EXPECT_EQ(nullptr, tcp::internal::Connect(std::move(mock), &error));
-    EXPECT_NE(std::string::npos, error.find("Unrecognized initialization message"));
-}
-
-TEST(TcpConnectTest, TestUnknownVersionFailure) {
-    std::unique_ptr<SocketMock> mock(new SocketMock);
-    mock->ExpectSend("FB01");
-    mock->AddReceive("FB00");
-
-    std::string error;
-    EXPECT_EQ(nullptr, tcp::internal::Connect(std::move(mock), &error));
-    EXPECT_EQ("Unknown TCP protocol version 00 (host version 01)", error);
-}
-
-// Fixture to configure a SocketMock for a successful TCP connection.
-class TcpTest : public ::testing::Test {
-  protected:
-    void SetUp() override {
-        mock_ = new SocketMock;
-        mock_->ExpectSend("FB01");
-        mock_->AddReceive("FB01");
-
-        std::string error;
-        transport_ = tcp::internal::Connect(std::unique_ptr<Socket>(mock_), &error);
-        ASSERT_NE(nullptr, transport_);
-        ASSERT_EQ("", error);
-    };
-
-    // Writes |message| to |transport_|, returns true on success.
-    bool Write(const std::string& message) {
-        return transport_->Write(message.data(), message.length()) ==
-               static_cast<ssize_t>(message.length());
-    }
-
-    // Reads from |transport_|, returns true if it matches |message|.
-    bool Read(const std::string& message) {
-        std::string buffer(message.length(), '\0');
-        return transport_->Read(&buffer[0], buffer.length()) ==
-                       static_cast<ssize_t>(message.length()) &&
-               buffer == message;
-    }
-
-    // Use a raw SocketMock* here because we pass ownership to the Transport object, but we still
-    // need access to configure mock expectations.
-    SocketMock* mock_ = nullptr;
-    std::unique_ptr<Transport> transport_;
-};
-
-TEST_F(TcpTest, TestWriteSuccess) {
-    mock_->ExpectSend(std::string{0, 0, 0, 0, 0, 0, 0, 3} + "foo");
-
-    EXPECT_TRUE(Write("foo"));
-}
-
-TEST_F(TcpTest, TestReadSuccess) {
-    mock_->AddReceive(std::string{0, 0, 0, 0, 0, 0, 0, 3});
-    mock_->AddReceive("foo");
-
-    EXPECT_TRUE(Read("foo"));
-}
-
-// Tests that fragmented TCP reads are handled properly.
-TEST_F(TcpTest, TestReadFragmentSuccess) {
-    mock_->AddReceive(std::string{0, 0, 0, 0});
-    mock_->AddReceive(std::string{0, 0, 0, 3});
-    mock_->AddReceive("f");
-    mock_->AddReceive("o");
-    mock_->AddReceive("o");
-
-    EXPECT_TRUE(Read("foo"));
-}
-
-TEST_F(TcpTest, TestLargeWriteSuccess) {
-    // 0x100000 = 1MiB.
-    std::string data(0x100000, '\0');
-    for (size_t i = 0; i < data.length(); ++i) {
-        data[i] = i;
-    }
-    mock_->ExpectSend(std::string{0, 0, 0, 0, 0, 0x10, 0, 0} + data);
-
-    EXPECT_TRUE(Write(data));
-}
-
-TEST_F(TcpTest, TestLargeReadSuccess) {
-    // 0x100000 = 1MiB.
-    std::string data(0x100000, '\0');
-    for (size_t i = 0; i < data.length(); ++i) {
-        data[i] = i;
-    }
-    mock_->AddReceive(std::string{0, 0, 0, 0, 0, 0x10, 0, 0});
-    mock_->AddReceive(data);
-
-    EXPECT_TRUE(Read(data));
-}
-
-// Tests a few sample fastboot protocol commands.
-TEST_F(TcpTest, TestFastbootProtocolSuccess) {
-    mock_->ExpectSend(std::string{0, 0, 0, 0, 0, 0, 0, 14} + "getvar:version");
-    mock_->AddReceive(std::string{0, 0, 0, 0, 0, 0, 0, 7});
-    mock_->AddReceive("OKAY0.4");
-
-    mock_->ExpectSend(std::string{0, 0, 0, 0, 0, 0, 0, 10} + "getvar:all");
-    mock_->AddReceive(std::string{0, 0, 0, 0, 0, 0, 0, 16});
-    mock_->AddReceive("INFOversion: 0.4");
-    mock_->AddReceive(std::string{0, 0, 0, 0, 0, 0, 0, 12});
-    mock_->AddReceive("INFOfoo: bar");
-    mock_->AddReceive(std::string{0, 0, 0, 0, 0, 0, 0, 4});
-    mock_->AddReceive("OKAY");
-
-    EXPECT_TRUE(Write("getvar:version"));
-    EXPECT_TRUE(Read("OKAY0.4"));
-
-    EXPECT_TRUE(Write("getvar:all"));
-    EXPECT_TRUE(Read("INFOversion: 0.4"));
-    EXPECT_TRUE(Read("INFOfoo: bar"));
-    EXPECT_TRUE(Read("OKAY"));
-}
-
-TEST_F(TcpTest, TestReadLengthFailure) {
-    mock_->AddReceiveFailure();
-
-    char buffer[16];
-    EXPECT_EQ(-1, transport_->Read(buffer, sizeof(buffer)));
-}
-
-TEST_F(TcpTest, TestReadDataFailure) {
-    mock_->AddReceive(std::string{0, 0, 0, 0, 0, 0, 0, 3});
-    mock_->AddReceiveFailure();
-
-    char buffer[16];
-    EXPECT_EQ(-1, transport_->Read(buffer, sizeof(buffer)));
-}
-
-TEST_F(TcpTest, TestWriteFailure) {
-    mock_->ExpectSendFailure(std::string{0, 0, 0, 0, 0, 0, 0, 3} + "foo");
-
-    EXPECT_EQ(-1, transport_->Write("foo", 3));
-}
-
-TEST_F(TcpTest, TestTransportClose) {
-    EXPECT_EQ(0, transport_->Close());
-
-    // After closing, Transport Read()/Write() should return -1 without actually attempting any
-    // network operations.
-    char buffer[16];
-    EXPECT_EQ(-1, transport_->Read(buffer, sizeof(buffer)));
-    EXPECT_EQ(-1, transport_->Write("foo", 3));
-}
diff --git a/fastboot/transport.h b/fastboot/transport.h
deleted file mode 100644
index 67d01f9..0000000
--- a/fastboot/transport.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef TRANSPORT_H_
-#define TRANSPORT_H_
-
-#include <android-base/macros.h>
-
-// General interface to allow the fastboot protocol to be used over different
-// types of transports.
-class Transport {
-  public:
-    Transport() = default;
-    virtual ~Transport() = default;
-
-    // Reads |len| bytes into |data|. Returns the number of bytes actually
-    // read or -1 on error.
-    virtual ssize_t Read(void* data, size_t len) = 0;
-
-    // Writes |len| bytes from |data|. Returns the number of bytes actually
-    // written or -1 on error.
-    virtual ssize_t Write(const void* data, size_t len) = 0;
-
-    // Closes the underlying transport. Returns 0 on success.
-    virtual int Close() = 0;
-
-    // Blocks until the transport disconnects. Transports that don't support
-    // this will return immediately. Returns 0 on success.
-    virtual int WaitForDisconnect() { return 0; }
-
-  private:
-    DISALLOW_COPY_AND_ASSIGN(Transport);
-};
-
-#endif  // TRANSPORT_H_
diff --git a/fastboot/udp.cpp b/fastboot/udp.cpp
deleted file mode 100644
index b36bd60..0000000
--- a/fastboot/udp.cpp
+++ /dev/null
@@ -1,391 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-// This file implements the fastboot UDP protocol; see fastboot_protocol.txt for documentation.
-
-#include "udp.h"
-
-#include <errno.h>
-#include <stdio.h>
-
-#include <list>
-#include <memory>
-#include <vector>
-
-#include <android-base/macros.h>
-#include <android-base/stringprintf.h>
-
-#include "socket.h"
-
-namespace udp {
-
-using namespace internal;
-
-constexpr size_t kMinPacketSize = 512;
-constexpr size_t kHeaderSize = 4;
-
-enum Index {
-    kIndexId = 0,
-    kIndexFlags = 1,
-    kIndexSeqH = 2,
-    kIndexSeqL = 3,
-};
-
-// Extracts a big-endian uint16_t from a byte array.
-static uint16_t ExtractUint16(const uint8_t* bytes) {
-    return (static_cast<uint16_t>(bytes[0]) << 8) | bytes[1];
-}
-
-// Packet header handling.
-class Header {
-  public:
-    Header();
-    ~Header() = default;
-
-    uint8_t id() const { return bytes_[kIndexId]; }
-    const uint8_t* bytes() const { return bytes_; }
-
-    void Set(uint8_t id, uint16_t sequence, Flag flag);
-
-    // Checks whether |response| is a match for this header.
-    bool Matches(const uint8_t* response);
-
-  private:
-    uint8_t bytes_[kHeaderSize];
-};
-
-Header::Header() {
-    Set(kIdError, 0, kFlagNone);
-}
-
-void Header::Set(uint8_t id, uint16_t sequence, Flag flag) {
-    bytes_[kIndexId] = id;
-    bytes_[kIndexFlags] = flag;
-    bytes_[kIndexSeqH] = sequence >> 8;
-    bytes_[kIndexSeqL] = sequence;
-}
-
-bool Header::Matches(const uint8_t* response) {
-    // Sequence numbers must be the same to match, but the response ID can either be the same
-    // or an error response which is always accepted.
-    return bytes_[kIndexSeqH] == response[kIndexSeqH] &&
-           bytes_[kIndexSeqL] == response[kIndexSeqL] &&
-           (bytes_[kIndexId] == response[kIndexId] || response[kIndexId] == kIdError);
-}
-
-// Implements the Transport interface to work with the fastboot engine.
-class UdpTransport : public Transport {
-  public:
-    // Factory function so we can return nullptr if initialization fails.
-    static std::unique_ptr<UdpTransport> NewTransport(std::unique_ptr<Socket> socket,
-                                                      std::string* error);
-    ~UdpTransport() override = default;
-
-    ssize_t Read(void* data, size_t length) override;
-    ssize_t Write(const void* data, size_t length) override;
-    int Close() override;
-
-  private:
-    UdpTransport(std::unique_ptr<Socket> socket) : socket_(std::move(socket)) {}
-
-    // Performs the UDP initialization procedure. Returns true on success.
-    bool InitializeProtocol(std::string* error);
-
-    // Sends |length| bytes from |data| and waits for the response packet up to |attempts| times.
-    // Continuation packets are handled automatically and any return data is written to |rx_data|.
-    // Excess bytes that cannot fit in |rx_data| are dropped.
-    // On success, returns the number of response data bytes received, which may be greater than
-    // |rx_length|. On failure, returns -1 and fills |error| on failure.
-    ssize_t SendData(Id id, const uint8_t* tx_data, size_t tx_length, uint8_t* rx_data,
-                     size_t rx_length, int attempts, std::string* error);
-
-    // Helper for SendData(); sends a single packet and handles the response. |header| specifies
-    // the initial outgoing packet information but may be modified by this function.
-    ssize_t SendSinglePacketHelper(Header* header, const uint8_t* tx_data, size_t tx_length,
-                                   uint8_t* rx_data, size_t rx_length, int attempts,
-                                   std::string* error);
-
-    std::unique_ptr<Socket> socket_;
-    int sequence_ = -1;
-    size_t max_data_length_ = kMinPacketSize - kHeaderSize;
-    std::vector<uint8_t> rx_packet_;
-
-    DISALLOW_COPY_AND_ASSIGN(UdpTransport);
-};
-
-std::unique_ptr<UdpTransport> UdpTransport::NewTransport(std::unique_ptr<Socket> socket,
-                                                         std::string* error) {
-    std::unique_ptr<UdpTransport> transport(new UdpTransport(std::move(socket)));
-
-    if (!transport->InitializeProtocol(error)) {
-        return nullptr;
-    }
-
-    return transport;
-}
-
-bool UdpTransport::InitializeProtocol(std::string* error) {
-    uint8_t rx_data[4];
-
-    sequence_ = 0;
-    rx_packet_.resize(kMinPacketSize);
-
-    // First send the query packet to sync with the target. Only attempt this a small number of
-    // times so we can fail out quickly if the target isn't available.
-    ssize_t rx_bytes = SendData(kIdDeviceQuery, nullptr, 0, rx_data, sizeof(rx_data),
-                                kMaxConnectAttempts, error);
-    if (rx_bytes == -1) {
-        return false;
-    } else if (rx_bytes < 2) {
-        *error = "invalid query response from target";
-        return false;
-    }
-    // The first two bytes contain the next expected sequence number.
-    sequence_ = ExtractUint16(rx_data);
-
-    // Now send the initialization packet with our version and maximum packet size.
-    uint8_t init_data[] = {kProtocolVersion >> 8, kProtocolVersion & 0xFF,
-                           kHostMaxPacketSize >> 8, kHostMaxPacketSize & 0xFF};
-    rx_bytes = SendData(kIdInitialization, init_data, sizeof(init_data), rx_data, sizeof(rx_data),
-                        kMaxTransmissionAttempts, error);
-    if (rx_bytes == -1) {
-        return false;
-    } else if (rx_bytes < 4) {
-        *error = "invalid initialization response from target";
-        return false;
-    }
-
-    // The first two data bytes contain the version, the second two bytes contain the target max
-    // supported packet size, which must be at least 512 bytes.
-    uint16_t version = ExtractUint16(rx_data);
-    if (version < kProtocolVersion) {
-        *error = android::base::StringPrintf("target reported invalid protocol version %d",
-                                             version);
-        return false;
-    }
-    uint16_t packet_size = ExtractUint16(rx_data + 2);
-    if (packet_size < kMinPacketSize) {
-        *error = android::base::StringPrintf("target reported invalid packet size %d", packet_size);
-        return false;
-    }
-
-    packet_size = std::min(kHostMaxPacketSize, packet_size);
-    max_data_length_ = packet_size - kHeaderSize;
-    rx_packet_.resize(packet_size);
-
-    return true;
-}
-
-// SendData() is just responsible for chunking |data| into packets until it's all been sent.
-// Per-packet timeout/retransmission logic is done in SendSinglePacketHelper().
-ssize_t UdpTransport::SendData(Id id, const uint8_t* tx_data, size_t tx_length, uint8_t* rx_data,
-                               size_t rx_length, int attempts, std::string* error) {
-    if (socket_ == nullptr) {
-        *error = "socket is closed";
-        return -1;
-    }
-
-    Header header;
-    size_t packet_data_length;
-    ssize_t ret = 0;
-    // We often send header-only packets with no data as part of the protocol, so always send at
-    // least once even if |length| == 0, then repeat until we've sent all of |data|.
-    do {
-        // Set the continuation flag and truncate packet data if needed.
-        if (tx_length > max_data_length_) {
-            packet_data_length = max_data_length_;
-            header.Set(id, sequence_, kFlagContinuation);
-        } else {
-            packet_data_length = tx_length;
-            header.Set(id, sequence_, kFlagNone);
-        }
-
-        ssize_t bytes = SendSinglePacketHelper(&header, tx_data, packet_data_length, rx_data,
-                                               rx_length, attempts, error);
-
-        // Advance our read and write buffers for the next packet. Keep going even if we run out
-        // of receive buffer space so we can detect overflows.
-        if (bytes == -1) {
-            return -1;
-        } else if (static_cast<size_t>(bytes) < rx_length) {
-            rx_data += bytes;
-            rx_length -= bytes;
-        } else {
-            rx_data = nullptr;
-            rx_length = 0;
-        }
-
-        tx_length -= packet_data_length;
-        tx_data += packet_data_length;
-
-        ret += bytes;
-    } while (tx_length > 0);
-
-    return ret;
-}
-
-ssize_t UdpTransport::SendSinglePacketHelper(
-        Header* header, const uint8_t* tx_data, size_t tx_length, uint8_t* rx_data,
-        size_t rx_length, const int attempts, std::string* error) {
-    ssize_t total_data_bytes = 0;
-    error->clear();
-
-    int attempts_left = attempts;
-    while (attempts_left > 0) {
-        if (!socket_->Send({{header->bytes(), kHeaderSize}, {tx_data, tx_length}})) {
-            *error = Socket::GetErrorMessage();
-            return -1;
-        }
-
-        // Keep receiving until we get a matching response or we timeout.
-        ssize_t bytes = 0;
-        do {
-            bytes = socket_->Receive(rx_packet_.data(), rx_packet_.size(), kResponseTimeoutMs);
-            if (bytes == -1) {
-                if (socket_->ReceiveTimedOut()) {
-                    break;
-                }
-                *error = Socket::GetErrorMessage();
-                return -1;
-            } else if (bytes < static_cast<ssize_t>(kHeaderSize)) {
-                *error = "protocol error: incomplete header";
-                return -1;
-            }
-        } while (!header->Matches(rx_packet_.data()));
-
-        if (socket_->ReceiveTimedOut()) {
-            --attempts_left;
-            continue;
-        }
-        ++sequence_;
-
-        // Save to |error| or |rx_data| as appropriate.
-        if (rx_packet_[kIndexId] == kIdError) {
-            error->append(rx_packet_.data() + kHeaderSize, rx_packet_.data() + bytes);
-        } else {
-            total_data_bytes += bytes - kHeaderSize;
-            size_t rx_data_bytes = std::min<size_t>(bytes - kHeaderSize, rx_length);
-            if (rx_data_bytes > 0) {
-                memcpy(rx_data, rx_packet_.data() + kHeaderSize, rx_data_bytes);
-                rx_data += rx_data_bytes;
-                rx_length -= rx_data_bytes;
-            }
-        }
-
-        // If the response has a continuation flag we need to prompt for more data by sending
-        // an empty packet.
-        if (rx_packet_[kIndexFlags] & kFlagContinuation) {
-            // We got a valid response so reset our attempt counter.
-            attempts_left = attempts;
-            header->Set(rx_packet_[kIndexId], sequence_, kFlagNone);
-            tx_data = nullptr;
-            tx_length = 0;
-            continue;
-        }
-
-        break;
-    }
-
-    if (attempts_left <= 0) {
-        *error = "no response from target";
-        return -1;
-    }
-
-    if (rx_packet_[kIndexId] == kIdError) {
-        *error = "target reported error: " + *error;
-        return -1;
-    }
-
-    return total_data_bytes;
-}
-
-ssize_t UdpTransport::Read(void* data, size_t length) {
-    // Read from the target by sending an empty packet.
-    std::string error;
-    ssize_t bytes = SendData(kIdFastboot, nullptr, 0, reinterpret_cast<uint8_t*>(data), length,
-                             kMaxTransmissionAttempts, &error);
-
-    if (bytes == -1) {
-        fprintf(stderr, "UDP error: %s\n", error.c_str());
-        return -1;
-    } else if (static_cast<size_t>(bytes) > length) {
-        // Fastboot protocol error: the target sent more data than our fastboot engine was prepared
-        // to receive.
-        fprintf(stderr, "UDP error: receive overflow, target sent too much fastboot data\n");
-        return -1;
-    }
-
-    return bytes;
-}
-
-ssize_t UdpTransport::Write(const void* data, size_t length) {
-    std::string error;
-    ssize_t bytes = SendData(kIdFastboot, reinterpret_cast<const uint8_t*>(data), length, nullptr,
-                             0, kMaxTransmissionAttempts, &error);
-
-    if (bytes == -1) {
-        fprintf(stderr, "UDP error: %s\n", error.c_str());
-        return -1;
-    } else if (bytes > 0) {
-        // UDP protocol error: only empty ACK packets are allowed when writing to a device.
-        fprintf(stderr, "UDP error: target sent fastboot data out-of-turn\n");
-        return -1;
-    }
-
-    return length;
-}
-
-int UdpTransport::Close() {
-    if (socket_ == nullptr) {
-        return 0;
-    }
-
-    int result = socket_->Close();
-    socket_.reset();
-    return result;
-}
-
-std::unique_ptr<Transport> Connect(const std::string& hostname, int port, std::string* error) {
-    return internal::Connect(Socket::NewClient(Socket::Protocol::kUdp, hostname, port, error),
-                             error);
-}
-
-namespace internal {
-
-std::unique_ptr<Transport> Connect(std::unique_ptr<Socket> sock, std::string* error) {
-    if (sock == nullptr) {
-        // If Socket creation failed |error| is already set.
-        return nullptr;
-    }
-
-    return UdpTransport::NewTransport(std::move(sock), error);
-}
-
-}  // namespace internal
-
-}  // namespace udp
diff --git a/fastboot/udp.h b/fastboot/udp.h
deleted file mode 100644
index 14f5b35..0000000
--- a/fastboot/udp.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#ifndef UDP_H_
-#define UDP_H_
-
-#include <memory>
-#include <string>
-
-#include "socket.h"
-#include "transport.h"
-
-namespace udp {
-
-constexpr int kDefaultPort = 5554;
-
-// Returns a newly allocated Transport object connected to |hostname|:|port|. On failure, |error| is
-// filled and nullptr is returned.
-std::unique_ptr<Transport> Connect(const std::string& hostname, int port, std::string* error);
-
-// Internal namespace for test use only.
-namespace internal {
-
-constexpr uint16_t kProtocolVersion = 1;
-
-// This will be negotiated with the device so may end up being smaller.
-constexpr uint16_t kHostMaxPacketSize = 8192;
-
-// Retransmission constants. Retransmission timeout must be at least 500ms, and the host must
-// attempt to send packets for at least 1 minute once the device has connected. See
-// fastboot_protocol.txt for more information.
-constexpr int kResponseTimeoutMs = 500;
-constexpr int kMaxConnectAttempts = 4;
-constexpr int kMaxTransmissionAttempts = 60 * 1000 / kResponseTimeoutMs;
-
-enum Id : uint8_t {
-    kIdError = 0x00,
-    kIdDeviceQuery = 0x01,
-    kIdInitialization = 0x02,
-    kIdFastboot = 0x03
-};
-
-enum Flag : uint8_t {
-    kFlagNone = 0x00,
-    kFlagContinuation = 0x01
-};
-
-// Creates a UDP Transport object using a given Socket. Used for unit tests to create a Transport
-// object that uses a SocketMock.
-std::unique_ptr<Transport> Connect(std::unique_ptr<Socket> sock, std::string* error);
-
-}  // namespace internal
-
-}  // namespace udp
-
-#endif  // UDP_H_
diff --git a/fastboot/udp_test.cpp b/fastboot/udp_test.cpp
deleted file mode 100644
index ff8cf0f..0000000
--- a/fastboot/udp_test.cpp
+++ /dev/null
@@ -1,531 +0,0 @@
-/*
- * Copyright (C) 2015 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "udp.h"
-
-#include <gtest/gtest.h>
-
-#include "socket.h"
-#include "socket_mock.h"
-
-using namespace udp;
-using namespace udp::internal;
-
-// Some possible corner case sequence numbers we want to check.
-static const uint16_t kTestSequenceNumbers[] = {0x0000, 0x0001, 0x00FF, 0x0100,
-                                                0x7FFF, 0x8000, 0xFFFF};
-
-// Converts |value| to a binary big-endian string.
-static std::string PacketValue(uint16_t value) {
-    return std::string{static_cast<char>(value >> 8), static_cast<char>(value)};
-}
-
-// Returns an Error packet.
-static std::string ErrorPacket(uint16_t sequence, const std::string& message = "",
-                               char flags = kFlagNone) {
-    return std::string{kIdError, flags} + PacketValue(sequence) + message;
-}
-
-// Returns a Query packet with no data.
-static std::string QueryPacket(uint16_t sequence) {
-    return std::string{kIdDeviceQuery, kFlagNone} + PacketValue(sequence);
-}
-
-// Returns a Query packet with a 2-byte |new_sequence|.
-static std::string QueryPacket(uint16_t sequence, uint16_t new_sequence) {
-    return std::string{kIdDeviceQuery, kFlagNone} + PacketValue(sequence) +
-           PacketValue(new_sequence);
-}
-
-// Returns an Init packet with a 2-byte |version| and |max_packet_size|.
-static std::string InitPacket(uint16_t sequence, uint16_t version, uint16_t max_packet_size) {
-    return std::string{kIdInitialization, kFlagNone} + PacketValue(sequence) +
-           PacketValue(version) + PacketValue(max_packet_size);
-}
-
-// Returns a Fastboot packet with |data|.
-static std::string FastbootPacket(uint16_t sequence, const std::string& data = "",
-                                  char flags = kFlagNone) {
-    return std::string{kIdFastboot, flags} + PacketValue(sequence) + data;
-}
-
-// Fixture class to test protocol initialization. Usage is to set up the expected calls to the
-// SocketMock object then call UdpConnect() and check the result.
-class UdpConnectTest : public ::testing::Test {
-  public:
-    UdpConnectTest() : mock_socket_(new SocketMock) {}
-
-    // Run the initialization, return whether it was successful or not. This passes ownership of
-    // the current |mock_socket_| but allocates a new one for re-use.
-    bool UdpConnect(std::string* error = nullptr) {
-        std::string local_error;
-        if (error == nullptr) {
-            error = &local_error;
-        }
-        std::unique_ptr<Transport> transport(Connect(std::move(mock_socket_), error));
-        mock_socket_.reset(new SocketMock);
-        return transport != nullptr && error->empty();
-    }
-
-  protected:
-    std::unique_ptr<SocketMock> mock_socket_;
-};
-
-// Tests a successful protocol initialization with various starting sequence numbers.
-TEST_F(UdpConnectTest, InitializationSuccess) {
-    for (uint16_t seq : kTestSequenceNumbers) {
-        mock_socket_->ExpectSend(QueryPacket(0));
-        mock_socket_->AddReceive(QueryPacket(0, seq));
-        mock_socket_->ExpectSend(InitPacket(seq, kProtocolVersion, kHostMaxPacketSize));
-        mock_socket_->AddReceive(InitPacket(seq, kProtocolVersion, 1024));
-
-        EXPECT_TRUE(UdpConnect());
-    }
-}
-
-// Tests continuation packets during initialization.
-TEST_F(UdpConnectTest, InitializationContinuationSuccess) {
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(std::string{kIdDeviceQuery, kFlagContinuation, 0, 0, 0x44});
-    mock_socket_->ExpectSend(std::string{kIdDeviceQuery, kFlagNone, 0, 1});
-    mock_socket_->AddReceive(std::string{kIdDeviceQuery, kFlagNone, 0, 1, 0x55});
-
-    mock_socket_->ExpectSend(InitPacket(0x4455, kProtocolVersion, kHostMaxPacketSize));
-    mock_socket_->AddReceive(std::string{kIdInitialization, kFlagContinuation, 0x44, 0x55, 0});
-    mock_socket_->ExpectSend(std::string{kIdInitialization, kFlagNone, 0x44, 0x56});
-    mock_socket_->AddReceive(std::string{kIdInitialization, kFlagContinuation, 0x44, 0x56, 1});
-    mock_socket_->ExpectSend(std::string{kIdInitialization, kFlagNone, 0x44, 0x57});
-    mock_socket_->AddReceive(std::string{kIdInitialization, kFlagContinuation, 0x44, 0x57, 2});
-    mock_socket_->ExpectSend(std::string{kIdInitialization, kFlagNone, 0x44, 0x58});
-    mock_socket_->AddReceive(std::string{kIdInitialization, kFlagNone, 0x44, 0x58, 0});
-
-    EXPECT_TRUE(UdpConnect());
-}
-
-
-// Tests a mismatched version number; as long as the minimum of the two versions is supported
-// we should allow the connection.
-TEST_F(UdpConnectTest, InitializationVersionMismatch) {
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(QueryPacket(0, 0));
-    mock_socket_->ExpectSend(InitPacket(0, kProtocolVersion, kHostMaxPacketSize));
-    mock_socket_->AddReceive(InitPacket(0, 2, 1024));
-
-    EXPECT_TRUE(UdpConnect());
-
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(QueryPacket(0, 0));
-    mock_socket_->ExpectSend(InitPacket(0, kProtocolVersion, kHostMaxPacketSize));
-    mock_socket_->AddReceive(InitPacket(0, 0, 1024));
-
-    EXPECT_FALSE(UdpConnect());
-}
-
-TEST_F(UdpConnectTest, QueryResponseTimeoutFailure) {
-    for (int i = 0; i < kMaxConnectAttempts; ++i) {
-        mock_socket_->ExpectSend(QueryPacket(0));
-        mock_socket_->AddReceiveTimeout();
-    }
-
-    EXPECT_FALSE(UdpConnect());
-}
-
-TEST_F(UdpConnectTest, QueryResponseReceiveFailure) {
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceiveFailure();
-
-    EXPECT_FALSE(UdpConnect());
-}
-
-TEST_F(UdpConnectTest, InitResponseTimeoutFailure) {
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(QueryPacket(0, 0));
-    for (int i = 0; i < kMaxTransmissionAttempts; ++i) {
-        mock_socket_->ExpectSend(InitPacket(0, kProtocolVersion, kHostMaxPacketSize));
-        mock_socket_->AddReceiveTimeout();
-    }
-
-    EXPECT_FALSE(UdpConnect());
-}
-
-TEST_F(UdpConnectTest, InitResponseReceiveFailure) {
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(QueryPacket(0, 0));
-    mock_socket_->ExpectSend(InitPacket(0, kProtocolVersion, kHostMaxPacketSize));
-    mock_socket_->AddReceiveFailure();
-
-    EXPECT_FALSE(UdpConnect());
-}
-
-// Tests that we can recover up to the maximum number of allowed retries.
-TEST_F(UdpConnectTest, ResponseRecovery) {
-    // The device query packet can recover from up to (kMaxConnectAttempts - 1) timeouts.
-    for (int i = 0; i < kMaxConnectAttempts - 1; ++i) {
-        mock_socket_->ExpectSend(QueryPacket(0));
-        mock_socket_->AddReceiveTimeout();
-    }
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(QueryPacket(0, 0));
-
-    // Subsequent packets try up to (kMaxTransmissionAttempts - 1) times.
-    for (int i = 0; i < kMaxTransmissionAttempts - 1; ++i) {
-        mock_socket_->ExpectSend(InitPacket(0, kProtocolVersion, kHostMaxPacketSize));
-        mock_socket_->AddReceiveTimeout();
-    }
-    mock_socket_->ExpectSend(InitPacket(0, kProtocolVersion, kHostMaxPacketSize));
-    mock_socket_->AddReceive(InitPacket(0, kProtocolVersion, 1024));
-
-    EXPECT_TRUE(UdpConnect());
-}
-
-// Tests that the host can handle receiving additional bytes for forward compatibility.
-TEST_F(UdpConnectTest, ExtraResponseDataSuccess) {
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(QueryPacket(0, 0) + "foo");
-    mock_socket_->ExpectSend(InitPacket(0, kProtocolVersion, kHostMaxPacketSize));
-    mock_socket_->AddReceive(InitPacket(0, kProtocolVersion, 1024) + "bar");
-
-    EXPECT_TRUE(UdpConnect());
-}
-
-// Tests mismatched response sequence numbers. A wrong sequence number is interpreted as a previous
-// retransmission and just ignored so we should be able to recover.
-TEST_F(UdpConnectTest, WrongSequenceRecovery) {
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(QueryPacket(1, 0));
-    mock_socket_->AddReceive(QueryPacket(0, 0));
-
-    mock_socket_->ExpectSend(InitPacket(0, kProtocolVersion, kHostMaxPacketSize));
-    mock_socket_->AddReceive(InitPacket(1, kProtocolVersion, 1024));
-    mock_socket_->AddReceive(InitPacket(0, kProtocolVersion, 1024));
-
-    EXPECT_TRUE(UdpConnect());
-}
-
-// Tests mismatched response IDs. This should also be interpreted as a retransmission and ignored.
-TEST_F(UdpConnectTest, WrongIdRecovery) {
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(FastbootPacket(0));
-    mock_socket_->AddReceive(QueryPacket(0, 0));
-
-    mock_socket_->ExpectSend(InitPacket(0, kProtocolVersion, kHostMaxPacketSize));
-    mock_socket_->AddReceive(FastbootPacket(0));
-    mock_socket_->AddReceive(InitPacket(0, kProtocolVersion, 1024));
-
-    EXPECT_TRUE(UdpConnect());
-}
-
-// Tests an invalid query response. Query responses must have at least 2 bytes of data.
-TEST_F(UdpConnectTest, InvalidQueryResponseFailure) {
-    std::string error;
-
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(QueryPacket(0));
-
-    EXPECT_FALSE(UdpConnect(&error));
-    EXPECT_EQ("invalid query response from target", error);
-
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(QueryPacket(0) + std::string{0x00});
-
-    EXPECT_FALSE(UdpConnect(&error));
-    EXPECT_EQ("invalid query response from target", error);
-}
-
-// Tests an invalid initialization response. Max packet size must be at least 512 bytes.
-TEST_F(UdpConnectTest, InvalidInitResponseFailure) {
-    std::string error;
-
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(QueryPacket(0, 0));
-    mock_socket_->ExpectSend(InitPacket(0, kProtocolVersion, kHostMaxPacketSize));
-    mock_socket_->AddReceive(InitPacket(0, kProtocolVersion, 511));
-
-    EXPECT_FALSE(UdpConnect(&error));
-    EXPECT_EQ("target reported invalid packet size 511", error);
-
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(QueryPacket(0, 0));
-    mock_socket_->ExpectSend(InitPacket(0, kProtocolVersion, kHostMaxPacketSize));
-    mock_socket_->AddReceive(InitPacket(0, 0, 1024));
-
-    EXPECT_FALSE(UdpConnect(&error));
-    EXPECT_EQ("target reported invalid protocol version 0", error);
-}
-
-TEST_F(UdpConnectTest, ErrorResponseFailure) {
-    std::string error;
-
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(ErrorPacket(0, "error1"));
-
-    EXPECT_FALSE(UdpConnect(&error));
-    EXPECT_NE(std::string::npos, error.find("error1"));
-
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(QueryPacket(0, 0));
-    mock_socket_->ExpectSend(InitPacket(0, kProtocolVersion, kHostMaxPacketSize));
-    mock_socket_->AddReceive(ErrorPacket(0, "error2"));
-
-    EXPECT_FALSE(UdpConnect(&error));
-    EXPECT_NE(std::string::npos, error.find("error2"));
-}
-
-// Tests an error response with continuation flag.
-TEST_F(UdpConnectTest, ErrorContinuationFailure) {
-    std::string error;
-
-    mock_socket_->ExpectSend(QueryPacket(0));
-    mock_socket_->AddReceive(ErrorPacket(0, "error1", kFlagContinuation));
-    mock_socket_->ExpectSend(ErrorPacket(1));
-    mock_socket_->AddReceive(ErrorPacket(1, " ", kFlagContinuation));
-    mock_socket_->ExpectSend(ErrorPacket(2));
-    mock_socket_->AddReceive(ErrorPacket(2, "error2"));
-
-    EXPECT_FALSE(UdpConnect(&error));
-    EXPECT_NE(std::string::npos, error.find("error1 error2"));
-}
-
-// Fixture class to test UDP Transport read/write functionality.
-class UdpTest : public ::testing::Test {
-  public:
-    void SetUp() override {
-        // Create |transport_| starting at sequence 0 with 512 byte max packet size. Tests can call
-        // InitializeTransport() again to change settings.
-        ASSERT_TRUE(InitializeTransport(0, 512));
-    }
-
-    // Sets up |mock_socket_| to correctly initialize the protocol and creates |transport_|. This
-    // can be called multiple times in a test if needed.
-    bool InitializeTransport(uint16_t starting_sequence, int device_max_packet_size = 512) {
-        mock_socket_ = new SocketMock;
-        mock_socket_->ExpectSend(QueryPacket(0));
-        mock_socket_->AddReceive(QueryPacket(0, starting_sequence));
-        mock_socket_->ExpectSend(
-                InitPacket(starting_sequence, kProtocolVersion, kHostMaxPacketSize));
-        mock_socket_->AddReceive(
-                InitPacket(starting_sequence, kProtocolVersion, device_max_packet_size));
-
-        std::string error;
-        transport_ = Connect(std::unique_ptr<Socket>(mock_socket_), &error);
-        return transport_ != nullptr && error.empty();
-    }
-
-    // Writes |message| to |transport_|, returns true on success.
-    bool Write(const std::string& message) {
-        return transport_->Write(message.data(), message.length()) ==
-                static_cast<ssize_t>(message.length());
-    }
-
-    // Reads from |transport_|, returns true if it matches |message|.
-    bool Read(const std::string& message) {
-        std::string buffer(message.length(), '\0');
-        return transport_->Read(&buffer[0], buffer.length()) ==
-                static_cast<ssize_t>(message.length()) && buffer == message;
-    }
-
-  protected:
-    // |mock_socket_| is a raw pointer here because we transfer ownership to |transport_| but we
-    // need to retain a pointer to set send and receive expectations.
-    SocketMock* mock_socket_ = nullptr;
-    std::unique_ptr<Transport> transport_;
-};
-
-// Tests sequence behavior with various starting sequence numbers.
-TEST_F(UdpTest, SequenceIncrementCheck) {
-    for (uint16_t seq : kTestSequenceNumbers) {
-        ASSERT_TRUE(InitializeTransport(seq));
-
-        for (int i = 0; i < 10; ++i) {
-            mock_socket_->ExpectSend(FastbootPacket(++seq, "foo"));
-            mock_socket_->AddReceive(FastbootPacket(seq, ""));
-            mock_socket_->ExpectSend(FastbootPacket(++seq, ""));
-            mock_socket_->AddReceive(FastbootPacket(seq, "bar"));
-
-            EXPECT_TRUE(Write("foo"));
-            EXPECT_TRUE(Read("bar"));
-        }
-    }
-}
-
-// Tests sending and receiving a few small packets.
-TEST_F(UdpTest, ReadAndWriteSmallPackets) {
-    mock_socket_->ExpectSend(FastbootPacket(1, "foo"));
-    mock_socket_->AddReceive(FastbootPacket(1, ""));
-    mock_socket_->ExpectSend(FastbootPacket(2, ""));
-    mock_socket_->AddReceive(FastbootPacket(2, "bar"));
-
-    EXPECT_TRUE(Write("foo"));
-    EXPECT_TRUE(Read("bar"));
-
-    mock_socket_->ExpectSend(FastbootPacket(3, "12345 67890"));
-    mock_socket_->AddReceive(FastbootPacket(3));
-    mock_socket_->ExpectSend(FastbootPacket(4, "\x01\x02\x03\x04\x05"));
-    mock_socket_->AddReceive(FastbootPacket(4));
-
-    EXPECT_TRUE(Write("12345 67890"));
-    EXPECT_TRUE(Write("\x01\x02\x03\x04\x05"));
-
-    // Reads are done by sending empty packets.
-    mock_socket_->ExpectSend(FastbootPacket(5));
-    mock_socket_->AddReceive(FastbootPacket(5, "foo bar baz"));
-    mock_socket_->ExpectSend(FastbootPacket(6));
-    mock_socket_->AddReceive(FastbootPacket(6, "\x01\x02\x03\x04\x05"));
-
-    EXPECT_TRUE(Read("foo bar baz"));
-    EXPECT_TRUE(Read("\x01\x02\x03\x04\x05"));
-}
-
-TEST_F(UdpTest, ResponseTimeoutFailure) {
-    for (int i = 0; i < kMaxTransmissionAttempts; ++i) {
-        mock_socket_->ExpectSend(FastbootPacket(1, "foo"));
-        mock_socket_->AddReceiveTimeout();
-    }
-
-    EXPECT_FALSE(Write("foo"));
-}
-
-TEST_F(UdpTest, ResponseReceiveFailure) {
-    mock_socket_->ExpectSend(FastbootPacket(1, "foo"));
-    mock_socket_->AddReceiveFailure();
-
-    EXPECT_FALSE(Write("foo"));
-}
-
-TEST_F(UdpTest, ResponseTimeoutRecovery) {
-    for (int i = 0; i < kMaxTransmissionAttempts - 1; ++i) {
-        mock_socket_->ExpectSend(FastbootPacket(1, "foo"));
-        mock_socket_->AddReceiveTimeout();
-    }
-    mock_socket_->ExpectSend(FastbootPacket(1, "foo"));
-    mock_socket_->AddReceive(FastbootPacket(1, ""));
-
-    EXPECT_TRUE(Write("foo"));
-}
-
-// Tests continuation packets for various max packet sizes.
-// The important part of this test is that regardless of what kind of packet fragmentation happens
-// at the socket layer, a single call to Transport::Read() and Transport::Write() is all the
-// fastboot code needs to do.
-TEST_F(UdpTest, ContinuationPackets) {
-    for (uint16_t max_packet_size : {512, 1024, 1200}) {
-        ASSERT_TRUE(InitializeTransport(0, max_packet_size));
-
-        // Initialize the data we want to send. Use (size - 4) to leave room for the header.
-        size_t max_data_size = max_packet_size - 4;
-        std::string data(max_data_size * 3, '\0');
-        for (size_t i = 0; i < data.length(); ++i) {
-            data[i] = i;
-        }
-        std::string chunks[] = {data.substr(0, max_data_size),
-                                data.substr(max_data_size, max_data_size),
-                                data.substr(max_data_size * 2, max_data_size)};
-
-        // Write data: split into 3 UDP packets, each of which will be ACKed.
-        mock_socket_->ExpectSend(FastbootPacket(1, chunks[0], kFlagContinuation));
-        mock_socket_->AddReceive(FastbootPacket(1));
-        mock_socket_->ExpectSend(FastbootPacket(2, chunks[1], kFlagContinuation));
-        mock_socket_->AddReceive(FastbootPacket(2));
-        mock_socket_->ExpectSend(FastbootPacket(3, chunks[2]));
-        mock_socket_->AddReceive(FastbootPacket(3));
-        EXPECT_TRUE(Write(data));
-
-        // Same thing for reading the data.
-        mock_socket_->ExpectSend(FastbootPacket(4));
-        mock_socket_->AddReceive(FastbootPacket(4, chunks[0], kFlagContinuation));
-        mock_socket_->ExpectSend(FastbootPacket(5));
-        mock_socket_->AddReceive(FastbootPacket(5, chunks[1], kFlagContinuation));
-        mock_socket_->ExpectSend(FastbootPacket(6));
-        mock_socket_->AddReceive(FastbootPacket(6, chunks[2]));
-        EXPECT_TRUE(Read(data));
-    }
-}
-
-// Tests that the continuation bit is respected even if the packet isn't max size.
-TEST_F(UdpTest, SmallContinuationPackets) {
-    mock_socket_->ExpectSend(FastbootPacket(1));
-    mock_socket_->AddReceive(FastbootPacket(1, "foo", kFlagContinuation));
-    mock_socket_->ExpectSend(FastbootPacket(2));
-    mock_socket_->AddReceive(FastbootPacket(2, "bar"));
-
-    EXPECT_TRUE(Read("foobar"));
-}
-
-// Tests receiving an error packet mid-continuation.
-TEST_F(UdpTest, ContinuationPacketError) {
-    mock_socket_->ExpectSend(FastbootPacket(1));
-    mock_socket_->AddReceive(FastbootPacket(1, "foo", kFlagContinuation));
-    mock_socket_->ExpectSend(FastbootPacket(2));
-    mock_socket_->AddReceive(ErrorPacket(2, "test error"));
-
-    EXPECT_FALSE(Read("foo"));
-}
-
-// Tests timeout during a continuation sequence.
-TEST_F(UdpTest, ContinuationTimeoutRecovery) {
-    mock_socket_->ExpectSend(FastbootPacket(1));
-    mock_socket_->AddReceive(FastbootPacket(1, "foo", kFlagContinuation));
-    mock_socket_->ExpectSend(FastbootPacket(2));
-    mock_socket_->AddReceiveTimeout();
-    mock_socket_->ExpectSend(FastbootPacket(2));
-    mock_socket_->AddReceive(FastbootPacket(2, "bar"));
-
-    EXPECT_TRUE(Read("foobar"));
-}
-
-// Tests read overflow returns -1 to indicate the failure.
-TEST_F(UdpTest, MultipleReadPacket) {
-    mock_socket_->ExpectSend(FastbootPacket(1));
-    mock_socket_->AddReceive(FastbootPacket(1, "foobarbaz"));
-
-    char buffer[3];
-    EXPECT_EQ(-1, transport_->Read(buffer, 3));
-}
-
-// Tests that packets arriving out-of-order are ignored.
-TEST_F(UdpTest, IgnoreOutOfOrderPackets) {
-    mock_socket_->ExpectSend(FastbootPacket(1));
-    mock_socket_->AddReceive(FastbootPacket(0, "sequence too low"));
-    mock_socket_->AddReceive(FastbootPacket(2, "sequence too high"));
-    mock_socket_->AddReceive(QueryPacket(1));
-    mock_socket_->AddReceive(FastbootPacket(1, "correct"));
-
-    EXPECT_TRUE(Read("correct"));
-}
-
-// Tests that an error response with the correct sequence number causes immediate failure.
-TEST_F(UdpTest, ErrorResponse) {
-    // Error packets with the wrong sequence number should be ignored like any other packet.
-    mock_socket_->ExpectSend(FastbootPacket(1, "foo"));
-    mock_socket_->AddReceive(ErrorPacket(0, "ignored error"));
-    mock_socket_->AddReceive(FastbootPacket(1));
-
-    EXPECT_TRUE(Write("foo"));
-
-    // Error packets with the correct sequence should abort immediately without retransmission.
-    mock_socket_->ExpectSend(FastbootPacket(2, "foo"));
-    mock_socket_->AddReceive(ErrorPacket(2, "test error"));
-
-    EXPECT_FALSE(Write("foo"));
-}
-
-// Tests that attempting to use a closed transport returns -1 without making any socket calls.
-TEST_F(UdpTest, CloseTransport) {
-    char buffer[32];
-    EXPECT_EQ(0, transport_->Close());
-    EXPECT_EQ(-1, transport_->Write("foo", 3));
-    EXPECT_EQ(-1, transport_->Read(buffer, sizeof(buffer)));
-}
diff --git a/fastboot/usb.h b/fastboot/usb.h
deleted file mode 100644
index 4acf12d..0000000
--- a/fastboot/usb.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#ifndef _USB_H_
-#define _USB_H_
-
-#include "transport.h"
-
-struct usb_ifc_info {
-        /* from device descriptor */
-    unsigned short dev_vendor;
-    unsigned short dev_product;
-
-    unsigned char dev_class;
-    unsigned char dev_subclass;
-    unsigned char dev_protocol;
-
-    unsigned char ifc_class;
-    unsigned char ifc_subclass;
-    unsigned char ifc_protocol;
-
-    unsigned char has_bulk_in;
-    unsigned char has_bulk_out;
-
-    unsigned char writable;
-
-    char serial_number[256];
-    char device_path[256];
-};
-
-typedef int (*ifc_match_func)(usb_ifc_info *ifc);
-
-Transport* usb_open(ifc_match_func callback);
-
-#endif
diff --git a/fastboot/usb_linux.cpp b/fastboot/usb_linux.cpp
deleted file mode 100644
index 02ffcd9..0000000
--- a/fastboot/usb_linux.cpp
+++ /dev/null
@@ -1,498 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include <ctype.h>
-#include <dirent.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <pthread.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/ioctl.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <unistd.h>
-
-#include <linux/usbdevice_fs.h>
-#include <linux/version.h>
-#include <linux/usb/ch9.h>
-
-#include <memory>
-
-#include "fastboot.h"
-#include "usb.h"
-
-#define MAX_RETRIES 5
-
-/* Timeout in seconds for usb_wait_for_disconnect.
- * It doesn't usually take long for a device to disconnect (almost always
- * under 2 seconds) but we'll time out after 3 seconds just in case.
- */
-#define WAIT_FOR_DISCONNECT_TIMEOUT  3
-
-#ifdef TRACE_USB
-#define DBG1(x...) fprintf(stderr, x)
-#define DBG(x...) fprintf(stderr, x)
-#else
-#define DBG(x...)
-#define DBG1(x...)
-#endif
-
-// Kernels before 3.3 have a 16KiB transfer limit. That limit was replaced
-// with a 16MiB global limit in 3.3, but each URB submitted required a
-// contiguous kernel allocation, so you would get ENOMEM if you tried to
-// send something larger than the biggest available contiguous kernel
-// memory region. 256KiB contiguous allocations are generally not reliable
-// on a device kernel that has been running for a while fragmenting its
-// memory, but that shouldn't be a problem for fastboot on the host.
-// In 3.6, the contiguous buffer limit was removed by allocating multiple
-// 16KiB chunks and having the USB driver stitch them back together while
-// transmitting using a scatter-gather list, so 256KiB bulk transfers should
-// be reliable.
-// 256KiB seems to work, but 1MiB bulk transfers lock up my z620 with a 3.13
-// kernel.
-#define MAX_USBFS_BULK_SIZE (16 * 1024)
-
-struct usb_handle
-{
-    char fname[64];
-    int desc;
-    unsigned char ep_in;
-    unsigned char ep_out;
-};
-
-class LinuxUsbTransport : public Transport {
-  public:
-    LinuxUsbTransport(std::unique_ptr<usb_handle> handle) : handle_(std::move(handle)) {}
-    ~LinuxUsbTransport() override = default;
-
-    ssize_t Read(void* data, size_t len) override;
-    ssize_t Write(const void* data, size_t len) override;
-    int Close() override;
-    int WaitForDisconnect() override;
-
-  private:
-    std::unique_ptr<usb_handle> handle_;
-
-    DISALLOW_COPY_AND_ASSIGN(LinuxUsbTransport);
-};
-
-/* True if name isn't a valid name for a USB device in /sys/bus/usb/devices.
- * Device names are made up of numbers, dots, and dashes, e.g., '7-1.5'.
- * We reject interfaces (e.g., '7-1.5:1.0') and host controllers (e.g. 'usb1').
- * The name must also start with a digit, to disallow '.' and '..'
- */
-static inline int badname(const char *name)
-{
-    if (!isdigit(*name))
-      return 1;
-    while(*++name) {
-        if(!isdigit(*name) && *name != '.' && *name != '-')
-            return 1;
-    }
-    return 0;
-}
-
-static int check(void *_desc, int len, unsigned type, int size)
-{
-    struct usb_descriptor_header *hdr = (struct usb_descriptor_header *)_desc;
-
-    if(len < size) return -1;
-    if(hdr->bLength < size) return -1;
-    if(hdr->bLength > len) return -1;
-    if(hdr->bDescriptorType != type) return -1;
-
-    return 0;
-}
-
-static int filter_usb_device(char* sysfs_name,
-                             char *ptr, int len, int writable,
-                             ifc_match_func callback,
-                             int *ept_in_id, int *ept_out_id, int *ifc_id)
-{
-    struct usb_device_descriptor *dev;
-    struct usb_config_descriptor *cfg;
-    struct usb_interface_descriptor *ifc;
-    struct usb_endpoint_descriptor *ept;
-    struct usb_ifc_info info;
-
-    int in, out;
-    unsigned i;
-    unsigned e;
-    
-    if (check(ptr, len, USB_DT_DEVICE, USB_DT_DEVICE_SIZE))
-        return -1;
-    dev = (struct usb_device_descriptor *)ptr;
-    len -= dev->bLength;
-    ptr += dev->bLength;
-
-    if (check(ptr, len, USB_DT_CONFIG, USB_DT_CONFIG_SIZE))
-        return -1;
-    cfg = (struct usb_config_descriptor *)ptr;
-    len -= cfg->bLength;
-    ptr += cfg->bLength;
-
-    info.dev_vendor = dev->idVendor;
-    info.dev_product = dev->idProduct;
-    info.dev_class = dev->bDeviceClass;
-    info.dev_subclass = dev->bDeviceSubClass;
-    info.dev_protocol = dev->bDeviceProtocol;
-    info.writable = writable;
-
-    snprintf(info.device_path, sizeof(info.device_path), "usb:%s", sysfs_name);
-
-    /* Read device serial number (if there is one).
-     * We read the serial number from sysfs, since it's faster and more
-     * reliable than issuing a control pipe read, and also won't
-     * cause problems for devices which don't like getting descriptor
-     * requests while they're in the middle of flashing.
-     */
-    info.serial_number[0] = '\0';
-    if (dev->iSerialNumber) {
-        char path[80];
-        int fd;
-
-        snprintf(path, sizeof(path),
-                 "/sys/bus/usb/devices/%s/serial", sysfs_name);
-        path[sizeof(path) - 1] = '\0';
-
-        fd = open(path, O_RDONLY);
-        if (fd >= 0) {
-            int chars_read = read(fd, info.serial_number,
-                                  sizeof(info.serial_number) - 1);
-            close(fd);
-
-            if (chars_read <= 0)
-                info.serial_number[0] = '\0';
-            else if (info.serial_number[chars_read - 1] == '\n') {
-                // strip trailing newline
-                info.serial_number[chars_read - 1] = '\0';
-            }
-        }
-    }
-
-    for(i = 0; i < cfg->bNumInterfaces; i++) {
-
-        while (len > 0) {
-	        struct usb_descriptor_header *hdr = (struct usb_descriptor_header *)ptr;
-            if (check(hdr, len, USB_DT_INTERFACE, USB_DT_INTERFACE_SIZE) == 0)
-                break;
-            len -= hdr->bLength;
-            ptr += hdr->bLength;
-        }
-
-        if (len <= 0)
-            return -1;
-
-        ifc = (struct usb_interface_descriptor *)ptr;
-        len -= ifc->bLength;
-        ptr += ifc->bLength;
-
-        in = -1;
-        out = -1;
-        info.ifc_class = ifc->bInterfaceClass;
-        info.ifc_subclass = ifc->bInterfaceSubClass;
-        info.ifc_protocol = ifc->bInterfaceProtocol;
-
-        for(e = 0; e < ifc->bNumEndpoints; e++) {
-            while (len > 0) {
-	            struct usb_descriptor_header *hdr = (struct usb_descriptor_header *)ptr;
-                if (check(hdr, len, USB_DT_ENDPOINT, USB_DT_ENDPOINT_SIZE) == 0)
-                    break;
-                len -= hdr->bLength;
-                ptr += hdr->bLength;
-            }
-            if (len < 0) {
-                break;
-            }
-
-            ept = (struct usb_endpoint_descriptor *)ptr;
-            len -= ept->bLength;
-            ptr += ept->bLength;
-
-            if((ept->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK) != USB_ENDPOINT_XFER_BULK)
-                continue;
-
-            if(ept->bEndpointAddress & USB_ENDPOINT_DIR_MASK) {
-                in = ept->bEndpointAddress;
-            } else {
-                out = ept->bEndpointAddress;
-            }
-
-            // For USB 3.0 devices skip the SS Endpoint Companion descriptor
-            if (check((struct usb_descriptor_hdr *)ptr, len,
-                      USB_DT_SS_ENDPOINT_COMP, USB_DT_SS_EP_COMP_SIZE) == 0) {
-                len -= USB_DT_SS_EP_COMP_SIZE;
-                ptr += USB_DT_SS_EP_COMP_SIZE;
-            }
-        }
-
-        info.has_bulk_in = (in != -1);
-        info.has_bulk_out = (out != -1);
-
-        if(callback(&info) == 0) {
-            *ept_in_id = in;
-            *ept_out_id = out;
-            *ifc_id = ifc->bInterfaceNumber;
-            return 0;
-        }
-    }
-
-    return -1;
-}
-
-static int read_sysfs_string(const char *sysfs_name, const char *sysfs_node,
-                             char* buf, int bufsize)
-{
-    char path[80];
-    int fd, n;
-
-    snprintf(path, sizeof(path),
-             "/sys/bus/usb/devices/%s/%s", sysfs_name, sysfs_node);
-    path[sizeof(path) - 1] = '\0';
-
-    fd = open(path, O_RDONLY);
-    if (fd < 0)
-        return -1;
-
-    n = read(fd, buf, bufsize - 1);
-    close(fd);
-
-    if (n < 0)
-        return -1;
-
-    buf[n] = '\0';
-
-    return n;
-}
-
-static int read_sysfs_number(const char *sysfs_name, const char *sysfs_node)
-{
-    char buf[16];
-    int value;
-
-    if (read_sysfs_string(sysfs_name, sysfs_node, buf, sizeof(buf)) < 0)
-        return -1;
-
-    if (sscanf(buf, "%d", &value) != 1)
-        return -1;
-
-    return value;
-}
-
-/* Given the name of a USB device in sysfs, get the name for the same
- * device in devfs. Returns 0 for success, -1 for failure.
- */
-static int convert_to_devfs_name(const char* sysfs_name,
-                                 char* devname, int devname_size)
-{
-    int busnum, devnum;
-
-    busnum = read_sysfs_number(sysfs_name, "busnum");
-    if (busnum < 0)
-        return -1;
-
-    devnum = read_sysfs_number(sysfs_name, "devnum");
-    if (devnum < 0)
-        return -1;
-
-    snprintf(devname, devname_size, "/dev/bus/usb/%03d/%03d", busnum, devnum);
-    return 0;
-}
-
-static std::unique_ptr<usb_handle> find_usb_device(const char* base, ifc_match_func callback)
-{
-    std::unique_ptr<usb_handle> usb;
-    char devname[64];
-    char desc[1024];
-    int n, in, out, ifc;
-
-    DIR *busdir;
-    struct dirent *de;
-    int fd;
-    int writable;
-
-    busdir = opendir(base);
-    if (busdir == 0) return 0;
-
-    while ((de = readdir(busdir)) && (usb == nullptr)) {
-        if (badname(de->d_name)) continue;
-
-        if (!convert_to_devfs_name(de->d_name, devname, sizeof(devname))) {
-
-//            DBG("[ scanning %s ]\n", devname);
-            writable = 1;
-            if ((fd = open(devname, O_RDWR)) < 0) {
-                // Check if we have read-only access, so we can give a helpful
-                // diagnostic like "adb devices" does.
-                writable = 0;
-                if ((fd = open(devname, O_RDONLY)) < 0) {
-                    continue;
-                }
-            }
-
-            n = read(fd, desc, sizeof(desc));
-
-            if (filter_usb_device(de->d_name, desc, n, writable, callback, &in, &out, &ifc) == 0) {
-                usb.reset(new usb_handle());
-                strcpy(usb->fname, devname);
-                usb->ep_in = in;
-                usb->ep_out = out;
-                usb->desc = fd;
-
-                n = ioctl(fd, USBDEVFS_CLAIMINTERFACE, &ifc);
-                if (n != 0) {
-                    close(fd);
-                    usb.reset();
-                    continue;
-                }
-            } else {
-                close(fd);
-            }
-        }
-    }
-    closedir(busdir);
-
-    return usb;
-}
-
-ssize_t LinuxUsbTransport::Write(const void* _data, size_t len)
-{
-    unsigned char *data = (unsigned char*) _data;
-    unsigned count = 0;
-    struct usbdevfs_bulktransfer bulk;
-    int n;
-
-    if (handle_->ep_out == 0 || handle_->desc == -1) {
-        return -1;
-    }
-
-    do {
-        int xfer;
-        xfer = (len > MAX_USBFS_BULK_SIZE) ? MAX_USBFS_BULK_SIZE : len;
-
-        bulk.ep = handle_->ep_out;
-        bulk.len = xfer;
-        bulk.data = data;
-        bulk.timeout = 0;
-
-        n = ioctl(handle_->desc, USBDEVFS_BULK, &bulk);
-        if(n != xfer) {
-            DBG("ERROR: n = %d, errno = %d (%s)\n",
-                n, errno, strerror(errno));
-            return -1;
-        }
-
-        count += xfer;
-        len -= xfer;
-        data += xfer;
-    } while(len > 0);
-
-    return count;
-}
-
-ssize_t LinuxUsbTransport::Read(void* _data, size_t len)
-{
-    unsigned char *data = (unsigned char*) _data;
-    unsigned count = 0;
-    struct usbdevfs_bulktransfer bulk;
-    int n, retry;
-
-    if (handle_->ep_in == 0 || handle_->desc == -1) {
-        return -1;
-    }
-
-    while(len > 0) {
-        int xfer = (len > MAX_USBFS_BULK_SIZE) ? MAX_USBFS_BULK_SIZE : len;
-
-        bulk.ep = handle_->ep_in;
-        bulk.len = xfer;
-        bulk.data = data;
-        bulk.timeout = 0;
-        retry = 0;
-
-        do{
-           DBG("[ usb read %d fd = %d], fname=%s\n", xfer, handle_->desc, handle_->fname);
-           n = ioctl(handle_->desc, USBDEVFS_BULK, &bulk);
-           DBG("[ usb read %d ] = %d, fname=%s, Retry %d \n", xfer, n, handle_->fname, retry);
-
-           if( n < 0 ) {
-            DBG1("ERROR: n = %d, errno = %d (%s)\n",n, errno, strerror(errno));
-            if ( ++retry > MAX_RETRIES ) return -1;
-            sleep( 1 );
-           }
-        }
-        while( n < 0 );
-
-        count += n;
-        len -= n;
-        data += n;
-
-        if(n < xfer) {
-            break;
-        }
-    }
-
-    return count;
-}
-
-int LinuxUsbTransport::Close()
-{
-    int fd;
-
-    fd = handle_->desc;
-    handle_->desc = -1;
-    if(fd >= 0) {
-        close(fd);
-        DBG("[ usb closed %d ]\n", fd);
-    }
-
-    return 0;
-}
-
-Transport* usb_open(ifc_match_func callback)
-{
-    std::unique_ptr<usb_handle> handle = find_usb_device("/sys/bus/usb/devices", callback);
-    return handle ? new LinuxUsbTransport(std::move(handle)) : nullptr;
-}
-
-/* Wait for the system to notice the device is gone, so that a subsequent
- * fastboot command won't try to access the device before it's rebooted.
- * Returns 0 for success, -1 for timeout.
- */
-int LinuxUsbTransport::WaitForDisconnect()
-{
-  double deadline = now() + WAIT_FOR_DISCONNECT_TIMEOUT;
-  while (now() < deadline) {
-    if (access(handle_->fname, F_OK))
-      return 0;
-    usleep(50000);
-  }
-  return -1;
-}
diff --git a/fastboot/usb_osx.cpp b/fastboot/usb_osx.cpp
deleted file mode 100644
index ee5d575..0000000
--- a/fastboot/usb_osx.cpp
+++ /dev/null
@@ -1,593 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include <inttypes.h>
-#include <stdio.h>
-#include <CoreFoundation/CoreFoundation.h>
-#include <IOKit/IOKitLib.h>
-#include <IOKit/IOCFPlugIn.h>
-#include <IOKit/usb/IOUSBLib.h>
-#include <IOKit/IOMessage.h>
-#include <mach/mach_port.h>
-
-#include <memory>
-
-#include "usb.h"
-
-
-/*
- * Internal helper functions and associated definitions.
- */
-
-#if TRACE_USB
-#define WARN(x...) fprintf(stderr, x)
-#else
-#define WARN(x...)
-#endif
-
-#define ERR(x...) fprintf(stderr, "ERROR: " x)
-
-/** An open usb device */
-struct usb_handle
-{
-    int success;
-    ifc_match_func callback;
-    usb_ifc_info info;
-
-    UInt8 bulkIn;
-    UInt8 bulkOut;
-    IOUSBInterfaceInterface190 **interface;
-    unsigned int zero_mask;
-};
-
-class OsxUsbTransport : public Transport {
-  public:
-    OsxUsbTransport(std::unique_ptr<usb_handle> handle) : handle_(std::move(handle)) {}
-    ~OsxUsbTransport() override = default;
-
-    ssize_t Read(void* data, size_t len) override;
-    ssize_t Write(const void* data, size_t len) override;
-    int Close() override;
-
-  private:
-    std::unique_ptr<usb_handle> handle_;
-
-    DISALLOW_COPY_AND_ASSIGN(OsxUsbTransport);
-};
-
-/** Try out all the interfaces and see if there's a match. Returns 0 on
- * success, -1 on failure. */
-static int try_interfaces(IOUSBDeviceInterface182 **dev, usb_handle *handle) {
-    IOReturn kr;
-    IOUSBFindInterfaceRequest request;
-    io_iterator_t iterator;
-    io_service_t usbInterface;
-    IOCFPlugInInterface **plugInInterface;
-    IOUSBInterfaceInterface190 **interface = NULL;
-    HRESULT result;
-    SInt32 score;
-    UInt8 interfaceNumEndpoints;
-    UInt8 configuration;
-
-    // Placing the constant KIOUSBFindInterfaceDontCare into the following
-    // fields of the IOUSBFindInterfaceRequest structure will allow us to
-    // find all of the interfaces
-    request.bInterfaceClass = kIOUSBFindInterfaceDontCare;
-    request.bInterfaceSubClass = kIOUSBFindInterfaceDontCare;
-    request.bInterfaceProtocol = kIOUSBFindInterfaceDontCare;
-    request.bAlternateSetting = kIOUSBFindInterfaceDontCare;
-
-    // SetConfiguration will kill an existing UMS connection, so let's
-    // not do this if not necessary.
-    configuration = 0;
-    (*dev)->GetConfiguration(dev, &configuration);
-    if (configuration != 1)
-        (*dev)->SetConfiguration(dev, 1);
-
-    // Get an iterator for the interfaces on the device
-    kr = (*dev)->CreateInterfaceIterator(dev, &request, &iterator);
-
-    if (kr != 0) {
-        ERR("Couldn't create a device interface iterator: (%08x)\n", kr);
-        return -1;
-    }
-
-    while ((usbInterface = IOIteratorNext(iterator))) {
-        // Create an intermediate plugin
-        kr = IOCreatePlugInInterfaceForService(
-                usbInterface,
-                kIOUSBInterfaceUserClientTypeID,
-                kIOCFPlugInInterfaceID,
-                &plugInInterface,
-                &score);
-
-        // No longer need the usbInterface object now that we have the plugin
-        (void) IOObjectRelease(usbInterface);
-
-        if ((kr != 0) || (!plugInInterface)) {
-            WARN("Unable to create plugin (%08x)\n", kr);
-            continue;
-        }
-
-        // Now create the interface interface for the interface
-        result = (*plugInInterface)->QueryInterface(
-                plugInInterface,
-                CFUUIDGetUUIDBytes(kIOUSBInterfaceInterfaceID),
-                (LPVOID*) &interface);
-
-        // No longer need the intermediate plugin
-        (*plugInInterface)->Release(plugInInterface);
-
-        if (result || !interface) {
-            ERR("Couldn't create interface interface: (%08x)\n",
-               (unsigned int) result);
-            // continue so we can try the next interface
-            continue;
-        }
-
-        /*
-         * Now open the interface. This will cause the pipes
-         * associated with the endpoints in the interface descriptor
-         * to be instantiated.
-         */
-
-        /*
-         * TODO: Earlier comments here indicated that it was a bad
-         * idea to just open any interface, because opening "mass
-         * storage endpoints" is bad. However, the only way to find
-         * out if an interface does bulk in or out is to open it, and
-         * the framework in this application wants to be told about
-         * bulk in / out before deciding whether it actually wants to
-         * use the interface. Maybe something needs to be done about
-         * this situation.
-         */
-
-        kr = (*interface)->USBInterfaceOpen(interface);
-
-        if (kr != 0) {
-            WARN("Could not open interface: (%08x)\n", kr);
-            (void) (*interface)->Release(interface);
-            // continue so we can try the next interface
-            continue;
-        }
-
-        // Get the number of endpoints associated with this interface.
-        kr = (*interface)->GetNumEndpoints(interface, &interfaceNumEndpoints);
-
-        if (kr != 0) {
-            ERR("Unable to get number of endpoints: (%08x)\n", kr);
-            goto next_interface;
-        }
-
-        // Get interface class, subclass and protocol
-        if ((*interface)->GetInterfaceClass(interface, &handle->info.ifc_class) != 0 ||
-            (*interface)->GetInterfaceSubClass(interface, &handle->info.ifc_subclass) != 0 ||
-            (*interface)->GetInterfaceProtocol(interface, &handle->info.ifc_protocol) != 0)
-        {
-            ERR("Unable to get interface class, subclass and protocol\n");
-            goto next_interface;
-        }
-
-        handle->info.has_bulk_in = 0;
-        handle->info.has_bulk_out = 0;
-
-        // Iterate over the endpoints for this interface and see if there
-        // are any that do bulk in/out.
-        for (UInt8 endpoint = 1; endpoint <= interfaceNumEndpoints; endpoint++) {
-            UInt8   transferType;
-            UInt16  maxPacketSize;
-            UInt8   interval;
-            UInt8   number;
-            UInt8   direction;
-
-            kr = (*interface)->GetPipeProperties(interface, endpoint,
-                    &direction,
-                    &number, &transferType, &maxPacketSize, &interval);
-
-            if (kr == 0) {
-                if (transferType != kUSBBulk) {
-                    continue;
-                }
-
-                if (direction == kUSBIn) {
-                    handle->info.has_bulk_in = 1;
-                    handle->bulkIn = endpoint;
-                } else if (direction == kUSBOut) {
-                    handle->info.has_bulk_out = 1;
-                    handle->bulkOut = endpoint;
-                }
-
-                if (handle->info.ifc_protocol == 0x01) {
-                    handle->zero_mask = maxPacketSize - 1;
-                }
-            } else {
-                ERR("could not get pipe properties for endpoint %u (%08x)\n", endpoint, kr);
-            }
-
-            if (handle->info.has_bulk_in && handle->info.has_bulk_out) {
-                break;
-            }
-        }
-
-        if (handle->callback(&handle->info) == 0) {
-            handle->interface = interface;
-            handle->success = 1;
-
-            /*
-             * Clear both the endpoints, because it has been observed
-             * that the Mac may otherwise (incorrectly) start out with
-             * them in bad state.
-             */
-
-            if (handle->info.has_bulk_in) {
-                kr = (*interface)->ClearPipeStallBothEnds(interface,
-                        handle->bulkIn);
-                if (kr != 0) {
-                    ERR("could not clear input pipe; result %x, ignoring...\n", kr);
-                }
-            }
-
-            if (handle->info.has_bulk_out) {
-                kr = (*interface)->ClearPipeStallBothEnds(interface,
-                        handle->bulkOut);
-                if (kr != 0) {
-                    ERR("could not clear output pipe; result %x, ignoring....\n", kr);
-                }
-            }
-
-            return 0;
-        }
-
-next_interface:
-        (*interface)->USBInterfaceClose(interface);
-        (*interface)->Release(interface);
-    }
-
-    return 0;
-}
-
-/** Try out the given device and see if there's a match. Returns 0 on
- * success, -1 on failure.
- */
-static int try_device(io_service_t device, usb_handle *handle) {
-    kern_return_t kr;
-    IOCFPlugInInterface **plugin = NULL;
-    IOUSBDeviceInterface182 **dev = NULL;
-    SInt32 score;
-    HRESULT result;
-    UInt8 serialIndex;
-    UInt32 locationId;
-
-    // Create an intermediate plugin.
-    kr = IOCreatePlugInInterfaceForService(device,
-            kIOUSBDeviceUserClientTypeID,
-            kIOCFPlugInInterfaceID,
-            &plugin, &score);
-
-    if ((kr != 0) || (plugin == NULL)) {
-        ERR("Unable to create a plug-in (%08x)\n", kr);
-        goto error;
-    }
-
-    // Now create the device interface.
-    result = (*plugin)->QueryInterface(plugin,
-            CFUUIDGetUUIDBytes(kIOUSBDeviceInterfaceID), (LPVOID*) &dev);
-    if ((result != 0) || (dev == NULL)) {
-        ERR("Couldn't create a device interface (%08x)\n", (int) result);
-        goto error;
-    }
-
-    /*
-     * We don't need the intermediate interface after the device interface
-     * is created.
-     */
-    IODestroyPlugInInterface(plugin);
-
-    // So, we have a device, finally. Grab its vitals.
-
-
-    kr = (*dev)->USBDeviceOpen(dev);
-    if (kr != 0) {
-        WARN("USBDeviceOpen");
-        goto out;
-    }
-
-    kr = (*dev)->GetDeviceVendor(dev, &handle->info.dev_vendor);
-    if (kr != 0) {
-        ERR("GetDeviceVendor");
-        goto error;
-    }
-
-    kr = (*dev)->GetDeviceProduct(dev, &handle->info.dev_product);
-    if (kr != 0) {
-        ERR("GetDeviceProduct");
-        goto error;
-    }
-
-    kr = (*dev)->GetDeviceClass(dev, &handle->info.dev_class);
-    if (kr != 0) {
-        ERR("GetDeviceClass");
-        goto error;
-    }
-
-    kr = (*dev)->GetDeviceSubClass(dev, &handle->info.dev_subclass);
-    if (kr != 0) {
-        ERR("GetDeviceSubClass");
-        goto error;
-    }
-
-    kr = (*dev)->GetDeviceProtocol(dev, &handle->info.dev_protocol);
-    if (kr != 0) {
-        ERR("GetDeviceProtocol");
-        goto error;
-    }
-
-    kr = (*dev)->GetLocationID(dev, &locationId);
-    if (kr != 0) {
-        ERR("GetLocationId");
-        goto error;
-    }
-    snprintf(handle->info.device_path, sizeof(handle->info.device_path),
-             "usb:%" PRIu32 "X", (unsigned int)locationId);
-
-    kr = (*dev)->USBGetSerialNumberStringIndex(dev, &serialIndex);
-
-    if (serialIndex > 0) {
-        IOUSBDevRequest req;
-        UInt16  buffer[256];
-
-        req.bmRequestType = USBmakebmRequestType(kUSBIn, kUSBStandard, kUSBDevice);
-        req.bRequest = kUSBRqGetDescriptor;
-        req.wValue = (kUSBStringDesc << 8) | serialIndex;
-        //language ID (en-us) for serial number string
-        req.wIndex = 0x0409;
-        req.pData = buffer;
-        req.wLength = sizeof(buffer);
-        kr = (*dev)->DeviceRequest(dev, &req);
-
-        if (kr == kIOReturnSuccess && req.wLenDone > 0) {
-            int i, count;
-
-            // skip first word, and copy the rest to the serial string, changing shorts to bytes.
-            count = (req.wLenDone - 1) / 2;
-            for (i = 0; i < count; i++)
-              handle->info.serial_number[i] = buffer[i + 1];
-            handle->info.serial_number[i] = 0;
-        }
-    } else {
-        // device has no serial number
-        handle->info.serial_number[0] = 0;
-    }
-    handle->info.writable = 1;
-
-    if (try_interfaces(dev, handle)) {
-        goto error;
-    }
-
-    out:
-
-    (*dev)->USBDeviceClose(dev);
-    (*dev)->Release(dev);
-    return 0;
-
-    error:
-
-    if (dev != NULL) {
-        (*dev)->USBDeviceClose(dev);
-        (*dev)->Release(dev);
-    }
-
-    return -1;
-}
-
-
-/** Initializes the USB system. Returns 0 on success, -1 on error. */
-static int init_usb(ifc_match_func callback, std::unique_ptr<usb_handle>* handle) {
-    int ret = -1;
-    CFMutableDictionaryRef matchingDict;
-    kern_return_t result;
-    io_iterator_t iterator;
-    usb_handle h;
-
-    h.success = 0;
-    h.callback = callback;
-
-    /*
-     * Create our matching dictionary to find appropriate devices.
-     * IOServiceAddMatchingNotification consumes the reference, so we
-     * do not need to release it.
-     */
-    matchingDict = IOServiceMatching(kIOUSBDeviceClassName);
-
-    if (matchingDict == NULL) {
-        ERR("Couldn't create USB matching dictionary.\n");
-        return -1;
-    }
-
-    result = IOServiceGetMatchingServices(
-            kIOMasterPortDefault, matchingDict, &iterator);
-
-    if (result != 0) {
-        ERR("Could not create iterator.");
-        return -1;
-    }
-
-    for (;;) {
-        if (! IOIteratorIsValid(iterator)) {
-            /*
-             * Apple documentation advises resetting the iterator if
-             * it should become invalid during iteration.
-             */
-            IOIteratorReset(iterator);
-            continue;
-        }
-
-        io_service_t device = IOIteratorNext(iterator);
-
-        if (device == 0) {
-            break;
-        }
-
-        if (try_device(device, &h) != 0) {
-            IOObjectRelease(device);
-            ret = -1;
-            break;
-        }
-
-        if (h.success) {
-            handle->reset(new usb_handle);
-            memcpy(handle->get(), &h, sizeof(usb_handle));
-            ret = 0;
-            break;
-        }
-
-        IOObjectRelease(device);
-    }
-
-    IOObjectRelease(iterator);
-
-    return ret;
-}
-
-
-
-/*
- * Definitions of this file's public functions.
- */
-
-Transport* usb_open(ifc_match_func callback) {
-    std::unique_ptr<usb_handle> handle;
-
-    if (init_usb(callback, &handle) < 0) {
-        /* Something went wrong initializing USB. */
-        return nullptr;
-    }
-
-    return new OsxUsbTransport(std::move(handle));
-}
-
-int OsxUsbTransport::Close() {
-    /* TODO: Something better here? */
-    return 0;
-}
-
-ssize_t OsxUsbTransport::Read(void* data, size_t len) {
-    IOReturn result;
-    UInt32 numBytes = len;
-
-    if (len == 0) {
-        return 0;
-    }
-
-    if (handle_ == nullptr) {
-        return -1;
-    }
-
-    if (handle_->interface == nullptr) {
-        ERR("usb_read interface was null\n");
-        return -1;
-    }
-
-    if (handle_->bulkIn == 0) {
-        ERR("bulkIn endpoint not assigned\n");
-        return -1;
-    }
-
-    result = (*handle_->interface)->ReadPipe(handle_->interface, handle_->bulkIn, data, &numBytes);
-
-    if (result == 0) {
-        return (int) numBytes;
-    } else {
-        ERR("usb_read failed with status %x\n", result);
-    }
-
-    return -1;
-}
-
-ssize_t OsxUsbTransport::Write(const void* data, size_t len) {
-    IOReturn result;
-
-    if (len == 0) {
-        return 0;
-    }
-
-    if (handle_ == NULL) {
-        return -1;
-    }
-
-    if (handle_->interface == NULL) {
-        ERR("usb_write interface was null\n");
-        return -1;
-    }
-
-    if (handle_->bulkOut == 0) {
-        ERR("bulkOut endpoint not assigned\n");
-        return -1;
-    }
-
-#if 0
-    result = (*handle_->interface)->WritePipe(
-            handle_->interface, handle_->bulkOut, (void *)data, len);
-#else
-    /* Attempt to work around crashes in the USB driver that may be caused
-     * by trying to write too much data at once.  The kernel IOCopyMapper
-     * panics if a single iovmAlloc needs more than half of its mapper pages.
-     */
-    const int maxLenToSend = 1048576; // 1 MiB
-    int lenRemaining = len;
-    result = 0;
-    while (lenRemaining > 0) {
-        int lenToSend = lenRemaining > maxLenToSend
-            ? maxLenToSend : lenRemaining;
-
-        result = (*handle_->interface)->WritePipe(
-                handle_->interface, handle_->bulkOut, (void *)data, lenToSend);
-        if (result != 0) break;
-
-        lenRemaining -= lenToSend;
-        data = (const char*)data + lenToSend;
-    }
-#endif
-
-    #if 0
-    if ((result == 0) && (handle_->zero_mask)) {
-        /* we need 0-markers and our transfer */
-        if(!(len & handle_->zero_mask)) {
-            result = (*handle_->interface)->WritePipe(
-                    handle_->interface, handle_->bulkOut, (void *)data, 0);
-        }
-    }
-    #endif
-
-    if (result != 0) {
-        ERR("usb_write failed with status %x\n", result);
-        return -1;
-    }
-
-    return len;
-}
diff --git a/fastboot/usb_windows.cpp b/fastboot/usb_windows.cpp
deleted file mode 100644
index 1cdeb32..0000000
--- a/fastboot/usb_windows.cpp
+++ /dev/null
@@ -1,370 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include <windows.h>
-#include <winerror.h>
-#include <errno.h>
-#include <usb100.h>
-#include <adb_api.h>
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <memory>
-#include <string>
-
-#include "usb.h"
-
-//#define TRACE_USB 1
-#if TRACE_USB
-#define DBG(x...) fprintf(stderr, x)
-#else
-#define DBG(x...)
-#endif
-
-#define MAX_USBFS_BULK_SIZE (1024 * 1024)
-
-/** Structure usb_handle describes our connection to the usb device via
-  AdbWinApi.dll. This structure is returned from usb_open() routine and
-  is expected in each subsequent call that is accessing the device.
-*/
-struct usb_handle {
-    /// Handle to USB interface
-    ADBAPIHANDLE  adb_interface;
-
-    /// Handle to USB read pipe (endpoint)
-    ADBAPIHANDLE  adb_read_pipe;
-
-    /// Handle to USB write pipe (endpoint)
-    ADBAPIHANDLE  adb_write_pipe;
-
-    /// Interface name
-    std::string interface_name;
-};
-
-class WindowsUsbTransport : public Transport {
-  public:
-    WindowsUsbTransport(std::unique_ptr<usb_handle> handle) : handle_(std::move(handle)) {}
-    ~WindowsUsbTransport() override = default;
-
-    ssize_t Read(void* data, size_t len) override;
-    ssize_t Write(const void* data, size_t len) override;
-    int Close() override;
-
-  private:
-    std::unique_ptr<usb_handle> handle_;
-
-    DISALLOW_COPY_AND_ASSIGN(WindowsUsbTransport);
-};
-
-/// Class ID assigned to the device by androidusb.sys
-static const GUID usb_class_id = ANDROID_USB_CLASS_ID;
-
-/// Checks if interface (device) matches certain criteria
-int recognized_device(usb_handle* handle, ifc_match_func callback);
-
-/// Opens usb interface (device) by interface (device) name.
-std::unique_ptr<usb_handle> do_usb_open(const wchar_t* interface_name);
-
-/// Cleans up opened usb handle
-void usb_cleanup_handle(usb_handle* handle);
-
-/// Cleans up (but don't close) opened usb handle
-void usb_kick(usb_handle* handle);
-
-
-std::unique_ptr<usb_handle> do_usb_open(const wchar_t* interface_name) {
-    // Allocate our handle
-    std::unique_ptr<usb_handle> ret(new usb_handle);
-
-    // Create interface.
-    ret->adb_interface = AdbCreateInterfaceByName(interface_name);
-
-    if (nullptr == ret->adb_interface) {
-        errno = GetLastError();
-        return nullptr;
-    }
-
-    // Open read pipe (endpoint)
-    ret->adb_read_pipe =
-        AdbOpenDefaultBulkReadEndpoint(ret->adb_interface,
-                                   AdbOpenAccessTypeReadWrite,
-                                   AdbOpenSharingModeReadWrite);
-    if (nullptr != ret->adb_read_pipe) {
-        // Open write pipe (endpoint)
-        ret->adb_write_pipe =
-            AdbOpenDefaultBulkWriteEndpoint(ret->adb_interface,
-                                      AdbOpenAccessTypeReadWrite,
-                                      AdbOpenSharingModeReadWrite);
-        if (nullptr != ret->adb_write_pipe) {
-            // Save interface name
-            unsigned long name_len = 0;
-
-            // First get expected name length
-            AdbGetInterfaceName(ret->adb_interface,
-                          nullptr,
-                          &name_len,
-                          true);
-            if (0 != name_len) {
-                // Now save the name
-                ret->interface_name.resize(name_len);
-                if (AdbGetInterfaceName(ret->adb_interface,
-                              &ret->interface_name[0],
-                              &name_len,
-                              true)) {
-                    // We're done at this point
-                    return ret;
-                }
-            }
-        }
-    }
-
-    // Something went wrong.
-    errno = GetLastError();
-    usb_cleanup_handle(ret.get());
-    SetLastError(errno);
-
-    return nullptr;
-}
-
-ssize_t WindowsUsbTransport::Write(const void* data, size_t len) {
-    unsigned long time_out = 5000;
-    unsigned long written = 0;
-    unsigned count = 0;
-    int ret;
-
-    DBG("usb_write %d\n", len);
-    if (nullptr != handle_) {
-        // Perform write
-        while(len > 0) {
-            int xfer = (len > MAX_USBFS_BULK_SIZE) ? MAX_USBFS_BULK_SIZE : len;
-            ret = AdbWriteEndpointSync(handle_->adb_write_pipe, const_cast<void*>(data), xfer,
-                                       &written, time_out);
-            errno = GetLastError();
-            DBG("AdbWriteEndpointSync returned %d, errno: %d\n", ret, errno);
-            if (ret == 0) {
-                // assume ERROR_INVALID_HANDLE indicates we are disconnected
-                if (errno == ERROR_INVALID_HANDLE)
-                usb_kick(handle_.get());
-                return -1;
-            }
-
-            count += written;
-            len -= written;
-            data = (const char *)data + written;
-
-            if (len == 0)
-                return count;
-        }
-    } else {
-        DBG("usb_write NULL handle\n");
-        SetLastError(ERROR_INVALID_HANDLE);
-    }
-
-    DBG("usb_write failed: %d\n", errno);
-
-    return -1;
-}
-
-ssize_t WindowsUsbTransport::Read(void* data, size_t len) {
-    unsigned long time_out = 0;
-    unsigned long read = 0;
-    int ret;
-
-    DBG("usb_read %d\n", len);
-    if (nullptr != handle_) {
-        while (1) {
-            int xfer = (len > MAX_USBFS_BULK_SIZE) ? MAX_USBFS_BULK_SIZE : len;
-
-            ret = AdbReadEndpointSync(handle_->adb_read_pipe, data, xfer, &read, time_out);
-            errno = GetLastError();
-            DBG("usb_read got: %ld, expected: %d, errno: %d\n", read, xfer, errno);
-            if (ret) {
-                return read;
-            } else {
-                // assume ERROR_INVALID_HANDLE indicates we are disconnected
-                if (errno == ERROR_INVALID_HANDLE)
-                    usb_kick(handle_.get());
-                break;
-            }
-            // else we timed out - try again
-        }
-    } else {
-        DBG("usb_read NULL handle\n");
-        SetLastError(ERROR_INVALID_HANDLE);
-    }
-
-    DBG("usb_read failed: %d\n", errno);
-
-    return -1;
-}
-
-void usb_cleanup_handle(usb_handle* handle) {
-    if (NULL != handle) {
-        if (NULL != handle->adb_write_pipe)
-            AdbCloseHandle(handle->adb_write_pipe);
-        if (NULL != handle->adb_read_pipe)
-            AdbCloseHandle(handle->adb_read_pipe);
-        if (NULL != handle->adb_interface)
-            AdbCloseHandle(handle->adb_interface);
-
-        handle->interface_name.clear();
-        handle->adb_write_pipe = NULL;
-        handle->adb_read_pipe = NULL;
-        handle->adb_interface = NULL;
-    }
-}
-
-void usb_kick(usb_handle* handle) {
-    if (NULL != handle) {
-        usb_cleanup_handle(handle);
-    } else {
-        SetLastError(ERROR_INVALID_HANDLE);
-        errno = ERROR_INVALID_HANDLE;
-    }
-}
-
-int WindowsUsbTransport::Close() {
-    DBG("usb_close\n");
-
-    if (nullptr != handle_) {
-        // Cleanup handle
-        usb_cleanup_handle(handle_.get());
-        handle_.reset();
-    }
-
-    return 0;
-}
-
-int recognized_device(usb_handle* handle, ifc_match_func callback) {
-    struct usb_ifc_info info;
-    USB_DEVICE_DESCRIPTOR device_desc;
-    USB_INTERFACE_DESCRIPTOR interf_desc;
-
-    if (NULL == handle)
-        return 0;
-
-    // Check vendor and product id first
-    if (!AdbGetUsbDeviceDescriptor(handle->adb_interface,
-                                 &device_desc)) {
-        return 0;
-    }
-
-    // Then check interface properties
-    if (!AdbGetUsbInterfaceDescriptor(handle->adb_interface,
-                                    &interf_desc)) {
-        return 0;
-    }
-
-    // Must have two endpoints
-    if (2 != interf_desc.bNumEndpoints) {
-        return 0;
-    }
-
-    info.dev_vendor = device_desc.idVendor;
-    info.dev_product = device_desc.idProduct;
-    info.dev_class = device_desc.bDeviceClass;
-    info.dev_subclass = device_desc.bDeviceSubClass;
-    info.dev_protocol = device_desc.bDeviceProtocol;
-    info.ifc_class = interf_desc.bInterfaceClass;
-    info.ifc_subclass = interf_desc.bInterfaceSubClass;
-    info.ifc_protocol = interf_desc.bInterfaceProtocol;
-    info.writable = 1;
-
-    // read serial number (if there is one)
-    unsigned long serial_number_len = sizeof(info.serial_number);
-    if (!AdbGetSerialNumber(handle->adb_interface, info.serial_number,
-                    &serial_number_len, true)) {
-        info.serial_number[0] = 0;
-    }
-
-    info.device_path[0] = 0;
-
-    if (callback(&info) == 0) {
-        return 1;
-    }
-
-    return 0;
-}
-
-static std::unique_ptr<usb_handle> find_usb_device(ifc_match_func callback) {
-    std::unique_ptr<usb_handle> handle;
-    char entry_buffer[2048];
-    char interf_name[2048];
-    AdbInterfaceInfo* next_interface = (AdbInterfaceInfo*)(&entry_buffer[0]);
-    unsigned long entry_buffer_size = sizeof(entry_buffer);
-    char* copy_name;
-
-    // Enumerate all present and active interfaces.
-    ADBAPIHANDLE enum_handle =
-        AdbEnumInterfaces(usb_class_id, true, true, true);
-
-    if (NULL == enum_handle)
-        return NULL;
-
-    while (AdbNextInterface(enum_handle, next_interface, &entry_buffer_size)) {
-        // TODO(vchtchetkine): FIXME - temp hack converting wchar_t into char.
-        // It would be better to change AdbNextInterface so it will return
-        // interface name as single char string.
-        const wchar_t* wchar_name = next_interface->device_name;
-        for(copy_name = interf_name;
-                L'\0' != *wchar_name;
-                wchar_name++, copy_name++) {
-            *copy_name = (char)(*wchar_name);
-        }
-        *copy_name = '\0';
-
-        handle = do_usb_open(next_interface->device_name);
-        if (NULL != handle) {
-            // Lets see if this interface (device) belongs to us
-            if (recognized_device(handle.get(), callback)) {
-                // found it!
-                break;
-            } else {
-                usb_cleanup_handle(handle.get());
-                handle.reset();
-            }
-        }
-
-        entry_buffer_size = sizeof(entry_buffer);
-    }
-
-    AdbCloseHandle(enum_handle);
-    return handle;
-}
-
-Transport* usb_open(ifc_match_func callback)
-{
-    std::unique_ptr<usb_handle> handle = find_usb_device(callback);
-    return handle ? new WindowsUsbTransport(std::move(handle)) : nullptr;
-}
-
-// called from fastboot.c
-void sleep(int seconds)
-{
-    Sleep(seconds * 1000);
-}
diff --git a/fastboot/usbtest.cpp b/fastboot/usbtest.cpp
deleted file mode 100644
index 9423c6d..0000000
--- a/fastboot/usbtest.cpp
+++ /dev/null
@@ -1,212 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-
-#include <sys/time.h>
-
-#include "usb.h"
-
-static unsigned arg_size = 4096;
-static unsigned arg_count = 4096;
-
-long long NOW(void)
-{
-    struct timeval tv;
-    gettimeofday(&tv, 0);
-
-    return (((long long) tv.tv_sec) * ((long long) 1000000)) +
-        (((long long) tv.tv_usec));
-}
-
-int printifc(usb_ifc_info *info)
-{
-    printf("dev: csp=%02x/%02x/%02x v=%04x p=%04x  ",
-           info->dev_class, info->dev_subclass, info->dev_protocol,
-           info->dev_vendor, info->dev_product);
-    printf("ifc: csp=%02x/%02x/%02x%s%s\n",
-           info->ifc_class, info->ifc_subclass, info->ifc_protocol,
-           info->has_bulk_in ? " in" : "",
-           info->has_bulk_out ? " out" : "");
-    return -1;
-}
-
-int match_null(usb_ifc_info *info)
-{
-    if(info->dev_vendor != 0x18d1) return -1;
-    if(info->ifc_class != 0xff) return -1;
-    if(info->ifc_subclass != 0xfe) return -1;
-    if(info->ifc_protocol != 0x01) return -1;
-    return 0;
-}
-
-int match_zero(usb_ifc_info *info)
-{
-    if(info->dev_vendor != 0x18d1) return -1;
-    if(info->ifc_class != 0xff) return -1;
-    if(info->ifc_subclass != 0xfe) return -1;
-    if(info->ifc_protocol != 0x02) return -1;
-    return 0;
-}
-
-int match_loop(usb_ifc_info *info)
-{
-    if(info->dev_vendor != 0x18d1) return -1;
-    if(info->ifc_class != 0xff) return -1;
-    if(info->ifc_subclass != 0xfe) return -1;
-    if(info->ifc_protocol != 0x03) return -1;
-    return 0;
-}
-
-int test_null(Transport* usb)
-{
-    unsigned i;
-    unsigned char buf[4096];
-    memset(buf, 0xee, 4096);
-    long long t0, t1;
-
-    t0 = NOW();
-    for (i = 0; i < arg_count; i++) {
-        if (usb->Write(buf, arg_size) != static_cast<int>(arg_size)) {
-            fprintf(stderr,"write failed (%s)\n", strerror(errno));
-            return -1;
-        }
-    }
-    t1 = NOW();
-    fprintf(stderr,"%d bytes in %lld uS\n", arg_count * arg_size, (t1 - t0));
-    return 0;
-}
-
-int test_zero(Transport* usb)
-{
-    unsigned i;
-    unsigned char buf[4096];
-    long long t0, t1;
-
-    t0 = NOW();
-    for (i = 0; i < arg_count; i++) {
-        if (usb->Read(buf, arg_size) != static_cast<int>(arg_size)) {
-            fprintf(stderr,"read failed (%s)\n", strerror(errno));
-            return -1;
-        }
-    }
-    t1 = NOW();
-    fprintf(stderr,"%d bytes in %lld uS\n", arg_count * arg_size, (t1 - t0));
-    return 0;
-}
-
-struct
-{
-    const char *cmd;
-    ifc_match_func match;
-    int (*test)(Transport* usb);
-    const char *help;
-} tests[] = {
-    { "list", printifc,   NULL,      "list interfaces" },
-    { "send", match_null, test_null, "send to null interface" },
-    { "recv", match_zero, test_zero, "recv from zero interface" },
-    { "loop", match_loop, NULL,      "exercise loopback interface" },
-    { NULL, NULL, NULL, NULL },
-};
-
-int usage(void)
-{
-    int i;
-
-    fprintf(stderr,"usage: usbtest <testname>\n\navailable tests:\n");
-    for(i = 0; tests[i].cmd; i++) {
-        fprintf(stderr," %-8s %s\n", tests[i].cmd, tests[i].help);
-    }
-    return -1;
-}
-
-int process_args(int argc, char **argv)
-{
-    while(argc-- > 0) {
-        char *arg = *argv++;
-        if(!strncmp(arg,"count=",6)) {
-            arg_count = atoi(arg + 6);
-        } else if(!strncmp(arg,"size=",5)) {
-            arg_size = atoi(arg + 5);
-        } else {
-            fprintf(stderr,"unknown argument: %s\n", arg);
-            return -1;
-        }
-    }
-
-    if(arg_count == 0) {
-        fprintf(stderr,"count may not be zero\n");
-        return -1;
-    }
-
-    if(arg_size > 4096) {
-        fprintf(stderr,"size may not be greater than 4096\n");
-        return -1;
-    }
-
-    return 0;
-}
-
-int main(int argc, char **argv)
-{
-    Transport* usb;
-    int i;
-
-    if(argc < 2)
-        return usage();
-
-    if(argc > 2) {
-        if(process_args(argc - 2, argv + 2))
-            return -1;
-    }
-
-    for(i = 0; tests[i].cmd; i++) {
-        if(!strcmp(argv[1], tests[i].cmd)) {
-            usb = usb_open(tests[i].match);
-            if(tests[i].test) {
-                if(usb == 0) {
-                    fprintf(stderr,"usbtest: %s: could not find interface\n",
-                            tests[i].cmd);
-                    return -1;
-                }
-                if(tests[i].test(usb)) {
-                    fprintf(stderr,"usbtest: %s: FAIL\n", tests[i].cmd);
-                    return -1;
-                } else {
-                    fprintf(stderr,"usbtest: %s: OKAY\n", tests[i].cmd);
-                }
-            }
-            return 0;
-        }
-    }
-
-    return usage();
-}
diff --git a/fastboot/util.cpp b/fastboot/util.cpp
deleted file mode 100644
index f2bbd34..0000000
--- a/fastboot/util.cpp
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include <stdarg.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include <sys/time.h>
-
-#include "fastboot.h"
-
-double now()
-{
-    struct timeval tv;
-    gettimeofday(&tv, NULL);
-    return (double)tv.tv_sec + (double)tv.tv_usec / 1000000;
-}
-
-char *mkmsg(const char *fmt, ...)
-{
-    char buf[256];
-    char *s;
-    va_list ap;
-
-    va_start(ap, fmt);
-    vsprintf(buf, fmt, ap);
-    va_end(ap);
-
-    s = strdup(buf);
-    if (s == 0) die("out of memory");
-    return s;
-}
-
-void die(const char *fmt, ...)
-{
-    va_list ap;
-    va_start(ap, fmt);
-    fprintf(stderr,"error: ");
-    vfprintf(stderr, fmt, ap);
-    fprintf(stderr,"\n");
-    va_end(ap);
-    exit(1);
-}
diff --git a/fastboot/util_linux.cpp b/fastboot/util_linux.cpp
deleted file mode 100644
index b788199..0000000
--- a/fastboot/util_linux.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "fastboot.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <limits.h>
-
-void get_my_path(char *path)
-{
-    char proc[64];
-    char *x;
-
-    sprintf(proc, "/proc/%d/exe", getpid());
-    int err = readlink(proc, path, PATH_MAX - 1);
-
-    if(err <= 0) {
-        path[0] = 0;
-    } else {
-        path[err] = 0;
-        x = strrchr(path,'/');
-        if(x) x[1] = 0;
-    }
-}
diff --git a/fastboot/util_osx.cpp b/fastboot/util_osx.cpp
deleted file mode 100644
index ae0b024..0000000
--- a/fastboot/util_osx.cpp
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "fastboot.h"
-
-#import <Carbon/Carbon.h>
-#include <unistd.h>
-
-void get_my_path(char s[PATH_MAX])
-{
-    CFBundleRef mainBundle = CFBundleGetMainBundle();
-    CFURLRef executableURL = CFBundleCopyExecutableURL(mainBundle);
-    CFStringRef executablePathString = CFURLCopyFileSystemPath(executableURL, kCFURLPOSIXPathStyle);
-    CFRelease(executableURL);
-
-    CFStringGetFileSystemRepresentation(executablePathString, s, PATH_MAX-1);
-    CFRelease(executablePathString);
-
-	char *x;
-    x = strrchr(s, '/');
-    if(x) x[1] = 0;
-}
-
-
diff --git a/fastboot/util_windows.cpp b/fastboot/util_windows.cpp
deleted file mode 100644
index ec52f39..0000000
--- a/fastboot/util_windows.cpp
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- *  * Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- *  * Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in
- *    the documentation and/or other materials provided with the
- *    distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
- * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
- * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
- * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
- * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
- * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
-#include "fastboot.h"
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <unistd.h>
-#include <limits.h>
-
-#include <windows.h>
-
-void get_my_path(char exe[PATH_MAX])
-{
-	char*  r;
-
-	GetModuleFileName( NULL, exe, PATH_MAX-1 );
-	exe[PATH_MAX-1] = 0;
-	r = strrchr( exe, '\\' );
-	if (r)
-		*r = 0;
-}
-
-- 
2.5.0

