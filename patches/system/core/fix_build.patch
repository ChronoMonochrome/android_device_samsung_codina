diff --git a/adb/Android.mk b/adb/Android.mk
index eabb2e2..75d33fc 100644
--- a/adb/Android.mk
+++ b/adb/Android.mk
@@ -212,7 +212,7 @@ LOCAL_SRC_FILES := \
 LOCAL_SANITIZE := $(adb_target_sanitize)
 LOCAL_STATIC_LIBRARIES := libadbd libcrypto_utils_static libcrypto_static
 LOCAL_SHARED_LIBRARIES := liblog libbase libcutils
-include $(BUILD_NATIVE_TEST)
+#include $(BUILD_NATIVE_TEST)
 
 # libdiagnose_usb
 # =========================================================
@@ -225,7 +225,7 @@ LOCAL_SRC_FILES := diagnose_usb.cpp
 # Even though we're building a static library (and thus there's no link step for
 # this to take effect), this adds the includes to our path.
 LOCAL_STATIC_LIBRARIES := libbase
-include $(BUILD_HOST_STATIC_LIBRARY)
+#include $(BUILD_HOST_STATIC_LIBRARY)
 
 # adb_test
 # =========================================================
@@ -269,7 +269,7 @@ LOCAL_STATIC_LIBRARIES_windows := AdbWinApi
 
 LOCAL_MULTILIB := first
 
-include $(BUILD_HOST_NATIVE_TEST)
+#include $(BUILD_HOST_NATIVE_TEST)
 
 # adb device tracker (used by ddms) test tool
 # =========================================================
@@ -286,7 +286,7 @@ LOCAL_SANITIZE := $(adb_host_sanitize)
 LOCAL_SHARED_LIBRARIES := libbase
 LOCAL_STATIC_LIBRARIES := libadb libcrypto_utils_static libcrypto_static libcutils
 LOCAL_LDLIBS += -lrt -ldl -lpthread
-include $(BUILD_HOST_EXECUTABLE)
+#include $(BUILD_HOST_EXECUTABLE)
 endif
 
 # adb host tool
@@ -353,7 +353,7 @@ LOCAL_CXX_STL := libc++_static
 # will violate ODR
 LOCAL_SHARED_LIBRARIES :=
 
-include $(BUILD_HOST_EXECUTABLE)
+#include $(BUILD_HOST_EXECUTABLE)
 
 $(call dist-for-goals,dist_files sdk win_sdk,$(LOCAL_BUILT_MODULE))
 ifdef HOST_CROSS_OS
diff --git a/adb/transport.cpp b/adb/transport.cpp
index c31f655..1e6f608 100644
--- a/adb/transport.cpp
+++ b/adb/transport.cpp
@@ -747,6 +747,16 @@ void atransport::Kick() {
     }
 }
 
+// Short help text must be a single line, and will look something like:
+//   no permissions (reason); see <URL>
+std::string UsbNoPermissionsShortHelpText_() {
+    std::string help_text = "no permissions";
+
+    return android::base::StringPrintf("%s", help_text.c_str());
+}
+
+
+
 const std::string atransport::connection_state_name() const {
     switch (connection_state) {
         case kCsOffline: return "offline";
@@ -754,7 +764,7 @@ const std::string atransport::connection_state_name() const {
         case kCsDevice: return "device";
         case kCsHost: return "host";
         case kCsRecovery: return "recovery";
-        case kCsNoPerm: return UsbNoPermissionsShortHelpText();
+        case kCsNoPerm: return UsbNoPermissionsShortHelpText_();
         case kCsSideload: return "sideload";
         case kCsUnauthorized: return "unauthorized";
         default: return "unknown";
diff --git a/adb/transport_local.cpp b/adb/transport_local.cpp
index 1f5a258..9626d4e 100644
--- a/adb/transport_local.cpp
+++ b/adb/transport_local.cpp
@@ -360,12 +360,14 @@ atransport* find_emulator_transport_by_adb_port_locked(int adb_port)
     }
     return NULL;
 }
+#endif
 
 std::string getEmulatorSerialString(int console_port)
 {
     return android::base::StringPrintf("emulator-%d", console_port);
 }
 
+#if ADB_HOST
 atransport* find_emulator_transport_by_adb_port(int adb_port)
 {
     adb_mutex_lock( &local_transports_lock );
diff --git a/fastboot/Android.mk b/fastboot/Android.mk
index 728a414..3be6cf0 100644
--- a/fastboot/Android.mk
+++ b/fastboot/Android.mk
@@ -86,7 +86,7 @@ LOCAL_CXX_STL := libc++_static
 # will violate ODR
 LOCAL_SHARED_LIBRARIES :=
 
-include $(BUILD_HOST_EXECUTABLE)
+#include $(BUILD_HOST_EXECUTABLE)
 
 my_dist_files := $(LOCAL_BUILT_MODULE)
 ifneq (,$(filter linux darwin,$(HOST_OS)))
diff --git a/init/devices.cpp b/init/devices.cpp
index f4bd972..14f4c08 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -162,17 +162,6 @@ void fixup_sys_perms(const char *upath)
         chown(buf, dp->uid, dp->gid);
         chmod(buf, dp->perm);
     }
-
-    // Now fixup SELinux file labels
-    int len = snprintf(buf, sizeof(buf), "/sys%s", upath);
-    if ((len < 0) || ((size_t) len >= sizeof(buf))) {
-        // Overflow
-        return;
-    }
-    if (access(buf, F_OK) == 0) {
-        INFO("restorecon_recursive: %s\n", buf);
-        restorecon_recursive(buf);
-    }
 }
 
 static bool perm_path_matches(const char *path, struct perms_ *dp)
diff --git a/init/init.cpp b/init/init.cpp
index 0bdb7c8..7349ff0 100755
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -659,6 +659,7 @@ int main(int argc, char** argv) {
         }
     }
 
+#if 0
     // These directories were necessarily created before initial policy load
     // and therefore need their security context restored to the proper value.
     // This must happen before /dev is populated by ueventd.
@@ -667,7 +668,7 @@ int main(int argc, char** argv) {
     restorecon("/dev/socket");
     restorecon("/dev/__properties__");
     restorecon_recursive("/sys");
-
+#endif
     epoll_fd = epoll_create1(EPOLL_CLOEXEC);
     if (epoll_fd == -1) {
         ERROR("epoll_create1 failed: %s\n", strerror(errno));
diff --git a/init/property_service.cpp b/init/property_service.cpp
index aa0cf24..408622c 100644
--- a/init/property_service.cpp
+++ b/init/property_service.cpp
@@ -181,6 +181,7 @@ static int property_set_impl(const char* name, const char* value) {
     if (!is_legal_property_name(name, namelen)) return -1;
     if (valuelen >= PROP_VALUE_MAX) return -1;
 
+#if 0
     if (strcmp("selinux.reload_policy", name) == 0 && strcmp("1", value) == 0) {
         if (selinux_reload_policy() != 0) {
             ERROR("Failed to reload policy\n");
@@ -190,7 +191,7 @@ static int property_set_impl(const char* name, const char* value) {
             ERROR("Failed to restorecon_recursive %s\n", value);
         }
     }
-
+#endif
     prop_info* pi = (prop_info*) __system_property_find(name);
 
     if(pi != 0) {
