From dbadecb58da07a555086415c537440f3ffac5339 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 1 Feb 2016 20:50:19 +0700
Subject: [PATCH 12/14] remove healthd

Change-Id: I0ee5b94f9a3e3958bbfdbf184117f6eef4c69290
---
 healthd/Android.mk                     | 107 ----
 healthd/BatteryMonitor.cpp             | 567 -------------------
 healthd/BatteryMonitor.h               |  63 ---
 healthd/BatteryPropertiesRegistrar.cpp | 103 ----
 healthd/BatteryPropertiesRegistrar.h   |  49 --
 healthd/healthd.cpp                    | 392 --------------
 healthd/healthd.h                      | 127 -----
 healthd/healthd_board_default.cpp      |  31 --
 healthd/healthd_mode_android.cpp       |  62 ---
 healthd/healthd_mode_charger.cpp       | 957 ---------------------------------
 healthd/healthd_msm.h                  |  20 -
 healthd/healthd_msm_alarm.cpp          | 216 --------
 healthd/images/battery_fail.png        | Bin 1368 -> 0 bytes
 healthd/images/battery_scale.png       | Bin 463 -> 0 bytes
 14 files changed, 2694 deletions(-)
 delete mode 100644 healthd/Android.mk
 delete mode 100644 healthd/BatteryMonitor.cpp
 delete mode 100644 healthd/BatteryMonitor.h
 delete mode 100644 healthd/BatteryPropertiesRegistrar.cpp
 delete mode 100644 healthd/BatteryPropertiesRegistrar.h
 delete mode 100644 healthd/healthd.cpp
 delete mode 100644 healthd/healthd.h
 delete mode 100644 healthd/healthd_board_default.cpp
 delete mode 100644 healthd/healthd_mode_android.cpp
 delete mode 100644 healthd/healthd_mode_charger.cpp
 delete mode 100644 healthd/healthd_msm.h
 delete mode 100644 healthd/healthd_msm_alarm.cpp
 delete mode 100644 healthd/images/battery_fail.png
 delete mode 100644 healthd/images/battery_scale.png

diff --git a/healthd/Android.mk b/healthd/Android.mk
deleted file mode 100644
index 5eaff5a..0000000
--- a/healthd/Android.mk
+++ /dev/null
@@ -1,107 +0,0 @@
-# Copyright 2013 The Android Open Source Project
-
-ifneq ($(BUILD_TINY_ANDROID),true)
-
-LOCAL_PATH := $(call my-dir)
-
-include $(CLEAR_VARS)
-LOCAL_SRC_FILES := healthd_board_default.cpp healthd_msm_alarm.cpp
-LOCAL_MODULE := libhealthd.default
-LOCAL_CFLAGS := -Werror
-include $(BUILD_STATIC_LIBRARY)
-
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES := \
-	healthd.cpp \
-	healthd_mode_android.cpp \
-	BatteryMonitor.cpp \
-	BatteryPropertiesRegistrar.cpp
-
-ifeq ($(strip $(BOARD_HEALTHD_CUSTOM_CHARGER)),)
-  LOCAL_SRC_FILES += healthd_mode_charger.cpp
-else
-  LOCAL_SRC_FILES += ../../../$(BOARD_HEALTHD_CUSTOM_CHARGER)
-endif
-
-LOCAL_MODULE := healthd
-LOCAL_MODULE_TAGS := optional
-LOCAL_FORCE_STATIC_EXECUTABLE := true
-LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT_SBIN)
-LOCAL_UNSTRIPPED_PATH := $(TARGET_ROOT_OUT_SBIN_UNSTRIPPED)
-
-LOCAL_CFLAGS := -D__STDC_LIMIT_MACROS -Werror
-
-HEALTHD_CHARGER_DEFINES := RED_LED_PATH \
-    GREEN_LED_PATH \
-    BLUE_LED_PATH \
-    BACKLIGHT_PATH \
-    CHARGING_ENABLED_PATH
-
-$(foreach healthd_charger_define,$(HEALTHD_CHARGER_DEFINES), \
-  $(if $($(healthd_charger_define)), \
-    $(eval LOCAL_CFLAGS += -D$(healthd_charger_define)=\"$($(healthd_charger_define))\") \
-  ) \
-)
-
-ifeq ($(strip $(BOARD_CHARGER_DISABLE_INIT_BLANK)),true)
-LOCAL_CFLAGS += -DCHARGER_DISABLE_INIT_BLANK
-endif
-
-ifeq ($(strip $(BOARD_CHARGER_ENABLE_SUSPEND)),true)
-LOCAL_CFLAGS += -DCHARGER_ENABLE_SUSPEND
-endif
-
-ifeq ($(strip $(BOARD_CHARGER_SHOW_PERCENTAGE)),true)
-LOCAL_CFLAGS += -DCHARGER_SHOW_PERCENTAGE
-endif
-
-LOCAL_C_INCLUDES := $(call project-path-for,recovery)
-
-LOCAL_STATIC_LIBRARIES := libbatteryservice libbinder libminui libpng libz libutils libstdc++ libcutils liblog libm libc
-
-ifeq ($(strip $(BOARD_CHARGER_ENABLE_SUSPEND)),true)
-LOCAL_STATIC_LIBRARIES += libsuspend
-endif
-
-LOCAL_HAL_STATIC_LIBRARIES := libhealthd
-
-# Symlink /charger to /sbin/charger
-LOCAL_POST_INSTALL_CMD := $(hide) mkdir -p $(TARGET_ROOT_OUT) \
-    && rm -f $(TARGET_ROOT_OUT)/charger && ln -sf /sbin/charger $(TARGET_ROOT_OUT)/charger
-
-include $(BUILD_EXECUTABLE)
-
-
-define _add-charger-image
-include $$(CLEAR_VARS)
-LOCAL_MODULE := system_core_charger_$(notdir $(1))
-LOCAL_MODULE_STEM := $(notdir $(1))
-_img_modules += $$(LOCAL_MODULE)
-LOCAL_SRC_FILES := $1
-LOCAL_MODULE_TAGS := optional
-LOCAL_MODULE_CLASS := ETC
-LOCAL_MODULE_PATH := $$(TARGET_ROOT_OUT)/res/images/charger
-include $$(BUILD_PREBUILT)
-endef
-
-_img_modules :=
-ifeq ($(strip $(BOARD_HEALTHD_CUSTOM_CHARGER_RES)),)
-IMAGES_DIR := images
-else
-IMAGES_DIR := ../../../$(BOARD_HEALTHD_CUSTOM_CHARGER_RES)
-endif
-_images :=
-$(foreach _img, $(call find-subdir-subdir-files, "$(IMAGES_DIR)", "*.png"), \
-  $(eval $(call _add-charger-image,$(_img))))
-
-include $(CLEAR_VARS)
-LOCAL_MODULE := charger_res_images
-LOCAL_MODULE_TAGS := optional
-LOCAL_REQUIRED_MODULES := $(_img_modules)
-include $(BUILD_PHONY_PACKAGE)
-
-_add-charger-image :=
-_img_modules :=
-
-endif
diff --git a/healthd/BatteryMonitor.cpp b/healthd/BatteryMonitor.cpp
deleted file mode 100644
index e99f519..0000000
--- a/healthd/BatteryMonitor.cpp
+++ /dev/null
@@ -1,567 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "healthd"
-
-#include "healthd.h"
-#include "BatteryMonitor.h"
-
-#include <dirent.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <unistd.h>
-#include <batteryservice/BatteryService.h>
-#include <cutils/klog.h>
-#include <cutils/properties.h>
-#include <sys/types.h>
-#include <utils/Errors.h>
-#include <utils/String8.h>
-#include <utils/Vector.h>
-
-#define POWER_SUPPLY_SUBSYSTEM "power_supply"
-#define POWER_SUPPLY_SYSFS_PATH "/sys/class/" POWER_SUPPLY_SUBSYSTEM
-#define FAKE_BATTERY_CAPACITY 42
-#define FAKE_BATTERY_TEMPERATURE 424
-
-namespace android {
-
-struct sysfsStringEnumMap {
-    const char* s;
-    int val;
-};
-
-static int mapSysfsString(const char* str,
-                          struct sysfsStringEnumMap map[]) {
-    for (int i = 0; map[i].s; i++)
-        if (!strcmp(str, map[i].s))
-            return map[i].val;
-
-    return -1;
-}
-
-int BatteryMonitor::getBatteryStatus(const char* status) {
-    int ret;
-    struct sysfsStringEnumMap batteryStatusMap[] = {
-        { "Unknown", BATTERY_STATUS_UNKNOWN },
-        { "Charging", BATTERY_STATUS_CHARGING },
-        { "Discharging", BATTERY_STATUS_DISCHARGING },
-        { "Not charging", BATTERY_STATUS_NOT_CHARGING },
-        { "Full", BATTERY_STATUS_FULL },
-        { NULL, 0 },
-    };
-
-    ret = mapSysfsString(status, batteryStatusMap);
-    if (ret < 0) {
-        KLOG_WARNING(LOG_TAG, "Unknown battery status '%s'\n", status);
-        ret = BATTERY_STATUS_UNKNOWN;
-    }
-
-    return ret;
-}
-
-int BatteryMonitor::getBatteryHealth(const char* status) {
-    int ret;
-    struct sysfsStringEnumMap batteryHealthMap[] = {
-        { "Unknown", BATTERY_HEALTH_UNKNOWN },
-        { "Good", BATTERY_HEALTH_GOOD },
-        { "Overheat", BATTERY_HEALTH_OVERHEAT },
-        { "Dead", BATTERY_HEALTH_DEAD },
-        { "Over voltage", BATTERY_HEALTH_OVER_VOLTAGE },
-        { "Unspecified failure", BATTERY_HEALTH_UNSPECIFIED_FAILURE },
-        { "Cold", BATTERY_HEALTH_COLD },
-        { NULL, 0 },
-    };
-
-    ret = mapSysfsString(status, batteryHealthMap);
-    if (ret < 0) {
-        KLOG_WARNING(LOG_TAG, "Unknown battery health '%s'\n", status);
-        ret = BATTERY_HEALTH_UNKNOWN;
-    }
-
-    return ret;
-}
-
-int BatteryMonitor::readFromFile(const String8& path, char* buf, size_t size) {
-    char *cp = NULL;
-
-    if (path.isEmpty())
-        return -1;
-    int fd = open(path.string(), O_RDONLY, 0);
-    if (fd == -1) {
-        KLOG_ERROR(LOG_TAG, "Could not open '%s'\n", path.string());
-        return -1;
-    }
-
-    ssize_t count = TEMP_FAILURE_RETRY(read(fd, buf, size));
-    if (count > 0)
-            cp = (char *)memrchr(buf, '\n', count);
-
-    if (cp)
-        *cp = '\0';
-    else
-        buf[0] = '\0';
-
-    close(fd);
-    return count;
-}
-
-BatteryMonitor::PowerSupplyType BatteryMonitor::readPowerSupplyType(const String8& path) {
-    const int SIZE = 128;
-    char buf[SIZE];
-    int length = readFromFile(path, buf, SIZE);
-    BatteryMonitor::PowerSupplyType ret;
-    struct sysfsStringEnumMap supplyTypeMap[] = {
-            { "Unknown", ANDROID_POWER_SUPPLY_TYPE_UNKNOWN },
-            { "Battery", ANDROID_POWER_SUPPLY_TYPE_BATTERY },
-            { "UPS", ANDROID_POWER_SUPPLY_TYPE_AC },
-            { "Mains", ANDROID_POWER_SUPPLY_TYPE_AC },
-            { "USB", ANDROID_POWER_SUPPLY_TYPE_USB },
-            { "USB_DCP", ANDROID_POWER_SUPPLY_TYPE_AC },
-            { "USB_CDP", ANDROID_POWER_SUPPLY_TYPE_AC },
-            { "USB_ACA", ANDROID_POWER_SUPPLY_TYPE_AC },
-            { "Wireless", ANDROID_POWER_SUPPLY_TYPE_WIRELESS },
-            { "Wipower", ANDROID_POWER_SUPPLY_TYPE_WIRELESS },
-            { NULL, 0 },
-    };
-
-    if (length <= 0)
-        return ANDROID_POWER_SUPPLY_TYPE_UNKNOWN;
-
-    ret = (BatteryMonitor::PowerSupplyType)mapSysfsString(buf, supplyTypeMap);
-    if (ret < 0)
-        ret = ANDROID_POWER_SUPPLY_TYPE_UNKNOWN;
-
-    return ret;
-}
-
-bool BatteryMonitor::getBooleanField(const String8& path) {
-    const int SIZE = 16;
-    char buf[SIZE];
-
-    bool value = false;
-    if (readFromFile(path, buf, SIZE) > 0) {
-        if (buf[0] != '0') {
-            value = true;
-        }
-    }
-
-    return value;
-}
-
-int BatteryMonitor::getIntField(const String8& path) {
-    const int SIZE = 128;
-    char buf[SIZE];
-
-    int value = 0;
-    if (readFromFile(path, buf, SIZE) > 0) {
-        value = strtol(buf, NULL, 0);
-    }
-    return value;
-}
-
-bool BatteryMonitor::update(void) {
-    bool logthis;
-
-    props.chargerAcOnline = false;
-    props.chargerUsbOnline = false;
-    props.chargerWirelessOnline = false;
-    props.batteryStatus = BATTERY_STATUS_UNKNOWN;
-    props.batteryHealth = BATTERY_HEALTH_UNKNOWN;
-
-    if (!mHealthdConfig->batteryPresentPath.isEmpty())
-        props.batteryPresent = getBooleanField(mHealthdConfig->batteryPresentPath);
-    else
-        props.batteryPresent = mBatteryDevicePresent;
-
-    props.batteryLevel = mBatteryFixedCapacity ?
-        mBatteryFixedCapacity :
-        getIntField(mHealthdConfig->batteryCapacityPath);
-    props.batteryVoltage = getIntField(mHealthdConfig->batteryVoltagePath) / 1000;
-
-    props.batteryTemperature = mBatteryFixedTemperature ?
-        mBatteryFixedTemperature :
-        getIntField(mHealthdConfig->batteryTemperaturePath);
-
-    const int SIZE = 128;
-    char buf[SIZE];
-    String8 btech;
-
-    if (readFromFile(mHealthdConfig->batteryStatusPath, buf, SIZE) > 0)
-        props.batteryStatus = getBatteryStatus(buf);
-
-    if (readFromFile(mHealthdConfig->batteryHealthPath, buf, SIZE) > 0)
-        props.batteryHealth = getBatteryHealth(buf);
-
-    if (readFromFile(mHealthdConfig->batteryTechnologyPath, buf, SIZE) > 0)
-        props.batteryTechnology = String8(buf);
-
-    // reinitialize the mChargerNames vector everytime there is an update
-    String8 path;
-    DIR* dir = opendir(POWER_SUPPLY_SYSFS_PATH);
-    if (dir == NULL) {
-        KLOG_ERROR(LOG_TAG, "Could not open %s\n", POWER_SUPPLY_SYSFS_PATH);
-    } else {
-        struct dirent* entry;
-        // reconstruct the charger strings
-        mChargerNames.clear();
-        while ((entry = readdir(dir))) {
-            const char* name = entry->d_name;
-
-            if (!strcmp(name, ".") || !strcmp(name, ".."))
-                continue;
-
-            // Look for "type" file in each subdirectory
-            path.clear();
-            path.appendFormat("%s/%s/type", POWER_SUPPLY_SYSFS_PATH, name);
-            switch(readPowerSupplyType(path)) {
-            case ANDROID_POWER_SUPPLY_TYPE_BATTERY:
-                break;
-            default:
-                path.clear();
-                path.appendFormat("%s/%s/online", POWER_SUPPLY_SYSFS_PATH, name);
-                if (access(path.string(), R_OK) == 0) {
-                    mChargerNames.add(String8(name));
-                    if (readFromFile(path, buf, SIZE) > 0) {
-                        if (buf[0] != '0') {
-                            path.clear();
-                            path.appendFormat("%s/%s/type", POWER_SUPPLY_SYSFS_PATH,
-                                              name);
-                            switch(readPowerSupplyType(path)) {
-                            case ANDROID_POWER_SUPPLY_TYPE_AC:
-                                props.chargerAcOnline = true;
-                                break;
-                            case ANDROID_POWER_SUPPLY_TYPE_USB:
-                                props.chargerUsbOnline = true;
-                                break;
-                            case ANDROID_POWER_SUPPLY_TYPE_WIRELESS:
-                                props.chargerWirelessOnline = true;
-                                break;
-                            default:
-                                KLOG_WARNING(LOG_TAG, "%s: Unknown power supply type\n",
-                                             name);
-                            }
-                        }
-                    }
-                }
-                break;
-            } //switch
-        } //while
-        closedir(dir);
-    }//else
-
-    logthis = !healthd_board_battery_update(&props);
-
-    if (logthis) {
-        char dmesgline[256];
-
-        if (props.batteryPresent) {
-            snprintf(dmesgline, sizeof(dmesgline),
-                 "battery l=%d v=%d t=%s%d.%d h=%d st=%d",
-                 props.batteryLevel, props.batteryVoltage,
-                 props.batteryTemperature < 0 ? "-" : "",
-                 abs(props.batteryTemperature / 10),
-                 abs(props.batteryTemperature % 10), props.batteryHealth,
-                 props.batteryStatus);
-
-            if (!mHealthdConfig->batteryCurrentNowPath.isEmpty()) {
-                int c = getIntField(mHealthdConfig->batteryCurrentNowPath);
-                char b[20];
-
-                snprintf(b, sizeof(b), " c=%d", c / 1000);
-                strlcat(dmesgline, b, sizeof(dmesgline));
-            }
-        } else {
-            snprintf(dmesgline, sizeof(dmesgline),
-                 "battery none");
-        }
-
-        KLOG_INFO(LOG_TAG, "%s chg=%s%s%s\n", dmesgline,
-                  props.chargerAcOnline ? "a" : "",
-                  props.chargerUsbOnline ? "u" : "",
-                  props.chargerWirelessOnline ? "w" : "");
-    }
-
-    healthd_mode_ops->battery_update(&props);
-    return props.chargerAcOnline | props.chargerUsbOnline |
-            props.chargerWirelessOnline;
-}
-
-status_t BatteryMonitor::getProperty(int id, struct BatteryProperty *val) {
-    status_t ret = BAD_VALUE;
-
-    val->valueInt64 = LONG_MIN;
-
-    switch(id) {
-    case BATTERY_PROP_CHARGE_COUNTER:
-        if (!mHealthdConfig->batteryChargeCounterPath.isEmpty()) {
-            val->valueInt64 =
-                getIntField(mHealthdConfig->batteryChargeCounterPath);
-            ret = NO_ERROR;
-        } else {
-            ret = NAME_NOT_FOUND;
-        }
-        break;
-
-    case BATTERY_PROP_CURRENT_NOW:
-        if (!mHealthdConfig->batteryCurrentNowPath.isEmpty()) {
-            val->valueInt64 =
-                getIntField(mHealthdConfig->batteryCurrentNowPath);
-            ret = NO_ERROR;
-        } else {
-            ret = NAME_NOT_FOUND;
-        }
-        break;
-
-    case BATTERY_PROP_CURRENT_AVG:
-        if (!mHealthdConfig->batteryCurrentAvgPath.isEmpty()) {
-            val->valueInt64 =
-                getIntField(mHealthdConfig->batteryCurrentAvgPath);
-            ret = NO_ERROR;
-        } else {
-            ret = NAME_NOT_FOUND;
-        }
-        break;
-
-    case BATTERY_PROP_CAPACITY:
-        if (!mHealthdConfig->batteryCapacityPath.isEmpty()) {
-            val->valueInt64 =
-                getIntField(mHealthdConfig->batteryCapacityPath);
-            ret = NO_ERROR;
-        } else {
-            ret = NAME_NOT_FOUND;
-        }
-        break;
-
-    case BATTERY_PROP_ENERGY_COUNTER:
-        if (mHealthdConfig->energyCounter) {
-            ret = mHealthdConfig->energyCounter(&val->valueInt64);
-        } else {
-            ret = NAME_NOT_FOUND;
-        }
-        break;
-
-    default:
-        break;
-    }
-
-    return ret;
-}
-
-void BatteryMonitor::dumpState(int fd) {
-    int v;
-    char vs[128];
-
-    snprintf(vs, sizeof(vs), "ac: %d usb: %d wireless: %d\n",
-             props.chargerAcOnline, props.chargerUsbOnline,
-             props.chargerWirelessOnline);
-    write(fd, vs, strlen(vs));
-    snprintf(vs, sizeof(vs), "status: %d health: %d present: %d\n",
-             props.batteryStatus, props.batteryHealth, props.batteryPresent);
-    write(fd, vs, strlen(vs));
-    snprintf(vs, sizeof(vs), "level: %d voltage: %d temp: %d\n",
-             props.batteryLevel, props.batteryVoltage,
-             props.batteryTemperature);
-    write(fd, vs, strlen(vs));
-
-    if (!mHealthdConfig->batteryCurrentNowPath.isEmpty()) {
-        v = getIntField(mHealthdConfig->batteryCurrentNowPath);
-        snprintf(vs, sizeof(vs), "current now: %d\n", v);
-        write(fd, vs, strlen(vs));
-    }
-
-    if (!mHealthdConfig->batteryCurrentAvgPath.isEmpty()) {
-        v = getIntField(mHealthdConfig->batteryCurrentAvgPath);
-        snprintf(vs, sizeof(vs), "current avg: %d\n", v);
-        write(fd, vs, strlen(vs));
-    }
-
-    if (!mHealthdConfig->batteryChargeCounterPath.isEmpty()) {
-        v = getIntField(mHealthdConfig->batteryChargeCounterPath);
-        snprintf(vs, sizeof(vs), "charge counter: %d\n", v);
-        write(fd, vs, strlen(vs));
-    }
-}
-
-void BatteryMonitor::init(struct healthd_config *hc) {
-    String8 path;
-    char pval[PROPERTY_VALUE_MAX];
-
-    mHealthdConfig = hc;
-    DIR* dir = opendir(POWER_SUPPLY_SYSFS_PATH);
-    if (dir == NULL) {
-        KLOG_ERROR(LOG_TAG, "Could not open %s\n", POWER_SUPPLY_SYSFS_PATH);
-    } else {
-        struct dirent* entry;
-
-        while ((entry = readdir(dir))) {
-            const char* name = entry->d_name;
-
-            if (!strcmp(name, ".") || !strcmp(name, ".."))
-                continue;
-
-            char buf[20];
-            // Look for "type" file in each subdirectory
-            path.clear();
-            path.appendFormat("%s/%s/type", POWER_SUPPLY_SYSFS_PATH, name);
-            switch(readPowerSupplyType(path)) {
-            case ANDROID_POWER_SUPPLY_TYPE_AC:
-            case ANDROID_POWER_SUPPLY_TYPE_USB:
-            case ANDROID_POWER_SUPPLY_TYPE_WIRELESS:
-                path.clear();
-                path.appendFormat("%s/%s/online", POWER_SUPPLY_SYSFS_PATH, name);
-                if (access(path.string(), R_OK) == 0)
-                    mChargerNames.add(String8(name));
-                break;
-
-            case ANDROID_POWER_SUPPLY_TYPE_BATTERY:
-                mBatteryDevicePresent = true;
-
-                if (mHealthdConfig->batteryStatusPath.isEmpty()) {
-                    path.clear();
-                    path.appendFormat("%s/%s/status", POWER_SUPPLY_SYSFS_PATH,
-                                      name);
-                    if (access(path, R_OK) == 0)
-                        mHealthdConfig->batteryStatusPath = path;
-                }
-
-                if (mHealthdConfig->batteryHealthPath.isEmpty()) {
-                    path.clear();
-                    path.appendFormat("%s/%s/health", POWER_SUPPLY_SYSFS_PATH,
-                                      name);
-                    if (access(path, R_OK) == 0)
-                        mHealthdConfig->batteryHealthPath = path;
-                }
-
-                if (mHealthdConfig->batteryPresentPath.isEmpty()) {
-                    path.clear();
-                    path.appendFormat("%s/%s/present", POWER_SUPPLY_SYSFS_PATH,
-                                      name);
-                    if (access(path, R_OK) == 0)
-                        mHealthdConfig->batteryPresentPath = path;
-                }
-
-                if (mHealthdConfig->batteryCapacityPath.isEmpty()) {
-                    path.clear();
-                    path.appendFormat("%s/%s/capacity", POWER_SUPPLY_SYSFS_PATH,
-                                      name);
-                    if (access(path, R_OK) == 0)
-                        mHealthdConfig->batteryCapacityPath = path;
-                }
-
-                if (mHealthdConfig->batteryVoltagePath.isEmpty()) {
-                    path.clear();
-                    path.appendFormat("%s/%s/voltage_now",
-                                      POWER_SUPPLY_SYSFS_PATH, name);
-                    if (access(path, R_OK) == 0) {
-                        mHealthdConfig->batteryVoltagePath = path;
-                    } else {
-                        path.clear();
-                        path.appendFormat("%s/%s/batt_vol",
-                                          POWER_SUPPLY_SYSFS_PATH, name);
-                        if (access(path, R_OK) == 0)
-                            mHealthdConfig->batteryVoltagePath = path;
-                    }
-                }
-
-                if (mHealthdConfig->batteryCurrentNowPath.isEmpty()) {
-                    path.clear();
-                    path.appendFormat("%s/%s/current_now",
-                                      POWER_SUPPLY_SYSFS_PATH, name);
-                    if (access(path, R_OK) == 0)
-                        mHealthdConfig->batteryCurrentNowPath = path;
-                }
-
-                if (mHealthdConfig->batteryCurrentAvgPath.isEmpty()) {
-                    path.clear();
-                    path.appendFormat("%s/%s/current_avg",
-                                      POWER_SUPPLY_SYSFS_PATH, name);
-                    if (access(path, R_OK) == 0)
-                        mHealthdConfig->batteryCurrentAvgPath = path;
-                }
-
-                if (mHealthdConfig->batteryChargeCounterPath.isEmpty()) {
-                    path.clear();
-                    path.appendFormat("%s/%s/charge_counter",
-                                      POWER_SUPPLY_SYSFS_PATH, name);
-                    if (access(path, R_OK) == 0)
-                        mHealthdConfig->batteryChargeCounterPath = path;
-                }
-
-                if (mHealthdConfig->batteryTemperaturePath.isEmpty()) {
-                    path.clear();
-                    path.appendFormat("%s/%s/temp", POWER_SUPPLY_SYSFS_PATH,
-                                      name);
-                    if (access(path, R_OK) == 0) {
-                        mHealthdConfig->batteryTemperaturePath = path;
-                    } else {
-                        path.clear();
-                        path.appendFormat("%s/%s/batt_temp",
-                                          POWER_SUPPLY_SYSFS_PATH, name);
-                        if (access(path, R_OK) == 0)
-                            mHealthdConfig->batteryTemperaturePath = path;
-                    }
-                }
-
-                if (mHealthdConfig->batteryTechnologyPath.isEmpty()) {
-                    path.clear();
-                    path.appendFormat("%s/%s/technology",
-                                      POWER_SUPPLY_SYSFS_PATH, name);
-                    if (access(path, R_OK) == 0)
-                        mHealthdConfig->batteryTechnologyPath = path;
-                }
-
-                break;
-
-            case ANDROID_POWER_SUPPLY_TYPE_UNKNOWN:
-                break;
-            }
-        }
-        closedir(dir);
-    }
-
-    if (!mChargerNames.size())
-        KLOG_ERROR(LOG_TAG, "No charger supplies found\n");
-    if (!mBatteryDevicePresent) {
-        KLOG_INFO(LOG_TAG, "No battery devices found\n");
-        hc->periodic_chores_interval_fast = -1;
-        hc->periodic_chores_interval_slow = -1;
-    } else {
-        if (mHealthdConfig->batteryStatusPath.isEmpty())
-            KLOG_WARNING(LOG_TAG, "BatteryStatusPath not found\n");
-        if (mHealthdConfig->batteryHealthPath.isEmpty())
-            KLOG_WARNING(LOG_TAG, "BatteryHealthPath not found\n");
-        if (mHealthdConfig->batteryPresentPath.isEmpty())
-            KLOG_WARNING(LOG_TAG, "BatteryPresentPath not found\n");
-        if (mHealthdConfig->batteryCapacityPath.isEmpty())
-            KLOG_WARNING(LOG_TAG, "BatteryCapacityPath not found\n");
-        if (mHealthdConfig->batteryVoltagePath.isEmpty())
-            KLOG_WARNING(LOG_TAG, "BatteryVoltagePath not found\n");
-        if (mHealthdConfig->batteryTemperaturePath.isEmpty())
-            KLOG_WARNING(LOG_TAG, "BatteryTemperaturePath not found\n");
-        if (mHealthdConfig->batteryTechnologyPath.isEmpty())
-            KLOG_WARNING(LOG_TAG, "BatteryTechnologyPath not found\n");
-    }
-
-    if (property_get("ro.boot.fake_battery", pval, NULL) > 0
-                                               && strtol(pval, NULL, 10) != 0) {
-        mBatteryFixedCapacity = FAKE_BATTERY_CAPACITY;
-        mBatteryFixedTemperature = FAKE_BATTERY_TEMPERATURE;
-    }
-}
-
-}; // namespace android
diff --git a/healthd/BatteryMonitor.h b/healthd/BatteryMonitor.h
deleted file mode 100644
index 3425f27..0000000
--- a/healthd/BatteryMonitor.h
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HEALTHD_BATTERYMONITOR_H
-#define HEALTHD_BATTERYMONITOR_H
-
-#include <batteryservice/BatteryService.h>
-#include <binder/IInterface.h>
-#include <utils/String8.h>
-#include <utils/Vector.h>
-
-#include "healthd.h"
-
-namespace android {
-
-class BatteryMonitor {
-  public:
-
-    enum PowerSupplyType {
-        ANDROID_POWER_SUPPLY_TYPE_UNKNOWN = 0,
-        ANDROID_POWER_SUPPLY_TYPE_AC,
-        ANDROID_POWER_SUPPLY_TYPE_USB,
-        ANDROID_POWER_SUPPLY_TYPE_WIRELESS,
-        ANDROID_POWER_SUPPLY_TYPE_BATTERY
-    };
-
-    void init(struct healthd_config *hc);
-    bool update(void);
-    status_t getProperty(int id, struct BatteryProperty *val);
-    void dumpState(int fd);
-
-  private:
-    struct healthd_config *mHealthdConfig;
-    Vector<String8> mChargerNames;
-    bool mBatteryDevicePresent;
-    int mBatteryFixedCapacity;
-    int mBatteryFixedTemperature;
-    struct BatteryProperties props;
-
-    int getBatteryStatus(const char* status);
-    int getBatteryHealth(const char* status);
-    int readFromFile(const String8& path, char* buf, size_t size);
-    PowerSupplyType readPowerSupplyType(const String8& path);
-    bool getBooleanField(const String8& path);
-    int getIntField(const String8& path);
-};
-
-}; // namespace android
-
-#endif // HEALTHD_BATTERY_MONTIOR_H
diff --git a/healthd/BatteryPropertiesRegistrar.cpp b/healthd/BatteryPropertiesRegistrar.cpp
deleted file mode 100644
index 74bcbfd..0000000
--- a/healthd/BatteryPropertiesRegistrar.cpp
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "BatteryPropertiesRegistrar.h"
-#include <batteryservice/BatteryService.h>
-#include <batteryservice/IBatteryPropertiesListener.h>
-#include <batteryservice/IBatteryPropertiesRegistrar.h>
-#include <binder/IPCThreadState.h>
-#include <binder/IServiceManager.h>
-#include <binder/PermissionCache.h>
-#include <private/android_filesystem_config.h>
-#include <utils/Errors.h>
-#include <utils/Mutex.h>
-#include <utils/String16.h>
-
-#include "healthd.h"
-
-namespace android {
-
-void BatteryPropertiesRegistrar::publish() {
-    defaultServiceManager()->addService(String16("batteryproperties"), this);
-}
-
-void BatteryPropertiesRegistrar::notifyListeners(struct BatteryProperties props) {
-    Mutex::Autolock _l(mRegistrationLock);
-    for (size_t i = 0; i < mListeners.size(); i++) {
-        mListeners[i]->batteryPropertiesChanged(props);
-    }
-}
-
-void BatteryPropertiesRegistrar::registerListener(const sp<IBatteryPropertiesListener>& listener) {
-    {
-        if (listener == NULL)
-            return;
-        Mutex::Autolock _l(mRegistrationLock);
-        // check whether this is a duplicate
-        for (size_t i = 0; i < mListeners.size(); i++) {
-            if (mListeners[i]->asBinder() == listener->asBinder()) {
-                return;
-            }
-        }
-
-        mListeners.add(listener);
-        listener->asBinder()->linkToDeath(this);
-    }
-    healthd_battery_update();
-}
-
-void BatteryPropertiesRegistrar::unregisterListener(const sp<IBatteryPropertiesListener>& listener) {
-    if (listener == NULL)
-        return;
-    Mutex::Autolock _l(mRegistrationLock);
-    for (size_t i = 0; i < mListeners.size(); i++) {
-        if (mListeners[i]->asBinder() == listener->asBinder()) {
-            mListeners[i]->asBinder()->unlinkToDeath(this);
-            mListeners.removeAt(i);
-            break;
-        }
-    }
-}
-
-status_t BatteryPropertiesRegistrar::getProperty(int id, struct BatteryProperty *val) {
-    return healthd_get_property(id, val);
-}
-
-status_t BatteryPropertiesRegistrar::dump(int fd, const Vector<String16>& /*args*/) {
-    IPCThreadState* self = IPCThreadState::self();
-    const int pid = self->getCallingPid();
-    const int uid = self->getCallingUid();
-    if ((uid != AID_SHELL) &&
-        !PermissionCache::checkPermission(
-                String16("android.permission.DUMP"), pid, uid))
-        return PERMISSION_DENIED;
-
-    healthd_dump_battery_state(fd);
-    return OK;
-}
-
-void BatteryPropertiesRegistrar::binderDied(const wp<IBinder>& who) {
-    Mutex::Autolock _l(mRegistrationLock);
-
-    for (size_t i = 0; i < mListeners.size(); i++) {
-        if (mListeners[i]->asBinder() == who) {
-            mListeners.removeAt(i);
-            break;
-        }
-    }
-}
-
-}  // namespace android
diff --git a/healthd/BatteryPropertiesRegistrar.h b/healthd/BatteryPropertiesRegistrar.h
deleted file mode 100644
index 8853874..0000000
--- a/healthd/BatteryPropertiesRegistrar.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HEALTHD_BATTERYPROPERTIES_REGISTRAR_H
-#define HEALTHD_BATTERYPROPERTIES_REGISTRAR_H
-
-#include <binder/IBinder.h>
-#include <utils/Mutex.h>
-#include <utils/String16.h>
-#include <utils/Vector.h>
-#include <batteryservice/BatteryService.h>
-#include <batteryservice/IBatteryPropertiesListener.h>
-#include <batteryservice/IBatteryPropertiesRegistrar.h>
-
-namespace android {
-
-class BatteryPropertiesRegistrar : public BnBatteryPropertiesRegistrar,
-                                   public IBinder::DeathRecipient {
-public:
-    void publish();
-    void notifyListeners(struct BatteryProperties props);
-
-private:
-    Mutex mRegistrationLock;
-    Vector<sp<IBatteryPropertiesListener> > mListeners;
-
-    void registerListener(const sp<IBatteryPropertiesListener>& listener);
-    void unregisterListener(const sp<IBatteryPropertiesListener>& listener);
-    status_t getProperty(int id, struct BatteryProperty *val);
-    status_t dump(int fd, const Vector<String16>& args);
-    void binderDied(const wp<IBinder>& who);
-};
-
-};  // namespace android
-
-#endif // HEALTHD_BATTERYPROPERTIES_REGISTRAR_H
diff --git a/healthd/healthd.cpp b/healthd/healthd.cpp
deleted file mode 100644
index 1bccffa..0000000
--- a/healthd/healthd.cpp
+++ /dev/null
@@ -1,392 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "healthd"
-#define KLOG_LEVEL 6
-
-#include "healthd.h"
-#include "BatteryMonitor.h"
-
-#include <errno.h>
-#include <libgen.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <batteryservice/BatteryService.h>
-#include <cutils/klog.h>
-#include <cutils/uevent.h>
-#include <sys/epoll.h>
-#include <sys/timerfd.h>
-#include <utils/Errors.h>
-#include <getopt.h>
-
-using namespace android;
-
-// Periodic chores intervals in seconds
-#ifdef QCOM_HARDWARE
-#define DEFAULT_PERIODIC_CHORES_INTERVAL_FAST (60 * 10)
-//For the designs without low battery detection,need to enable
-//the default 60*10s wakeup timer to periodic check.
-#define DEFAULT_PERIODIC_CHORES_INTERVAL_SLOW -1
-#else
-#define DEFAULT_PERIODIC_CHORES_INTERVAL_FAST (60 * 1)
-#define DEFAULT_PERIODIC_CHORES_INTERVAL_SLOW (60 * 10)
-#endif
-
-static struct healthd_config healthd_config = {
-    .periodic_chores_interval_fast = DEFAULT_PERIODIC_CHORES_INTERVAL_FAST,
-    .periodic_chores_interval_slow = DEFAULT_PERIODIC_CHORES_INTERVAL_SLOW,
-    .batteryStatusPath = String8(String8::kEmptyString),
-    .batteryHealthPath = String8(String8::kEmptyString),
-    .batteryPresentPath = String8(String8::kEmptyString),
-    .batteryCapacityPath = String8(String8::kEmptyString),
-    .batteryVoltagePath = String8(String8::kEmptyString),
-    .batteryTemperaturePath = String8(String8::kEmptyString),
-    .batteryTechnologyPath = String8(String8::kEmptyString),
-    .batteryCurrentNowPath = String8(String8::kEmptyString),
-    .batteryCurrentAvgPath = String8(String8::kEmptyString),
-    .batteryChargeCounterPath = String8(String8::kEmptyString),
-    .energyCounter = NULL,
-};
-
-static int eventct;
-static int epollfd;
-
-#define POWER_SUPPLY_SUBSYSTEM "power_supply"
-
-// epoll_create() parameter is actually unused
-#define MAX_EPOLL_EVENTS 40
-static int uevent_fd;
-static int wakealarm_fd;
-static int binder_fd;
-
-// -1 for no epoll timeout
-static int awake_poll_interval = -1;
-
-static int wakealarm_wake_interval = DEFAULT_PERIODIC_CHORES_INTERVAL_FAST;
-
-static BatteryMonitor* gBatteryMonitor;
-
-struct healthd_mode_ops *healthd_mode_ops;
-
-// Android mode
-
-extern void healthd_mode_android_init(struct healthd_config *config);
-extern int healthd_mode_android_preparetowait(void);
-extern void healthd_mode_android_battery_update(
-    struct android::BatteryProperties *props);
-
-// Charger mode
-
-extern void healthd_mode_charger_init(struct healthd_config *config);
-extern int healthd_mode_charger_preparetowait(void);
-extern void healthd_mode_charger_heartbeat(void);
-extern void healthd_mode_charger_battery_update(
-    struct android::BatteryProperties *props);
-
-static const struct option OPTIONS[] = {
-    { "mode", required_argument, NULL, 'm' },
-    { NULL, 0, NULL, 0 },
-};
-
-int mode = NORMAL;
-
-// NOPs for modes that need no special action
-
-static void healthd_mode_nop_init(struct healthd_config *config);
-static int healthd_mode_nop_preparetowait(void);
-static void healthd_mode_nop_heartbeat(void);
-static void healthd_mode_nop_battery_update(
-    struct android::BatteryProperties *props);
-
-static struct healthd_mode_ops android_ops = {
-    .init = healthd_mode_android_init,
-    .preparetowait = healthd_mode_android_preparetowait,
-    .heartbeat = healthd_mode_nop_heartbeat,
-    .battery_update = healthd_mode_android_battery_update,
-};
-
-static struct healthd_mode_ops charger_ops = {
-    .init = healthd_mode_charger_init,
-    .preparetowait = healthd_mode_charger_preparetowait,
-    .heartbeat = healthd_mode_charger_heartbeat,
-    .battery_update = healthd_mode_charger_battery_update,
-};
-
-static struct healthd_mode_ops recovery_ops = {
-    .init = healthd_mode_nop_init,
-    .preparetowait = healthd_mode_nop_preparetowait,
-    .heartbeat = healthd_mode_nop_heartbeat,
-    .battery_update = healthd_mode_nop_battery_update,
-};
-
-static void healthd_mode_nop_init(struct healthd_config* /*config*/) {
-}
-
-static int healthd_mode_nop_preparetowait(void) {
-    return -1;
-}
-
-static void healthd_mode_nop_heartbeat(void) {
-}
-
-static void healthd_mode_nop_battery_update(
-    struct android::BatteryProperties* /*props*/) {
-}
-
-int healthd_register_event(int fd, void (*handler)(uint32_t)) {
-    struct epoll_event ev;
-
-    ev.events = EPOLLIN | EPOLLWAKEUP;
-    ev.data.ptr = (void *)handler;
-    if (epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &ev) == -1) {
-        KLOG_ERROR(LOG_TAG,
-                   "epoll_ctl failed; errno=%d\n", errno);
-        return -1;
-    }
-
-    eventct++;
-    return 0;
-}
-
-static void wakealarm_set_interval(int interval) {
-    struct itimerspec itval;
-
-    if (wakealarm_fd == -1)
-            return;
-
-    wakealarm_wake_interval = interval;
-
-    if (interval == -1)
-        interval = 0;
-
-    itval.it_interval.tv_sec = interval;
-    itval.it_interval.tv_nsec = 0;
-    itval.it_value.tv_sec = interval;
-    itval.it_value.tv_nsec = 0;
-
-    if (timerfd_settime(wakealarm_fd, 0, &itval, NULL) == -1)
-        KLOG_ERROR(LOG_TAG, "wakealarm_set_interval: timerfd_settime failed\n");
-}
-
-status_t healthd_get_property(int id, struct BatteryProperty *val) {
-    return gBatteryMonitor->getProperty(id, val);
-}
-
-void healthd_battery_update(void) {
-    // Fast wake interval when on charger (watch for overheat);
-    // slow wake interval when on battery (watch for drained battery).
-
-   int new_wake_interval = gBatteryMonitor->update() ?
-       healthd_config.periodic_chores_interval_fast :
-           healthd_config.periodic_chores_interval_slow;
-
-    if (new_wake_interval != wakealarm_wake_interval)
-            wakealarm_set_interval(new_wake_interval);
-
-    // During awake periods poll at fast rate.  If wake alarm is set at fast
-    // rate then just use the alarm; if wake alarm is set at slow rate then
-    // poll at fast rate while awake and let alarm wake up at slow rate when
-    // asleep.
-
-    if (healthd_config.periodic_chores_interval_fast == -1)
-        awake_poll_interval = -1;
-    else
-        awake_poll_interval =
-            new_wake_interval == healthd_config.periodic_chores_interval_fast ?
-                -1 : healthd_config.periodic_chores_interval_fast * 1000;
-}
-
-void healthd_dump_battery_state(int fd) {
-    gBatteryMonitor->dumpState(fd);
-    fsync(fd);
-}
-
-static void periodic_chores() {
-    healthd_battery_update();
-}
-
-#define UEVENT_MSG_LEN 2048
-static void uevent_event(uint32_t /*epevents*/) {
-    char msg[UEVENT_MSG_LEN+2];
-    char *cp;
-    int n;
-
-    n = uevent_kernel_multicast_recv(uevent_fd, msg, UEVENT_MSG_LEN);
-    if (n <= 0)
-        return;
-    if (n >= UEVENT_MSG_LEN)   /* overflow -- discard */
-        return;
-
-    msg[n] = '\0';
-    msg[n+1] = '\0';
-    cp = msg;
-
-    while (*cp) {
-        if (!strcmp(cp, "SUBSYSTEM=" POWER_SUPPLY_SUBSYSTEM)) {
-            healthd_battery_update();
-            break;
-        }
-
-        /* advance to after the next \0 */
-        while (*cp++)
-            ;
-    }
-}
-
-static void uevent_init(void) {
-    uevent_fd = uevent_open_socket(64*1024, true);
-
-    if (uevent_fd < 0) {
-        KLOG_ERROR(LOG_TAG, "uevent_init: uevent_open_socket failed\n");
-        return;
-    }
-
-    fcntl(uevent_fd, F_SETFL, O_NONBLOCK);
-    if (healthd_register_event(uevent_fd, uevent_event))
-        KLOG_ERROR(LOG_TAG,
-                   "register for uevent events failed\n");
-}
-
-static void wakealarm_event(uint32_t /*epevents*/) {
-    unsigned long long wakeups;
-
-    if (read(wakealarm_fd, &wakeups, sizeof(wakeups)) == -1) {
-        KLOG_ERROR(LOG_TAG, "wakealarm_event: read wakealarm fd failed\n");
-        return;
-    }
-
-    periodic_chores();
-}
-
-static void wakealarm_init(void) {
-    wakealarm_fd = timerfd_create(CLOCK_BOOTTIME_ALARM, TFD_NONBLOCK);
-    if (wakealarm_fd == -1) {
-        KLOG_ERROR(LOG_TAG, "wakealarm_init: timerfd_create failed\n");
-        return;
-    }
-
-    if (healthd_register_event(wakealarm_fd, wakealarm_event))
-        KLOG_ERROR(LOG_TAG,
-                   "Registration of wakealarm event failed\n");
-
-    wakealarm_set_interval(healthd_config.periodic_chores_interval_fast);
-}
-
-static void healthd_mainloop(void) {
-    while (1) {
-        struct epoll_event events[eventct];
-        int nevents;
-        int timeout = awake_poll_interval;
-        int mode_timeout;
-
-        mode_timeout = healthd_mode_ops->preparetowait();
-        if (timeout < 0 || (mode_timeout > 0 && mode_timeout < timeout))
-            timeout = mode_timeout;
-        nevents = epoll_wait(epollfd, events, eventct, timeout);
-
-        if (nevents == -1) {
-            if (errno == EINTR)
-                continue;
-            KLOG_ERROR(LOG_TAG, "healthd_mainloop: epoll_wait failed\n");
-            break;
-        }
-
-        for (int n = 0; n < nevents; ++n) {
-            if (events[n].data.ptr)
-                (*(void (*)(int))events[n].data.ptr)(events[n].events);
-        }
-
-        if (!nevents)
-            periodic_chores();
-
-        healthd_mode_ops->heartbeat();
-    }
-
-    return;
-}
-
-static int healthd_init() {
-    epollfd = epoll_create(MAX_EPOLL_EVENTS);
-    if (epollfd == -1) {
-        KLOG_ERROR(LOG_TAG,
-                   "epoll_create failed; errno=%d\n",
-                   errno);
-        return -1;
-    }
-
-    healthd_mode_ops->init(&healthd_config);
-    healthd_board_init(&healthd_config);
-    wakealarm_init();
-    uevent_init();
-    gBatteryMonitor = new BatteryMonitor();
-    gBatteryMonitor->init(&healthd_config);
-    return 0;
-}
-
-int main(int argc, char **argv) {
-    int ch;
-    int ret;
-
-    klog_set_level(KLOG_LEVEL);
-    healthd_mode_ops = &android_ops;
-
-    if (!strcmp(basename(argv[0]), "charger")) {
-        healthd_mode_ops = &charger_ops;
-        int arg;
-        while ((arg=getopt_long(argc, argv,"m:" , OPTIONS, NULL))!=-1) {
-            switch (arg) {
-                case 'm':
-                    mode = atoi(optarg);
-                    break;
-                case '?':
-                default:
-                    KLOG_ERROR(LOG_TAG, "Unrecognized charger option\n");
-                    continue;
-            }
-        }
-    } else {
-        while ((ch = getopt(argc, argv, "cr")) != -1) {
-            switch (ch) {
-            case 'c':
-                healthd_mode_ops = &charger_ops;
-                break;
-            case 'r':
-                healthd_mode_ops = &recovery_ops;
-                break;
-            case '?':
-            default:
-                KLOG_ERROR(LOG_TAG, "Unrecognized healthd option: %c\n",
-                           optopt);
-                exit(1);
-            }
-        }
-    }
-
-    ret = healthd_init();
-    if (ret) {
-        KLOG_ERROR("Initialization failed, exiting\n");
-        exit(2);
-    }
-
-    periodic_chores();
-    healthd_mode_ops->heartbeat();
-
-    healthd_mainloop();
-    KLOG_ERROR("Main loop terminated, exiting\n");
-    return 3;
-}
diff --git a/healthd/healthd.h b/healthd/healthd.h
deleted file mode 100644
index 0477d9f..0000000
--- a/healthd/healthd.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _HEALTHD_H_
-#define _HEALTHD_H_
-
-#include <batteryservice/BatteryService.h>
-#include <sys/types.h>
-#include <utils/Errors.h>
-#include <utils/String8.h>
-
-// periodic_chores_interval_fast, periodic_chores_interval_slow: intervals at
-// which healthd wakes up to poll health state and perform periodic chores,
-// in units of seconds:
-//
-//    periodic_chores_interval_fast is used while the device is not in
-//    suspend, or in suspend and connected to a charger (to watch for battery
-//    overheat due to charging).  The default value is 60 (1 minute).  Value
-//    -1 turns off periodic chores (and wakeups) in these conditions.
-//
-//    periodic_chores_interval_slow is used when the device is in suspend and
-//    not connected to a charger (to watch for a battery drained to zero
-//    remaining capacity).  The default value is 600 (10 minutes).  Value -1
-//    tuns off periodic chores (and wakeups) in these conditions.
-//
-// power_supply sysfs attribute file paths.  Set these to specific paths
-// to use for the associated battery parameters.  healthd will search for
-// appropriate power_supply attribute files to use for any paths left empty:
-//
-//    batteryStatusPath: charging status (POWER_SUPPLY_PROP_STATUS)
-//    batteryHealthPath: battery health (POWER_SUPPLY_PROP_HEALTH)
-//    batteryPresentPath: battery present (POWER_SUPPLY_PROP_PRESENT)
-//    batteryCapacityPath: remaining capacity (POWER_SUPPLY_PROP_CAPACITY)
-//    batteryVoltagePath: battery voltage (POWER_SUPPLY_PROP_VOLTAGE_NOW)
-//    batteryTemperaturePath: battery temperature (POWER_SUPPLY_PROP_TEMP)
-//    batteryTechnologyPath: battery technology (POWER_SUPPLY_PROP_TECHNOLOGY)
-//    batteryCurrentNowPath: battery current (POWER_SUPPLY_PROP_CURRENT_NOW)
-//    batteryChargeCounterPath: battery accumulated charge
-//                                         (POWER_SUPPLY_PROP_CHARGE_COUNTER)
-
-struct healthd_config {
-    int periodic_chores_interval_fast;
-    int periodic_chores_interval_slow;
-
-    android::String8 batteryStatusPath;
-    android::String8 batteryHealthPath;
-    android::String8 batteryPresentPath;
-    android::String8 batteryCapacityPath;
-    android::String8 batteryVoltagePath;
-    android::String8 batteryTemperaturePath;
-    android::String8 batteryTechnologyPath;
-    android::String8 batteryCurrentNowPath;
-    android::String8 batteryCurrentAvgPath;
-    android::String8 batteryChargeCounterPath;
-
-    int (*energyCounter)(int64_t *);
-};
-
-// Global helper functions
-
-int healthd_register_event(int fd, void (*handler)(uint32_t));
-void healthd_battery_update();
-android::status_t healthd_get_property(int id,
-    struct android::BatteryProperty *val);
-void healthd_dump_battery_state(int fd);
-
-struct healthd_mode_ops {
-    void (*init)(struct healthd_config *config);
-    int (*preparetowait)(void);
-    void (*heartbeat)(void);
-    void (*battery_update)(struct android::BatteryProperties *props);
-};
-
-extern struct healthd_mode_ops *healthd_mode_ops;
-
-enum MODE {
-    NORMAL = 0,
-    QUICKBOOT,
-};
-
-// Charger mode
-
-void healthd_mode_charger_init(struct healthd_config *config);
-int healthd_mode_charger_preparetowait(void);
-void healthd_mode_charger_heartbeat(void);
-void healthd_mode_charger_battery_update(
-    struct android::BatteryProperties *props);
-
-// The following are implemented in libhealthd_board to handle board-specific
-// behavior.
-//
-// healthd_board_init() is called at startup time to modify healthd's
-// configuration according to board-specific requirements.  config
-// points to the healthd configuration values described above.  To use default
-// values, this function can simply return without modifying the fields of the
-// config parameter.
-
-void healthd_board_init(struct healthd_config *config);
-
-// Process updated battery property values.  This function is called when
-// the kernel sends updated battery status via a uevent from the power_supply
-// subsystem, or when updated values are polled by healthd, as for periodic
-// poll of battery state.
-//
-// props are the battery properties read from the kernel.  These values may
-// be modified in this call, prior to sending the modified values to the
-// Android runtime.
-//
-// Return 0 to indicate the usual kernel log battery status heartbeat message
-// is to be logged, or non-zero to prevent logging this information.
-
-int healthd_board_battery_update(struct android::BatteryProperties *props);
-
-#endif /* _HEALTHD_H_ */
diff --git a/healthd/healthd_board_default.cpp b/healthd/healthd_board_default.cpp
deleted file mode 100644
index 3d07362..0000000
--- a/healthd/healthd_board_default.cpp
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <healthd.h>
-#include "healthd_msm.h"
-
-void healthd_board_init(struct healthd_config*)
-{
-    // use defaults
-    power_off_alarm_init();
-}
-
-
-int healthd_board_battery_update(struct android::BatteryProperties*)
-{
-    // return 0 to log periodic polled battery status to kernel log
-    return 1;
-}
diff --git a/healthd/healthd_mode_android.cpp b/healthd/healthd_mode_android.cpp
deleted file mode 100644
index fd153a2..0000000
--- a/healthd/healthd_mode_android.cpp
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#define LOG_TAG "healthd-android"
-
-#include "healthd.h"
-#include "BatteryPropertiesRegistrar.h"
-
-#include <binder/IPCThreadState.h>
-#include <binder/ProcessState.h>
-#include <cutils/klog.h>
-#include <sys/epoll.h>
-
-using namespace android;
-
-static int gBinderFd;
-static sp<BatteryPropertiesRegistrar> gBatteryPropertiesRegistrar;
-
-void healthd_mode_android_battery_update(
-    struct android::BatteryProperties *props) {
-    if (gBatteryPropertiesRegistrar != NULL)
-        gBatteryPropertiesRegistrar->notifyListeners(*props);
-
-    return;
-}
-
-int healthd_mode_android_preparetowait(void) {
-    IPCThreadState::self()->flushCommands();
-    return -1;
-}
-
-static void binder_event(uint32_t /*epevents*/) {
-    IPCThreadState::self()->handlePolledCommands();
-}
-
-void healthd_mode_android_init(struct healthd_config* /*config*/) {
-    ProcessState::self()->setThreadPoolMaxThreadCount(0);
-    IPCThreadState::self()->disableBackgroundScheduling(true);
-    IPCThreadState::self()->setupPolling(&gBinderFd);
-
-    if (gBinderFd >= 0) {
-        if (healthd_register_event(gBinderFd, binder_event))
-            KLOG_ERROR(LOG_TAG,
-                       "Register for binder events failed\n");
-    }
-
-    gBatteryPropertiesRegistrar = new BatteryPropertiesRegistrar();
-    gBatteryPropertiesRegistrar->publish();
-}
diff --git a/healthd/healthd_mode_charger.cpp b/healthd/healthd_mode_charger.cpp
deleted file mode 100644
index 4c7f43f..0000000
--- a/healthd/healthd_mode_charger.cpp
+++ /dev/null
@@ -1,957 +0,0 @@
-/*
- * Copyright (C) 2011-2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <dirent.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <inttypes.h>
-#include <linux/input.h>
-#include <stdbool.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/epoll.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <sys/un.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <sys/socket.h>
-#include <linux/netlink.h>
-
-#include <batteryservice/BatteryService.h>
-#include <cutils/android_reboot.h>
-#include <cutils/klog.h>
-#include <cutils/misc.h>
-#include <cutils/uevent.h>
-#include <cutils/properties.h>
-
-#ifdef CHARGER_ENABLE_SUSPEND
-#include <suspend/autosuspend.h>
-#endif
-
-#include "minui/minui.h"
-
-#include "healthd.h"
-
-char *locale;
-
-#ifndef max
-#define max(a,b) ((a) > (b) ? (a) : (b))
-#endif
-
-#ifndef min
-#define min(a,b) ((a) < (b) ? (a) : (b))
-#endif
-
-#define ARRAY_SIZE(x)           (sizeof(x)/sizeof(x[0]))
-
-#define MSEC_PER_SEC            (1000LL)
-#define NSEC_PER_MSEC           (1000000LL)
-
-#define BATTERY_UNKNOWN_TIME    (2 * MSEC_PER_SEC)
-#define POWER_ON_KEY_TIME       (2 * MSEC_PER_SEC)
-#define UNPLUGGED_SHUTDOWN_TIME (10 * MSEC_PER_SEC)
-
-#define BATTERY_FULL_THRESH     95
-#define SCREEN_ON_BATTERY_THRESH 0
-
-#define LAST_KMSG_PATH          "/proc/last_kmsg"
-#define LAST_KMSG_PSTORE_PATH   "/sys/fs/pstore/console-ramoops"
-#define LAST_KMSG_MAX_SZ        (32 * 1024)
-#ifndef RED_LED_PATH
-#define RED_LED_PATH            "/sys/class/leds/red/brightness"
-#endif
-#ifndef GREEN_LED_PATH
-#define GREEN_LED_PATH          "/sys/class/leds/green/brightness"
-#endif
-#ifndef BLUE_LED_PATH
-#define BLUE_LED_PATH           "/sys/class/leds/blue/brightness"
-#endif
-#ifndef BACKLIGHT_PATH
-#define BACKLIGHT_PATH          "/sys/class/leds/lcd-backlight/brightness"
-#endif
-#ifndef CHARGING_ENABLED_PATH
-#define CHARGING_ENABLED_PATH   "/sys/class/power_supply/battery/charging_enabled"
-#endif
-
-#define LOGE(x...) do { KLOG_ERROR("charger", x); } while (0)
-#define LOGI(x...) do { KLOG_INFO("charger", x); } while (0)
-#define LOGV(x...) do { KLOG_DEBUG("charger", x); } while (0)
-
-extern int mode;
-
-struct key_state {
-    bool pending;
-    bool down;
-    int64_t timestamp;
-};
-
-struct frame {
-    int disp_time;
-    int min_capacity;
-    bool level_only;
-
-    gr_surface surface;
-};
-
-struct animation {
-    bool run;
-
-    struct frame *frames;
-    int cur_frame;
-    int num_frames;
-
-    int cur_cycle;
-    int num_cycles;
-
-    /* current capacity being animated */
-    int capacity;
-};
-
-struct charger {
-    bool have_battery_state;
-    bool charger_connected;
-    int capacity;
-    int64_t next_screen_transition;
-    int64_t next_key_check;
-    int64_t next_pwr_check;
-
-    struct key_state keys[KEY_MAX + 1];
-
-    struct animation *batt_anim;
-    gr_surface surf_unknown;
-};
-
-static struct frame batt_anim_frames[] = {
-    {
-        .disp_time = 750,
-        .min_capacity = 0,
-        .level_only = false,
-        .surface = NULL,
-    },
-    {
-        .disp_time = 750,
-        .min_capacity = 20,
-        .level_only = false,
-        .surface = NULL,
-    },
-    {
-        .disp_time = 750,
-        .min_capacity = 40,
-        .level_only = false,
-        .surface = NULL,
-    },
-    {
-        .disp_time = 750,
-        .min_capacity = 60,
-        .level_only = false,
-        .surface = NULL,
-    },
-    {
-        .disp_time = 750,
-        .min_capacity = 80,
-        .level_only = true,
-        .surface = NULL,
-    },
-    {
-        .disp_time = 750,
-        .min_capacity = BATTERY_FULL_THRESH,
-        .level_only = false,
-        .surface = NULL,
-    },
-};
-
-static struct animation battery_animation = {
-    .run = false,
-    .frames = batt_anim_frames,
-    .cur_frame = 0,
-    .num_frames = ARRAY_SIZE(batt_anim_frames),
-    .cur_cycle = 0,
-    .num_cycles = 3,
-    .capacity = 0,
-};
-
-enum {
-    RED_LED = 0x01 << 0,
-    GREEN_LED = 0x01 << 1,
-    BLUE_LED = 0x01 << 2,
-};
-
-struct led_ctl {
-    int color;
-    const char *path;
-};
-
-struct led_ctl leds[3] =
-    {{RED_LED, RED_LED_PATH},
-    {GREEN_LED, GREEN_LED_PATH},
-    {BLUE_LED, BLUE_LED_PATH}};
-
-struct soc_led_color_mapping {
-    int soc;
-    int color;
-};
-
-struct soc_led_color_mapping soc_leds[3] = {
-    {15, RED_LED},
-    {90, RED_LED | GREEN_LED},
-    {100, GREEN_LED},
-};
-
-static struct charger charger_state;
-
-static int char_width;
-static int char_height;
-static bool minui_inited;
-
-static int set_tricolor_led(int on, int color)
-{
-    int fd, i;
-    char buffer[10];
-
-    for (i = 0; i < (int)ARRAY_SIZE(leds); i++) {
-        if ((color & leds[i].color) && (access(leds[i].path, R_OK | W_OK) == 0)) {
-            fd = open(leds[i].path, O_RDWR);
-            if (fd < 0) {
-                LOGE("Could not open led node %d\n", i);
-                continue;
-            }
-            if (on)
-                snprintf(buffer, sizeof(int), "%d\n", 255);
-            else
-                snprintf(buffer, sizeof(int), "%d\n", 0);
-
-            if (write(fd, buffer, strlen(buffer)) < 0)
-                LOGE("Could not write to led node\n");
-            close(fd);
-        }
-    }
-
-    return 0;
-}
-
-static int set_battery_soc_leds(int soc)
-{
-    int i, color;
-    static int old_color = 0;
-
-    for (i = 0; i < (int)ARRAY_SIZE(soc_leds); i++) {
-        if (soc <= soc_leds[i].soc)
-            break;
-    }
-    color = soc_leds[i].color;
-    if (old_color != color) {
-        set_tricolor_led(0, old_color);
-        set_tricolor_led(1, color);
-        old_color = color;
-        LOGV("soc = %d, set led color 0x%x\n", soc, soc_leds[i].color);
-    }
-
-    return 0;
-}
-
-#define BACKLIGHT_ON_LEVEL    100
-static int set_backlight(bool on)
-{
-    int fd;
-    char buffer[10];
-
-    if (access(BACKLIGHT_PATH, R_OK | W_OK) != 0)
-    {
-        LOGI("Backlight control not support\n");
-        return 0;
-    }
-
-    memset(buffer, '\0', sizeof(buffer));
-    fd = open(BACKLIGHT_PATH, O_RDWR);
-    if (fd < 0) {
-        LOGE("Could not open backlight node : %s\n", strerror(errno));
-        return 0;
-    }
-    LOGV("Enabling backlight\n");
-    snprintf(buffer, sizeof(buffer), "%d\n", on ? BACKLIGHT_ON_LEVEL : 0);
-    if (write(fd, buffer,strlen(buffer)) < 0) {
-        LOGE("Could not write to backlight node : %s\n", strerror(errno));
-    }
-    close(fd);
-
-    return 0;
-}
-
-/* current time in milliseconds */
-static int64_t curr_time_ms(void)
-{
-    struct timespec tm;
-    clock_gettime(CLOCK_MONOTONIC, &tm);
-    return tm.tv_sec * MSEC_PER_SEC + (tm.tv_nsec / NSEC_PER_MSEC);
-}
-
-static void clear_screen(void)
-{
-    gr_color(0, 0, 0, 255);
-    gr_clear();
-}
-
-#define MAX_KLOG_WRITE_BUF_SZ 256
-
-static void dump_last_kmsg(void)
-{
-    char *buf;
-    char *ptr;
-    unsigned sz = 0;
-    int len;
-
-    LOGI("\n");
-    LOGI("*************** LAST KMSG ***************\n");
-    LOGI("\n");
-    buf = (char *)load_file(LAST_KMSG_PSTORE_PATH, &sz);
-
-    if (!buf || !sz) {
-        buf = (char *)load_file(LAST_KMSG_PATH, &sz);
-        if (!buf || !sz) {
-            LOGI("last_kmsg not found. Cold reset?\n");
-            goto out;
-        }
-    }
-
-    len = min(sz, LAST_KMSG_MAX_SZ);
-    ptr = buf + (sz - len);
-
-    while (len > 0) {
-        int cnt = min(len, MAX_KLOG_WRITE_BUF_SZ);
-        char yoink;
-        char *nl;
-
-        nl = (char *)memrchr(ptr, '\n', cnt - 1);
-        if (nl)
-            cnt = nl - ptr + 1;
-
-        yoink = ptr[cnt];
-        ptr[cnt] = '\0';
-        klog_write(6, "<6>%s", ptr);
-        ptr[cnt] = yoink;
-
-        len -= cnt;
-        ptr += cnt;
-    }
-
-    free(buf);
-
-out:
-    LOGI("\n");
-    LOGI("************* END LAST KMSG *************\n");
-    LOGI("\n");
-}
-
-static int read_file(const char *path, char *buf, size_t sz)
-{
-    int fd;
-    size_t cnt;
-
-    fd = open(path, O_RDONLY, 0);
-    if (fd < 0)
-        goto err;
-
-    cnt = read(fd, buf, sz - 1);
-    if (cnt <= 0)
-        goto err;
-    buf[cnt] = '\0';
-    if (buf[cnt - 1] == '\n') {
-        cnt--;
-        buf[cnt] = '\0';
-    }
-
-    close(fd);
-    return cnt;
-
-err:
-    if (fd >= 0)
-        close(fd);
-    return -1;
-}
-
-static int read_file_int(const char *path, int *val)
-{
-    char buf[32];
-    int ret;
-    int tmp;
-    char *end;
-
-    ret = read_file(path, buf, sizeof(buf));
-    if (ret < 0)
-        return -1;
-
-    tmp = strtol(buf, &end, 0);
-    if (end == buf ||
-        ((end < buf+sizeof(buf)) && (*end != '\n' && *end != '\0')))
-        goto err;
-
-    *val = tmp;
-    return 0;
-
-err:
-    return -1;
-}
-
-static int get_battery_capacity()
-{
-    return charger_state.capacity;
-}
-
-#ifdef CHARGER_ENABLE_SUSPEND
-static int request_suspend(bool enable)
-{
-    if (enable)
-        return autosuspend_enable();
-    else
-        return autosuspend_disable();
-}
-#else
-static int request_suspend(bool /*enable*/)
-{
-    return 0;
-}
-#endif
-
-static int draw_text(const char *str, int x, int y)
-{
-    int str_len_px = gr_measure(str);
-
-    if (x < 0)
-        x = (gr_fb_width() - str_len_px) / 2;
-    if (y < 0)
-        y = (gr_fb_height() - char_height) / 2;
-    gr_text(x, y, str, 0);
-
-    return y + char_height;
-}
-
-static void android_green(void)
-{
-    gr_color(0xa4, 0xc6, 0x39, 255);
-}
-
-/* returns the last y-offset of where the surface ends */
-static int draw_surface_centered(struct charger* /*charger*/, gr_surface surface)
-{
-    int w;
-    int h;
-    int x;
-    int y;
-
-    w = gr_get_width(surface);
-    h = gr_get_height(surface);
-    x = (gr_fb_width() - w) / 2 ;
-    y = (gr_fb_height() - h) / 2 ;
-
-    LOGV("drawing surface %dx%d+%d+%d\n", w, h, x, y);
-    gr_blit(surface, 0, 0, w, h, x, y);
-    return y + h;
-}
-
-static void draw_unknown(struct charger *charger)
-{
-    int y;
-    if (charger->surf_unknown) {
-        draw_surface_centered(charger, charger->surf_unknown);
-    } else {
-        android_green();
-        y = draw_text("Charging!", -1, -1);
-        draw_text("?\?/100", -1, y + 25);
-    }
-}
-
-static void draw_battery(struct charger *charger)
-{
-    struct animation *batt_anim = charger->batt_anim;
-    struct frame *frame = &batt_anim->frames[batt_anim->cur_frame];
-
-    if (batt_anim->num_frames != 0) {
-        draw_surface_centered(charger, frame->surface);
-        LOGV("drawing frame #%d min_cap=%d time=%d\n",
-             batt_anim->cur_frame, frame->min_capacity,
-             frame->disp_time);
-    }
-}
-
-#ifdef CHARGER_SHOW_PERCENTAGE
-#define STR_LEN    64
-static void draw_capacity(struct charger *charger)
-{
-    char cap_str[STR_LEN];
-    int x, y;
-    int str_len_px;
-
-    snprintf(cap_str, (STR_LEN - 1), "%d%%", charger->batt_anim->capacity);
-    str_len_px = gr_measure(cap_str);
-    x = (gr_fb_width() - str_len_px) / 2;
-    y = (gr_fb_height() + char_height) / 2;
-    android_green();
-    gr_text(x, y, cap_str, 0);
-}
-#endif
-
-static void redraw_screen(struct charger *charger)
-{
-    struct animation *batt_anim = charger->batt_anim;
-
-    clear_screen();
-
-    /* try to display *something* */
-    if (batt_anim->capacity < 0 || batt_anim->num_frames == 0) {
-        draw_unknown(charger);
-    } else {
-        draw_battery(charger);
-#ifdef CHARGER_SHOW_PERCENTAGE
-        draw_capacity(charger);
-#endif
-    }
-    gr_flip();
-}
-
-static void kick_animation(struct animation *anim)
-{
-    anim->run = true;
-}
-
-static void reset_animation(struct animation *anim)
-{
-    anim->cur_cycle = 0;
-    anim->cur_frame = 0;
-    anim->run = false;
-}
-
-static void update_screen_state(struct charger *charger, int64_t now)
-{
-    struct animation *batt_anim = charger->batt_anim;
-    int cur_frame;
-    int disp_time;
-
-    if (!batt_anim->run || now < charger->next_screen_transition)
-        return;
-
-    if (!minui_inited) {
-        int batt_cap = get_battery_capacity();
-
-        if (batt_cap < SCREEN_ON_BATTERY_THRESH) {
-            LOGV("[%" PRId64 "] level %d, leave screen off\n", now, batt_cap);
-            batt_anim->run = false;
-            charger->next_screen_transition = -1;
-            if (charger->charger_connected)
-                request_suspend(true);
-            return;
-        }
-
-        gr_init();
-        gr_font_size(&char_width, &char_height);
-
-#ifndef CHARGER_DISABLE_INIT_BLANK
-        gr_fb_blank(true);
-#endif
-        minui_inited = true;
-    }
-
-    /* animation is over, blank screen and leave */
-    if (batt_anim->cur_cycle == batt_anim->num_cycles) {
-        reset_animation(batt_anim);
-        charger->next_screen_transition = -1;
-        set_backlight(false);
-        gr_fb_blank(true);
-        LOGV("[%" PRId64 "] animation done\n", now);
-        if (charger->charger_connected)
-            request_suspend(true);
-        return;
-    }
-
-    disp_time = batt_anim->frames[batt_anim->cur_frame].disp_time;
-
-    /* animation starting, set up the animation */
-    if (batt_anim->cur_frame == 0) {
-        int batt_cap;
-        int ret;
-
-        LOGV("[%" PRId64 "] animation starting\n", now);
-        batt_cap = get_battery_capacity();
-        if (batt_cap >= 0 && batt_anim->num_frames != 0) {
-            int i;
-
-            /* find first frame given current capacity */
-            for (i = 1; i < batt_anim->num_frames; i++) {
-                if (batt_cap < batt_anim->frames[i].min_capacity)
-                    break;
-            }
-            batt_anim->cur_frame = i - 1;
-
-            /* show the first frame for twice as long */
-            disp_time = batt_anim->frames[batt_anim->cur_frame].disp_time * 2;
-        }
-
-        batt_anim->capacity = batt_cap;
-    }
-
-    /* unblank the screen on first cycle */
-    if (batt_anim->cur_cycle == 0) {
-        gr_fb_blank(false);
-        set_backlight(true);
-    }
-
-    /* draw the new frame (@ cur_frame) */
-    redraw_screen(charger);
-
-    /* if we don't have anim frames, we only have one image, so just bump
-     * the cycle counter and exit
-     */
-    if (batt_anim->num_frames == 0 || batt_anim->capacity < 0) {
-        LOGV("[%" PRId64 "] animation missing or unknown battery status\n", now);
-        charger->next_screen_transition = now + BATTERY_UNKNOWN_TIME;
-        batt_anim->cur_cycle++;
-        return;
-    }
-
-    /* schedule next screen transition */
-    charger->next_screen_transition = now + disp_time;
-
-    /* advance frame cntr to the next valid frame only if we are charging
-     * if necessary, advance cycle cntr, and reset frame cntr
-     */
-    if (charger->charger_connected) {
-        batt_anim->cur_frame++;
-
-        /* if the frame is used for level-only, that is only show it when it's
-         * the current level, skip it during the animation.
-         */
-        while (batt_anim->cur_frame < batt_anim->num_frames &&
-               batt_anim->frames[batt_anim->cur_frame].level_only)
-            batt_anim->cur_frame++;
-        if (batt_anim->cur_frame >= batt_anim->num_frames) {
-            batt_anim->cur_cycle++;
-            batt_anim->cur_frame = 0;
-
-            /* don't reset the cycle counter, since we use that as a signal
-             * in a test above to check if animation is over
-             */
-        }
-    } else {
-        /* Stop animating if we're not charging.
-         * If we stop it immediately instead of going through this loop, then
-         * the animation would stop somewhere in the middle.
-         */
-        batt_anim->cur_frame = 0;
-        batt_anim->cur_cycle++;
-    }
-}
-
-static int set_key_callback(int code, int value, void *data)
-{
-    struct charger *charger = (struct charger *)data;
-    int64_t now = curr_time_ms();
-    int down = !!value;
-
-    if (code > KEY_MAX)
-        return -1;
-
-    /* ignore events that don't modify our state */
-    if (charger->keys[code].down == down)
-        return 0;
-
-    /* only record the down even timestamp, as the amount
-     * of time the key spent not being pressed is not useful */
-    if (down)
-        charger->keys[code].timestamp = now;
-    charger->keys[code].down = down;
-    charger->keys[code].pending = true;
-    if (down) {
-        LOGV("[%" PRId64 "] key[%d] down\n", now, code);
-    } else {
-        int64_t duration = now - charger->keys[code].timestamp;
-        int64_t secs = duration / 1000;
-        int64_t msecs = duration - secs * 1000;
-        LOGV("[%" PRId64 "] key[%d] up (was down for %" PRId64 ".%" PRId64 "sec)\n",
-             now, code, secs, msecs);
-    }
-
-    return 0;
-}
-
-static void update_input_state(struct charger *charger,
-                               struct input_event *ev)
-{
-    if (ev->type != EV_KEY)
-        return;
-    set_key_callback(ev->code, ev->value, charger);
-}
-
-static void set_next_key_check(struct charger *charger,
-                               struct key_state *key,
-                               int64_t timeout)
-{
-    int64_t then = key->timestamp + timeout;
-
-    if (charger->next_key_check == -1 || then < charger->next_key_check)
-        charger->next_key_check = then;
-}
-
-static void process_key(struct charger *charger, int code, int64_t now)
-{
-    struct animation *batt_anim = charger->batt_anim;
-    struct key_state *key = &charger->keys[code];
-    int64_t next_key_check;
-
-    if (code == KEY_POWER) {
-        if (key->down) {
-            int64_t reboot_timeout = key->timestamp + POWER_ON_KEY_TIME;
-            if (now >= reboot_timeout) {
-                /* We do not currently support booting from charger mode on
-                   all devices. Check the property and continue booting or reboot
-                   accordingly. */
-                if (property_get_bool("ro.enable_boot_charger_mode", false)) {
-                    LOGI("[%" PRId64 "] booting from charger mode\n", now);
-                    property_set("sys.boot_from_charger_mode", "1");
-                } else {
-                    LOGI("[%" PRId64 "] rebooting\n", now);
-                    android_reboot(ANDROID_RB_RESTART, 0, 0);
-                }
-            } else {
-                /* if the key is pressed but timeout hasn't expired,
-                 * make sure we wake up at the right-ish time to check
-                 */
-                set_next_key_check(charger, key, POWER_ON_KEY_TIME);
-            }
-        } else {
-            /* if the power key got released, force screen state cycle */
-            if (key->pending) {
-                if (!batt_anim->run) {
-                    request_suspend(false);
-                    kick_animation(batt_anim);
-                } else {
-                    reset_animation(batt_anim);
-                    charger->next_screen_transition = -1;
-                    set_backlight(false);
-                    gr_fb_blank(true);
-                    if (charger->charger_connected)
-                        request_suspend(true);
-                }
-            }
-        }
-    } else {
-        if (key->pending) {
-            request_suspend(false);
-            kick_animation(charger->batt_anim);
-        }
-    }
-
-    key->pending = false;
-}
-
-static void handle_input_state(struct charger *charger, int64_t now)
-{
-    process_key(charger, KEY_POWER, now);
-    process_key(charger, KEY_HOME, now);
-
-    if (charger->next_key_check != -1 && now > charger->next_key_check)
-        charger->next_key_check = -1;
-}
-
-static void handle_power_supply_state(struct charger *charger, int64_t now)
-{
-    static int old_soc = 0;
-    int soc;
-
-    if (!charger->have_battery_state)
-        return;
-
-    soc = get_battery_capacity();
-    if (old_soc != soc) {
-        old_soc = soc;
-        set_battery_soc_leds(soc);
-    }
-
-    if (!charger->charger_connected) {
-        request_suspend(false);
-        if (charger->next_pwr_check == -1) {
-            if (mode == QUICKBOOT) {
-                set_backlight(false);
-                gr_fb_blank(true);
-                request_suspend(true);
-                /* exit here. There is no need to keep running when charger
-                 * unplugged under QuickBoot mode
-                 */
-                exit(0);
-            }
-            charger->next_pwr_check = now + UNPLUGGED_SHUTDOWN_TIME;
-            LOGI("[%" PRId64 "] device unplugged: shutting down in %" PRId64 " (@ %" PRId64 ")\n",
-                 now, (int64_t)UNPLUGGED_SHUTDOWN_TIME, charger->next_pwr_check);
-        } else if (now >= charger->next_pwr_check) {
-            LOGI("[%" PRId64 "] shutting down\n", now);
-            android_reboot(ANDROID_RB_POWEROFF, 0, 0);
-        } else {
-            /* otherwise we already have a shutdown timer scheduled */
-        }
-    } else {
-        /* online supply present, reset shutdown timer if set */
-        if (charger->next_pwr_check != -1) {
-            LOGI("[%" PRId64 "] device plugged in: shutdown cancelled\n", now);
-            kick_animation(charger->batt_anim);
-        }
-        charger->next_pwr_check = -1;
-    }
-}
-
-void healthd_mode_charger_heartbeat()
-{
-    struct charger *charger = &charger_state;
-    int64_t now = curr_time_ms();
-    int ret;
-
-    handle_input_state(charger, now);
-    handle_power_supply_state(charger, now);
-
-    /* do screen update last in case any of the above want to start
-     * screen transitions (animations, etc)
-     */
-    update_screen_state(charger, now);
-}
-
-void healthd_mode_charger_battery_update(
-    struct android::BatteryProperties *props)
-{
-    struct charger *charger = &charger_state;
-
-    charger->charger_connected =
-        props->chargerAcOnline || props->chargerUsbOnline ||
-        props->chargerWirelessOnline;
-    charger->capacity = props->batteryLevel;
-
-    if (!charger->have_battery_state) {
-        charger->have_battery_state = true;
-        charger->next_screen_transition = curr_time_ms() - 1;
-        reset_animation(charger->batt_anim);
-        kick_animation(charger->batt_anim);
-    }
-}
-
-int healthd_mode_charger_preparetowait(void)
-{
-    struct charger *charger = &charger_state;
-    int64_t now = curr_time_ms();
-    int64_t next_event = INT64_MAX;
-    int64_t timeout;
-    struct input_event ev;
-    int ret;
-
-    LOGV("[%" PRId64 "] next screen: %" PRId64 " next key: %" PRId64 " next pwr: %" PRId64 "\n", now,
-         charger->next_screen_transition, charger->next_key_check,
-         charger->next_pwr_check);
-
-    if (charger->next_screen_transition != -1)
-        next_event = charger->next_screen_transition;
-    if (charger->next_key_check != -1 && charger->next_key_check < next_event)
-        next_event = charger->next_key_check;
-    if (charger->next_pwr_check != -1 && charger->next_pwr_check < next_event)
-        next_event = charger->next_pwr_check;
-
-    if (next_event != -1 && next_event != INT64_MAX)
-        timeout = max(0, next_event - now);
-    else
-        timeout = -1;
-
-   return (int)timeout;
-}
-
-static int input_callback(int fd, unsigned int epevents, void *data)
-{
-    struct charger *charger = (struct charger *)data;
-    struct input_event ev;
-    int ret;
-
-    ret = ev_get_input(fd, epevents, &ev);
-    if (ret)
-        return -1;
-    update_input_state(charger, &ev);
-    return 0;
-}
-
-static void charger_event_handler(uint32_t /*epevents*/)
-{
-    int ret;
-
-    ret = ev_wait(-1);
-    if (!ret)
-        ev_dispatch();
-}
-
-void healthd_mode_charger_init(struct healthd_config* /*config*/)
-{
-    int ret;
-    int charging_enabled = 1;
-    struct charger *charger = &charger_state;
-    int i;
-    int epollfd;
-
-    dump_last_kmsg();
-
-    LOGI("--------------- STARTING CHARGER MODE ---------------\n");
-
-    if (mode == NORMAL) {
-        /* check the charging is enabled or not */
-        ret = read_file_int(CHARGING_ENABLED_PATH, &charging_enabled);
-        if (!ret && !charging_enabled) {
-            /* if charging is disabled, reboot and exit power off charging */
-            LOGI("android charging is disabled, exit!\n");
-            android_reboot(ANDROID_RB_RESTART, 0, 0);
-        }
-    }
-
-    ret = ev_init(input_callback, charger);
-    if (!ret) {
-        epollfd = ev_get_epollfd();
-        healthd_register_event(epollfd, charger_event_handler);
-    }
-
-    ret = res_create_display_surface("charger/battery_fail", &charger->surf_unknown);
-    if (ret < 0) {
-        LOGE("Cannot load battery_fail image\n");
-        charger->surf_unknown = NULL;
-    }
-
-    charger->batt_anim = &battery_animation;
-
-    gr_surface* scale_frames;
-    int scale_count;
-    ret = res_create_multi_display_surface("charger/battery_scale", &scale_count, &scale_frames);
-    if (ret < 0) {
-        LOGE("Cannot load battery_scale image\n");
-        charger->batt_anim->num_frames = 0;
-        charger->batt_anim->num_cycles = 1;
-    } else if (scale_count != charger->batt_anim->num_frames) {
-        LOGE("battery_scale image has unexpected frame count (%d, expected %d)\n",
-             scale_count, charger->batt_anim->num_frames);
-        charger->batt_anim->num_frames = 0;
-        charger->batt_anim->num_cycles = 1;
-    } else {
-        for (i = 0; i < charger->batt_anim->num_frames; i++) {
-            charger->batt_anim->frames[i].surface = scale_frames[i];
-        }
-    }
-
-    ev_sync_key_state(set_key_callback, charger);
-
-    charger->next_screen_transition = -1;
-    charger->next_key_check = -1;
-    charger->next_pwr_check = -1;
-}
diff --git a/healthd/healthd_msm.h b/healthd/healthd_msm.h
deleted file mode 100644
index 6c46b20..0000000
--- a/healthd/healthd_msm.h
+++ /dev/null
@@ -1,20 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef _HEALTHD_MSM_H_
-#define _HEALTHD_MSM_H_
-void power_off_alarm_init(void);
-#endif /* _HEALTHD_MSM_H_ */
diff --git a/healthd/healthd_msm_alarm.cpp b/healthd/healthd_msm_alarm.cpp
deleted file mode 100644
index cbe809a..0000000
--- a/healthd/healthd_msm_alarm.cpp
+++ /dev/null
@@ -1,216 +0,0 @@
-/*
- * Copyright (C) 2014 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <errno.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <sys/stat.h>
-#include <sys/types.h>
-#include <time.h>
-#include <unistd.h>
-
-#include <cutils/android_reboot.h>
-#include <cutils/klog.h>
-#include <cutils/misc.h>
-#include <cutils/uevent.h>
-#include <cutils/properties.h>
-
-#include <pthread.h>
-#include <linux/android_alarm.h>
-#include <linux/rtc.h>
-
-#include "healthd_msm.h"
-
-#define LOGE(x...) do { KLOG_ERROR("charger", x); } while (0)
-#define LOGI(x...) do { KLOG_INFO("charger", x); } while (0)
-#define LOGV(x...) do { KLOG_DEBUG("charger", x); } while (0)
-
-enum alarm_time_type {
-    ALARM_TIME,
-    RTC_TIME,
-};
-
-/*
- * shouldn't be changed after
- * reading from alarm register
- */
-static time_t alm_secs;
-
-static int alarm_get_time(enum alarm_time_type time_type,
-                          time_t *secs)
-{
-    struct tm tm;
-    unsigned int cmd;
-    int rc, fd = -1;
-
-    if (!secs)
-        return -1;
-
-    fd = open("/dev/rtc0", O_RDWR);
-    if (fd < 0) {
-        LOGE("Can't open rtc devfs node\n");
-        return -1;
-    }
-
-    switch (time_type) {
-        case ALARM_TIME:
-            cmd = RTC_ALM_READ;
-            break;
-        case RTC_TIME:
-            cmd = RTC_RD_TIME;
-            break;
-        default:
-            LOGE("Invalid time type\n");
-            goto err;
-    }
-
-    rc = ioctl(fd, cmd, &tm);
-    if (rc < 0) {
-        LOGE("Unable to get time\n");
-        goto err;
-    }
-
-    *secs = mktime(&tm) + tm.tm_gmtoff;
-    if (*secs < 0) {
-        LOGE("Invalid seconds = %ld\n", *secs);
-        goto err;
-    }
-
-    close(fd);
-    return 0;
-
-err:
-    close(fd);
-    return -1;
-}
-
-#define ERR_SECS 2
-static int alarm_is_alm_expired()
-{
-    int rc;
-    time_t rtc_secs;
-
-    rc = alarm_get_time(RTC_TIME, &rtc_secs);
-    if (rc < 0)
-        return 0;
-
-    return (alm_secs >= rtc_secs - ERR_SECS &&
-            alm_secs <= rtc_secs + ERR_SECS) ? 1 : 0;
-}
-
-static int alarm_set_reboot_time_and_wait(time_t secs)
-{
-    int rc, fd;
-    struct timespec ts;
-
-    fd = open("/dev/alarm", O_RDWR);
-    if (fd < 0) {
-        LOGE("Can't open alarm devfs node\n");
-        goto err;
-    }
-
-    /* get the elapsed realtime from boot time to now */
-    rc = ioctl(fd, ANDROID_ALARM_GET_TIME(
-                      ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP), &ts);
-    if (rc < 0) {
-        LOGE("Unable to get elapsed realtime\n");
-        goto err;
-    }
-
-    /* calculate the elapsed time from boot time to reboot time */
-    ts.tv_sec += secs;
-    ts.tv_nsec = 0;
-
-    rc = ioctl(fd, ANDROID_ALARM_SET(
-                      ANDROID_ALARM_ELAPSED_REALTIME_WAKEUP), &ts);
-    if (rc < 0) {
-        LOGE("Unable to set reboot time to %ld\n", secs);
-        goto err;
-    }
-
-    do {
-        rc = ioctl(fd, ANDROID_ALARM_WAIT);
-    } while ((rc < 0 && errno == EINTR) || !alarm_is_alm_expired());
-
-    if (rc <= 0) {
-        LOGE("Unable to wait on alarm\n");
-        goto err;
-    }
-
-    close(fd);
-    return 0;
-
-err:
-    if (fd >= 0)
-        close(fd);
-    return -1;
-}
-
-static void *alarm_thread(void *)
-{
-    time_t rtc_secs, rb_secs;
-    int rc;
-
-    /*
-     * to support power off alarm, the time
-     * stored in alarm register at latest
-     * shutdown time should be some time
-     * earlier than the actual alarm time
-     * set by user
-     */
-    rc = alarm_get_time(ALARM_TIME, &alm_secs);
-    if (rc < 0 || !alm_secs)
-        goto err;
-
-    rc = alarm_get_time(RTC_TIME, &rtc_secs);
-    if (rc < 0)
-        goto err;
-
-    /*
-     * calculate the reboot time after which
-     * the phone will reboot
-     */
-    rb_secs = alm_secs - rtc_secs;
-    if (rb_secs <= 0)
-        goto err;
-
-    rc = alarm_set_reboot_time_and_wait(rb_secs);
-    if (rc < 0)
-        goto err;
-
-    LOGI("Exit from power off charging, reboot the phone!\n");
-    android_reboot(ANDROID_RB_RESTART2, 0, (char *)"rtc");
-
-err:
-    LOGE("Exit from alarm thread\n");
-    return NULL;
-}
-
-void power_off_alarm_init(void)
-{
-    pthread_t tid;
-    int rc;
-    char value[PROP_VALUE_MAX];
-
-    property_get("ro.bootmode", value, "");
-    if (!strcmp("charger", value)) {
-        rc = pthread_create(&tid, NULL, alarm_thread, NULL);
-        if (rc < 0)
-            LOGE("Create alarm thread failed\n");
-    }
-}
diff --git a/healthd/images/battery_fail.png b/healthd/images/battery_fail.png
deleted file mode 100644
index aded88a002798346576c21555001a851f153c84a..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 1368
zcmbVMeN5bB7%ySjbQwYXV}hHrDamxYyT0ww>qqXuyWX*#?ic~)E^f{%y_chbwzsxG
z!H?mHAH*pBqbM%hGMt)dh&ZPpQ#o%Y60;?2GTo33qA^j&#xjYUS=6_{p(bR1_@sT_
z_j&s~zvuI9XJy5vyp?yZ#4s!`vN=?RRvW#a+=3YP0C}b#Ek#y1W>xETR*PgnERfJ^
zAs$hsB&>o`qILHO^kG<Tol+CCV$m&vtgCLx(Q(^q%0a<=Wp+xE8=!^P!la`4iOWNu
z6S$J_6Wf_6h^9nXuWW8JV0BwXjoj8C^9iD?6!+Nz0#KnP;kMeSnS$*n=5PhHcaBK{
zpHs0K{KR}vv1lbO>ITFaH*m?o3ve&xraUDq%WlMJKmiiaBt^R@R`AdQ0QdqC$eWR<
z6RJYx3%-!#C+aOLC6HuGON+b3<JOHNN%1`IV9>M+X}HW*&5~@FW)^1=LeP{AC1okP
zhC7H-t=?q$2^8sk3Ti4ET?E$5g+if{k+zf~DK{Wh)yZp4+qA0SKVdAXZPv7=AXx=X
zy~&VKKkACJ#;A5TcjPFdXoRhXf|?>VhIF|}g_;!!`3dyJolp`25W_sn2E$&8ro9|R
z@f6_saF}5L;KUNHJd3fEtymtSy-YY527G{`5NE<XC-R;k7bqzS@?zFDqM4SY$uR3z
zL4Fr(12?r5L<35eZq(>{V|D^6>vc;v>-7{aRx@~1k`>L7o%YOU8-j+?3=`#suHtj`
z6_h3X1BL?>#g+h;22S1qHW=VJuNXklds)B}3$}^>Q!^3;LpsCpuVKj^p$T-hi=&T(
z#mfUVbYl#3H4d$zmSI@V^N~=X#?G1kc6aARa9jHo&ORP=9S?5&#^El+(eq<h5?}oj
z#|^ys{iWg2*Pj``?3w9!x#+cnvs<4!{nx?SlVG0SKXz~Y*Y*y1cuCrmTfqyN!HaJ{
zv8{{VbO)zL`=(#u_vK&je|XCj_kqZqO%IM7S$)4<aCmI_$wME-hWk5rdE427Put3T
zBS)LpZtHtxe5z^LFSlosSJ#WP%>xfU*2>9OPt5#w?f16==e1{(KcCA~7G3yb*MM(L
z&wY=+I&-?KdwQ~X=Oe48HtgyC;&9`NuAJ`e>7g-h!<Xm%cTJtjynDCr=(_zkCe58c
zXfx}d9LZZZ!Px2E$II{GUeX>)uh?Hv)YFl_?~T!0dq4bYjA?KB_(U2zGtsj*=e?mF
zt4dR+4xC+HI(vnA`p9Po)JgSN?~TcGnbCqv6UEokgU@|Ep1z(Jcg5rJ4smTEqF8=m
j;diA-{tsPfe=+w@tkC_AnYW|abpCaba7Cyu7~lIha#-=&

diff --git a/healthd/images/battery_scale.png b/healthd/images/battery_scale.png
deleted file mode 100644
index 2ae8f0fd7e501b439dfdda2486e87b5b6ba54d4d..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 463
zcmeAS@N?(olHy`uVBq!ia0vp^6$}h4F)YkL)?y2fOF)W0z$e5NNdE_cGeBT$Z2VW?
zhXYWEqr^3$#H}bXH?^3-EdIluXABIC>7Fi*Ar*{ouWjUPFc5LQ$ibIjR>1Oo{yDpZ
zkD(PUbHblHSzOJ3yzSqP;+p8r{wSS&VJwS%r6qE2CEePR$&A8`zGMI9c!Z8v_tB({
zJN8ED+<Sa~p66_{T%f|s%Y0{VtKMw@Wx~Y>GWr@W0<{uUMo>-b#d#t<lpC|95z{&D
k5bt3%JZU31JRV6qWUTo+<N0(>U^Fmzy85}Sb4q9e0C{iTuK)l5

-- 
2.5.0

