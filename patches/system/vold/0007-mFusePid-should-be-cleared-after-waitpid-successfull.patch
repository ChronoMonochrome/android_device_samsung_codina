From 390d8960f1d4bb964f4fbd1d38a4327568177863 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 20 Aug 2018 22:57:43 +0300
Subject: [PATCH 07/10] mFusePid should be cleared after waitpid successfully

When waitpid is successful, we need to reset mFusePid
since mFusePid will be killed again unnecessarily
in doUnmount() if we don't reset mFusePid.

As a result, it will kill another unrelated process
in the case of pids wrap around.
---
 EmulatedVolume.cpp | 3 +++
 PublicVolume.cpp   | 3 +++
 2 files changed, 6 insertions(+)

diff --git a/EmulatedVolume.cpp b/EmulatedVolume.cpp
index eac2f86..7344abf 100644
--- a/EmulatedVolume.cpp
+++ b/EmulatedVolume.cpp
@@ -116,6 +116,9 @@ status_t EmulatedVolume::doMount() {
         LOG(VERBOSE) << "Waiting for FUSE to spin up...";
         usleep(50000); // 50ms
     }
+    /* sdcardfs will have exited already. FUSE will still be running */
+    if (TEMP_FAILURE_RETRY(waitpid(mFusePid, nullptr, WNOHANG)) == mFusePid)
+        mFusePid = 0;
 
     return OK;
 }
diff --git a/PublicVolume.cpp b/PublicVolume.cpp
index c8070dd..d16f3d1 100644
--- a/PublicVolume.cpp
+++ b/PublicVolume.cpp
@@ -245,6 +245,9 @@ status_t PublicVolume::doMount() {
         LOG(VERBOSE) << "Waiting for FUSE to spin up...";
         usleep(50000); // 50ms
     }
+    /* sdcardfs will have exited already. FUSE will still be running */
+    if (TEMP_FAILURE_RETRY(waitpid(mFusePid, nullptr, WNOHANG)) == mFusePid)
+        mFusePid = 0;
 
     return OK;
 }
-- 
2.11.0

