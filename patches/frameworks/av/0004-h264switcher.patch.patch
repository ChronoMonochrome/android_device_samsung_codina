From 92134c34efcb4ae67c8041a6232fb493a1cb248d Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Fri, 17 Jul 2015 22:28:04 +0300
Subject: [PATCH 4/6] h264switcher.patch

Change-Id: I781177b3578c6d4f5ea0514723614da72fa7084b
---
 media/libstagefright/MediaCodecList.cpp | 58 +++++++++++++++++++++++++++++++++
 1 file changed, 58 insertions(+)

diff --git a/media/libstagefright/MediaCodecList.cpp b/media/libstagefright/MediaCodecList.cpp
index b1815f3..5a67d11 100644
--- a/media/libstagefright/MediaCodecList.cpp
+++ b/media/libstagefright/MediaCodecList.cpp
@@ -26,6 +26,8 @@
 #include <media/stagefright/OMXCodec.h>
 #include <utils/threads.h>
 
+#include <cutils/properties.h>
+
 #include <libexpat/expat.h>
 #ifdef QCOM_HARDWARE
 #include "include/ExtendedUtils.h"
@@ -446,6 +448,17 @@ ssize_t MediaCodecList::findCodecByType(
 }
 
 ssize_t MediaCodecList::findCodecByName(const char *name) const {
+
+
+    char prop_retrieved_value[PROPERTY_VALUE_MAX];
+
+    int ret = property_get("vu.co.meticulus.h264switch", prop_retrieved_value, "false");
+
+    if(strcmp(name, "OMX.ST.VFM.H264Dec") == 0 && strcmp(prop_retrieved_value, "true") == 0){
+	ALOGI("h264switch: %s - %s -> OMX.google.h264.decoder",__func__,name);
+	name = "OMX.google.h264.decoder";
+    }
+
     for (size_t i = 0; i < mCodecInfos.size(); ++i) {
         const CodecInfo &info = mCodecInfos.itemAt(i);
 
@@ -465,8 +478,19 @@ const char *MediaCodecList::getCodecName(size_t index) const {
     if (index >= mCodecInfos.size()) {
         return NULL;
     }
+    const CodecInfo &binfo = mCodecInfos.itemAt(index);
+
+    char prop_retrieved_value[PROPERTY_VALUE_MAX];
+
+    int ret = property_get("vu.co.meticulus.h264switch", prop_retrieved_value, "false");
+
+    if(strcmp(binfo.mName.c_str(), "OMX.ST.VFM.H264Dec") == 0 && strcmp(prop_retrieved_value, "true") == 0){
+	ALOGI("h264switch: %s - %s -> OMX.google.h264.decoder",__func__,binfo.mName.c_str());
+	index = findCodecByName("OMX.google.h264.decoder");
+    }
 
     const CodecInfo &info = mCodecInfos.itemAt(index);
+
     return info.mName.c_str();
 }
 
@@ -485,6 +509,17 @@ bool MediaCodecList::codecHasQuirk(
         return NULL;
     }
 
+    const CodecInfo &binfo = mCodecInfos.itemAt(index);
+
+    char prop_retrieved_value[PROPERTY_VALUE_MAX];
+
+    int ret = property_get("vu.co.meticulus.h264switch", prop_retrieved_value, "false");
+
+    if(strcmp(binfo.mName.c_str(), "OMX.ST.VFM.H264Dec") == 0 && strcmp(prop_retrieved_value, "true") == 0){
+	ALOGI("h264switch: %s - %s -> OMX.google.h264.decoder",__func__,binfo.mName.c_str());
+	index = findCodecByName("OMX.google.h264.decoder");
+    }
+
     const CodecInfo &info = mCodecInfos.itemAt(index);
 
     if (info.mQuirks != 0) {
@@ -505,6 +540,17 @@ status_t MediaCodecList::getSupportedTypes(
         return -ERANGE;
     }
 
+    const CodecInfo &binfo = mCodecInfos.itemAt(index);
+
+    char prop_retrieved_value[PROPERTY_VALUE_MAX];
+
+    int ret = property_get("vu.co.meticulus.h264switch", prop_retrieved_value, "false");
+
+    if(strcmp(binfo.mName.c_str(), "OMX.ST.VFM.H264Dec") == 0 && strcmp(prop_retrieved_value, "true") == 0){
+	ALOGI("h264switch: %s - %s -> OMX.google.h264.decoder",__func__,binfo.mName.c_str());
+	index = findCodecByName("OMX.google.h264.decoder");
+    }
+
     const CodecInfo &info = mCodecInfos.itemAt(index);
 
     for (size_t i = 0; i < mTypes.size(); ++i) {
@@ -530,6 +576,18 @@ status_t MediaCodecList::getCodecCapabilities(
         return -ERANGE;
     }
 
+    const CodecInfo &binfo = mCodecInfos.itemAt(index);
+
+    char prop_retrieved_value[PROPERTY_VALUE_MAX];
+
+    int ret = property_get("vu.co.meticulus.h264switch", prop_retrieved_value, "false");
+
+    if(strcmp(binfo.mName.c_str(), "OMX.ST.VFM.H264Dec") == 0 && strcmp(prop_retrieved_value, "true") == 0){
+	ALOGI("h264switch: %s - %s -> OMX.google.h264.decoder",__func__,binfo.mName.c_str());
+	index = findCodecByName("OMX.google.h264.decoder");
+	
+    }
+
     const CodecInfo &info = mCodecInfos.itemAt(index);
 
     OMXClient client;
-- 
1.9.1

