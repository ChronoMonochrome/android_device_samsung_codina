From da340b552b54a380b45468b0aefadf42ca4c5b62 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 11 May 2015 04:53:33 +0300
Subject: [PATCH 07/13] Revert "frameworks-av_001-AV-fix.patch"

This reverts commit 23faafeb5c9c6f45c39f5eadcf0b8846a5490f1a.
---
 include/media/stagefright/ColorConverter.h         |    5 -
 include/media/stagefright/MediaDefs.h              |    6 -
 include/media/stagefright/OMXCodec.h               |   85 +-
 media/libstagefright/ACodec.cpp                    |  590 +----------
 media/libstagefright/CameraSource.cpp              |   15 -
 media/libstagefright/MediaDefs.cpp                 |    6 -
 media/libstagefright/OMXCodec.cpp                  | 1079 ++------------------
 .../colorconversion/ColorConverter.cpp             |  145 ---
 8 files changed, 141 insertions(+), 1790 deletions(-)
 mode change 100755 => 100644 media/libstagefright/ACodec.cpp

diff --git a/include/media/stagefright/ColorConverter.h b/include/media/stagefright/ColorConverter.h
index e34791c..85ba920 100644
--- a/include/media/stagefright/ColorConverter.h
+++ b/include/media/stagefright/ColorConverter.h
@@ -72,11 +72,6 @@ private:
 
     status_t convertQCOMYUV420SemiPlanar(
             const BitmapParams &src, const BitmapParams &dst);
-			
-#ifdef STE_HARDWARE
-    status_t convertSTEYUV420PackedSemiPlanarMB(
-            const BitmapParams &src, const BitmapParams &dst);
-#endif
 
     status_t convertYUV420SemiPlanar(
             const BitmapParams &src, const BitmapParams &dst);
diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
index 663d64c..13695d5 100644
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -28,14 +28,8 @@ extern const char *MEDIA_MIMETYPE_VIDEO_AVC;
 extern const char *MEDIA_MIMETYPE_VIDEO_HEVC;
 extern const char *MEDIA_MIMETYPE_VIDEO_MPEG4;
 extern const char *MEDIA_MIMETYPE_VIDEO_H263;
-#ifdef STE_HARDWARE
-extern const char *MEDIA_MIMETYPE_VIDEO_H263_SW;
-#endif
 extern const char *MEDIA_MIMETYPE_VIDEO_MPEG2;
 extern const char *MEDIA_MIMETYPE_VIDEO_RAW;
-#ifdef STE_HARDWARE
-extern const char *MEDIA_MIMETYPE_VIDEO_VC1;
-#endif
 
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_NB;
 extern const char *MEDIA_MIMETYPE_AUDIO_AMR_WB;
diff --git a/include/media/stagefright/OMXCodec.h b/include/media/stagefright/OMXCodec.h
index df23858..e341160 100644
--- a/include/media/stagefright/OMXCodec.h
+++ b/include/media/stagefright/OMXCodec.h
@@ -12,25 +12,6 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- *
- * This file was modified by Dolby Laboratories, Inc. The portions of the
- * code that are surrounded by "DOLBY..." are copyrighted and
- * licensed separately, as follows:
- *
- *  (C) 2014 Dolby Laboratories, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
  */
 
 #ifndef OMX_CODEC_H_
@@ -45,15 +26,6 @@
 
 #include <OMX_Audio.h>
 
-#include <media/stagefright/ExtendedStats.h>
-
-#define PLAYER_STATS(func, ...) \
-    do { \
-        if(mPlayerExtendedStats != NULL) { \
-            mPlayerExtendedStats->func(__VA_ARGS__);} \
-    } \
-    while(0)
-
 namespace android {
 
 struct MediaCodecInfo;
@@ -114,10 +86,6 @@ struct OMXCodec : public MediaSource,
     // from MediaBufferObserver
     virtual void signalBufferReturned(MediaBuffer *buffer);
 
-#ifdef STE_HARDWARE
-    static uint32_t OmxToHALFormat(OMX_COLOR_FORMATTYPE omxValue);
-#endif
-
     enum Quirks {
         kNeedsFlushBeforeDisable              = 1,
         kWantsNALFragments                    = 2,
@@ -132,11 +100,6 @@ struct OMXCodec : public MediaSource,
         kSupportsMultipleFramesPerInputBuffer = 1024,
         kRequiresLargerEncoderOutputBuffer    = 2048,
         kOutputBuffersAreUnreadable           = 4096,
-#ifdef STE_HARDWARE
-        kRequiresStoreMetaDataBeforeIdle      = 16384,
-#endif
-        kRequiresGlobalFlush                  = 0x20000000, // 2^29
-        kRequiresWMAProComponent              = 0x40000000, //2^30
     };
 
     struct CodecNameAndQuirks {
@@ -156,19 +119,11 @@ struct OMXCodec : public MediaSource,
 
     static bool findCodecQuirks(const char *componentName, uint32_t *quirks);
 
-    // If profile/level is set in the meta data, its value in the meta
-    // data will be used; otherwise, the default value will be used.
-    status_t getVideoProfileLevel(const sp<MetaData>& meta,
-            const CodecProfileLevel& defaultProfileLevel,
-            CodecProfileLevel& profileLevel);
-
 protected:
     virtual ~OMXCodec();
 
 private:
 
-    sp<PlayerExtendedStats> mPlayerExtendedStats;
-
     // Make sure mLock is accessible to OMXCodecObserver
     friend class OMXCodecObserver;
 
@@ -184,14 +139,10 @@ private:
         EXECUTING_TO_IDLE,
         IDLE_TO_LOADED,
         RECONFIGURING,
-        PAUSING,
-        FLUSHING,
-        PAUSED,
         ERROR
     };
 
     enum {
-        kPortIndexBoth   = -1,
         kPortIndexInput  = 0,
         kPortIndexOutput = 1
     };
@@ -218,7 +169,6 @@ private:
         size_t mSize;
         void *mData;
         MediaBuffer *mMediaBuffer;
-        bool mOutputCropChanged;
     };
 
     struct CodecSpecificData {
@@ -265,11 +215,6 @@ private:
     Condition mAsyncCompletion;
 
     bool mPaused;
-#ifdef DOLBY_UDC
-    // Indicate if processed audio is being provided by Dolby decoder
-    bool mDolbyProcessedAudio;
-    bool mDolbyProcessedAudioStateChanged;
-#endif // DOLBY_END
 
     sp<ANativeWindow> mNativeWindow;
 
@@ -326,6 +271,12 @@ private:
     status_t isColorFormatSupported(
             OMX_COLOR_FORMATTYPE colorFormat, int portIndex);
 
+    // If profile/level is set in the meta data, its value in the meta
+    // data will be used; otherwise, the default value will be used.
+    status_t getVideoProfileLevel(const sp<MetaData>& meta,
+            const CodecProfileLevel& defaultProfileLevel,
+            CodecProfileLevel& profileLevel);
+
     status_t setVideoOutputFormat(
             const char *mime, const sp<MetaData>& meta);
 
@@ -340,27 +291,8 @@ private:
     void setRawAudioFormat(
             OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels);
 
-    //video
-    status_t setWMVFormat(const sp<MetaData> &inputFormat);
-    status_t setRVFormat(const sp<MetaData> &inputFormat);
-    status_t setFFmpegVideoFormat(const sp<MetaData> &inputFormat);
-    //audio
-    status_t setMP3Format(const sp<MetaData> &inputFormat);
-    status_t setWMAFormat(const sp<MetaData> &inputFormat);
-    status_t setVORBISFormat(const sp<MetaData> &inputFormat);
-    status_t setRAFormat(const sp<MetaData> &inputFormat);
-    status_t setFLACFormat(const sp<MetaData> &inputFormat);
-    status_t setMP2Format(const sp<MetaData> &inputFormat);
-    status_t setAC3Format(const sp<MetaData> &inputFormat);
-    status_t setAPEFormat(const sp<MetaData> &inputFormat);
-    status_t setDTSFormat(const sp<MetaData> &inputFormat);
-    status_t setFFmpegAudioFormat(const sp<MetaData> &inputFormat);
-
     status_t allocateBuffers();
     status_t allocateBuffersOnPort(OMX_U32 portIndex);
-#ifdef USE_SAMSUNG_COLORFORMAT
-    void setNativeWindowColorFormat(OMX_COLOR_FORMATTYPE &eNativeColorFormat);
-#endif
     status_t allocateOutputBuffersFromNativeWindow();
 
     status_t queueBufferToNativeWindow(BufferInfo *info);
@@ -418,7 +350,6 @@ private:
     status_t applyRotation();
     status_t waitForBufferFilled_l();
 
-    status_t resumeLocked(bool drainInputBuf);
     int64_t getDecodingTimeUs();
 
     status_t parseHEVCCodecSpecificData(
@@ -432,10 +363,6 @@ private:
 
     OMXCodec(const OMXCodec &);
     OMXCodec &operator=(const OMXCodec &);
-
-    int32_t mNumBFrames;
-    bool mInSmoothStreamingMode;
-    bool mOutputCropChanged;
 };
 
 struct CodecCapabilities {
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
old mode 100755
new mode 100644
index ce6f2f6..faac586
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -12,43 +12,6 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- *
- * This file was modified by Dolby Laboratories, Inc. The portions of the
- * code that are surrounded by "DOLBY..." are copyrighted and
- * licensed separately, as follows:
- *
- *  (C) 2011-2015 Dolby Laboratories, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- **
- ** This file was modified by DTS, Inc. The portions of the
- ** code that are surrounded by "DTS..." are copyrighted and
- ** licensed separately, as follows:
- **
- **  (C) 2014 DTS, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **    http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License
  */
 
 //#define LOG_NDEBUG 0
@@ -77,8 +40,6 @@
 #include <media/stagefright/NativeWindowWrapper.h>
 #include <media/stagefright/OMXClient.h>
 #include <media/stagefright/OMXCodec.h>
-#include <media/stagefright/ExtendedCodec.h>
-#include <media/stagefright/FFMPEGSoftCodec.h>
 
 #include <media/hardware/HardwareAPI.h>
 
@@ -87,23 +48,8 @@
 #include <OMX_Component.h>
 #include <OMX_IndexExt.h>
 
-#include "include/ExtendedUtils.h"
-
-#ifdef USE_SAMSUNG_COLORFORMAT
-#include <sec_format.h>
-#endif
-
 #include "include/avc_utils.h"
 
-#ifdef ENABLE_AV_ENHANCEMENTS
-#include <QCMediaDefs.h>
-#include <ExtendedUtils.h>
-#endif
-#ifdef DTS_CODEC_M_
-#include "include/DTSUtils.h"
-#include "include/OMX_Audio_DTS.h"
-#endif
-
 namespace android {
 
 // OMX errors are directly mapped into status_t range if
@@ -476,10 +422,7 @@ ACodec::ACodec()
       mTimePerFrameUs(-1ll),
       mTimePerCaptureUs(-1ll),
       mCreateInputBuffersSuspended(false),
-      mTunneled(false),
-      mIsVideoRenderingDisabled(false),
-      mEncoderComponent(false),
-      mComponentAllocByName(false) {
+      mTunneled(false) {
     mUninitializedState = new UninitializedState(this);
     mLoadedState = new LoadedState(this);
     mLoadedToIdleState = new LoadedToIdleState(this);
@@ -525,9 +468,6 @@ void ACodec::initiateAllocateComponent(const sp<AMessage> &msg) {
 }
 
 void ACodec::initiateConfigureComponent(const sp<AMessage> &msg) {
-    if (mMediaExtendedStats == NULL)
-        msg->findObject(MEDIA_EXTENDED_STATS, (sp<RefBase>*)&mMediaExtendedStats);
-
     msg->setWhat(kWhatConfigureComponent);
     msg->setTarget(id());
     msg->post();
@@ -581,14 +521,6 @@ void ACodec::signalSubmitOutputMetaDataBufferIfEOS_workaround() {
 }
 
 status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
-    ATRACE_NAME(mComponentName.c_str());
-
-    bool isVideo = mComponentName.find("video") != -1;
-    const char* portType = portIndex == kPortIndexInput ?
-                                        STATS_PROFILE_ALLOCATE_INPUT(isVideo) :
-                                        STATS_PROFILE_ALLOCATE_OUTPUT(isVideo);
-    ExtendedStats::AutoProfile autoProfile(portType, mMediaExtendedStats);
-
     CHECK(portIndex == kPortIndexInput || portIndex == kPortIndexOutput);
 
     CHECK(mDealer[portIndex] == NULL);
@@ -619,13 +551,7 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
                     def.nBufferCountActual, def.nBufferSize,
                     portIndex == kPortIndexInput ? "input" : "output");
 
-#ifdef MTK_HARDWARE
-            OMX_U32 memoryAlign = 32;
-            size_t totalSize = def.nBufferCountActual *
-                ((def.nBufferSize + (memoryAlign - 1))&(~(memoryAlign - 1)));
-#else
             size_t totalSize = def.nBufferCountActual * def.nBufferSize;
-#endif
             mDealer[portIndex] = new MemoryDealer(totalSize, "ACodec");
 
             for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
@@ -706,40 +632,11 @@ status_t ACodec::configureOutputBuffersFromNativeWindow(
         return err;
     }
 
-#ifdef USE_SAMSUNG_COLORFORMAT
-    OMX_COLOR_FORMATTYPE eNativeColorFormat = def.format.video.eColorFormat;
-    setNativeWindowColorFormat(eNativeColorFormat);
-
-    err = native_window_set_buffers_geometry(
-    mNativeWindow.get(),
-    def.format.video.nFrameWidth,
-    def.format.video.nFrameHeight,
-    eNativeColorFormat);
-#elif defined(MTK_HARDWARE)
-    OMX_U32 frameWidth = def.format.video.nFrameWidth;
-    OMX_U32 frameHeight = def.format.video.nFrameHeight;
-
-    if (!strncmp("OMX.MTK.", mComponentName.c_str(), 8)) {
-        frameWidth = def.format.video.nStride;
-        frameHeight = def.format.video.nSliceHeight;
-    }
-
-    err = native_window_set_buffers_geometry(
-            mNativeWindow.get(),
-            frameWidth,
-            frameHeight,
-            def.format.video.eColorFormat);
-#else
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
-#ifdef STE_HARDWARE
-            OMXCodec::OmxToHALFormat(def.format.video.eColorFormat));
-#else
             def.format.video.eColorFormat);
-#endif          
-#endif
 
     if (err != 0) {
         ALOGE("native_window_set_buffers_geometry failed: %s (%d)",
@@ -1032,26 +929,6 @@ status_t ACodec::submitOutputMetaDataBuffer() {
     return OK;
 }
 
-#ifdef USE_SAMSUNG_COLORFORMAT
-void ACodec::setNativeWindowColorFormat(OMX_COLOR_FORMATTYPE &eNativeColorFormat)
-{
-    // In case of Samsung decoders, we set proper native color format for the Native Window
-    if (!strcasecmp(mComponentName.c_str(), "OMX.SEC.AVC.Decoder")
-        || !strcasecmp(mComponentName.c_str(), "OMX.SEC.FP.AVC.Decoder")
-        || !strcasecmp(mComponentName.c_str(), "OMX.Exynos.AVC.Decoder")) {
-        switch (eNativeColorFormat) {
-            case OMX_COLOR_FormatYUV420SemiPlanar:
-                eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_SP;
-                break;
-            case OMX_COLOR_FormatYUV420Planar:
-            default:
-                eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_P;
-                break;
-        }
-    }
-}
-#endif
-
 status_t ACodec::cancelBufferToNativeWindow(BufferInfo *info) {
     CHECK_EQ((int)info->mStatus, (int)BufferInfo::OWNED_BY_US);
 
@@ -1071,6 +948,7 @@ status_t ACodec::cancelBufferToNativeWindow(BufferInfo *info) {
 
 ACodec::BufferInfo *ACodec::dequeueBufferFromNativeWindow() {
     ANativeWindowBuffer *buf;
+    int fenceFd = -1;
     CHECK(mNativeWindow.get() != NULL);
 
     if (mTunneled) {
@@ -1222,14 +1100,6 @@ status_t ACodec::setComponentRole(
             "audio_decoder.amrnb", "audio_encoder.amrnb" },
         { MEDIA_MIMETYPE_AUDIO_AMR_WB,
             "audio_decoder.amrwb", "audio_encoder.amrwb" },
-#ifdef ENABLE_AV_ENHANCEMENTS
-        { MEDIA_MIMETYPE_AUDIO_AMR_WB_PLUS,
-            "audio_decoder.amrwbplus", "audio_encoder.amrwbplus" },
-        { MEDIA_MIMETYPE_AUDIO_EVRC,
-            "audio_decoder.evrchw", "audio_encoder.evrc" },
-        { MEDIA_MIMETYPE_AUDIO_QCELP,
-            "audio_decoder,qcelp13Hw", "audio_encoder.qcelp13" },
-#endif
         { MEDIA_MIMETYPE_AUDIO_AAC,
             "audio_decoder.aac", "audio_encoder.aac" },
         { MEDIA_MIMETYPE_AUDIO_VORBIS,
@@ -1246,10 +1116,6 @@ status_t ACodec::setComponentRole(
             "video_decoder.hevc", "video_encoder.hevc" },
         { MEDIA_MIMETYPE_VIDEO_MPEG4,
             "video_decoder.mpeg4", "video_encoder.mpeg4" },
-#ifdef ENABLE_AV_ENHANCEMENTS			
-        { MEDIA_MIMETYPE_VIDEO_MPEG4_DP,
-            "video_decoder.mpeg4", NULL },
-#endif			
         { MEDIA_MIMETYPE_VIDEO_H263,
             "video_decoder.h263", "video_encoder.h263" },
         { MEDIA_MIMETYPE_VIDEO_VP8,
@@ -1258,35 +1124,16 @@ status_t ACodec::setComponentRole(
             "video_decoder.vp9", "video_encoder.vp9" },
         { MEDIA_MIMETYPE_AUDIO_RAW,
             "audio_decoder.raw", "audio_encoder.raw" },
-#ifdef ENABLE_AV_ENHANCEMENTS			
-#ifdef QTI_FLAC_DECODER
-        { MEDIA_MIMETYPE_AUDIO_FLAC,
-            "audio_decoder.raw", NULL },
-#else
         { MEDIA_MIMETYPE_AUDIO_FLAC,
             "audio_decoder.flac", "audio_encoder.flac" },
-#endif
-#endif
         { MEDIA_MIMETYPE_AUDIO_MSGSM,
             "audio_decoder.gsm", "audio_encoder.gsm" },
         { MEDIA_MIMETYPE_VIDEO_MPEG2,
             "video_decoder.mpeg2", "video_encoder.mpeg2" },
         { MEDIA_MIMETYPE_AUDIO_AC3,
             "audio_decoder.ac3", "audio_encoder.ac3" },
-#ifdef ENABLE_AV_ENHANCEMENTS			
-#ifdef DTS_CODEC_M_
-        { MEDIA_MIMETYPE_AUDIO_DTS,
-            "audio_decoder.dts", "audio_encoder.dts" },
-#endif
-#endif
         { MEDIA_MIMETYPE_AUDIO_EAC3,
             "audio_decoder.eac3", "audio_encoder.eac3" },
-#ifdef ENABLE_AV_ENHANCEMENTS
-#ifdef DOLBY_UDC
-        { MEDIA_MIMETYPE_AUDIO_EAC3_JOC,
-            "audio_decoder.eac3_joc", NULL },
-#endif // DOLBY_END
-#endif
     };
 
     static const size_t kNumMimeToRole =
@@ -1300,16 +1147,7 @@ status_t ACodec::setComponentRole(
     }
 
     if (i == kNumMimeToRole) {
-        status_t err = BAD_VALUE;
-#ifdef ENABLE_AV_ENHANCEMENTS
-        if (!strncmp(mComponentName.c_str(), "OMX.qcom.", 9)) {
-            err = ExtendedCodec::setSupportedRole(mOMX, mNode, isEncoder, mime);
-        }
-#endif
-        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
-            err = FFMPEGSoftCodec::setSupportedRole(mOMX, mNode, isEncoder, mime);
-        }
-        return err;
+        return ERROR_UNSUPPORTED;
     }
 
     const char *role =
@@ -1342,16 +1180,11 @@ status_t ACodec::setComponentRole(
 
 status_t ACodec::configureCodec(
         const char *mime, const sp<AMessage> &msg) {
-    ATRACE_NAME("configureCodec");
     int32_t encoder;
     if (!msg->findInt32("encoder", &encoder)) {
         encoder = false;
     }
 
-    bool isVideo = mComponentName.find("video") != -1;
-    ExtendedStats::AutoProfile autoProfile(
-            STATS_PROFILE_CONFIGURE_CODEC(isVideo), mMediaExtendedStats);
-
     sp<AMessage> inputFormat = new AMessage();
     sp<AMessage> outputFormat = mNotify->dup(); // will use this for kWhatOutputFormatChanged
 
@@ -1548,21 +1381,13 @@ status_t ACodec::configureCodec(
                 return err;
             }
 
-            bool bAdaptivePlaybackMode = false;
-            int32_t preferAdaptive = 0;
-            if (msg->findInt32("prefer-adaptive-playback", &preferAdaptive)
-                    && preferAdaptive == 1) {
-                ALOGI("[%s] Adaptive playback preferred", mComponentName.c_str());
-            } else {
-                // Always try to enable dynamic output buffers on native surface
-                err = mOMX->storeMetaDataInBuffers(
-                        mNode, kPortIndexOutput, OMX_TRUE);
-                if (err != OK) {
-                    ALOGE("[%s] storeMetaDataInBuffers failed w/ err %d",
-                            mComponentName.c_str(), err);
-                }
-            }
-            if (err != OK || preferAdaptive) {
+            // Always try to enable dynamic output buffers on native surface
+            err = mOMX->storeMetaDataInBuffers(
+                    mNode, kPortIndexOutput, OMX_TRUE);
+            if (err != OK) {
+                ALOGE("[%s] storeMetaDataInBuffers failed w/ err %d",
+                        mComponentName.c_str(), err);
+
                 // if adaptive playback has been requested, try JB fallback
                 // NOTE: THIS FALLBACK MECHANISM WILL BE REMOVED DUE TO ITS
                 // LARGE MEMORY REQUIREMENT
@@ -1589,7 +1414,7 @@ status_t ACodec::configureCodec(
                 if (canDoAdaptivePlayback &&
                         msg->findInt32("max-width", &maxWidth) &&
                         msg->findInt32("max-height", &maxHeight)) {
-                    ALOGI("[%s] prepareForAdaptivePlayback(%dx%d)",
+                    ALOGV("[%s] prepareForAdaptivePlayback(%dx%d)",
                             mComponentName.c_str(), maxWidth, maxHeight);
 
                     err = mOMX->prepareForAdaptivePlayback(
@@ -1604,19 +1429,6 @@ status_t ACodec::configureCodec(
                         inputFormat->setInt32("max-height", maxHeight);
                         inputFormat->setInt32("adaptive-playback", true);
                     }
-                    bAdaptivePlaybackMode = (err == OK);
-                }
-                // if Adaptive mode was tried first and codec failed it, try dynamic mode
-                if (err != OK && preferAdaptive) {
-                    err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexOutput, OMX_TRUE);
-                    if (err != OK) {
-                        ALOGE("[%s] storeMetaDataInBuffers failed w/ err %d",
-                              mComponentName.c_str(), err);
-                    } else {
-                        ALOGV("[%s] storeMetaDataInBuffers succeeded", mComponentName.c_str());
-                        mStoreMetaDataInOutputBuffers = true;
-                        inputFormat->setInt32("adaptive-playback", true);
-                    }
                 }
                 // allow failure
                 err = OK;
@@ -1627,9 +1439,6 @@ status_t ACodec::configureCodec(
                 inputFormat->setInt32("adaptive-playback", true);
             }
 
-            ALOGI("[%s] DRC Mode: %s", mComponentName.c_str(),
-                    (mStoreMetaDataInOutputBuffers ? "Dynamic Buffer Mode" :
-                    (bAdaptivePlaybackMode ? "Adaptive Mode" : "Port Reconfig Mode")));
             int32_t push;
             if (msg->findInt32("push-blank-buffers-on-shutdown", &push)
                     && push != 0) {
@@ -1643,19 +1452,12 @@ status_t ACodec::configureCodec(
         } else {
             mRotationDegrees = 0;
         }
-        // enforce screen-capture protection if requested by app
-        int32_t preventScreenCapture = 0;
-        if (msg->findInt32("prevent-screen-capture", &preventScreenCapture)
-                && preventScreenCapture == 1) {
-            mFlags |= kFlagIsGrallocUsageProtected;
-        }
     }
 
     if (video) {
         // determine need for software renderer
         bool usingSwRenderer = false;
-        if (haveNativeWindow && (mComponentName.startsWith("OMX.google.") ||
-                                 mComponentName.startsWith("OMX.ffmpeg."))) {
+        if (haveNativeWindow && mComponentName.startsWith("OMX.google.")) {
             usingSwRenderer = true;
             haveNativeWindow = false;
         }
@@ -1664,12 +1466,6 @@ status_t ACodec::configureCodec(
             err = setupVideoEncoder(mime, msg);
         } else {
             err = setupVideoDecoder(mime, msg, haveNativeWindow);
-#ifdef ENABLE_AV_ENHANCEMENTS
-            if (err == OK) {
-                const char* componentName = mComponentName.c_str();
-                ExtendedCodec::configureVideoDecoder(msg, mime, mOMX, 0, mNode, componentName);
-            }
-#endif
         }
 
         if (err != OK) {
@@ -1734,36 +1530,18 @@ status_t ACodec::configureCodec(
             outputFormat->setInt32("using-sw-renderer", 1);
         }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) {
-        int32_t numChannels, sampleRate, bitsPerSample;
-
+        int32_t numChannels, sampleRate;
         if (!msg->findInt32("channel-count", &numChannels)
                 || !msg->findInt32("sample-rate", &sampleRate)) {
             // Since we did not always check for these, leave them optional
             // and have the decoder figure it all out.
             err = OK;
         } else {
-            int32_t bitsPerSample = 16;
-            msg->findInt32("bits-per-sample", &bitsPerSample);
             err = setupRawAudioFormat(
                     encoder ? kPortIndexInput : kPortIndexOutput,
                     sampleRate,
-                    numChannels, bitsPerSample);
-        }
-#ifdef DTS_CODEC_M_
-    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_DTS)) {
-        ALOGV(" (DTS) mime == MEDIA_MIMETYPE_AUDIO_DTS");
-        int32_t numChannels, sampleRate;
-        if (!msg->findInt32("channel-count", &numChannels)
-                || !msg->findInt32("sample-rate", &sampleRate)) {
-            ALOGE("missing channel count or sample rate for DTS decoder");
-            err = INVALID_OPERATION;
-        } else {
-            err = DTSUtils::setupDecoder(mOMX, mNode, sampleRate);
+                    numChannels);
         }
-        if (err != OK) {
-            return err;
-        }
-#endif
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AAC)) {
         int32_t numChannels, sampleRate;
         if (!msg->findInt32("channel-count", &numChannels)
@@ -1833,10 +1611,11 @@ status_t ACodec::configureCodec(
         } else {
             err = setupG711Codec(encoder, numChannels);
         }
-    } else if (encoder && !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) {
-        int32_t numChannels = 0, sampleRate = 0, compressionLevel = -1;
-        if (!msg->findInt32("channel-count", &numChannels)
-                    || !msg->findInt32("sample-rate", &sampleRate)) {
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) {
+        int32_t numChannels, sampleRate, compressionLevel = -1;
+        if (encoder &&
+                (!msg->findInt32("channel-count", &numChannels)
+                        || !msg->findInt32("sample-rate", &sampleRate))) {
             ALOGE("missing channel count or sample rate for FLAC encoder");
             err = INVALID_OPERATION;
         } else {
@@ -1858,10 +1637,8 @@ status_t ACodec::configureCodec(
                     compressionLevel = 8;
                 }
             }
-            int32_t bitsPerSample = 16;
-            msg->findInt32("bits-per-sample", &bitsPerSample);
             err = setupFlacCodec(
-                    encoder, numChannels, sampleRate, compressionLevel, bitsPerSample);
+                    encoder, numChannels, sampleRate, compressionLevel);
         }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_RAW)) {
         int32_t numChannels, sampleRate;
@@ -1870,21 +1647,16 @@ status_t ACodec::configureCodec(
                 || !msg->findInt32("sample-rate", &sampleRate)) {
             err = INVALID_OPERATION;
         } else {
-            int32_t bitsPerSample = 16;
-            msg->findInt32("bits-per-sample", &bitsPerSample);
-            err = setupRawAudioFormat(kPortIndexInput, sampleRate, numChannels, bitsPerSample);
+            err = setupRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
         }
-    } else if (!strncmp(mComponentName.c_str(), "OMX.google.", 11)
-            && !strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AC3)) {
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_AC3)) {
         int32_t numChannels;
         int32_t sampleRate;
         if (!msg->findInt32("channel-count", &numChannels)
                 || !msg->findInt32("sample-rate", &sampleRate)) {
             err = INVALID_OPERATION;
         } else {
-            int32_t bitsPerSample = 16;
-            msg->findInt32("bits-per-sample", &bitsPerSample);
-            err = setupAC3Codec(encoder, numChannels, sampleRate, bitsPerSample);
+            err = setupAC3Codec(encoder, numChannels, sampleRate);
         }
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_EAC3)) {
         int32_t numChannels;
@@ -1893,30 +1665,7 @@ status_t ACodec::configureCodec(
                 || !msg->findInt32("sample-rate", &sampleRate)) {
             err = INVALID_OPERATION;
         } else {
-            int32_t bitsPerSample = 16;
-            msg->findInt32("bits-per-sample", &bitsPerSample);
-            err = setupEAC3Codec(encoder, numChannels, sampleRate, bitsPerSample);
-        }
-    } else {
-        if (encoder) {
-            int32_t numChannels, sampleRate;
-            if (msg->findInt32("channel-count", &numChannels)
-                  && msg->findInt32("sample-rate", &sampleRate)) {
-                setupRawAudioFormat(kPortIndexInput, sampleRate, numChannels, 16);
-            }
-        }
-#ifdef ENABLE_AV_ENHANCEMENTS
-        if (!strncmp(mComponentName.c_str(), "OMX.qcom.", 9)) {
-            err = ExtendedCodec::setAudioFormat(
-                    msg, mime, mOMX, mNode, mIsEncoder);
-        }
-#endif
-        if(!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
-            err = FFMPEGSoftCodec::setAudioFormat(
-                    msg, mime, mOMX, mNode, mIsEncoder);
-        }
-        if (err != OK) {
-            return err;
+            err = setupEAC3Codec(encoder, numChannels, sampleRate);
         }
     }
 
@@ -2030,7 +1779,7 @@ status_t ACodec::setupAACCodec(
     status_t err = setupRawAudioFormat(
             encoder ? kPortIndexInput : kPortIndexOutput,
             sampleRate,
-            numChannels, 16);
+            numChannels);
 
     if (err != OK) {
         return err;
@@ -2166,9 +1915,9 @@ status_t ACodec::setupAACCodec(
 }
 
 status_t ACodec::setupAC3Codec(
-        bool encoder, int32_t numChannels, int32_t sampleRate, int32_t bitsPerSample) {
+        bool encoder, int32_t numChannels, int32_t sampleRate) {
     status_t err = setupRawAudioFormat(
-            encoder ? kPortIndexInput : kPortIndexOutput, sampleRate, numChannels, bitsPerSample);
+            encoder ? kPortIndexInput : kPortIndexOutput, sampleRate, numChannels);
 
     if (err != OK) {
         return err;
@@ -2204,9 +1953,9 @@ status_t ACodec::setupAC3Codec(
 }
 
 status_t ACodec::setupEAC3Codec(
-        bool encoder, int32_t numChannels, int32_t sampleRate, int32_t bitsPerSample) {
+        bool encoder, int32_t numChannels, int32_t sampleRate) {
     status_t err = setupRawAudioFormat(
-            encoder ? kPortIndexInput : kPortIndexOutput, sampleRate, numChannels, bitsPerSample);
+            encoder ? kPortIndexInput : kPortIndexOutput, sampleRate, numChannels);
 
     if (err != OK) {
         return err;
@@ -2311,19 +2060,18 @@ status_t ACodec::setupAMRCodec(bool encoder, bool isWAMR, int32_t bitrate) {
     return setupRawAudioFormat(
             encoder ? kPortIndexInput : kPortIndexOutput,
             isWAMR ? 16000 : 8000 /* sampleRate */,
-            1 /* numChannels */, 16);
+            1 /* numChannels */);
 }
 
 status_t ACodec::setupG711Codec(bool encoder, int32_t numChannels) {
     CHECK(!encoder);  // XXX TODO
 
     return setupRawAudioFormat(
-            kPortIndexInput, 8000 /* sampleRate */, numChannels, 16);
+            kPortIndexInput, 8000 /* sampleRate */, numChannels);
 }
 
 status_t ACodec::setupFlacCodec(
-        bool encoder, int32_t numChannels, int32_t sampleRate, int32_t compressionLevel,
-        int32_t bitsPerSample) {
+        bool encoder, int32_t numChannels, int32_t sampleRate, int32_t compressionLevel) {
 
     if (encoder) {
         OMX_AUDIO_PARAM_FLACTYPE def;
@@ -2344,26 +2092,18 @@ status_t ACodec::setupFlacCodec(
         }
     }
 
-#ifdef QTI_FLAC_DECODER
-    return setupRawAudioFormat(
-            kPortIndexInput,
-            sampleRate,
-            numChannels, bitsPerSample);
-#else
     return setupRawAudioFormat(
             encoder ? kPortIndexInput : kPortIndexOutput,
             sampleRate,
-            numChannels, bitsPerSample);
-#endif
+            numChannels);
 }
 
 status_t ACodec::setupRawAudioFormat(
-        OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels, int32_t bitsPerSample) {
+        OMX_U32 portIndex, int32_t sampleRate, int32_t numChannels) {
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = portIndex;
 
-    ALOGI("sampleRate=%d channels=%d bits=%d", sampleRate, numChannels, bitsPerSample);
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
 
@@ -2394,7 +2134,7 @@ status_t ACodec::setupRawAudioFormat(
     pcmParams.nChannels = numChannels;
     pcmParams.eNumData = OMX_NumericalDataSigned;
     pcmParams.bInterleaved = OMX_TRUE;
-    pcmParams.nBitPerSample = bitsPerSample;
+    pcmParams.nBitPerSample = 16;
     pcmParams.nSamplingRate = sampleRate;
     pcmParams.ePCMMode = OMX_AUDIO_PCMModeLinear;
 
@@ -2570,7 +2310,6 @@ static const struct VideoCodingMapEntry {
     { MEDIA_MIMETYPE_VIDEO_AVC, OMX_VIDEO_CodingAVC },
     { MEDIA_MIMETYPE_VIDEO_HEVC, OMX_VIDEO_CodingHEVC },
     { MEDIA_MIMETYPE_VIDEO_MPEG4, OMX_VIDEO_CodingMPEG4 },
-    { MEDIA_MIMETYPE_VIDEO_MPEG4_DP, OMX_VIDEO_CodingMPEG4 },
     { MEDIA_MIMETYPE_VIDEO_H263, OMX_VIDEO_CodingH263 },
     { MEDIA_MIMETYPE_VIDEO_MPEG2, OMX_VIDEO_CodingMPEG2 },
     { MEDIA_MIMETYPE_VIDEO_VP8, OMX_VIDEO_CodingVP8 },
@@ -2621,18 +2360,7 @@ status_t ACodec::setupVideoDecoder(
     status_t err = GetVideoCodingTypeFromMime(mime, &compressionFormat);
 
     if (err != OK) {
-#ifdef ENABLE_AV_ENHANCEMENTS
-        if (!strncmp(mComponentName.c_str(), "OMX.qcom.", 9)) {
-            err = ExtendedCodec::setVideoFormat(msg, mime, &compressionFormat);
-        }
-#endif
-        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
-            err = FFMPEGSoftCodec::setVideoFormat(
-                    msg, mime, mOMX, mNode, mIsEncoder, &compressionFormat);
-        }
-        if (err != OK) {
-            return err;
-        }
+        return err;
     }
 
     err = setVideoPortFormatType(
@@ -2782,19 +2510,7 @@ status_t ACodec::setupVideoEncoder(const char *mime, const sp<AMessage> &msg) {
     err = GetVideoCodingTypeFromMime(mime, &compressionFormat);
 
     if (err != OK) {
-#ifdef ENABLE_AV_ENHANCEMENTS
-        if (!strncmp(mComponentName.c_str(), "OMX.qcom.", 9)) {
-            err = ExtendedCodec::setVideoFormat(msg, mime, &compressionFormat);
-        }
-#endif
-        if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
-            err = FFMPEGSoftCodec::setVideoFormat(
-                    msg, mime, mOMX, mNode, mIsEncoder, &compressionFormat);
-        }
-        if (err != OK) {
-            ALOGE("Not a supported video mime type: %s", mime);
-            return err;
-        }
+        return err;
     }
 
     err = setVideoPortFormatType(
@@ -2859,8 +2575,7 @@ status_t ACodec::setupVideoEncoder(const char *mime, const sp<AMessage> &msg) {
             break;
     }
 
-    ALOGI("[%s] setupVideoEncoder %s", mComponentName.c_str(),
-            err == OK ? "succeeded" : "failed");
+    ALOGI("setupVideoEncoder succeeded");
 
     return err;
 }
@@ -2985,7 +2700,6 @@ status_t ACodec::setupMPEG4EncoderParameters(const sp<AMessage> &msg) {
         mpeg4type.eProfile = static_cast<OMX_VIDEO_MPEG4PROFILETYPE>(profile);
         mpeg4type.eLevel = static_cast<OMX_VIDEO_MPEG4LEVELTYPE>(level);
     }
-    ExtendedUtils::setBFrames(mpeg4type, mComponentName.c_str());
 
     err = mOMX->setParameter(
             mNode, OMX_IndexParamVideoMpeg4, &mpeg4type, sizeof(mpeg4type));
@@ -3184,8 +2898,6 @@ status_t ACodec::setupAVCEncoderParameters(const sp<AMessage> &msg) {
         err = verifySupportForProfileAndLevel(profile, level);
 
         if (err != OK) {
-            ALOGE("%s does not support profile %x @ level %x",
-                    mComponentName.c_str(), profile, level);
             return err;
         }
 
@@ -3194,14 +2906,11 @@ status_t ACodec::setupAVCEncoderParameters(const sp<AMessage> &msg) {
     }
 
     // XXX
-    // Allow higher profiles to be set since the encoder seems to support
-#if 0
     if (h264type.eProfile != OMX_VIDEO_AVCProfileBaseline) {
         ALOGW("Use baseline profile instead of %d for AVC recording",
             h264type.eProfile);
         h264type.eProfile = OMX_VIDEO_AVCProfileBaseline;
     }
-#endif
 
     if (h264type.eProfile == OMX_VIDEO_AVCProfileBaseline) {
         h264type.nSliceHeaderSpacing = 0;
@@ -3221,8 +2930,6 @@ status_t ACodec::setupAVCEncoderParameters(const sp<AMessage> &msg) {
         h264type.bDirectSpatialTemporal = OMX_FALSE;
         h264type.nCabacInitIdc = 0;
     }
-    ExtendedUtils::setBFrames(h264type, iFrameInterval,
-            frameRate, mComponentName.c_str());
 
     if (h264type.nBFrames != 0) {
         h264type.nAllowedPictureTypes |= OMX_VIDEO_PictureTypeB;
@@ -3445,7 +3152,7 @@ status_t ACodec::setupErrorCorrectionParameters() {
 
     errorCorrectionType.bEnableHEC = OMX_FALSE;
     errorCorrectionType.bEnableResync = OMX_TRUE;
-    errorCorrectionType.nResynchMarkerSpacing = 0;
+    errorCorrectionType.nResynchMarkerSpacing = 256;
     errorCorrectionType.bEnableDataPartitioning = OMX_FALSE;
     errorCorrectionType.bEnableRVLC = OMX_FALSE;
 
@@ -3570,6 +3277,7 @@ bool ACodec::allYourBuffersAreBelongToUs() {
 }
 
 void ACodec::deferMessage(const sp<AMessage> &msg) {
+    bool wasEmptyBefore = mDeferredQueue.empty();
     mDeferredQueue.push_back(msg);
 }
 
@@ -3600,7 +3308,6 @@ bool ACodec::describeDefaultColorFormat(DescribeColorFormatParams &params) {
         fmt != OMX_COLOR_FormatYUV420PackedPlanar &&
         fmt != OMX_COLOR_FormatYUV420SemiPlanar &&
         fmt != OMX_COLOR_FormatYUV420PackedSemiPlanar &&
-        fmt != OMX_TI_COLOR_FormatYUV420PackedSemiPlanar &&
         fmt != HAL_PIXEL_FORMAT_YV12) {
         ALOGW("do not know color format 0x%x = %d", fmt, fmt);
         return false;
@@ -3673,7 +3380,6 @@ bool ACodec::describeDefaultColorFormat(DescribeColorFormatParams &params) {
         case OMX_COLOR_FormatYUV420SemiPlanar:
             // FIXME: NV21 for sw-encoder, NV12 for decoder and hw-encoder
         case OMX_COLOR_FormatYUV420PackedSemiPlanar:
-        case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
             // NV12
             image.mPlane[image.U].mOffset = params.nStride * params.nSliceHeight;
             image.mPlane[image.U].mColInc = 2;
@@ -3929,6 +3635,8 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
 
                     CHECK_GT(params.nChannels, 0);
                     CHECK(params.nChannels == 1 || params.bInterleaved);
+                    CHECK_EQ(params.nBitPerSample, 16u);
+
                     CHECK_EQ((int)params.eNumData,
                              (int)OMX_NumericalDataSigned);
 
@@ -3939,11 +3647,6 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     notify->setInt32("channel-count", params.nChannels);
                     notify->setInt32("sample-rate", params.nSamplingRate);
 
-                    CHECK(params.nBitPerSample == 16u ||
-                          params.nBitPerSample == 24u ||
-                          params.nBitPerSample == 32u);
-                    notify->setInt32("bits-per-sample", params.nBitPerSample);
-
                     if (mChannelMaskPresent) {
                         notify->setInt32("channel-mask", mChannelMask);
                     }
@@ -4123,23 +3826,7 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                     notify->setInt32("sample-rate", params.nSamplingRate);
                     break;
                 }
-#ifdef DTS_CODEC_M_
-                case OMX_AUDIO_CodingDTSHD:
-                {
-                    OMX_AUDIO_PARAM_DTSDECTYPE params;
-                    InitOMXParams(&params);
-                    params.nPortIndex = portIndex;
 
-                    CHECK_EQ((status_t)OK, mOMX->getParameter(
-                            mNode,
-                            (OMX_INDEXTYPE)OMX_IndexParamAudioDTSDec,
-                            &params,
-                            sizeof(params)));
-
-                    notify->setString("mime", MEDIA_MIMETYPE_AUDIO_DTS);
-                    break;
-                }
-#endif
                 case OMX_AUDIO_CodingGSMFR:
                 {
                     OMX_AUDIO_PARAM_MP3TYPE params;
@@ -4158,39 +3845,8 @@ status_t ACodec::getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify) {
                 }
 
                 default:
-                {
-                    AString mimeType;
-                    status_t err = ERROR_UNSUPPORTED;
-#ifdef ENABLE_AV_ENHANCEMENTS
-                    if (!strncmp(mComponentName.c_str(), "OMX.qcom.", 9)) {
-                        err = ExtendedCodec::handleSupportedAudioFormats(
-                            audioDef->eEncoding, &mimeType);
-                    }
-#endif
-                    if (!strncmp(mComponentName.c_str(), "OMX.ffmpeg.", 11)) {
-                        err = FFMPEGSoftCodec::handleSupportedAudioFormats(
-                                audioDef->eEncoding, &mimeType);
-                    }
-                    if (err == OK) {
-                        int channelCount = 0;
-                        int sampleRate = 0;
-#ifdef ENABLE_AV_ENHANCEMENTS
-                        err = ExtendedCodec::getSupportedAudioFormatInfo(
-                                      &mimeType,
-                                      mOMX,
-                                      mNode,
-                                      portIndex,
-                                      &channelCount,
-                                      &sampleRate);
-#endif
-                        notify->setString("mime", mimeType.c_str());
-                        notify->setInt32("channel-count", channelCount);
-                        notify->setInt32("sample-rate", sampleRate);
-                        break;
-                    }
                     ALOGE("UNKNOWN AUDIO CODING: %d\n", audioDef->eEncoding);
                     TRESPASS();
-                }
             }
             break;
         }
@@ -4329,6 +3985,7 @@ status_t ACodec::pushBlankBuffersToNativeWindow() {
     // on the screen and then been replaced, so an previous video frames are
     // guaranteed NOT to be currently displayed.
     for (int i = 0; i < numBufs + 1; i++) {
+        int fenceFd = -1;
         err = native_window_dequeue_buffer_and_wait(mNativeWindow.get(), &anb);
         if (err != NO_ERROR) {
             ALOGE("error pushing blank frames: dequeueBuffer failed: %s (%d)",
@@ -4781,12 +4438,6 @@ void ACodec::BaseState::onInputBufferFilled(const sp<AMessage> &msg) {
                     }
                 }
 
-                if (mCodec->mMediaExtendedStats != NULL) {
-                    bool isVideo = mCodec->mComponentName.find("video") != -1;
-                    mCodec->mMediaExtendedStats->profileStartOnce(
-                            STATS_PROFILE_FIRST_BUFFER(isVideo));
-                }
-
                 CHECK_EQ(mCodec->mOMX->emptyBuffer(
                             mCodec->mNode,
                             bufferID,
@@ -4954,7 +4605,6 @@ bool ACodec::BaseState::onOMXFillBufferDone(
                 mCodec->mSkipCutBuffer->submit(info->mData);
             }
             info->mData->meta()->setInt64("timeUs", timeUs);
-            //info->mData->meta()->setObject("graphic-buffer", (android::RefBase*)&info->mGraphicBuffer);
 
             sp<AMessage> notify = mCodec->mNotify->dup();
             notify->setInt32("what", CodecBase::kWhatDrainThisBuffer);
@@ -5014,17 +4664,10 @@ void ACodec::BaseState::onOutputBufferDrained(const sp<AMessage> &msg) {
     int32_t render;
     if (mCodec->mNativeWindow != NULL
             && msg->findInt32("render", &render) && render != 0
-            && info->mData != NULL && info->mData->size() != 0
-            && !mCodec->mIsVideoRenderingDisabled) {
+            && info->mData != NULL && info->mData->size() != 0) {
         ATRACE_NAME("render");
         // The client wants this buffer to be rendered.
 
-        if (mCodec->mMediaExtendedStats != NULL) {
-            bool isVideo = mCodec->mComponentName.find("video") != -1;
-            mCodec->mMediaExtendedStats->profileStop(
-                STATS_PROFILE_FIRST_BUFFER(isVideo));
-        }
-
         int64_t timestampNs = 0;
         if (!msg->findInt64("timestampNs", &timestampNs)) {
             // TODO: it seems like we should use the timestamp
@@ -5054,9 +4697,8 @@ void ACodec::BaseState::onOutputBufferDrained(const sp<AMessage> &msg) {
             info->mStatus = BufferInfo::OWNED_BY_US;
         }
     } else {
-        if (mCodec->mNativeWindow != NULL
-            && msg->findInt32("render", &render) && render == 0
-            && (info->mData == NULL || info->mData->size() != 0)) {
+        if (mCodec->mNativeWindow != NULL &&
+            (info->mData == NULL || info->mData->size() != 0)) {
             ATRACE_NAME("frame-drop");
         }
         info->mStatus = BufferInfo::OWNED_BY_US;
@@ -5131,8 +4773,6 @@ void ACodec::UninitializedState::stateEntered() {
     mCodec->mOMX.clear();
     mCodec->mQuirks = 0;
     mCodec->mFlags = 0;
-    mCodec->mEncoderComponent = 0;
-    mCodec->mComponentAllocByName = 0;
     mCodec->mUseMetadataOnEncoderOutput = 0;
     mCodec->mComponentName.clear();
 }
@@ -5206,7 +4846,7 @@ void ACodec::UninitializedState::onSetup(
 
 bool ACodec::UninitializedState::onAllocateComponent(const sp<AMessage> &msg) {
     ALOGV("onAllocateComponent");
-    ATRACE_NAME("onAllocatecomponent");
+
     CHECK(mCodec->mNode == NULL);
 
     OMXClient client;
@@ -5234,7 +4874,6 @@ bool ACodec::UninitializedState::onAllocateComponent(const sp<AMessage> &msg) {
         ssize_t index = matchingCodecs.add();
         OMXCodec::CodecNameAndQuirks *entry = &matchingCodecs.editItemAt(index);
         entry->mName = String8(componentName.c_str());
-        mCodec->mComponentAllocByName = true;
 
         if (!OMXCodec::findCodecQuirks(
                     componentName.c_str(), &entry->mQuirks)) {
@@ -5247,39 +4886,6 @@ bool ACodec::UninitializedState::onAllocateComponent(const sp<AMessage> &msg) {
             encoder = false;
         }
 
-        ALOGV("onAllocateComponent %s %d", mime.c_str(), encoder);
-
-        if (encoder == true) {
-            mCodec->mEncoderComponent = true;
-        }
-
-#ifdef ENABLE_AV_ENHANCEMENTS
-    // Call UseQCHWAACEncoder with no arguments to get the correct state since
-    // MediaCodecSource does not pass the output format details when calling
-    // kInit leading to msg passed not having enough details
-    if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_AUDIO_AAC)
-        && ExtendedUtils::UseQCHWAACEncoder()) {
-        //use hw aac encoder
-        ALOGD("use QCOM HW AAC encoder");
-        OMXCodec::findMatchingCodecs(
-                mime.c_str(),
-                encoder, // createEncoder
-                "OMX.qcom.audio.encoder.aac",  // OMX.qcom.audio.encoder.aac
-                0,     // flags
-                &matchingCodecs);
-    } else
-#endif
-#ifdef QTI_FLAC_DECODER
-    if (!strcasecmp(mime.c_str(), MEDIA_MIMETYPE_AUDIO_FLAC) && !encoder) {
-        //use google's raw decoder
-        OMXCodec::findMatchingCodecs(
-                MEDIA_MIMETYPE_AUDIO_RAW,
-                encoder, //createEncoder
-                "OMX.google.raw.decoder",
-                0, //flags
-                &matchingCodecs);
-    } else
-#endif
         OMXCodec::findMatchingCodecs(
                 mime.c_str(),
                 encoder, // createEncoder
@@ -5295,8 +4901,6 @@ bool ACodec::UninitializedState::onAllocateComponent(const sp<AMessage> &msg) {
             ++matchIndex) {
         componentName = matchingCodecs.itemAt(matchIndex).mName.string();
         quirks = matchingCodecs.itemAt(matchIndex).mQuirks;
-        // this doesn't work here as the format isn't passed in the message
-        //ExtendedCodec::overrideComponentName(quirks, msg, &componentName, &mime, encoder);
 
         pid_t tid = androidGetTid();
         int prevPriority = androidGetThreadPriority(tid);
@@ -5472,98 +5076,13 @@ bool ACodec::LoadedState::onConfigureComponent(
         ALOGE("[%s] configureCodec returning error %d",
               mCodec->mComponentName.c_str(), err);
 
-        if (!mCodec->mEncoderComponent && !mCodec->mComponentAllocByName && !strncmp(mime.c_str(), "video/", strlen("video/"))) {
-            Vector<OMXCodec::CodecNameAndQuirks> matchingCodecs;
-
-            OMXCodec::findMatchingCodecs(
-                mime.c_str(),
-                false, // createEncoder
-                NULL,  // matchComponentName
-                0,     // flags
-                &matchingCodecs);
-
-            status_t err = mCodec->mOMX->freeNode(mCodec->mNode);
-
-            if (err != OK) {
-                ALOGE("Failed to freeNode");
-                mCodec->signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));
-                return false;
-            }
-
-            mCodec->mNode = NULL;
-            AString componentName;
-            sp<CodecObserver> observer = new CodecObserver;
-            for (size_t matchIndex = 0; matchIndex < matchingCodecs.size();
-                    ++matchIndex) {
-                componentName = matchingCodecs.itemAt(matchIndex).mName.string();
-                if (!strcmp(mCodec->mComponentName.c_str(), componentName.c_str())) {
-                    continue;
-                }
-
-                status_t err = mCodec->mOMX->allocateNode(componentName.c_str(), observer, &mCodec->mNode);
-
-                if (err == OK) {
-                    break;
-                } else {
-                    ALOGW("Allocating component '%s' failed, try next one.", componentName.c_str());
-                }
-
-                mCodec->mNode = NULL;
-            }
-
-            if (mCodec->mNode == NULL) {
-                if (!mime.empty()) {
-                    ALOGE("Unable to instantiate a decoder for type '%s'", mime.c_str());
-                } else {
-                    ALOGE("Unable to instantiate codec '%s'.", componentName.c_str());
-                }
-
-                mCodec->signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));
-                return false;
-            }
-
-            sp<AMessage> notify = new AMessage(kWhatOMXMessage, mCodec->id());
-            observer->setNotificationMessage(notify);
-            mCodec->mComponentName = componentName;
-
-            err = mCodec->configureCodec(mime.c_str(), msg);
-
-            if (err != OK) {
-                ALOGE("[%s] configureCodec returning error %d",
-                         mCodec->mComponentName.c_str(), err);
-                mCodec->signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));
-                return false;
-            }
-        } else {
-            if (err != OK) {
-                ALOGE("[%s] configureCodec returning error %d",
-                         mCodec->mComponentName.c_str(), err);
-                 mCodec->signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));
-                 return false;
-            }
-        }
-    }
-
-    sp<RefBase> obj;
-    if (msg->findObject("native-window", &obj)
-            && strncmp("OMX.google.", mCodec->mComponentName.c_str(), 11)
-            && strncmp("OMX.ffmpeg.", mCodec->mComponentName.c_str(), 11)) {
-        sp<NativeWindowWrapper> nativeWindow(
-                static_cast<NativeWindowWrapper *>(obj.get()));
-        CHECK(nativeWindow != NULL);
-        mCodec->mNativeWindow = nativeWindow->getNativeWindow();
-
-        native_window_set_scaling_mode(
-                mCodec->mNativeWindow.get(),
-                NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW);
-        mCodec->mIsVideoRenderingDisabled = ExtendedUtils::ShellProp::isVideoRenderingDisabled();
+        mCodec->signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));
+        return false;
     }
-    CHECK_EQ((status_t)OK, mCodec->initNativeWindow());
 
     {
         sp<AMessage> notify = mCodec->mNotify->dup();
         notify->setInt32("what", CodecBase::kWhatComponentConfigured);
-        notify->setString("componentName", mCodec->mComponentName.c_str());
         notify->setMessage("input-format", mCodec->mInputFormat);
         notify->setMessage("output-format", mCodec->mOutputFormat);
         notify->post();
@@ -6124,11 +5643,6 @@ bool ACodec::ExecutingState::onOMXEvent(
                 mCodec->freeOutputBuffersNotOwnedByComponent();
 
                 mCodec->changeState(mCodec->mOutputPortSettingsChangedState);
-
-                bool isVideo = mCodec->mComponentName.find("video") != -1;
-                if (isVideo) {
-                    CODEC_PLAYER_STATS(profileStart, STATS_PROFILE_RECONFIGURE);
-                }
             } else if (data2 == OMX_IndexConfigCommonOutputCrop) {
                 mCodec->mSentFormat = false;
             } else {
@@ -6175,7 +5689,6 @@ bool ACodec::OutputPortSettingsChangedState::onMessageReceived(
         case kWhatFlush:
         case kWhatShutdown:
         case kWhatResume:
-        case kWhatSetParameters:
         {
             if (msg->what() == kWhatResume) {
                 ALOGV("[%s] Deferring resume", mCodec->mComponentName.c_str());
@@ -6251,11 +5764,6 @@ bool ACodec::OutputPortSettingsChangedState::onOMXEvent(
 
                 mCodec->changeState(mCodec->mExecutingState);
 
-                bool isVideo = mCodec->mComponentName.find("video") != -1;
-                if (isVideo) {
-                    CODEC_PLAYER_STATS(profileStop, STATS_PROFILE_RECONFIGURE);
-                }
-
                 return true;
             }
 
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index 8e715ce..c3a940a 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -122,12 +122,6 @@ static int32_t getColorFormat(const char* colorFormat) {
        return OMX_TI_COLOR_FormatYUV420PackedSemiPlanar;
     }
 
-#ifdef STE_HARDWARE
-    if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_YUV420MB)) {
-       return OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB;
-    }
-#endif
-
     if (!strcmp(colorFormat, CameraParameters::PIXEL_FORMAT_ANDROID_OPAQUE)) {
         return OMX_COLOR_FormatAndroidOpaque;
     }
@@ -573,22 +567,13 @@ status_t CameraSource::initWithCameraAccess(
 
     // XXX: query camera for the stride and slice height
     // when the capability becomes available.
-#ifdef STE_HARDWARE
-    int stride = newCameraParams.getInt(CameraParameters::KEY_RECORD_STRIDE);
-    int sliceHeight = newCameraParams.getInt(CameraParameters::KEY_RECORD_SLICE_HEIGHT);
-#endif
     mMeta = new MetaData;
     mMeta->setCString(kKeyMIMEType,  MEDIA_MIMETYPE_VIDEO_RAW);
     mMeta->setInt32(kKeyColorFormat, mColorFormat);
     mMeta->setInt32(kKeyWidth,       mVideoSize.width);
     mMeta->setInt32(kKeyHeight,      mVideoSize.height);
-#ifdef STE_HARDWARE
-    mMeta->setInt32(kKeyStride,      stride != -1 ? stride : mVideoSize.width);
-    mMeta->setInt32(kKeySliceHeight, sliceHeight != -1 ? sliceHeight : mVideoSize.height);
-#else
     mMeta->setInt32(kKeyStride,      mVideoSize.width);
     mMeta->setInt32(kKeySliceHeight, mVideoSize.height);
-#endif
     mMeta->setInt32(kKeyFrameRate,   mVideoFrameRate);
     return OK;
 }
diff --git a/media/libstagefright/MediaDefs.cpp b/media/libstagefright/MediaDefs.cpp
index f5ed371..c5a6939 100644
--- a/media/libstagefright/MediaDefs.cpp
+++ b/media/libstagefright/MediaDefs.cpp
@@ -26,14 +26,8 @@ const char *MEDIA_MIMETYPE_VIDEO_AVC = "video/avc";
 const char *MEDIA_MIMETYPE_VIDEO_HEVC = "video/hevc";
 const char *MEDIA_MIMETYPE_VIDEO_MPEG4 = "video/mp4v-es";
 const char *MEDIA_MIMETYPE_VIDEO_H263 = "video/3gpp";
-#ifdef STE_HARDWARE
-const char *MEDIA_MIMETYPE_VIDEO_H263_SW = "video/3gpp-sw";
-#endif
 const char *MEDIA_MIMETYPE_VIDEO_MPEG2 = "video/mpeg2";
 const char *MEDIA_MIMETYPE_VIDEO_RAW = "video/raw";
-//#ifdef STE_HARDWARE
-//const char *MEDIA_MIMETYPE_VIDEO_VC1 = "video/vc1";
-//#endif
 
 const char *MEDIA_MIMETYPE_AUDIO_AMR_NB = "audio/3gpp";
 const char *MEDIA_MIMETYPE_AUDIO_AMR_WB = "audio/amr-wb";
diff --git a/media/libstagefright/OMXCodec.cpp b/media/libstagefright/OMXCodec.cpp
index a46adfb..58372ed 100644
--- a/media/libstagefright/OMXCodec.cpp
+++ b/media/libstagefright/OMXCodec.cpp
@@ -1,53 +1,17 @@
 /*
  * Copyright (C) 2009 The Android Open Source Project
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * This file was modified by Dolby Laboratories, Inc. The portions of the
- * code that are surrounded by "DOLBY..." are copyrighted and
- * licensed separately, as follows:
- *
- *  (C) 2011-2015 Dolby Laboratories, Inc.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ *      http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- *
- **
- ** This file was modified by DTS, Inc. The portions of the
- ** code that are surrounded by "DTS..." are copyrighted and
- ** licensed separately, as follows:
- **
- **  (C) 2014 DTS, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **    http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License
  */
 
 #include <inttypes.h>
@@ -60,8 +24,6 @@
 #endif
 
 #include <utils/Log.h>
-#define ATRACE_TAG ATRACE_TAG_VIDEO
-#include <utils/Trace.h>
 
 #include "include/AACEncoder.h"
 
@@ -91,60 +53,10 @@
 #include <OMX_VideoExt.h>
 #include <OMX_AsString.h>
 
-#include "include/ExtendedUtils.h"
-
 #include "include/avc_utils.h"
-#ifdef DOLBY_UDC
-#include "ds_config.h"
-#endif // DOLBY_END
-
-#include <media/stagefright/ExtendedCodec.h>
-#include <media/stagefright/FFMPEGSoftCodec.h>
-
-#ifdef ENABLE_AV_ENHANCEMENTS
-#include <QCMediaDefs.h>
-#include <QCMetaData.h>
-#include <QOMX_AudioExtensions.h>
-#endif
-#ifdef DTS_CODEC_M_
-#include "include/DTSUtils.h"
-#include "include/OMX_Audio_DTS.h"
-#endif
-
-#ifdef QTI_FLAC_DECODER
-#include "include/FLACDecoder.h"
-#endif
-
-#ifdef USE_SAMSUNG_COLORFORMAT
-#include <sec_format.h>
-#endif
-
-#ifdef USE_S3D_SUPPORT
-#include "Exynos_OMX_Def.h"
-#include "ExynosHWCService.h"
-#endif
 
 namespace android {
 
-#ifdef USE_SAMSUNG_COLORFORMAT
-static const int OMX_SEC_COLOR_FormatNV12TPhysicalAddress = 0x7F000001;
-static const int OMX_SEC_COLOR_FormatNV12LPhysicalAddress = 0x7F000002;
-static const int OMX_SEC_COLOR_FormatNV12LVirtualAddress = 0x7F000003;
-static const int OMX_SEC_COLOR_FormatNV12Tiled = 0x7FC00002;
-static int calc_plane(int width, int height)
-{
-    int mbX, mbY;
-
-    mbX = (width + 15)/16;
-    mbY = (height + 15)/16;
-
-    /* Alignment for interlaced processing */
-    mbY = (mbY + 1) / 2 * 2;
-
-    return (mbX * 16) * (mbY * 16);
-}
-#endif // USE_SAMSUNG_COLORFORMAT
-
 // Treat time out as an error if we have not received any output
 // buffers after 3 seconds.
 const static int64_t kBufferFilledEventTimeOutNs = 3000000000LL;
@@ -156,10 +68,6 @@ const static int64_t kBufferFilledEventTimeOutNs = 3000000000LL;
 // component in question is buggy or not.
 const static uint32_t kMaxColorFormatSupported = 1000;
 
-#define FACTORY_CREATE(name) \
-static sp<MediaSource> Make##name(const sp<MediaSource> &source) { \
-    return new name(source); \
-}
 #define FACTORY_CREATE_ENCODER(name) \
 static sp<MediaSource> Make##name(const sp<MediaSource> &source, const sp<MetaData> &meta) { \
     return new name(source, meta); \
@@ -167,9 +75,6 @@ static sp<MediaSource> Make##name(const sp<MediaSource> &source, const sp<MetaDa
 
 #define FACTORY_REF(name) { #name, Make##name },
 
-#ifdef QTI_FLAC_DECODER
-FACTORY_CREATE(FLACDecoder)
-#endif
 FACTORY_CREATE_ENCODER(AACEncoder)
 
 static sp<MediaSource> InstantiateSoftwareEncoder(
@@ -193,29 +98,6 @@ static sp<MediaSource> InstantiateSoftwareEncoder(
     return NULL;
 }
 
-#ifdef QTI_FLAC_DECODER
-static sp<MediaSource> InstantiateSoftwareDecoder(
-        const char *name, const sp<MediaSource> &source) {
-    struct FactoryInfo {
-        const char *name;
-        sp<MediaSource> (*CreateFunc)(const sp<MediaSource> &);
-    };
-
-    static const FactoryInfo kFactoryInfo[] = {
-        FACTORY_REF(FLACDecoder)
-    };
-    for (size_t i = 0;
-         i < sizeof(kFactoryInfo) / sizeof(kFactoryInfo[0]); ++i) {
-        if (!strcmp(name, kFactoryInfo[i].name)) {
-            return (*kFactoryInfo[i].CreateFunc)(source);
-        }
-
-    }
-
-    return NULL;
-}
-#endif
-
 #undef FACTORY_CREATE_ENCODER
 #undef FACTORY_REF
 
@@ -264,13 +146,7 @@ static void InitOMXParams(T *params) {
 }
 
 static bool IsSoftwareCodec(const char *componentName) {
-#ifdef DOLBY_UDC
-    if (!strncmp("OMX.dolby.", componentName, 10)) {
-        return true;
-    }
-#endif // DOLBY_END
-    if (!strncmp("OMX.google.", componentName, 11)
-        || !strncmp("OMX.ffmpeg.", componentName, 11)) {
+    if (!strncmp("OMX.google.", componentName, 11)) {
         return true;
     }
 
@@ -315,20 +191,6 @@ static int CompareSoftwareCodecsFirst(
     return 0;
 }
 
-#ifdef STE_HARDWARE
-uint32_t OMXCodec::OmxToHALFormat(OMX_COLOR_FORMATTYPE omxValue) {
-    switch (omxValue) {
-        case OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB:
-            return HAL_PIXEL_FORMAT_YCBCR42XMBN;
-        case OMX_COLOR_FormatYUV420Planar:
-            return HAL_PIXEL_FORMAT_YCbCr_420_P;
-        default:
-            ALOGI("Unknown OMX pixel format (0x%X), passing it on unchanged", omxValue);
-            return omxValue;
-    }
-}
-#endif
-
 // static
 void OMXCodec::findMatchingCodecs(
         const char *mime,
@@ -343,32 +205,6 @@ void OMXCodec::findMatchingCodecs(
     }
 
     size_t index = 0;
-
-#ifdef ENABLE_AV_ENHANCEMENTS
-    //Check if application specially reuqested for  aac hardware encoder
-    //This is not a part of  mediacodec list
-    if (matchComponentName &&
-            !strncmp("OMX.qcom.audio.encoder.aac", matchComponentName, 26)) {
-        matchingCodecs->add();
-
-        CodecNameAndQuirks *entry = &matchingCodecs->editItemAt(index);
-        entry->mName = String8("OMX.qcom.audio.encoder.aac");
-        entry->mQuirks = 0;
-        return;
-    }
-
-#ifdef QTI_FLAC_DECODER
-    if (matchComponentName && !strncmp("FLACDecoder", matchComponentName, strlen("FLACDecoder"))) {
-            matchingCodecs->add();
-
-            CodecNameAndQuirks *entry = &matchingCodecs->editItemAt(index);
-            entry->mName = String8("FLACDecoder");
-            entry->mQuirks = 0;
-            return;
-    }
-#endif
-#endif
-
     for (;;) {
         ssize_t matchIndex =
             list->findCodecByType(mime, createEncoder, index);
@@ -424,30 +260,6 @@ uint32_t OMXCodec::getComponentQuirks(
     if (info->hasQuirk("output-buffers-are-unreadable")) {
         quirks |= kOutputBuffersAreUnreadable;
     }
-    if (info->hasQuirk("requies-loaded-to-idle-after-allocation")) {
-        quirks |= kRequiresLoadedToIdleAfterAllocation;
-    }
-    if (info->hasQuirk("requires-global-flush")) {
-        quirks |= kRequiresGlobalFlush;
-    }
-
-#ifdef STE_HARDWARE
-    if (info->hasQuirk("requires-store-metadata-before-idle")) {
-      quirks |= kRequiresStoreMetaDataBeforeIdle;
-    }
-#endif
-#ifdef ENABLE_AV_ENHANCEMENTS
-    quirks |= ExtendedCodec::getComponentQuirks(info);
-#endif
-
-#ifdef DOLBY_UDC
-    if (info->hasQuirk("needs-flush-before-disable")) {
-        quirks |= kNeedsFlushBeforeDisable;
-    }
-    if (info->hasQuirk("requires-flush-complete-emulation")) {
-        quirks |= kRequiresFlushCompleteEmulation;
-    }
-#endif // DOLBY_END
 
     return quirks;
 }
@@ -458,15 +270,6 @@ bool OMXCodec::findCodecQuirks(const char *componentName, uint32_t *quirks) {
     if (list == NULL) {
         return false;
     }
-#ifdef ENABLE_AV_ENHANCEMENTS
-    //Check for aac hardware encoder
-    //This is not a part of  mediacodec list
-    if (componentName &&
-            !strncmp("OMX.qcom.audio.encoder.aac", componentName, 26)) {
-        *quirks = 0;
-        return true;
-    }
-#endif
 
     ssize_t index = list->findCodecByName(componentName);
 
@@ -503,14 +306,7 @@ sp<MediaSource> OMXCodec::Create(
     CHECK(success);
 
     Vector<CodecNameAndQuirks> matchingCodecs;
-
-#ifdef QTI_FLAC_DECODER
-    if (!strncmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC, strlen(MEDIA_MIMETYPE_AUDIO_FLAC))) {
-        findMatchingCodecs(mime, createEncoder,
-            "FLACDecoder", flags, &matchingCodecs);
-    } else
-#endif
-        findMatchingCodecs(
+    findMatchingCodecs(
             mime, createEncoder, matchComponentName, flags, &matchingCodecs);
 
     if (matchingCodecs.isEmpty()) {
@@ -536,25 +332,15 @@ sp<MediaSource> OMXCodec::Create(
             componentName = tmp.c_str();
         }
 
-        sp<MediaSource> softwareCodec;
         if (createEncoder) {
-            softwareCodec = InstantiateSoftwareEncoder(componentName, source, meta);
-        }
-#ifdef QTI_FLAC_DECODER
-        else {
-            softwareCodec = InstantiateSoftwareDecoder(componentName, source);
-        }
-#endif
-
-        if (softwareCodec != NULL) {
-            ALOGV("Successfully allocated software codec '%s'", componentName);
+            sp<MediaSource> softwareCodec =
+                InstantiateSoftwareEncoder(componentName, source, meta);
 
-            return softwareCodec;
-        }
+            if (softwareCodec != NULL) {
+                ALOGV("Successfully allocated software codec '%s'", componentName);
 
-        const char* ext_componentName = ExtendedCodec::overrideComponentName(quirks, meta, mime, createEncoder);
-        if(ext_componentName != NULL) {
-          componentName = ext_componentName;
+                return softwareCodec;
+            }
         }
 
         ALOGV("Attempting to allocate OMX node '%s'", componentName);
@@ -574,23 +360,9 @@ sp<MediaSource> OMXCodec::Create(
             }
         }
 
-        //STATS profiling
-        PlayerExtendedStats* tempPtr = NULL;
-        meta->findPointer(ExtendedStats::MEDIA_STATS_FLAG, (void**)&tempPtr);
-
-        bool isVideo = !strncasecmp("video/", mime, 6);
-        if (tempPtr) {
-            tempPtr->profileStart(STATS_PROFILE_ALLOCATE_NODE(isVideo));
-        }
-
         status_t err = omx->allocateNode(componentName, observer, &node);
-
-        if (tempPtr) {
-            tempPtr->profileStop(STATS_PROFILE_ALLOCATE_NODE(isVideo));
-        }
-
         if (err == OK) {
-            ALOGD("Successfully allocated OMX node '%s'", componentName);
+            ALOGV("Successfully allocated OMX node '%s'", componentName);
 
             sp<OMXCodec> codec = new OMXCodec(
                     omx, node, quirks, flags,
@@ -599,16 +371,7 @@ sp<MediaSource> OMXCodec::Create(
 
             observer->setCodec(codec);
 
-            { //profile configure codec
-                ExtendedStats::AutoProfile autoProfile(
-                        STATS_PROFILE_CONFIGURE_CODEC(isVideo), tempPtr);
-                err = codec->configureCodec(meta);
-            }
-
-            /* set the stats pointer if we haven't yet and it exists */
-            if(codec->mPlayerExtendedStats == NULL && tempPtr)
-                codec->mPlayerExtendedStats = tempPtr;
-
+            err = codec->configureCodec(meta);
             if (err == OK) {
                 return codec;
             }
@@ -688,7 +451,7 @@ status_t OMXCodec::parseAVCCodecSpecificData(
     // assertion, let's be lenient for now...
     // CHECK((ptr[4] >> 2) == 0x3f);  // reserved
 
-    size_t lengthSize __unused = 1 + (ptr[4] & 3);
+    size_t lengthSize = 1 + (ptr[4] & 3);
 
     // commented out check below as H264_QVGA_500_NO_AUDIO.3gp
     // violates it...
@@ -767,14 +530,8 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             esds.getCodecSpecificInfo(
                     &codec_specific_data, &codec_specific_data_size);
 
-            const char * mime_type;
-            meta->findCString(kKeyMIMEType, &mime_type);
-            if (strncmp(mime_type,
-                        MEDIA_MIMETYPE_AUDIO_MPEG,
-                        strlen(MEDIA_MIMETYPE_AUDIO_MPEG))) {
-                addCodecSpecificData(
+            addCodecSpecificData(
                     codec_specific_data, codec_specific_data_size);
-            }
         } else if (meta->findData(kKeyAVCC, &type, &data, &size)) {
             // Parse the AVCDecoderConfigurationRecord
 
@@ -786,10 +543,6 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
                 return err;
             }
 
-#ifdef QCOM_BSP_LEGACY
-	        ExtendedUtils::setArbitraryModeIfInterlaced((const uint8_t *)data, meta);
-#endif
-
             CODEC_LOGI(
                     "AVC profile = %u (%s), level = %u",
                     profile, AVCProfileToString(profile), level);
@@ -819,21 +572,9 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             addCodecSpecificData(data, size);
             CHECK(meta->findData(kKeyOpusSeekPreRoll, &type, &data, &size));
             addCodecSpecificData(data, size);
-        } else if (meta->findData(kKeyRawCodecSpecificData, &type, &data, &size)) {
-            ALOGV("OMXCodec::configureCodec found kKeyRawCodecSpecificData of size %d\n", size);
-            addCodecSpecificData(data, size);
-#ifdef ENABLE_AV_ENHANCEMENTS
-        } else {
-            ExtendedCodec::getRawCodecSpecificData(meta, data, size);
-            if (size) {
-                addCodecSpecificData(data, size);
-            }
-#endif
         }
     }
 
-    if (!strncasecmp(mMIME, "audio/", 6)) {
-
     int32_t bitRate = 0;
     if (mIsEncoder) {
         CHECK(meta->findInt32(kKeyBitRate, &bitRate));
@@ -861,17 +602,6 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
             CODEC_LOGE("setAACFormat() failed (err = %d)", err);
             return err;
         }
-
-#ifdef ENABLE_AV_ENHANCEMENTS
-        uint32_t type;
-        const void *data;
-        size_t size;
-
-        if (meta->findData(kKeyAacCodecSpecificData, &type, &data, &size)) {
-            ALOGV("OMXCodec:: configureCodec found kKeyAacCodecSpecificData of size %d\n", size);
-            addCodecSpecificData(data, size);
-        }
-#endif
     } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_MPEG, mMIME)) {
         int32_t numChannels, sampleRate;
         if (meta->findInt32(kKeyChannelCount, &numChannels)
@@ -911,42 +641,6 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
         CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
 
         setRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
-#ifdef DTS_CODEC_M_
-    } else if (!strcasecmp(MEDIA_MIMETYPE_AUDIO_DTS, mMIME)) {
-        ALOGV(" (DTS) mime == MEDIA_MIMETYPE_AUDIO_DTS");
-        int32_t numChannels, sampleRate;
-        CHECK(meta->findInt32(kKeyChannelCount, &numChannels));
-        CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
-
-        status_t err = DTSUtils::setupDecoder(mOMX, mNode, sampleRate);
-
-        if (err != OK) {
-            return err;
-        }
-#endif
-    } else {
-        if (mIsEncoder && !mIsVideo) {
-            int32_t numChannels, sampleRate;
-            CHECK(meta->findInt32(kKeyChannelCount, &numChannels));
-            CHECK(meta->findInt32(kKeySampleRate, &sampleRate));
-            setRawAudioFormat(kPortIndexInput, sampleRate, numChannels);
-        }
-        status_t err = OK;
-
-#ifdef ENABLE_AV_ENHANCEMENTS
-        if (!strncmp(mComponentName, "OMX.qcom.", 9)) {
-            err = ExtendedCodec::setAudioFormat(
-                    meta, mMIME, mOMX, mNode, mIsEncoder);
-        }
-#endif
-        if (!strncmp(mComponentName, "OMX.ffmpeg.", 11)) {
-            err = FFMPEGSoftCodec::setAudioFormat(
-                    meta, mMIME, mOMX, mNode, mIsEncoder);
-        }
-        if (OK != err) {
-            return err;
-        }
-    }
     }
 
     if (!strncasecmp(mMIME, "video/", 6)) {
@@ -954,18 +648,12 @@ status_t OMXCodec::configureCodec(const sp<MetaData> &meta) {
         if (mIsEncoder) {
             setVideoInputFormat(mMIME, meta);
         } else {
-#ifdef ENABLE_AV_ENHANCEMENTS
-            ExtendedCodec::configureVideoDecoder(
-                    meta, mMIME, mOMX, mFlags, mNode, mComponentName);
-#endif
-            status_t err = setVideoOutputFormat(mMIME, meta);
+            status_t err = setVideoOutputFormat(
+                    mMIME, meta);
+
             if (err != OK) {
                 return err;
             }
-#ifdef ENABLE_AV_ENHANCEMENTS
-            ExtendedCodec::enableSmoothStreaming(
-                    mOMX, mNode, &mInSmoothStreamingMode, mComponentName);
-#endif
         }
     }
 
@@ -1094,7 +782,6 @@ status_t OMXCodec::setVideoPortFormatType(
     }
 
     if (!found) {
-        CODEC_LOGE("not found a match.");
         return UNKNOWN_ERROR;
     }
 
@@ -1106,10 +793,6 @@ status_t OMXCodec::setVideoPortFormatType(
     return err;
 }
 
-#ifdef USE_SAMSUNG_COLORFORMAT
-#define ALIGN(x, a) (((x) + (a) - 1) & ~((a) - 1))
-#endif
-
 static size_t getFrameSize(
         OMX_COLOR_FORMATTYPE colorFormat, int32_t width, int32_t height) {
     switch (colorFormat) {
@@ -1120,10 +803,6 @@ static size_t getFrameSize(
         case OMX_COLOR_FormatYUV420Planar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
-#ifdef STE_HARDWARE
-        case OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB:
-#endif
-
         /*
         * FIXME: For the Opaque color format, the frame size does not
         * need to be (w*h*3)/2. It just needs to
@@ -1133,20 +812,8 @@ static size_t getFrameSize(
         * this part in the future
         */
         case OMX_COLOR_FormatAndroidOpaque:
-#ifdef USE_SAMSUNG_COLORFORMAT
-        case OMX_SEC_COLOR_FormatNV12TPhysicalAddress:
-        case OMX_SEC_COLOR_FormatNV12LPhysicalAddress:
-#endif
             return (width * height * 3) / 2;
-#ifdef USE_SAMSUNG_COLORFORMAT
-
-        case OMX_SEC_COLOR_FormatNV12LVirtualAddress:
-            return ALIGN((ALIGN(width, 16) * ALIGN(height, 16)), 2048) + ALIGN((ALIGN(width, 16) * ALIGN(height >> 1, 8)), 2048);
-        case OMX_SEC_COLOR_FormatNV12Tiled:
-            static unsigned int frameBufferYSise = calc_plane(width, height);
-            static unsigned int frameBufferUVSise = calc_plane(width, height >> 1);
-            return (frameBufferYSise + frameBufferUVSise);
-#endif
+
         default:
             CHECK(!"Should not be here. Unsupported color format.");
             break;
@@ -1225,26 +892,13 @@ void OMXCodec::setVideoInputFormat(
         compressionFormat = OMX_VIDEO_CodingAVC;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mime)) {
         compressionFormat = OMX_VIDEO_CodingHEVC;
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime) ||
-            !strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4_DP, mime)) {
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime)) {
         compressionFormat = OMX_VIDEO_CodingMPEG4;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_H263, mime)) {
         compressionFormat = OMX_VIDEO_CodingH263;
     } else {
-        status_t err = ERROR_UNSUPPORTED;
-#ifdef ENABLE_AV_ENHANCEMENTS
-        if (!strncmp(mComponentName, "OMX.qcom.", 9)) {
-            err = ExtendedCodec::setVideoFormat(meta, mime, &compressionFormat);
-        }
-#endif
-        if (err != OK && !strncmp(mComponentName, "OMX.ffmpeg.", 11)) {
-            err = FFMPEGSoftCodec::setVideoFormat(
-                    meta, mime, mOMX, mNode, mIsEncoder, &compressionFormat);
-        }
-        if (err != OK) {
-            ALOGE("Not a supported video mime type: %s", mime);
-            CHECK(!"Should not be here. Not a supported video mime type.");
-        }
+        ALOGE("Not a supported video mime type: %s", mime);
+        CHECK(!"Should not be here. Not a supported video mime type.");
     }
 
     OMX_COLOR_FORMATTYPE colorFormat;
@@ -1330,18 +984,8 @@ void OMXCodec::setVideoInputFormat(
         }
 
         default:
-        {
-#ifdef ENABLE_AV_ENHANCEMENTS
-            bool retVal = ExtendedCodec::checkIfCompressionHEVC((int)compressionFormat);
-            if (retVal) {
-                CHECK_EQ(ExtendedCodec::setupHEVCEncoderParameters(meta, mOMX,
-                         mNode, mComponentName, kPortIndexOutput, this), (status_t)OK);
-            } else {
-                CHECK(!"Support for this compressionFormat to be implemented.");
-            }
-#endif
+            CHECK(!"Support for this compressionFormat to be implemented.");
             break;
-        }
     }
 }
 
@@ -1369,8 +1013,8 @@ status_t OMXCodec::setupErrorCorrectionParameters() {
     }
 
     errorCorrectionType.bEnableHEC = OMX_FALSE;
-    errorCorrectionType.bEnableResync = OMX_FALSE;
-    errorCorrectionType.nResynchMarkerSpacing = 0;
+    errorCorrectionType.bEnableResync = OMX_TRUE;
+    errorCorrectionType.nResynchMarkerSpacing = 256;
     errorCorrectionType.bEnableDataPartitioning = OMX_FALSE;
     errorCorrectionType.bEnableRVLC = OMX_FALSE;
 
@@ -1640,8 +1284,7 @@ status_t OMXCodec::setVideoOutputFormat(
     OMX_VIDEO_CODINGTYPE compressionFormat = OMX_VIDEO_CodingUnused;
     if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime)) {
         compressionFormat = OMX_VIDEO_CodingAVC;
-    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime) ||
-            !strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4_DP, mime)) {
+    } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG4, mime)) {
         compressionFormat = OMX_VIDEO_CodingMPEG4;
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mime)) {
         compressionFormat = OMX_VIDEO_CodingHEVC;
@@ -1654,20 +1297,8 @@ status_t OMXCodec::setVideoOutputFormat(
     } else if (!strcasecmp(MEDIA_MIMETYPE_VIDEO_MPEG2, mime)) {
         compressionFormat = OMX_VIDEO_CodingMPEG2;
     } else {
-        status_t err = ERROR_UNSUPPORTED;
-#ifdef ENABLE_AV_ENHANCEMENTS
-        if (!strncmp(mComponentName, "OMX.qcom.", 9)) {
-            err = ExtendedCodec::setVideoFormat(meta, mime, &compressionFormat);
-        }
-#endif
-        if(err != OK && !strncmp(mComponentName, "OMX.ffmpeg.", 11)) {
-            err = FFMPEGSoftCodec::setVideoFormat(
-                    meta, mMIME, mOMX, mNode, mIsEncoder, &compressionFormat);
-        }
-        if (err != OK) {
-            ALOGE("Not a supported video mime type: %s", mime);
-            return err;
-        }
+        ALOGE("Not a supported video mime type: %s", mime);
+        CHECK(!"Should not be here. Not a supported video mime type.");
     }
 
     status_t err = setVideoPortFormatType(
@@ -1690,30 +1321,6 @@ status_t OMXCodec::setVideoOutputFormat(
         CHECK_EQ(err, (status_t)OK);
         CHECK_EQ((int)format.eCompressionFormat, (int)OMX_VIDEO_CodingUnused);
 
-#if 0
-        CHECK(format.eColorFormat == OMX_COLOR_FormatYUV420Planar
-               || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
-               || format.eColorFormat == OMX_COLOR_FormatCbYCrY
-               || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar
-               || format.eColorFormat == OMX_QCOM_COLOR_FormatYVU420SemiPlanar
-               || format.eColorFormat == OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka
-#ifdef USE_SAMSUNG_COLORFORMAT
-               || format.eColorFormat == OMX_SEC_COLOR_FormatNV12TPhysicalAddress
-               || format.eColorFormat == OMX_SEC_COLOR_FormatNV12Tiled
-#endif
-               );
-
-#ifdef USE_SAMSUNG_COLORFORMAT
-        if (!strncmp("OMX.SEC.", mComponentName, 8)) {
-            if (mNativeWindow == NULL)
-                format.eColorFormat = OMX_COLOR_FormatYUV420Planar;
-            else
-                format.eColorFormat = (OMX_COLOR_FORMATTYPE)OMX_SEC_COLOR_FormatNV12Tiled;
-        }
-#endif
-
-#endif
-
         int32_t colorFormat;
         if (meta->findInt32(kKeyColorFormat, &colorFormat)
                 && colorFormat != OMX_COLOR_FormatUnused
@@ -1757,11 +1364,7 @@ status_t OMXCodec::setVideoOutputFormat(
 
 #if 1
     // XXX Need a (much) better heuristic to compute input buffer sizes.
-#ifdef USE_SAMSUNG_COLORFORMAT
-    const size_t X = 64 * 8 * 1024;
-#else
     const size_t X = 64 * 1024;
-#endif
     if (def.nBufferSize < X) {
         def.nBufferSize = X;
     }
@@ -1783,11 +1386,6 @@ status_t OMXCodec::setVideoOutputFormat(
     }
 
     ////////////////////////////////////////////////////////////////////////////
-    int32_t frameRate;
-    if (meta->findInt32(kKeyFrameRate, &frameRate)) {
-            PLAYER_STATS(setFrameRate, frameRate);
-    }
-    ////////////////////////////////////////////////////////////////////////////
 
     InitOMXParams(&def);
     def.nPortIndex = kPortIndexOutput;
@@ -1842,19 +1440,11 @@ OMXCodec::OMXCodec(
       mSkipCutBuffer(NULL),
       mLeftOverBuffer(NULL),
       mPaused(false),
-#ifdef DOLBY_UDC
-      mDolbyProcessedAudio(false),
-      mDolbyProcessedAudioStateChanged(false),
-#endif // DOLBY_END
       mNativeWindow(
-              (!strncmp(componentName, "OMX.google.", 11)
-              || !strncmp(componentName, "OMX.ffmpeg.", 11))
-                        ? NULL : nativeWindow),
-      mNumBFrames(0),
-      mInSmoothStreamingMode(false),
-      mOutputCropChanged(false) {
-    mPortStatus[kPortIndexInput] = ENABLING;
-    mPortStatus[kPortIndexOutput] = ENABLING;
+              (!strncmp(componentName, "OMX.google.", 11))
+                        ? NULL : nativeWindow) {
+    mPortStatus[kPortIndexInput] = ENABLED;
+    mPortStatus[kPortIndexOutput] = ENABLED;
 
     setComponentRole();
 }
@@ -1880,10 +1470,6 @@ void OMXCodec::setComponentRole(
             "audio_decoder.amrnb", "audio_encoder.amrnb" },
         { MEDIA_MIMETYPE_AUDIO_AMR_WB,
             "audio_decoder.amrwb", "audio_encoder.amrwb" },
-#ifdef ENABLE_AV_ENHANCEMENTS
-        { MEDIA_MIMETYPE_AUDIO_AMR_WB_PLUS,
-            "audio_decoder.amrwbplus", "audio_encoder.amrwbplus" },
-#endif
         { MEDIA_MIMETYPE_AUDIO_AAC,
             "audio_decoder.aac", "audio_encoder.aac" },
         { MEDIA_MIMETYPE_AUDIO_VORBIS,
@@ -1894,26 +1480,14 @@ void OMXCodec::setComponentRole(
             "audio_decoder.g711mlaw", "audio_encoder.g711mlaw" },
         { MEDIA_MIMETYPE_AUDIO_G711_ALAW,
             "audio_decoder.g711alaw", "audio_encoder.g711alaw" },
-#ifdef ENABLE_AV_ENHANCEMENTS
-        { MEDIA_MIMETYPE_AUDIO_EVRC,
-            "audio_decoder.evrchw", "audio_encoder.evrc" },
-        { MEDIA_MIMETYPE_AUDIO_QCELP,
-            "audio_decoder,qcelp13Hw", "audio_encoder.qcelp13" },
-#endif
         { MEDIA_MIMETYPE_VIDEO_AVC,
             "video_decoder.avc", "video_encoder.avc" },
         { MEDIA_MIMETYPE_VIDEO_HEVC,
             "video_decoder.hevc", "video_encoder.hevc" },
         { MEDIA_MIMETYPE_VIDEO_MPEG4,
             "video_decoder.mpeg4", "video_encoder.mpeg4" },
-        { MEDIA_MIMETYPE_VIDEO_MPEG4_DP,
-            "video_decoder.mpeg4", NULL },
         { MEDIA_MIMETYPE_VIDEO_H263,
             "video_decoder.h263", "video_encoder.h263" },
-#ifdef STE_HARDWARE
-        { MEDIA_MIMETYPE_VIDEO_VC1,
-            "video_decoder.vc1", "video_encoder.vc1" },
-#endif
         { MEDIA_MIMETYPE_VIDEO_VP8,
             "video_decoder.vp8", "video_encoder.vp8" },
         { MEDIA_MIMETYPE_VIDEO_VP9,
@@ -1928,16 +1502,6 @@ void OMXCodec::setComponentRole(
             "video_decoder.mpeg2", "video_encoder.mpeg2" },
         { MEDIA_MIMETYPE_AUDIO_AC3,
             "audio_decoder.ac3", "audio_encoder.ac3" },
-#ifdef DOLBY_UDC
-        { MEDIA_MIMETYPE_AUDIO_EAC3,
-            "audio_decoder.eac3", NULL },
-        { MEDIA_MIMETYPE_AUDIO_EAC3_JOC,
-            "audio_decoder.eac3_joc", NULL },
-#endif // DOLBY_END
-#ifdef DTS_CODEC_M_
-        { MEDIA_MIMETYPE_AUDIO_DTS,
-            "audio_decoder.dts", "audio_encoder.dts" },
-#endif
     };
 
     static const size_t kNumMimeToRole =
@@ -1951,13 +1515,6 @@ void OMXCodec::setComponentRole(
     }
 
     if (i == kNumMimeToRole) {
-        status_t err = ERROR_UNSUPPORTED;
-#ifdef ENABLE_AV_ENHANCEMENTS
-        err = ExtendedCodec::setSupportedRole(omx, node, isEncoder, mime);
-#endif
-        if (err != OK) {
-            err = FFMPEGSoftCodec::setSupportedRole(omx, node, isEncoder, mime);
-        }
         return;
     }
 
@@ -2014,16 +1571,6 @@ status_t OMXCodec::init() {
     CHECK_EQ((int)mState, (int)LOADED);
 
     status_t err;
-#ifdef STE_HARDWARE
-    if ((mQuirks & kRequiresStoreMetaDataBeforeIdle)
-        && (mFlags & kStoreMetaDataInVideoBuffers)) {
-        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
-        if (err != OK) {
-            ALOGE("Storing meta data in video buffers is not supported");
-            return err;
-        }
-    }
-#endif
     if (!(mQuirks & kRequiresLoadedToIdleAfterAllocation)) {
         err = mOMX->sendCommand(mNode, OMX_CommandStateSet, OMX_StateIdle);
         CHECK_EQ(err, (status_t)OK);
@@ -2054,8 +1601,6 @@ bool OMXCodec::isIntermediateState(State state) {
     return state == LOADED_TO_IDLE
         || state == IDLE_TO_EXECUTING
         || state == EXECUTING_TO_IDLE
-        || state == PAUSING
-        || state == FLUSHING
         || state == IDLE_TO_LOADED
         || state == RECONFIGURING;
 }
@@ -2071,11 +1616,6 @@ status_t OMXCodec::allocateBuffers() {
 }
 
 status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
-    const char* type = portIndex == kPortIndexInput ?
-                                    STATS_PROFILE_ALLOCATE_INPUT(mIsVideo) :
-                                    STATS_PROFILE_ALLOCATE_OUTPUT(mIsVideo);
-    ExtendedStats::AutoProfile autoProfile(type, mPlayerExtendedStats);
-
     if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {
         return allocateOutputBuffersFromNativeWindow();
     }
@@ -2086,12 +1626,7 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
     }
 
     status_t err = OK;
-#ifdef STE_HARDWARE
-    if (!(mQuirks & kRequiresStoreMetaDataBeforeIdle)
-            && (mFlags & kStoreMetaDataInVideoBuffers)
-#else
     if ((mFlags & kStoreMetaDataInVideoBuffers)
-#endif
             && portIndex == kPortIndexInput) {
         err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);
         if (err != OK) {
@@ -2111,17 +1646,11 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
         return err;
     }
 
-    CODEC_LOGI("allocating %lu buffers of size %lu on %s port",
+    CODEC_LOGV("allocating %lu buffers of size %lu on %s port",
             def.nBufferCountActual, def.nBufferSize,
             portIndex == kPortIndexInput ? "input" : "output");
 
-#ifdef MTK_HARDWARE
-    OMX_U32 memoryAlign = 32;
-    size_t totalSize = def.nBufferCountActual *
-        ((def.nBufferSize + (memoryAlign - 1))&(~(memoryAlign - 1)));
-#else
     size_t totalSize = def.nBufferCountActual * def.nBufferSize;
-#endif
     mDealer[portIndex] = new MemoryDealer(totalSize, "OMXCodec");
 
     for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {
@@ -2175,7 +1704,6 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
         info.mStatus = OWNED_BY_US;
         info.mMem = mem;
         info.mMediaBuffer = NULL;
-        info.mOutputCropChanged = false;
 
         if (portIndex == kPortIndexOutput) {
             // Fail deferred MediaBuffer creation until FILL_BUFFER_DONE;
@@ -2191,7 +1719,7 @@ status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {
 
         mPortBuffers[portIndex].push(info);
 
-        CODEC_LOGI("allocated buffer %p on %s port", buffer,
+        CODEC_LOGV("allocated buffer %p on %s port", buffer,
              portIndex == kPortIndexInput ? "input" : "output");
     }
 
@@ -2293,42 +1821,11 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         return err;
     }
 
-#ifdef USE_SAMSUNG_COLORFORMAT
-    OMX_COLOR_FORMATTYPE eNativeColorFormat = def.format.video.eColorFormat;
-    setNativeWindowColorFormat(eNativeColorFormat);
-
-    err = native_window_set_buffers_geometry(
-    mNativeWindow.get(),
-    def.format.video.nFrameWidth,
-    def.format.video.nFrameHeight,
-    eNativeColorFormat);
-#elif defined(MTK_HARDWARE)
-    OMX_U32 frameWidth = def.format.video.nFrameWidth;
-    OMX_U32 frameHeight = def.format.video.nFrameHeight;
-
-    if (!strncmp("OMX.MTK.", mComponentName, 8)) {
-        frameWidth = def.format.video.nStride;
-        frameHeight = def.format.video.nSliceHeight;
-    }
-
-    err = native_window_set_buffers_geometry(
-            mNativeWindow.get(),
-            frameWidth,
-            frameHeight,
-            def.format.video.eColorFormat);
-#elif defined(STE_HARDWARE)
-    err = native_window_set_buffers_geometry(
-            mNativeWindow.get(),
-            def.format.video.nFrameWidth,
-            def.format.video.nFrameHeight,
-            OmxToHALFormat(def.format.video.eColorFormat));
-#else
     err = native_window_set_buffers_geometry(
             mNativeWindow.get(),
             def.format.video.nFrameWidth,
             def.format.video.nFrameHeight,
             def.format.video.eColorFormat);
-#endif
 
     if (err != 0) {
         ALOGE("native_window_set_buffers_geometry failed: %s (%d)",
@@ -2351,10 +1848,6 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
     }
     if (mFlags & kEnableGrallocUsageProtected) {
         usage |= GRALLOC_USAGE_PROTECTED;
-#ifdef GRALLOC_USAGE_PRIVATE_NONSECURE
-        if (!(mFlags & kUseSecureInputBuffers))
-            usage |= GRALLOC_USAGE_PRIVATE_NONSECURE;
-#endif
     }
 
     // Make sure to check whether either Stagefright or the video decoder
@@ -2377,20 +1870,8 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
     }
 
     ALOGV("native_window_set_usage usage=0x%lx", usage);
-
-#ifdef MTK_HARDWARE
-    usage |= (GRALLOC_USAGE_SW_WRITE_OFTEN | GRALLOC_USAGE_SW_READ_OFTEN);
-#endif
-
-#ifdef EXYNOS4_ENHANCEMENTS
-    err = native_window_set_usage(
-            mNativeWindow.get(), usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP
-            | GRALLOC_USAGE_HW_FIMC1 | GRALLOC_USAGE_HWC_HWOVERLAY);
-#else
     err = native_window_set_usage(
             mNativeWindow.get(), usage | GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_EXTERNAL_DISP);
-#endif
-
     if (err != 0) {
         ALOGE("native_window_set_usage failed: %s (%d)", strerror(-err), -err);
         return err;
@@ -2457,16 +1938,6 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         return err;
     }
 
-#ifdef QCOM_BSP_LEGACY
-    err = mNativeWindow.get()->perform(mNativeWindow.get(),
-			     NATIVE_WINDOW_SET_BUFFERS_SIZE, def.nBufferSize);
-    if (err != 0) {
-	ALOGE("mNativeWindow.get()->perform() faild: %s (%d)", strerror(-err),
-		-err);
-	return err; 
-    }	 
-#endif
-
     CODEC_LOGV("allocating %u buffers from a native window of size %u on "
             "output port", def.nBufferCountActual, def.nBufferSize);
 
@@ -2487,6 +1958,7 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         info.mMem = NULL;
         info.mMediaBuffer = new MediaBuffer(graphicBuffer);
         info.mMediaBuffer->setObserver(this);
+        mPortBuffers[kPortIndexOutput].push(info);
 
         IOMX::buffer_id bufferId;
         err = mOMX->useGraphicBuffer(mNode, kPortIndexOutput, graphicBuffer,
@@ -2494,12 +1966,9 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
         if (err != 0) {
             CODEC_LOGE("registering GraphicBuffer with OMX IL component "
                     "failed: %d", err);
-            info.mMediaBuffer->setObserver(NULL);
-            info.mMediaBuffer->release();
             break;
         }
 
-        mPortBuffers[kPortIndexOutput].push(info);
         mPortBuffers[kPortIndexOutput].editItemAt(i).mBuffer = bufferId;
 
         CODEC_LOGV("registered graphic buffer with ID %u (pointer = %p)",
@@ -2527,30 +1996,6 @@ status_t OMXCodec::allocateOutputBuffersFromNativeWindow() {
     return err;
 }
 
-#ifdef USE_SAMSUNG_COLORFORMAT
-void OMXCodec::setNativeWindowColorFormat(OMX_COLOR_FORMATTYPE &eNativeColorFormat)
-{
-    // Convert OpenMAX color format to native color format
-    switch (eNativeColorFormat) {
-        // In case of SAMSUNG color format
-        case OMX_SEC_COLOR_FormatNV12TPhysicalAddress:
-            eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_CUSTOM_YCbCr_420_SP_TILED;
-            break;
-        case OMX_SEC_COLOR_FormatNV12Tiled:
-            eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_SP_TILED;
-            break;
-        // In case of OpenMAX color formats
-        case OMX_COLOR_FormatYUV420SemiPlanar:
-            eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_SP;
-            break;
-        case OMX_COLOR_FormatYUV420Planar:
-            default:
-            eNativeColorFormat = (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YCbCr_420_P;
-            break;
-    }
-}
-#endif // USE_SAMSUNG_COLORFORMAT
-
 status_t OMXCodec::cancelBufferToNativeWindow(BufferInfo *info) {
     CHECK_EQ((int)info->mStatus, (int)OWNED_BY_US);
     CODEC_LOGV("Calling cancelBuffer on buffer %u", info->mBuffer);
@@ -2569,6 +2014,7 @@ status_t OMXCodec::cancelBufferToNativeWindow(BufferInfo *info) {
 OMXCodec::BufferInfo* OMXCodec::dequeueBufferFromNativeWindow() {
     // Dequeue the next buffer from the native window.
     ANativeWindowBuffer* buf;
+    int fenceFd = -1;
     int err = native_window_dequeue_buffer_and_wait(mNativeWindow.get(), &buf);
     if (err != 0) {
       CODEC_LOGE("dequeueBuffer failed w/ error 0x%08x", err);
@@ -2673,6 +2119,7 @@ status_t OMXCodec::pushBlankBuffersToNativeWindow() {
     // on the screen and then been replaced, so an previous video frames are
     // guaranteed NOT to be currently displayed.
     for (int i = 0; i < numBufs + 1; i++) {
+        int fenceFd = -1;
         err = native_window_dequeue_buffer_and_wait(mNativeWindow.get(), &anb);
         if (err != NO_ERROR) {
             ALOGE("error pushing blank frames: dequeueBuffer failed: %s (%d)",
@@ -2787,7 +2234,6 @@ void OMXCodec::on_message(const omx_message &msg) {
 
         case omx_message::EMPTY_BUFFER_DONE:
         {
-            ATRACE_BEGIN("EMPTY_BUFFER_DONE");
             IOMX::buffer_id buffer = msg.u.extended_buffer_data.buffer;
 
             CODEC_LOGV("EMPTY_BUFFER_DONE(buffer: %u)", buffer);
@@ -2828,13 +2274,11 @@ void OMXCodec::on_message(const omx_message &msg) {
                     drainInputBuffer(&buffers->editItemAt(i));
                 }
             }
-            ATRACE_END();
             break;
         }
 
         case omx_message::FILL_BUFFER_DONE:
         {
-            ATRACE_BEGIN("FILL_BUFFER_DONE");
             IOMX::buffer_id buffer = msg.u.extended_buffer_data.buffer;
             OMX_U32 flags = msg.u.extended_buffer_data.flags;
 
@@ -2867,10 +2311,6 @@ void OMXCodec::on_message(const omx_message &msg) {
                 status_t err = freeBuffer(kPortIndexOutput, i);
                 CHECK_EQ(err, (status_t)OK);
 
-            } else if (mPortStatus[kPortIndexOutput] == ENABLED
-                       && (flags & OMX_BUFFERFLAG_DATACORRUPT)) {
-                CODEC_LOGV("Filled buffer data is corrupted, drop buffer");
-                mBufferFilled.signal();
 #if 0
             } else if (mPortStatus[kPortIndexOutput] == ENABLED
                        && (flags & OMX_BUFFERFLAG_EOS)) {
@@ -2938,7 +2378,6 @@ void OMXCodec::on_message(const omx_message &msg) {
                                 msg.u.extended_buffer_data.timestamp);
 
                         fillOutputBuffer(info);
-                        ATRACE_END();
                         break;
                     }
 
@@ -2950,23 +2389,13 @@ void OMXCodec::on_message(const omx_message &msg) {
                     mTargetTimeUs = -1;
                 }
 
-                if (mOutputCropChanged) {
-                    mOutputCropChanged = false;
-                    info->mOutputCropChanged = true;
-                }
                 mFilledBuffers.push_back(i);
                 mBufferFilled.signal();
-                if (!strncasecmp(mMIME, "video/", 6)) {
-                    ATRACE_INT("Output buffers with OMXCodec", mFilledBuffers.size());
-                    ATRACE_INT("Output Buffers with OMX client",
-                            countBuffersWeOwn(mPortBuffers[kPortIndexOutput]));
-                }
                 if (mIsEncoder) {
                     sched_yield();
                 }
             }
 
-            ATRACE_END();
             break;
         }
 
@@ -3141,48 +2570,7 @@ void OMXCodec::onEvent(OMX_EVENTTYPE event, OMX_U32 data1, OMX_U32 data2) {
             break;
         }
 #endif
-#ifdef DOLBY_UDC
-        case OMX_EventDolbyProcessedAudio:
-        {
-            mDolbyProcessedAudio = data1;
-            mDolbyProcessedAudioStateChanged = true;
-            break;
-        }
-#endif // DOLBY_END
-#ifdef USE_S3D_SUPPORT
-        case (OMX_EVENTTYPE)OMX_EventS3DInformation:
-        {
-            if (mFlags & kClientNeedsFramebuffer)
-                break;
 
-            sp<IServiceManager> sm = defaultServiceManager();
-            sp<android::IExynosHWCService> hwc = interface_cast<android::IExynosHWCService>(sm->getService(String16("Exynos.HWCService")));
-            if (hwc != NULL) {
-                if (data1 == OMX_TRUE) {
-                    int eS3DMode;
-                    switch (data2) {
-                    case OMX_SEC_FPARGMT_SIDE_BY_SIDE:
-                        eS3DMode = S3D_SBS;
-                        break;
-                    case OMX_SEC_FPARGMT_TOP_BOTTOM:
-                        eS3DMode = S3D_TB;
-                        break;
-                    case OMX_SEC_FPARGMT_CHECKERBRD_INTERL: // unsupport format at HDMI
-                    case OMX_SEC_FPARGMT_COLUMN_INTERL:
-                    case OMX_SEC_FPARGMT_ROW_INTERL:
-                    case OMX_SEC_FPARGMT_TEMPORAL_INTERL:
-                    default:
-                        eS3DMode = S3D_NONE;
-                    }
-
-                    hwc->setHdmiResolution(0, eS3DMode);
-                }
-            } else {
-                ALOGE("Exynos.HWCService is unavailable");
-            }
-            break;
-        }
-#endif
         default:
         {
             CODEC_LOGV("EVENT(%d, %u, %u)", event, data1, data2);
@@ -3270,18 +2658,11 @@ void OMXCodec::onCmdComplete(OMX_COMMANDTYPE cmd, OMX_U32 data) {
 
             CODEC_LOGV("FLUSH_DONE(%u)", portIndex);
 
-            if (portIndex == (OMX_U32) -1) {
-                CHECK_EQ((int)mPortStatus[kPortIndexInput], (int)SHUTTING_DOWN);
-                mPortStatus[kPortIndexInput] = ENABLED;
-                CHECK_EQ((int)mPortStatus[kPortIndexOutput], (int)SHUTTING_DOWN);
-                mPortStatus[kPortIndexOutput] = ENABLED;
-            } else {
-                CHECK_EQ((int)mPortStatus[portIndex], (int)SHUTTING_DOWN);
-                mPortStatus[portIndex] = ENABLED;
+            CHECK_EQ((int)mPortStatus[portIndex], (int)SHUTTING_DOWN);
+            mPortStatus[portIndex] = ENABLED;
 
-                CHECK_EQ(countBuffersWeOwn(mPortBuffers[portIndex]),
+            CHECK_EQ(countBuffersWeOwn(mPortBuffers[portIndex]),
                      mPortBuffers[portIndex].size());
-            }
 
             if (mSkipCutBuffer != NULL && mPortStatus[kPortIndexOutput] == ENABLED) {
                 mSkipCutBuffer->clear();
@@ -3314,7 +2695,6 @@ void OMXCodec::onCmdComplete(OMX_COMMANDTYPE cmd, OMX_U32 data) {
 
                     // We implicitly resume pulling on our upstream source.
                     mPaused = false;
-                    mNoMoreOutputData = false;
 
                     drainInputBuffers();
                     fillOutputBuffers();
@@ -3353,10 +2733,6 @@ void OMXCodec::onStateChange(OMX_STATETYPE newState) {
 
                 CHECK_EQ(err, (status_t)OK);
 
-                //Both ports should be enabled by now
-                mPortStatus[kPortIndexInput] = ENABLED;
-                mPortStatus[kPortIndexOutput] = ENABLED;
-
                 setState(IDLE_TO_EXECUTING);
             } else {
                 CHECK_EQ((int)mState, (int)EXECUTING_TO_IDLE);
@@ -3393,30 +2769,13 @@ void OMXCodec::onStateChange(OMX_STATETYPE newState) {
                 mPortStatus[kPortIndexInput] = ENABLED;
                 mPortStatus[kPortIndexOutput] = ENABLED;
 
-                if (mNativeWindow != NULL) {
-#ifdef QCOM_BSP_LEGACY
-		    /*
-		     * reset buffer size field with SurfaceTexture
-		     * back to 0. This wil ensure proper size
-		     * buffers are allocated if the same SurfaceTexture
-		     * is re-used in a different decode session
-		     */
-		    int err = 
-			mNativeWindow.get()->perform(mNativeWindow.get(), 
-						     NATIVE_WINDOW_SET_BUFFERS_SIZE,
-						     0);
-		    if (err != 0) {
-		    	ALOGE("mNativeWindow.get()->Perform() failed: %s (%d)", strerror(-err),
-				-err);	
-		    }		 
-#endif
-		    if (mFlags & kEnableGrallocUsageProtected) {	
-	                // We push enough 1x1 blank buffers to ensure that one of
-                        // them has made it to the display.  This allows the OMX
-                        // component teardown to zero out any protected buffers
-                        // without the risk of scanning out one of those buffers.
-                        pushBlankBuffersToNativeWindow();
-		    }
+                if ((mFlags & kEnableGrallocUsageProtected) &&
+                        mNativeWindow != NULL) {
+                    // We push enough 1x1 blank buffers to ensure that one of
+                    // them has made it to the display.  This allows the OMX
+                    // component teardown to zero out any protected buffers
+                    // without the risk of scanning out one of those buffers.
+                    pushBlankBuffersToNativeWindow();
                 }
 
                 setState(IDLE_TO_LOADED);
@@ -3452,14 +2811,6 @@ void OMXCodec::onStateChange(OMX_STATETYPE newState) {
             break;
         }
 
-        case OMX_StatePause:
-        {
-            CODEC_LOGV("Now paused.");
-            CHECK_EQ((int)mState, (int)PAUSING);
-            setState(PAUSED);
-            break;
-        }
-
         case OMX_StateInvalid:
         {
             setState(ERROR);
@@ -3574,27 +2925,22 @@ void OMXCodec::onPortSettingsChanged(OMX_U32 portIndex) {
 
 bool OMXCodec::flushPortAsync(OMX_U32 portIndex) {
     CHECK(mState == EXECUTING || mState == RECONFIGURING
-            || mState == EXECUTING_TO_IDLE || mState == FLUSHING);
+            || mState == EXECUTING_TO_IDLE);
 
-    if (portIndex == (OMX_U32) -1 ) {
-        mPortStatus[kPortIndexInput] = SHUTTING_DOWN;
-        mPortStatus[kPortIndexOutput] = SHUTTING_DOWN;
-    } else {
-        CODEC_LOGV("flushPortAsync(%ld): we own %d out of %d buffers already.",
-            portIndex, countBuffersWeOwn(mPortBuffers[portIndex]),
-            mPortBuffers[portIndex].size());
+    CODEC_LOGV("flushPortAsync(%ld): we own %d out of %d buffers already.",
+         portIndex, countBuffersWeOwn(mPortBuffers[portIndex]),
+         mPortBuffers[portIndex].size());
 
-        CHECK_EQ((int)mPortStatus[portIndex], (int)ENABLED);
-        mPortStatus[portIndex] = SHUTTING_DOWN;
+    CHECK_EQ((int)mPortStatus[portIndex], (int)ENABLED);
+    mPortStatus[portIndex] = SHUTTING_DOWN;
 
-        if ((mQuirks & kRequiresFlushCompleteEmulation)
-            && countBuffersWeOwn(mPortBuffers[portIndex])
+    if ((mQuirks & kRequiresFlushCompleteEmulation)
+        && countBuffersWeOwn(mPortBuffers[portIndex])
                 == mPortBuffers[portIndex].size()) {
-            // No flush is necessary and this component fails to send a
-            // flush-complete event in this case.
+        // No flush is necessary and this component fails to send a
+        // flush-complete event in this case.
 
-            return false;
-        }
+        return false;
     }
 
     status_t err =
@@ -3629,7 +2975,7 @@ status_t OMXCodec::enablePortAsync(OMX_U32 portIndex) {
 }
 
 void OMXCodec::fillOutputBuffers() {
-    CHECK(mState == EXECUTING || mState == FLUSHING);
+    CHECK_EQ((int)mState, (int)EXECUTING);
 
     // This is a workaround for some decoders not properly reporting
     // end-of-output-stream. If we own all input buffers and also own
@@ -3656,7 +3002,7 @@ void OMXCodec::fillOutputBuffers() {
 }
 
 void OMXCodec::drainInputBuffers() {
-    CHECK(mState == EXECUTING || mState == RECONFIGURING || mState == FLUSHING);
+    CHECK(mState == EXECUTING || mState == RECONFIGURING);
 
     if (mFlags & kUseSecureInputBuffers) {
         Vector<BufferInfo> *buffers = &mPortBuffers[kPortIndexInput];
@@ -3722,7 +3068,6 @@ OMXCodec::BufferInfo *OMXCodec::findEmptyInputBuffer() {
 }
 
 bool OMXCodec::drainInputBuffer(BufferInfo *info) {
-    ATRACE_CALL();
     if (info != NULL) {
         CHECK_EQ((int)info->mStatus, (int)OWNED_BY_US);
     }
@@ -3741,7 +3086,7 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
 
         if ((!strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mMIME) ||
              !strcasecmp(MEDIA_MIMETYPE_VIDEO_HEVC, mMIME))
-             && !(mQuirks & kWantsNALFragments)) {
+                && !(mQuirks & kWantsNALFragments)) {
             static const uint8_t kNALStartCode[4] =
                     { 0x00, 0x00, 0x00, 0x01 };
 
@@ -3785,9 +3130,6 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
     size_t offset = 0;
     int32_t n = 0;
 
-    int32_t interlaceFormatDetected = false;
-    int32_t interlaceFrameCount = 0;
-
 
     for (;;) {
         MediaBuffer *srcBuffer;
@@ -3834,9 +3176,6 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
             break;
         }
 
-	sp<MetaData> metaData = mSource->getFormat();
-	interlaceFormatDetected = ExtendedUtils::checkIsInterlace(metaData);
-
         if (mFlags & kUseSecureInputBuffers) {
             info = findInputBufferByDataPointer(srcBuffer->data());
             CHECK(info != NULL);
@@ -3876,55 +3215,16 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
                 CHECK(info->mMediaBuffer == NULL);
                 info->mMediaBuffer = srcBuffer;
         } else {
-#ifdef USE_SAMSUNG_COLORFORMAT
-            OMX_PARAM_PORTDEFINITIONTYPE def;
-            InitOMXParams(&def);
-            def.nPortIndex = kPortIndexInput;
-
-            status_t err = mOMX->getParameter(mNode, OMX_IndexParamPortDefinition,
-            &def, sizeof(def));
-            CHECK_EQ(err, (status_t)OK);
-
-            if (def.eDomain == OMX_PortDomainVideo) {
-                OMX_VIDEO_PORTDEFINITIONTYPE *videoDef = &def.format.video;
-                switch (videoDef->eColorFormat) {
-                    case OMX_SEC_COLOR_FormatNV12LVirtualAddress: {
-                        CHECK(srcBuffer->data() != NULL);
-                        void *pSharedMem = (void *)(srcBuffer->data());
-                        memcpy((uint8_t *)info->mData + offset,
-                        (const void *)&pSharedMem, sizeof(void *));
-                        break;
-                    }
-                    default:
-                        CHECK(srcBuffer->data() != NULL);
-                        memcpy((uint8_t *)info->mData + offset,
-                        (const uint8_t *)srcBuffer->data()
-                        + srcBuffer->range_offset(),
-                        srcBuffer->range_length());
-                        break;
-                    }
-            } else {
-                CHECK(srcBuffer->data() != NULL);
-                memcpy((uint8_t *)info->mData + offset,
-                        (const uint8_t *)srcBuffer->data()
-                            + srcBuffer->range_offset(),
-                        srcBuffer->range_length());
-            }
-#else
             CHECK(srcBuffer->data() != NULL) ;
             memcpy((uint8_t *)info->mData + offset,
                     (const uint8_t *)srcBuffer->data()
                         + srcBuffer->range_offset(),
                     srcBuffer->range_length());
-#endif // USE_SAMSUNG_COLORFORMAT
         }
 
         int64_t lastBufferTimeUs;
         CHECK(srcBuffer->meta_data()->findInt64(kKeyTime, &lastBufferTimeUs));
         CHECK(lastBufferTimeUs >= 0);
-
-        PLAYER_STATS(logBitRate, srcBuffer->range_length(), lastBufferTimeUs);
-
         if (mIsEncoder && mIsVideo) {
             mDecodingTimeList.push_back(lastBufferTimeUs);
         }
@@ -3977,25 +3277,8 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
 
     OMX_U32 flags = OMX_BUFFERFLAG_ENDOFFRAME;
 
-    if(interlaceFormatDetected) {
-	interlaceFrameCount++;
-    }
-
     if (signalEOS) {
         flags |= OMX_BUFFERFLAG_EOS;
-    } else if (ExtendedUtils::checkIsThumbNailMode(mFlags, mComponentName)
-			&& (!interlaceFormatDetected || interlaceFrameCount >= 2)) {
-	// Because we don't get EOS after getting the first frame, we 
-	// nee to notify the component with OMX_BUFFERFLAG_EOS, set
-	//mNoMoreOutputData to false so fillOutputBuffer gets called on 
-	// the first output buffer (see comment in fillOutputBuffer), and 
-	// mSignalledEOS must be true so drainInputBuffer is not executed
-	// on extra frames. Setting mFinalStatus to ERROR_END_OF_STREAM as 
-	// we dont want to return OK and NULL buffer in read.
-	flags |= OMX_BUFFERFLAG_EOS;
-	mNoMoreOutputData = false;
-	mSignalledEOS = true;
-	mFinalStatus = ERROR_END_OF_STREAM;
     } else {
         mNoMoreOutputData = false;
     }
@@ -4010,7 +3293,6 @@ bool OMXCodec::drainInputBuffer(BufferInfo *info) {
         info = findEmptyInputBuffer();
     }
 
-    PLAYER_STATS(profileStartOnce, STATS_PROFILE_FIRST_BUFFER(mIsVideo));
     CODEC_LOGV("Calling emptyBuffer on buffer %p (length %d), "
                "timestamp %lld us (%.2f secs)",
                info->mBuffer, offset,
@@ -4088,20 +3370,13 @@ void OMXCodec::setState(State newState) {
 
 status_t OMXCodec::waitForBufferFilled_l() {
 
-    ATRACE_CALL();
-    if (mIsEncoder && mIsVideo) {
+    if (mIsEncoder) {
         // For timelapse video recording, the timelapse video recording may
         // not send an input frame for a _long_ time. Do not use timeout
         // for video encoding.
         return mBufferFilled.wait(mLock);
     }
     status_t err = mBufferFilled.waitRelative(mLock, kBufferFilledEventTimeOutNs);
-    if ((err == -ETIMEDOUT) && (mPaused == true)){
-        // When the audio playback is paused, the fill buffer maybe timed out
-        // if input data is not available to decode. Hence, considering the
-        // timed out as a valid case.
-        err = OK;
-    }
     if (err != OK) {
         CODEC_LOGE("Timed out waiting for output buffers: %d/%d",
             countBuffersWeOwn(mPortBuffers[kPortIndexInput]),
@@ -4117,7 +3392,6 @@ void OMXCodec::setRawAudioFormat(
     OMX_PARAM_PORTDEFINITIONTYPE def;
     InitOMXParams(&def);
     def.nPortIndex = portIndex;
-    def.format.audio.cMIMEType = NULL;
     status_t err = mOMX->getParameter(
             mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));
     CHECK_EQ(err, (status_t)OK);
@@ -4475,11 +3749,6 @@ void OMXCodec::clearCodecSpecificData() {
 status_t OMXCodec::start(MetaData *meta) {
     Mutex::Autolock autoLock(mLock);
 
-    if (mPaused) {
-        status_t err = resumeLocked(true);
-        return err;
-    }
-
     if (mState != LOADED) {
         CODEC_LOGE("called start in the unexpected state: %d", mState);
         return UNKNOWN_ERROR;
@@ -4533,15 +3802,7 @@ status_t OMXCodec::start(MetaData *meta) {
         CODEC_LOGE("source failed to start: %d", err);
         return err;
     }
-    if ((err = init()) != OK) {
-        CODEC_LOGE("init failed: %d", err);
-        //Something went wrong..component refused to move to idle or allocation
-        //failed. Set state to error and force stopping component to cleanup as
-        //much as possible
-        setState(ERROR);
-        stopOmxComponent_l();
-    }
-    return err;
+    return init();
 }
 
 status_t OMXCodec::stop() {
@@ -4598,7 +3859,6 @@ status_t OMXCodec::stopOmxComponent_l() {
             isError = true;
         }
 
-        case PAUSED:
         case EXECUTING:
         {
             setState(EXECUTING_TO_IDLE);
@@ -4607,27 +3867,18 @@ status_t OMXCodec::stopOmxComponent_l() {
                 CODEC_LOGV("This component requires a flush before transitioning "
                      "from EXECUTING to IDLE...");
 
-                //DSP supports flushing of ports simultaneously.
-                //Flushing individual port is not supported.
-                if(mQuirks & kRequiresGlobalFlush) {
-                    bool emulateFlushCompletion = !flushPortAsync(kPortIndexBoth);
-                    if (emulateFlushCompletion) {
-                        onCmdComplete(OMX_CommandFlush, kPortIndexBoth);
-                    }
-                } else {
-                    bool emulateInputFlushCompletion =
-                        !flushPortAsync(kPortIndexInput);
+                bool emulateInputFlushCompletion =
+                    !flushPortAsync(kPortIndexInput);
 
-                    bool emulateOutputFlushCompletion =
-                        !flushPortAsync(kPortIndexOutput);
+                bool emulateOutputFlushCompletion =
+                    !flushPortAsync(kPortIndexOutput);
 
-                    if (emulateInputFlushCompletion) {
-                        onCmdComplete(OMX_CommandFlush, kPortIndexInput);
-                    }
+                if (emulateInputFlushCompletion) {
+                    onCmdComplete(OMX_CommandFlush, kPortIndexInput);
+                }
 
-                    if (emulateOutputFlushCompletion) {
-                        onCmdComplete(OMX_CommandFlush, kPortIndexOutput);
-                    }
+                if (emulateOutputFlushCompletion) {
+                    onCmdComplete(OMX_CommandFlush, kPortIndexOutput);
                 }
             } else {
                 mPortStatus[kPortIndexInput] = SHUTTING_DOWN;
@@ -4674,20 +3925,11 @@ sp<MetaData> OMXCodec::getFormat() {
 
 status_t OMXCodec::read(
         MediaBuffer **buffer, const ReadOptions *options) {
-    ATRACE_CALL();
     status_t err = OK;
     *buffer = NULL;
 
     Mutex::Autolock autoLock(mLock);
 
-    if (mPaused) {
-        err = resumeLocked(false);
-        if(err != OK) {
-            CODEC_LOGE("Failed to restart codec err= %d", err);
-            return err;
-        }
-    }
-
     if (mState != EXECUTING && mState != RECONFIGURING) {
         return UNKNOWN_ERROR;
     }
@@ -4713,13 +3955,13 @@ status_t OMXCodec::read(
             mPaused = false;
         }
 
+        drainInputBuffers();
 
         if (mState == EXECUTING) {
             // Otherwise mState == RECONFIGURING and this code will trigger
             // after the output port is reenabled.
             fillOutputBuffers();
         }
-        drainInputBuffers();
     }
 
     if (seeking) {
@@ -4744,35 +3986,16 @@ status_t OMXCodec::read(
         mFilledBuffers.clear();
 
         CHECK_EQ((int)mState, (int)EXECUTING);
-        //DSP supports flushing of ports simultaneously. Flushing individual port is not supported.
-        setState(FLUSHING);
 
-        if(mQuirks & kRequiresGlobalFlush) {
-            bool emulateFlushCompletion = !flushPortAsync(kPortIndexBoth);
-            if (emulateFlushCompletion) {
-                onCmdComplete(OMX_CommandFlush, kPortIndexBoth);
-            }
-        } else {
+        bool emulateInputFlushCompletion = !flushPortAsync(kPortIndexInput);
+        bool emulateOutputFlushCompletion = !flushPortAsync(kPortIndexOutput);
 
-            //DSP supports flushing of ports simultaneously.
-            //Flushing individual port is not supported.
-            if(mQuirks & kRequiresGlobalFlush) {
-                bool emulateFlushCompletion = !flushPortAsync(kPortIndexBoth);
-                if (emulateFlushCompletion) {
-                    onCmdComplete(OMX_CommandFlush, kPortIndexBoth);
-                }
-            } else {
-                bool emulateInputFlushCompletion = !flushPortAsync(kPortIndexInput);
-                bool emulateOutputFlushCompletion = !flushPortAsync(kPortIndexOutput);
-
-                if (emulateInputFlushCompletion) {
-                    onCmdComplete(OMX_CommandFlush, kPortIndexInput);
-                }
+        if (emulateInputFlushCompletion) {
+            onCmdComplete(OMX_CommandFlush, kPortIndexInput);
+        }
 
-                if (emulateOutputFlushCompletion) {
-                    onCmdComplete(OMX_CommandFlush, kPortIndexOutput);
-                }
-            }
+        if (emulateOutputFlushCompletion) {
+            onCmdComplete(OMX_CommandFlush, kPortIndexOutput);
         }
 
         while (mSeekTimeUs >= 0) {
@@ -4782,12 +4005,6 @@ status_t OMXCodec::read(
         }
     }
 
-    if (!strncasecmp(mMIME, "video/", 6)) {
-        ATRACE_INT("Output buffers with OMXCodec", mFilledBuffers.size());
-        ATRACE_INT("Output Buffers with OMX client",
-                countBuffersWeOwn(mPortBuffers[kPortIndexOutput]));
-    }
-
     while (mState != ERROR && !mNoMoreOutputData && mFilledBuffers.empty()) {
         if ((err = waitForBufferFilled_l()) != OK) {
             return err;
@@ -4798,11 +4015,6 @@ status_t OMXCodec::read(
         return UNKNOWN_ERROR;
     }
 
-    if (seeking) {
-        CHECK_EQ((int)mState, (int)FLUSHING);
-        setState(EXECUTING);
-    }
-
     if (mFilledBuffers.empty()) {
         return mSignalledEOS ? mFinalStatus : ERROR_END_OF_STREAM;
     }
@@ -4815,11 +4027,6 @@ status_t OMXCodec::read(
 
     size_t index = *mFilledBuffers.begin();
     mFilledBuffers.erase(mFilledBuffers.begin());
-    if (!strncasecmp(mMIME, "video/", 6)) {
-        ATRACE_INT("Output buffers with OMXCodec", mFilledBuffers.size());
-        ATRACE_INT("Output Buffers with OMX client",
-                countBuffersWeOwn(mPortBuffers[kPortIndexOutput]));
-    }
 
     BufferInfo *info = &mPortBuffers[kPortIndexOutput].editItemAt(index);
     CHECK_EQ((int)info->mStatus, (int)OWNED_BY_US);
@@ -4831,20 +4038,6 @@ status_t OMXCodec::read(
     }
     *buffer = info->mMediaBuffer;
 
-#ifndef MTK_HARDWARE
-    if (info->mOutputCropChanged) {
-        initNativeWindowCrop();
-        info->mOutputCropChanged = false;
-    }
-#endif
-#ifdef DOLBY_UDC
-    if (mDolbyProcessedAudioStateChanged) {
-        mDolbyProcessedAudioStateChanged = false;
-        return mDolbyProcessedAudio
-            ? INFO_DOLBY_PROCESSED_AUDIO_START
-            : INFO_DOLBY_PROCESSED_AUDIO_STOP;
-    }
-#endif  // DOLBY_END
     return OK;
 }
 
@@ -5067,8 +4260,6 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
             mOutputFormat->setInt32(kKeyColorFormat, imageDef->eColorFormat);
             mOutputFormat->setInt32(kKeyWidth, imageDef->nFrameWidth);
             mOutputFormat->setInt32(kKeyHeight, imageDef->nFrameHeight);
-            mOutputFormat->setInt32(kKeyStride, imageDef->nStride);
-            mOutputFormat->setInt32(kKeySliceHeight, imageDef->nSliceHeight);
             break;
         }
 
@@ -5094,14 +4285,14 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 inputFormat->findInt32(kKeySampleRate, &sampleRate);
 
                 if ((OMX_U32)numChannels != params.nChannels) {
-                    ALOGI("Codec outputs a different number of channels than "
+                    ALOGV("Codec outputs a different number of channels than "
                          "the input stream contains (contains %d channels, "
                          "codec outputs %ld channels).",
                          numChannels, params.nChannels);
                 }
 
                 if (sampleRate != (int32_t)params.nSamplingRate) {
-                    ALOGI("Codec outputs at different sampling rate than "
+                    ALOGV("Codec outputs at different sampling rate than "
                          "what the input stream contains (contains data at "
                          "%d Hz, codec outputs %lu Hz)",
                          sampleRate, params.nSamplingRate);
@@ -5167,29 +4358,7 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 mOutputFormat->setInt32(kKeySampleRate, sampleRate);
                 mOutputFormat->setInt32(kKeyBitRate, bitRate);
             } else {
-                AString mimeType;
-                err = BAD_VALUE;
-#ifdef ENABLE_AV_ENHANCEMENTS
-                err = ExtendedCodec::handleSupportedAudioFormats(
-                        audio_def->eEncoding, &mimeType);
-#endif
-                if (err != OK) {
-                    err = FFMPEGSoftCodec::handleSupportedAudioFormats(
-                            audio_def->eEncoding, &mimeType);
-                }
-                if (err == OK) {
-                    mOutputFormat->setCString(
-                            kKeyMIMEType, mimeType.c_str());
-                    int32_t numChannels, sampleRate, bitRate;
-                    inputFormat->findInt32(kKeyChannelCount, &numChannels);
-                    inputFormat->findInt32(kKeySampleRate, &sampleRate);
-                    inputFormat->findInt32(kKeyBitRate, &bitRate);
-                    mOutputFormat->setInt32(kKeyChannelCount, numChannels);
-                    mOutputFormat->setInt32(kKeySampleRate, sampleRate);
-                    mOutputFormat->setInt32(kKeyBitRate, bitRate);
-                } else {
-                    CHECK(!"Should not be here. Unknown audio encoding.");
-                }
+                CHECK(!"Should not be here. Unknown audio encoding.");
             }
             break;
         }
@@ -5211,28 +4380,12 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 mOutputFormat->setCString(
                         kKeyMIMEType, MEDIA_MIMETYPE_VIDEO_AVC);
             } else {
-                AString mimeType;
-                err = BAD_VALUE;
-#ifdef ENABLE_AV_ENHANCEMENTS
-                err = ExtendedCodec::handleSupportedVideoFormats(
-                        video_def->eCompressionFormat, &mimeType);
-#endif
-                if (err != OK) {
-                    err = FFMPEGSoftCodec::handleSupportedVideoFormats(
-                            video_def->eCompressionFormat, &mimeType);
-                }
-                if (err == OK) {
-                    mOutputFormat->setCString(kKeyMIMEType, mimeType.c_str());
-                } else {
-                    CHECK(!"Unknown compression format.");
-                }
+                CHECK(!"Unknown compression format.");
             }
 
             mOutputFormat->setInt32(kKeyWidth, video_def->nFrameWidth);
             mOutputFormat->setInt32(kKeyHeight, video_def->nFrameHeight);
             mOutputFormat->setInt32(kKeyColorFormat, video_def->eColorFormat);
-            mOutputFormat->setInt32(kKeyStride, video_def->nStride);
-            mOutputFormat->setInt32(kKeySliceHeight, video_def->nSliceHeight);
 
             if (!mIsEncoder) {
                 OMX_CONFIG_RECTTYPE rect;
@@ -5274,14 +4427,7 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
                 }
 
                 if (mNativeWindow != NULL) {
-#ifndef MTK_HARDWARE
-                     if (mInSmoothStreamingMode) {
-                         mOutputCropChanged = true;
-                     } else
-#endif
-                     {
-                         initNativeWindowCrop();
-                     }
+                     initNativeWindowCrop();
                 }
             }
             break;
@@ -5304,64 +4450,11 @@ void OMXCodec::initOutputFormat(const sp<MetaData> &inputFormat) {
 }
 
 status_t OMXCodec::pause() {
-   CODEC_LOGV("pause mState=%d", mState);
-
-   Mutex::Autolock autoLock(mLock);
-
-   if (mState != EXECUTING) {
-       return UNKNOWN_ERROR;
-   }
-
-   while (isIntermediateState(mState)) {
-       mAsyncCompletion.wait(mLock);
-   }
-   if (!strncmp(mComponentName, "OMX.qcom.", 9)) {
-       status_t err = mOMX->sendCommand(mNode,
-           OMX_CommandStateSet, OMX_StatePause);
-       CHECK_EQ(err, (status_t)OK);
-       setState(PAUSING);
-
-       mPaused = true;
-       while (mState != PAUSED && mState != ERROR) {
-           mAsyncCompletion.wait(mLock);
-       }
-       return mState == ERROR ? UNKNOWN_ERROR : OK;
-   } else {
-       mPaused = true;
-       return OK;
-   }
-
-}
+    Mutex::Autolock autoLock(mLock);
 
-status_t OMXCodec::resumeLocked(bool drainInputBuf) {
-   CODEC_LOGV("resume mState=%d", mState);
+    mPaused = true;
 
-   if (!strncmp(mComponentName, "OMX.qcom.", 9) && mPaused) {
-        while (isIntermediateState(mState)) {
-            mAsyncCompletion.wait(mLock);
-        }
-        if (mState == (status_t)EXECUTING) {
-            CODEC_LOGI("in EXECUTING state, return OK");
-            return OK;
-        }
-        CHECK_EQ(mState, (status_t)PAUSED);
-        status_t err = mOMX->sendCommand(mNode,
-        OMX_CommandStateSet, OMX_StateExecuting);
-        CHECK_EQ(err, (status_t)OK);
-        setState(IDLE_TO_EXECUTING);
-        mPaused = false;
-        while (mState != EXECUTING && mState != ERROR) {
-            mAsyncCompletion.wait(mLock);
-        }
-        if(drainInputBuf)
-            drainInputBuffers();
-        return mState == ERROR ? UNKNOWN_ERROR : OK;
-    } else {   // SW Codec
-        mPaused = false;
-        if(drainInputBuf)
-            drainInputBuffers();
-        return OK;
-    }
+    return OK;
 }
 
 ////////////////////////////////////////////////////////////////////////////////
diff --git a/media/libstagefright/colorconversion/ColorConverter.cpp b/media/libstagefright/colorconversion/ColorConverter.cpp
index a85ad72..597167f 100644
--- a/media/libstagefright/colorconversion/ColorConverter.cpp
+++ b/media/libstagefright/colorconversion/ColorConverter.cpp
@@ -47,9 +47,6 @@ bool ColorConverter::isValid() const {
         case OMX_QCOM_COLOR_FormatYVU420SemiPlanar:
         case OMX_COLOR_FormatYUV420SemiPlanar:
         case OMX_TI_COLOR_FormatYUV420PackedSemiPlanar:
-#ifdef STE_HARDWARE
-        case OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB:
-#endif
             return true;
 
         default:
@@ -125,12 +122,6 @@ status_t ColorConverter::convert(
             err = convertTIYUV420PackedSemiPlanar(src, dst);
             break;
 
-#ifdef STE_HARDWARE
-        case OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB:
-            err = convertSTEYUV420PackedSemiPlanarMB(src, dst);
-            break;
-#endif
-
         default:
         {
             CHECK(!"Should not be here. Unknown color conversion.");
@@ -515,142 +506,6 @@ status_t ColorConverter::convertTIYUV420PackedSemiPlanar(
     return OK;
 }
 
-#ifdef STE_HARDWARE
-status_t ColorConverter::convertSTEYUV420PackedSemiPlanarMB(
-        const BitmapParams &src, const BitmapParams &dst) {
-
-    if (!((dst.mWidth & 1) == 0
-            && src.mCropLeft == 0
-            && src.mCropTop == 0
-            && src.cropWidth() == dst.cropWidth()
-            && src.cropHeight() == dst.cropHeight())) {
-        return ERROR_UNSUPPORTED;
-    }
-
-    OMX_U32 mx = src.mWidth / 16;
-    OMX_U32 my = src.mHeight / 16;
-    OMX_U32 lx, ly;
-    OMX_U32 *pChroma, *pLuma = (OMX_U32 *)src.mBits;
-
-    pChroma = (OMX_U32 *)src.mBits + mx * my * 64;
-    for (ly = 0; ly < my; ly++) {
-        for (lx = 0; lx < mx; lx++) {
-            OMX_U32 col, row, lumaWord, chromaWord1 = 0, rgbWord, i;
-            OMX_U8 y[4], cb[4], cr[4], r[4], g[4], b[4];
-            OMX_U32 *dstBuf, *locBuf;
-            OMX_U32 *pBurstLuma = 0, *pBurstChroma = 0;
-            OMX_U32 *pWordLuma = 0, *pWordChroma = 0;
-            OMX_U8 nbOfBlock;
-
-            dstBuf = ((OMX_U32 *)dst.mBits) + (ly * 16) * dst.mWidth / 2;
-            dstBuf += (lx * 16) / 2;
-
-            pBurstLuma = pLuma;
-            pBurstChroma = pChroma;
-
-            for (col = 0; col < 2; col++) {
-                // conversion of a macroblock
-                for (nbOfBlock = 0; nbOfBlock < 2; nbOfBlock++) {
-                    locBuf = dstBuf + 4 * col + 2 * nbOfBlock;
-                    OMX_U32 dstRowOrigo = ly * 16 * dst.mWidth;
-
-                    switch (nbOfBlock) {
-                    case 0:
-                        pWordLuma = pBurstLuma;
-                        pWordChroma = pBurstChroma;
-                        break;
-                    case 1:
-                        pWordLuma = pBurstLuma + 1;
-                        pWordChroma = pBurstChroma + 1;
-                        break;
-                    }
-                    for (row = 0; row < 16; row++) {
-                        // Check for cropping on the y axis
-                        if (ly * 16 + row >= dst.mHeight) {
-                            break;
-                        }
-
-                        lumaWord = *pWordLuma;
-                        pWordLuma += 2;
-                        if (row % 2 == 0) {
-                            chromaWord1 = *pWordChroma;
-                            pWordChroma += 2;
-                        }
-
-                        y[3] = ((lumaWord >> 24) & 0xff);
-                        y[2] = ((lumaWord >> 16) & 0xff);
-                        y[1] = ((lumaWord >>  8) & 0xff);
-                        y[0] = ((lumaWord >>  0) & 0xff);
-
-                        cb[0] = cb[1] = ((chromaWord1 >>  0) & 0xff);
-                        cb[2] = cb[3] = ((chromaWord1 >> 16) & 0xff);
-                        cr[0] = cr[1] = ((chromaWord1 >>  8) & 0xff);
-                        cr[2] = cr[3] = ((chromaWord1 >> 24) & 0xff);
-
-                        for (i = 0; i < 4; i++) {
-                            int32_t rW,gW,bW;
-
-                            rW = 298 * y[i] + 408 * cr[i] - 57059;
-                            gW = 298 * y[i] - 100 * cb[i] - 208 * cr[i] + 34713;
-                            bW = 298 * y[i] + 516 * cb[i] - 70887;
-
-                            if (rW < 0) {
-                                r[i] = 0;
-                            } else if (rW >= 65536) {
-                                r[i] = 255;
-                            } else {
-                                r[i] = (rW >> 8);
-                            }
-                            if (gW < 0) {
-                                g[i] = 0;
-                            } else if (gW >= 65536) {
-                                g[i] = 255;
-                            } else {
-                                g[i] = (gW >> 8);
-                            }
-                            if (bW < 0) {
-                                b[i] = 0;
-                            } else if (bW >= 65536) {
-                                b[i] = 255;
-                            } else {
-                                b[i] = (bW >> 8);
-                            }
-                            r[i] >>= 3;
-                            g[i] >>= 2;
-                            b[i] >>= 3;
-                        }
-                        for (i = 0; i < 4; i += 2) {
-                            // Check for cropping on the x axis
-                            OMX_U32 rowPos = (locBuf - (OMX_U32 *)dst.mBits) * 2 - dstRowOrigo;
-                            if (rowPos >= dst.mWidth) {
-                                locBuf++;
-                                continue;
-                            }
-
-                            rgbWord = (r[i + 1] << 27) +
-                                (g[i + 1] << 21) +
-                                (b[i + 1] << 16) +
-                                (r[i] << 11) +
-                                (g[i] << 5) +
-                                (b[i] << 0);
-                            *locBuf++ = rgbWord;
-                        }
-                        locBuf += dst.mWidth / 2 - 2;
-                        dstRowOrigo += dst.mWidth;
-                    } //end of for 16 loop
-                }  //end of 2 block loop
-                pBurstLuma += 32;
-                pBurstChroma += 16;
-            } // end of 2 col loop
-            pLuma   += 64;
-            pChroma += 32;
-        }
-    }
-
-    return OK;
-}
-#endif
-
 uint8_t *ColorConverter::initClip() {
     static const signed kClipMin = -278;
     static const signed kClipMax = 535;
-- 
1.9.1

