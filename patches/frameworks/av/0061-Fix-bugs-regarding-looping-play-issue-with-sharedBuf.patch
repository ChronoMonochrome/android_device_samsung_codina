From f76ea466319f6bcc03f16ab48c08846187cb93e1 Mon Sep 17 00:00:00 2001
From: "donghyub.cho" <donghyub.cho@lge.com>
Date: Wed, 21 Jan 2015 13:48:35 +0900
Subject: [PATCH 61/95] Fix bugs regarding looping play issue with sharedBuffer

1. Looping play error.
Looping SoundPool play with FastMixer sometimes does not work depends on audio frameCount.

2. When a audio is played with SoundPool, AudioTrack is created with the "AUDIO_OUTPUT_FLAG_FAST" flag.
If all the conditions such as callback transfer mode, mSharedBuffer, and sampling rate, for FastMixer usage are satisfied, then FastMixer is ready for working.
For instance, suppose that a audio frameCount is set as "6721" before StaticAudioTrackClientProxy class instance is created,[AudioTrack::createTrack_l()]
on playing, the initial value("6721") of "frameReady" is getting to be decreased by the value("240") of "current->mFrameCount"[FastMixer::onWork()]
After all, the value of "frameReady" is getting to be decreased, and the remaing value of "frameReady" getting to be "1".

3. On this moment, "underruns.mBitFields.mMostRecent" becames to be "UNDERRUN_PARTIAL"[FastMixer::onWork()],
and the value of "recentUnderruns" becames to be "1"[AudioFlinger::MixerThread::prepareTracks_l].
If the value of "recentUnderruns" is "1", then even though the vale of "track->mState" is "TrackBase::ACTIVE", "presentationComplete()" API will be called.
Therefore, looping play becames suddenly stop.

4. To prevent playing stop in this case, the routine of checking "recentEmpty" value is added.

Change-Id: I716aa987205021662da336c12a69407caacb99a5
Signed-off-by: donghyub cho <donghyub.cho@lge.com>
---
 services/audioflinger/Threads.cpp | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/services/audioflinger/Threads.cpp b/services/audioflinger/Threads.cpp
index 5282ffe..6b23f0f 100644
--- a/services/audioflinger/Threads.cpp
+++ b/services/audioflinger/Threads.cpp
@@ -3298,6 +3298,12 @@ AudioFlinger::PlaybackThread::mixer_state AudioFlinger::MixerThread::prepareTrac
                     isActive = false;
                     break;
                 }
+                else {
+                   if (recentEmpty == 0) {
+                   // no, then ignore the partial underruns as they are allowed indefinitely
+                      break;
+                   }
+                }
                 // fall through
             case TrackBase::STOPPING_2:
             case TrackBase::PAUSED:
-- 
2.5.0

