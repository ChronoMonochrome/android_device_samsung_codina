From a06e6019d93396c69fd80f8a5586aace8db5674b Mon Sep 17 00:00:00 2001
From: Dhananjay Kumar <dhakumar@codeaurora.org>
Date: Wed, 31 Dec 2014 20:10:33 +0530
Subject: [PATCH 95/95] soundpool: reuse channel for same sample if available

Reuse channel for same sample if the channel completed
current playback and is not reallocated to another sample,
i.e. not stolen by other sample.

CRs-Fixed: 769440
Change-Id: Ibe7ee318c7dc11f3c4fd3a2f57d861318b10973b
---
 include/media/SoundPool.h    |  4 ++-
 media/libmedia/SoundPool.cpp | 69 ++++++++++++++++++++++++++++----------------
 2 files changed, 47 insertions(+), 26 deletions(-)

diff --git a/include/media/SoundPool.h b/include/media/SoundPool.h
index 5830475..61141e9 100644
--- a/include/media/SoundPool.h
+++ b/include/media/SoundPool.h
@@ -144,6 +144,7 @@ public:
     void nextEvent();
     int nextChannelID() { return mNextEvent.channelID(); }
     void dump();
+    int getPrevSampleID(void) { return mPrevSampleID; }
 
 private:
     static void callback(int event, void* user, void *info);
@@ -160,6 +161,7 @@ private:
     int                 mAudioBufferSize;
     unsigned long       mToggle;
     bool                mAutoPaused;
+    int                 mPrevSampleID;
 };
 
 // application object for managing a pool of sounds
@@ -202,7 +204,7 @@ private:
     sp<Sample> findSample(int sampleID) { return mSamples.valueFor(sampleID); }
     SoundChannel* findChannel (int channelID);
     SoundChannel* findNextChannel (int channelID);
-    SoundChannel* allocateChannel_l(int priority);
+    SoundChannel* allocateChannel_l(int priority, int sampleID);
     void moveToFront_l(SoundChannel* channel);
     void notify(SoundPoolEvent event);
     void dump();
diff --git a/media/libmedia/SoundPool.cpp b/media/libmedia/SoundPool.cpp
index d2e381b..ab6daca 100644
--- a/media/libmedia/SoundPool.cpp
+++ b/media/libmedia/SoundPool.cpp
@@ -262,7 +262,7 @@ int SoundPool::play(int sampleID, float leftVolume, float rightVolume,
     dump();
 
     // allocate a channel
-    channel = allocateChannel_l(priority);
+    channel = allocateChannel_l(priority, sampleID);
 
     // no channel allocated - return 0
     if (!channel) {
@@ -277,13 +277,25 @@ int SoundPool::play(int sampleID, float leftVolume, float rightVolume,
     return channelID;
 }
 
-SoundChannel* SoundPool::allocateChannel_l(int priority)
+SoundChannel* SoundPool::allocateChannel_l(int priority, int sampleID)
 {
     List<SoundChannel*>::iterator iter;
     SoundChannel* channel = NULL;
 
-    // allocate a channel
+    // check if channel for given sampleID still available
     if (!mChannels.empty()) {
+        for (iter = mChannels.begin(); iter != mChannels.end(); ++iter) {
+            if (sampleID == (*iter)->getPrevSampleID() && (*iter)->state() == SoundChannel::IDLE) {
+                channel = *iter;
+                mChannels.erase(iter);
+                ALOGV("Allocated recycled channel for same sampleID");
+                break;
+            }
+        }
+    }
+
+    // allocate any channel
+    if (!channel && !mChannels.empty()) {
         iter = mChannels.begin();
         if (priority >= (*iter)->priority()) {
             channel = *iter;
@@ -551,6 +563,7 @@ error:
 void SoundChannel::init(SoundPool* soundPool)
 {
     mSoundPool = soundPool;
+    mPrevSampleID = -1;
 }
 
 // call with sound pool lock held
@@ -559,7 +572,7 @@ void SoundChannel::play(const sp<Sample>& sample, int nextChannelID, float leftV
 {
     sp<AudioTrack> oldTrack;
     sp<AudioTrack> newTrack;
-    status_t status;
+    status_t status = NO_ERROR;
 
     { // scope for the lock
         Mutex::Autolock lock(&mLock);
@@ -605,37 +618,42 @@ void SoundChannel::play(const sp<Sample>& sample, int nextChannelID, float leftV
         }
 #endif
 
-        // mToggle toggles each time a track is started on a given channel.
-        // The toggle is concatenated with the SoundChannel address and passed to AudioTrack
-        // as callback user data. This enables the detection of callbacks received from the old
-        // audio track while the new one is being started and avoids processing them with
-        // wrong audio audio buffer size  (mAudioBufferSize)
-        unsigned long toggle = mToggle ^ 1;
-        void *userData = (void *)((unsigned long)this | toggle);
-        audio_channel_mask_t channelMask = audio_channel_out_mask_from_count(numChannels);
-
-        // do not create a new audio track if current track is compatible with sample parameters
+        if (!mAudioTrack.get() || mPrevSampleID != sample->sampleID()) {
+            // mToggle toggles each time a track is started on a given channel.
+            // The toggle is concatenated with the SoundChannel address and passed to AudioTrack
+            // as callback user data. This enables the detection of callbacks received from the old
+            // audio track while the new one is being started and avoids processing them with
+            // wrong audio audio buffer size  (mAudioBufferSize)
+            unsigned long toggle = mToggle ^ 1;
+            void *userData = (void *)((unsigned long)this | toggle);
+            audio_channel_mask_t channelMask = audio_channel_out_mask_from_count(numChannels);
+
+            // do not create a new audio track if current track is compatible with sample parameters
 #ifdef USE_SHARED_MEM_BUFFER
-        newTrack = new AudioTrack(streamType, sampleRate, sample->format(),
+            newTrack = new AudioTrack(streamType, sampleRate, sample->format(),
                 channelMask, sample->getIMemory(), AUDIO_OUTPUT_FLAG_FAST, callback, userData);
 #else
-        newTrack = new AudioTrack(streamType, sampleRate, sample->format(),
+            newTrack = new AudioTrack(streamType, sampleRate, sample->format(),
                 channelMask, frameCount, AUDIO_OUTPUT_FLAG_FAST, callback, userData,
                 bufferFrames);
 #endif
-        oldTrack = mAudioTrack;
-        status = newTrack->initCheck();
-        if (status != NO_ERROR) {
-            ALOGE("Error creating AudioTrack");
-            goto exit;
+            oldTrack = mAudioTrack;
+            status = newTrack->initCheck();
+            if (status != NO_ERROR) {
+                ALOGE("Error creating AudioTrack");
+                goto exit;
+            }
+            // From now on, AudioTrack callbacks received with previous toggle value will be ignored.
+            mToggle = toggle;
+            mAudioTrack = newTrack;
+            ALOGV("using new track %p for sample %d", newTrack.get(), sample->sampleID());
+        } else {
+            newTrack = mAudioTrack;
+            ALOGV("reusing track %p for sample %d", mAudioTrack.get(), sample->sampleID());
         }
-        ALOGV("setVolume %p", newTrack.get());
         newTrack->setVolume(leftVolume, rightVolume);
         newTrack->setLoop(0, frameCount, loop);
 
-        // From now on, AudioTrack callbacks received with previous toggle value will be ignored.
-        mToggle = toggle;
-        mAudioTrack = newTrack;
         mPos = 0;
         mSample = sample;
         mChannelID = nextChannelID;
@@ -777,6 +795,7 @@ bool SoundChannel::doStop_l()
         setVolume_l(0, 0);
         ALOGV("stop");
         mAudioTrack->stop();
+        mPrevSampleID = mSample->sampleID();
         mSample.clear();
         mState = IDLE;
         mPriority = IDLE_PRIORITY;
-- 
2.5.0

