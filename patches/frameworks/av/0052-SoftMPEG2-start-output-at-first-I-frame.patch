From e6d9384d9252050836a38f8340ca03f1363983fb Mon Sep 17 00:00:00 2001
From: Venkatarama Avadhani <venkatarama.avadhani@ittiam.com>
Date: Fri, 17 Apr 2015 19:20:08 +0530
Subject: [PATCH 52/95] SoftMPEG2: start output at first I-frame

This fixes thumbnail generation for open GOP sequences

Also add -Werror to this library to detect issues.

Change-Id: I0136ca05070326c895fb3010b8e9557eac2d25df
---
 media/libstagefright/codecs/mpeg2dec/SoftMPEG2.cpp | 25 +++++++++++++++++-----
 media/libstagefright/codecs/mpeg2dec/SoftMPEG2.h   |  1 +
 2 files changed, 21 insertions(+), 5 deletions(-)

diff --git a/media/libstagefright/codecs/mpeg2dec/SoftMPEG2.cpp b/media/libstagefright/codecs/mpeg2dec/SoftMPEG2.cpp
index fb7394b..7e98928 100644
--- a/media/libstagefright/codecs/mpeg2dec/SoftMPEG2.cpp
+++ b/media/libstagefright/codecs/mpeg2dec/SoftMPEG2.cpp
@@ -245,6 +245,7 @@ status_t SoftMPEG2::setFlushMode() {
         return UNKNOWN_ERROR;
     }
 
+    mWaitForI = true;
     mIsInFlush = true;
     return OK;
 }
@@ -257,6 +258,7 @@ status_t SoftMPEG2::initDecoder() {
     UWORD32 u4_share_disp_buf;
 
     mNumCores = GetCPUCoreCount();
+    mWaitForI = true;
 
     /* Initialize number of ref and reorder modes (for MPEG2) */
     u4_num_reorder_frames = 16;
@@ -448,6 +450,8 @@ status_t SoftMPEG2::reInitDecoder() {
 void SoftMPEG2::onReset() {
     SoftVideoDecoderOMXComponent::onReset();
 
+    mWaitForI = true;
+
     resetDecoder();
     resetPlugin();
 }
@@ -710,11 +714,22 @@ void SoftMPEG2::onQueueFilled(OMX_U32 portIndex) {
                 outHeader->nTimeStamp = mTimeStamps[timeStampIdx];
                 mTimeStampsValid[timeStampIdx] = false;
 
-                outInfo->mOwnedByUs = false;
-                outQueue.erase(outQueue.begin());
-                outInfo = NULL;
-                notifyFillBufferDone(outHeader);
-                outHeader = NULL;
+                /* mWaitForI waits for the first I picture. Once made FALSE, it
+                   has to remain false till explicitly set to TRUE. */
+                mWaitForI = mWaitForI && !(IV_I_FRAME == s_dec_op.e_pic_type);
+
+                if (mWaitForI) {
+                    s_dec_op.u4_output_present = false;
+                } else {
+                    ALOGV("Output timestamp: %lld, res: %ux%u",
+                            (long long)outHeader->nTimeStamp, mWidth, mHeight);
+                    DUMP_TO_FILE(mOutFile, outHeader->pBuffer, outHeader->nFilledLen);
+                    outInfo->mOwnedByUs = false;
+                    outQueue.erase(outQueue.begin());
+                    outInfo = NULL;
+                    notifyFillBufferDone(outHeader);
+                    outHeader = NULL;
+                }
             } else {
                 /* If in flush mode and no output is returned by the codec,
                  * then come out of flush mode */
diff --git a/media/libstagefright/codecs/mpeg2dec/SoftMPEG2.h b/media/libstagefright/codecs/mpeg2dec/SoftMPEG2.h
index f7b1961..a625e08 100644
--- a/media/libstagefright/codecs/mpeg2dec/SoftMPEG2.h
+++ b/media/libstagefright/codecs/mpeg2dec/SoftMPEG2.h
@@ -105,6 +105,7 @@ private:
     // codec. So the codec is switching to decode the new resolution.
     bool mChangingResolution;
     bool mFlushNeeded;
+    bool mWaitForI;
 
     status_t initDecoder();
     status_t deInitDecoder();
-- 
2.5.0

