From 04323631f6eb09f4ae44334926efad7cdc17caa3 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 22 Feb 2016 16:41:18 +0700
Subject: [PATCH 2/2] omx: reset to omni

Change-Id: I45d95434c9dd378d731249d9b284aa0f2bc3e093
---
 media/libstagefright/omx/Android.mk           |  6 +--
 media/libstagefright/omx/OMX.cpp              | 21 ++------
 media/libstagefright/omx/OMXMaster.cpp        | 70 ++++++++++-----------------
 media/libstagefright/omx/OMXMaster.h          |  7 +--
 media/libstagefright/omx/OMXNodeInstance.cpp  | 14 +++---
 media/libstagefright/omx/SoftOMXPlugin.cpp    | 57 ++--------------------
 media/libstagefright/omx/tests/OMXHarness.cpp | 23 +++++++++
 7 files changed, 67 insertions(+), 131 deletions(-)

diff --git a/media/libstagefright/omx/Android.mk b/media/libstagefright/omx/Android.mk
index 4408050..7ab0989 100644
--- a/media/libstagefright/omx/Android.mk
+++ b/media/libstagefright/omx/Android.mk
@@ -33,12 +33,10 @@ LOCAL_SHARED_LIBRARIES :=               \
         libstagefright_foundation       \
         libdl
 
-ifeq ($(DTS_CODEC_M_), true)
-  LOCAL_CFLAGS += -DDTS_CODEC_M_
-endif
-
 LOCAL_MODULE:= libstagefright_omx
 
+LOCAL_CFLAGS += -fno-lto
+
 include $(BUILD_SHARED_LIBRARY)
 
 ################################################################################
diff --git a/media/libstagefright/omx/OMX.cpp b/media/libstagefright/omx/OMX.cpp
index 5332436..11b0d6d 100644
--- a/media/libstagefright/omx/OMX.cpp
+++ b/media/libstagefright/omx/OMX.cpp
@@ -453,12 +453,7 @@ OMX_ERRORTYPE OMX::OnEvent(
     msg.u.event_data.data1 = nData1;
     msg.u.event_data.data2 = nData2;
 
-    sp<OMX::CallbackDispatcher> callbackDispatcher = findDispatcher(node);
-    if (callbackDispatcher != NULL) {
-        callbackDispatcher->post(msg);
-    } else {
-        ALOGE("OnEvent Callback dispatcher NULL, skip post");
-    }
+    findDispatcher(node)->post(msg);
 
     return OMX_ErrorNone;
 }
@@ -472,12 +467,7 @@ OMX_ERRORTYPE OMX::OnEmptyBufferDone(
     msg.node = node;
     msg.u.buffer_data.buffer = buffer;
 
-    sp<OMX::CallbackDispatcher> callbackDispatcher = findDispatcher(node);
-    if (callbackDispatcher != NULL) {
-        callbackDispatcher->post(msg);
-    } else {
-        ALOGE("OnEmptyBufferDone Callback dispatcher NULL, skip post");
-    }
+    findDispatcher(node)->post(msg);
 
     return OMX_ErrorNone;
 }
@@ -495,12 +485,7 @@ OMX_ERRORTYPE OMX::OnFillBufferDone(
     msg.u.extended_buffer_data.flags = pBuffer->nFlags;
     msg.u.extended_buffer_data.timestamp = pBuffer->nTimeStamp;
 
-    sp<OMX::CallbackDispatcher> callbackDispatcher = findDispatcher(node);
-    if (callbackDispatcher != NULL) {
-        callbackDispatcher->post(msg);
-    } else {
-        ALOGE("OnFillBufferDone Callback dispatcher NULL, skip post");
-    }
+    findDispatcher(node)->post(msg);
 
     return OMX_ErrorNone;
 }
diff --git a/media/libstagefright/omx/OMXMaster.cpp b/media/libstagefright/omx/OMXMaster.cpp
index 54aecff..ae3cb33 100644
--- a/media/libstagefright/omx/OMXMaster.cpp
+++ b/media/libstagefright/omx/OMXMaster.cpp
@@ -25,60 +25,52 @@
 #include <dlfcn.h>
 
 #include <media/stagefright/foundation/ADebug.h>
-#include <cutils/properties.h>
 
 namespace android {
 
-OMXMaster::OMXMaster() {
+OMXMaster::OMXMaster()
+    : mVendorLibHandle(NULL) {
     addVendorPlugin();
     addPlugin(new SoftOMXPlugin);
-    addUserPlugin();
 }
 
 OMXMaster::~OMXMaster() {
     clearPlugins();
+
+    if (mVendorLibHandle != NULL) {
+        dlclose(mVendorLibHandle);
+        mVendorLibHandle = NULL;
+    }
 }
 
 void OMXMaster::addVendorPlugin() {
     addPlugin("libstagefrighthw.so");
 }
 
-void OMXMaster::addUserPlugin() {
-    char plugin[PROPERTY_VALUE_MAX];
-    if (property_get("media.sf.omx-plugin", plugin, NULL)) {
-        if (plugin != NULL) {
-            addPlugin(plugin);
-        }
-    }
-}
-
 void OMXMaster::addPlugin(const char *libname) {
-    void* handle = dlopen(libname, RTLD_NOW);
+    mVendorLibHandle = dlopen(libname, RTLD_NOW);
 
-    if (handle == NULL) {
+    if (mVendorLibHandle == NULL) {
         return;
     }
 
     typedef OMXPluginBase *(*CreateOMXPluginFunc)();
     CreateOMXPluginFunc createOMXPlugin =
         (CreateOMXPluginFunc)dlsym(
-                handle, "createOMXPlugin");
+                mVendorLibHandle, "createOMXPlugin");
     if (!createOMXPlugin)
         createOMXPlugin = (CreateOMXPluginFunc)dlsym(
-                handle, "_ZN7android15createOMXPluginEv");
+                mVendorLibHandle, "_ZN7android15createOMXPluginEv");
 
     if (createOMXPlugin) {
-        addPlugin((*createOMXPlugin)(), handle);
+        addPlugin((*createOMXPlugin)());
     }
 }
 
-void OMXMaster::addPlugin(OMXPluginBase *plugin, void *handle) {
-    if (plugin == 0) {
-       return;
-    }
+void OMXMaster::addPlugin(OMXPluginBase *plugin) {
     Mutex::Autolock autoLock(mLock);
 
-    mPlugins.add(plugin, handle);
+    mPlugins.push_back(plugin);
 
     OMX_U32 index = 0;
 
@@ -108,33 +100,21 @@ void OMXMaster::clearPlugins() {
     Mutex::Autolock autoLock(mLock);
 
     typedef void (*DestroyOMXPluginFunc)(OMXPluginBase*);
+    DestroyOMXPluginFunc destroyOMXPlugin =
+        (DestroyOMXPluginFunc)dlsym(
+                mVendorLibHandle, "destroyOMXPlugin");
 
-    for (unsigned int i = 0; i < mPlugins.size(); i++) {
-        OMXPluginBase *plugin = mPlugins.keyAt(i);
-        if (plugin != NULL) {
-            void *handle = mPlugins.valueAt(i);
-            ALOGI("clearPlugins: %d key=%x value=%x", i, plugin, handle);
-
-            if (handle != NULL) {
-                DestroyOMXPluginFunc destroyOMXPlugin =
-                    (DestroyOMXPluginFunc)dlsym(
-                            handle, "destroyOMXPlugin");
-
-                if (destroyOMXPlugin)
-                    destroyOMXPlugin(plugin);
-                else
-                    delete plugin;
-
-                dlclose(handle);
-            } else {
-                delete plugin;
-            }
+    mPluginByComponentName.clear();
 
-            plugin = NULL;
-        }
+    for (List<OMXPluginBase *>::iterator it = mPlugins.begin();
+            it != mPlugins.end(); ++it) {
+        if (destroyOMXPlugin)
+            destroyOMXPlugin(*it);
+        else
+            delete *it;
+        *it = NULL;
     }
 
-    mPluginByComponentName.clear();
     mPlugins.clear();
 }
 
diff --git a/media/libstagefright/omx/OMXMaster.h b/media/libstagefright/omx/OMXMaster.h
index c07fed3..6069741 100644
--- a/media/libstagefright/omx/OMXMaster.h
+++ b/media/libstagefright/omx/OMXMaster.h
@@ -51,14 +51,15 @@ struct OMXMaster : public OMXPluginBase {
 
 private:
     Mutex mLock;
-    KeyedVector<OMXPluginBase *, void *> mPlugins;
+    List<OMXPluginBase *> mPlugins;
     KeyedVector<String8, OMXPluginBase *> mPluginByComponentName;
     KeyedVector<OMX_COMPONENTTYPE *, OMXPluginBase *> mPluginByInstance;
 
+    void *mVendorLibHandle;
+
     void addVendorPlugin();
-    void addUserPlugin();
     void addPlugin(const char *libname);
-    void addPlugin(OMXPluginBase *plugin, void *handle = NULL);
+    void addPlugin(OMXPluginBase *plugin);
     void clearPlugins();
 
     OMXMaster(const OMXMaster &);
diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index 270ee55..2823cfc 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -119,20 +119,20 @@ struct BufferMeta {
         if (!mIsBackup) {
             return;
         }
-        size_t bytesToCopy = header->nFlags & OMX_BUFFERFLAG_EXTRADATA ?
-            header->nAllocLen - header->nOffset : header->nFilledLen;
+
         memcpy((OMX_U8 *)mMem->pointer() + header->nOffset,
-               header->pBuffer + header->nOffset, bytesToCopy);
+                header->pBuffer + header->nOffset,
+                header->nFilledLen);
     }
 
     void CopyToOMX(const OMX_BUFFERHEADERTYPE *header) {
         if (!mIsBackup) {
             return;
         }
-        size_t bytesToCopy = header->nFlags & OMX_BUFFERFLAG_EXTRADATA ?
-            header->nAllocLen - header->nOffset : header->nFilledLen;
+
         memcpy(header->pBuffer + header->nOffset,
-               (const OMX_U8 *)mMem->pointer() + header->nOffset, bytesToCopy);
+                (const OMX_U8 *)mMem->pointer() + header->nOffset,
+                header->nFilledLen);
     }
 
     void setGraphicBuffer(const sp<GraphicBuffer> &graphicBuffer) {
@@ -182,7 +182,6 @@ OMXNodeInstance::OMXNodeInstance(
     mNumPortBuffers[1] = 0;
     mDebugLevelBumpPendingBuffers[0] = 0;
     mDebugLevelBumpPendingBuffers[1] = 0;
-    mIsSecure = AString(name).endsWith(".secure");
 }
 
 OMXNodeInstance::~OMXNodeInstance() {
@@ -256,7 +255,6 @@ status_t OMXNodeInstance::freeNode(OMXMaster *master) {
     OMX_STATETYPE state;
     CHECK_EQ(OMX_GetState(mHandle, &state), OMX_ErrorNone);
     switch (state) {
-        case OMX_StatePause:
         case OMX_StateExecuting:
         {
             ALOGV("forcing Executing->Idle");
diff --git a/media/libstagefright/omx/SoftOMXPlugin.cpp b/media/libstagefright/omx/SoftOMXPlugin.cpp
index d2e9100..9b6958a 100644
--- a/media/libstagefright/omx/SoftOMXPlugin.cpp
+++ b/media/libstagefright/omx/SoftOMXPlugin.cpp
@@ -12,43 +12,6 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- *
- * This file was modified by Dolby Laboratories, Inc. The portions of the
- * code that are surrounded by "DOLBY..." are copyrighted and
- * licensed separately, as follows:
- *
- *  (C) 2011-2015 Dolby Laboratories, Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- **
- ** This file was modified by DTS, Inc. The portions of the
- ** code that are surrounded by "DTS..." are copyrighted and
- ** licensed separately, as follows:
- **
- **  (C) 2014 DTS, Inc.
- **
- ** Licensed under the Apache License, Version 2.0 (the "License");
- ** you may not use this file except in compliance with the License.
- ** You may obtain a copy of the License at
- **
- **    http://www.apache.org/licenses/LICENSE-2.0
- **
- ** Unless required by applicable law or agreed to in writing, software
- ** distributed under the License is distributed on an "AS IS" BASIS,
- ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- ** See the License for the specific language governing permissions and
- ** limitations under the License
  */
 
 //#define LOG_NDEBUG 0
@@ -77,8 +40,8 @@ static const struct {
     { "OMX.google.amrnb.encoder", "amrnbenc", "audio_encoder.amrnb" },
     { "OMX.google.amrwb.decoder", "amrdec", "audio_decoder.amrwb" },
     { "OMX.google.amrwb.encoder", "amrwbenc", "audio_encoder.amrwb" },
-    { "OMX.google.h264.decoder", "avcdec", "video_decoder.avc" },
-    { "OMX.google.h264.encoder", "avcenc", "video_encoder.avc" },
+    { "OMX.google.h264.decoder", "h264dec", "video_decoder.avc" },
+    { "OMX.google.h264.encoder", "h264enc", "video_encoder.avc" },
     { "OMX.google.hevc.decoder", "hevcdec", "video_decoder.hevc" },
     { "OMX.google.g711.alaw.decoder", "g711dec", "audio_decoder.g711alaw" },
     { "OMX.google.g711.mlaw.decoder", "g711dec", "audio_decoder.g711mlaw" },
@@ -95,14 +58,6 @@ static const struct {
     { "OMX.google.raw.decoder", "rawdec", "audio_decoder.raw" },
     { "OMX.google.flac.encoder", "flacenc", "audio_encoder.flac" },
     { "OMX.google.gsm.decoder", "gsmdec", "audio_decoder.gsm" },
-#ifdef DOLBY_UDC
-    { "OMX.dolby.ac3.decoder", "ddpdec", "audio_decoder.ac3" },
-    { "OMX.dolby.eac3.decoder", "ddpdec", "audio_decoder.eac3" },
-    { "OMX.dolby.eac3_joc.decoder", "ddpdec", "audio_decoder.eac3_joc" },
-#endif // DOLBY_END
-#ifdef DTS_CODEC_M_
-    { "OMX.DTS.audio_decoder.dts", "dtsdec", "audio_decoder.dts" },
-#endif
 };
 
 static const size_t kNumComponents =
@@ -118,7 +73,6 @@ OMX_ERRORTYPE SoftOMXPlugin::makeComponentInstance(
         OMX_COMPONENTTYPE **component) {
     ALOGV("makeComponentInstance '%s'", name);
 
-    dlerror(); // clear any existing error
     for (size_t i = 0; i < kNumComponents; ++i) {
         if (strcmp(name, kComponents[i].mName)) {
             continue;
@@ -131,13 +85,11 @@ OMX_ERRORTYPE SoftOMXPlugin::makeComponentInstance(
         void *libHandle = dlopen(libName.c_str(), RTLD_NOW);
 
         if (libHandle == NULL) {
-            ALOGE("unable to dlopen %s: %s", libName.c_str(), dlerror());
+            ALOGE("unable to dlopen %s", libName.c_str());
 
             return OMX_ErrorComponentNotFound;
         }
 
-        ALOGV("load component %s for %s", libName.c_str(), name);
-
         typedef SoftOMXComponent *(*CreateSoftOMXComponentFunc)(
                 const char *, const OMX_CALLBACKTYPE *,
                 OMX_PTR, OMX_COMPONENTTYPE **);
@@ -148,8 +100,7 @@ OMX_ERRORTYPE SoftOMXPlugin::makeComponentInstance(
                     "_Z22createSoftOMXComponentPKcPK16OMX_CALLBACKTYPE"
                     "PvPP17OMX_COMPONENTTYPE");
 
-        if (const char *error = dlerror()) {
-            ALOGE("unable to dlsym %s: %s", libName.c_str(), error);
+        if (createSoftOMXComponent == NULL) {
             dlclose(libHandle);
             libHandle = NULL;
 
diff --git a/media/libstagefright/omx/tests/OMXHarness.cpp b/media/libstagefright/omx/tests/OMXHarness.cpp
index 67ff145..f4dfd6b 100644
--- a/media/libstagefright/omx/tests/OMXHarness.cpp
+++ b/media/libstagefright/omx/tests/OMXHarness.cpp
@@ -253,6 +253,29 @@ static sp<MediaExtractor> CreateExtractorFromURI(const char *uri) {
     return MediaExtractor::Create(source);
 }
 
+static sp<MediaSource> MakeSource(
+        const char *uri,
+        const char *mimeType) {
+    sp<MediaExtractor> extractor = CreateExtractorFromURI(uri);
+
+    if (extractor == NULL) {
+        return NULL;
+    }
+
+    for (size_t i = 0; i < extractor->countTracks(); ++i) {
+        sp<MetaData> meta = extractor->getTrackMetaData(i);
+
+        const char *trackMIME;
+        CHECK(meta->findCString(kKeyMIMEType, &trackMIME));
+
+        if (!strcasecmp(trackMIME, mimeType)) {
+            return extractor->getTrack(i);
+        }
+    }
+
+    return NULL;
+}
+
 status_t Harness::testStateTransitions(
         const char *componentName, const char *componentRole) {
     if (strncmp(componentName, "OMX.", 4)) {
-- 
2.5.0

