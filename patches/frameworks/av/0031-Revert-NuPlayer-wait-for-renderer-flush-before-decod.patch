From c556712e23fb93ef718000958af581ad8dd3eb2c Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Thu, 28 Jan 2016 12:15:14 +0700
Subject: [PATCH 31/58] Revert "NuPlayer: wait for renderer flush before
 decoder shutdown"

This reverts commit 8d121d41f5355b78b687f44e8d4aae4de2aa0359.
---
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp  | 101 ++++++++++-----------
 media/libmediaplayerservice/nuplayer/NuPlayer.h    |  13 +--
 .../nuplayer/NuPlayerDriver.cpp                    |   2 +-
 3 files changed, 52 insertions(+), 64 deletions(-)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index 1c73995..53eec91 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -174,7 +174,6 @@ NuPlayer::NuPlayer()
       mNumFramesDropped(0ll),
       mVideoScalingMode(NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW),
       mStarted(false) {
-    clearFlushComplete();
 }
 
 NuPlayer::~NuPlayer() {
@@ -334,6 +333,25 @@ void NuPlayer::seekToAsync(int64_t seekTimeUs, bool needNotify) {
     msg->post();
 }
 
+// static
+bool NuPlayer::IsFlushingState(FlushStatus state, bool *needShutdown) {
+    switch (state) {
+        case FLUSHING_DECODER:
+            if (needShutdown != NULL) {
+                *needShutdown = false;
+            }
+            return true;
+
+        case FLUSHING_DECODER_SHUTDOWN:
+            if (needShutdown != NULL) {
+                *needShutdown = true;
+            }
+            return true;
+
+        default:
+            return false;
+    }
+}
 
 void NuPlayer::writeTrackInfo(
         Parcel* reply, const sp<AMessage> format) const {
@@ -755,9 +773,38 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
 
                 mRenderer->queueEOS(audio, err);
             } else if (what == Decoder::kWhatFlushCompleted) {
+                bool needShutdown;
+
+                if (audio) {
+                    CHECK(IsFlushingState(mFlushingAudio, &needShutdown));
+                    mFlushingAudio = FLUSHED;
+                } else {
+                    CHECK(IsFlushingState(mFlushingVideo, &needShutdown));
+                    mFlushingVideo = FLUSHED;
+
+                    mVideoLateByUs = 0;
+                }
+
                 ALOGV("decoder %s flush completed", audio ? "audio" : "video");
 
-                handleFlushComplete(audio, true /* isDecoder */);
+                if (needShutdown) {
+                    ALOGV("initiating %s decoder shutdown",
+                         audio ? "audio" : "video");
+
+                    // Widevine source reads must stop before releasing the video decoder.
+                    if (!audio && mSource != NULL && mSourceFlags & Source::FLAG_SECURE) {
+                        mSource->stop();
+                    }
+
+                    getDecoder(audio)->initiateShutdown();
+
+                    if (audio) {
+                        mFlushingAudio = SHUTTING_DOWN_DECODER;
+                    } else {
+                        mFlushingVideo = SHUTTING_DOWN_DECODER;
+                    }
+                }
+
                 finishFlushIfPossible();
             } else if (what == Decoder::kWhatOutputFormatChanged) {
                 sp<AMessage> format;
@@ -910,8 +957,6 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
                 CHECK(msg->findInt32("audio", &audio));
 
                 ALOGV("renderer %s flush completed.", audio ? "audio" : "video");
-                handleFlushComplete(audio, false /* isDecoder */);
-                finishFlushIfPossible();
             } else if (what == Renderer::kWhatVideoRenderingStart) {
                 notifyListener(MEDIA_INFO, MEDIA_INFO_RENDERING_START, 0);
             } else if (what == Renderer::kWhatMediaRenderingStart) {
@@ -1039,50 +1084,6 @@ bool NuPlayer::audioDecoderStillNeeded() {
     return ((mFlushingAudio != SHUT_DOWN) && (mFlushingAudio != SHUTTING_DOWN_DECODER));
 }
 
-void NuPlayer::handleFlushComplete(bool audio, bool isDecoder) {
-    // We wait for both the decoder flush and the renderer flush to complete
-    // before entering either the FLUSHED or the SHUTTING_DOWN_DECODER state.
-
-    mFlushComplete[audio][isDecoder] = true;
-    if (!mFlushComplete[audio][!isDecoder]) {
-        return;
-    }
-
-    FlushStatus *state = audio ? &mFlushingAudio : &mFlushingVideo;
-    switch (*state) {
-        case FLUSHING_DECODER:
-        {
-            *state = FLUSHED;
-
-            if (!audio) {
-                mVideoLateByUs = 0;
-            }
-            break;
-        }
-
-        case FLUSHING_DECODER_SHUTDOWN:
-        {
-            *state = SHUTTING_DOWN_DECODER;
-
-            ALOGV("initiating %s decoder shutdown", audio ? "audio" : "video");
-            if (!audio) {
-                mVideoLateByUs = 0;
-                // Widevine source reads must stop before releasing the video decoder.
-                if (mSource != NULL && mSourceFlags & Source::FLAG_SECURE) {
-                    mSource->stop();
-                }
-            }
-            getDecoder(audio)->initiateShutdown();
-            break;
-        }
-
-        default:
-            // decoder flush completes only occur in a flushing state.
-            LOG_ALWAYS_FATAL_IF(isDecoder, "decoder flush in invalid state %d", *state);
-            break;
-    }
-}
-
 void NuPlayer::finishFlushIfPossible() {
     if (mFlushingAudio != NONE && mFlushingAudio != FLUSHED
             && mFlushingAudio != SHUT_DOWN) {
@@ -1115,8 +1116,6 @@ void NuPlayer::finishFlushIfPossible() {
     mFlushingAudio = NONE;
     mFlushingVideo = NONE;
 
-    clearFlushComplete();
-
     processDeferredActions();
 }
 
@@ -1721,8 +1720,6 @@ void NuPlayer::flushDecoder(
     FlushStatus newStatus =
         needShutdown ? FLUSHING_DECODER_SHUTDOWN : FLUSHING_DECODER;
 
-    mFlushComplete[audio][false /* isDecoder */] = false;
-    mFlushComplete[audio][true /* isDecoder */] = false;
     if (audio) {
         ALOGE_IF(mFlushingAudio != NONE,
                 "audio flushDecoder() is called in state %d", mFlushingAudio);
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.h b/media/libmediaplayerservice/nuplayer/NuPlayer.h
index 1b9a756..8157733 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.h
@@ -164,9 +164,6 @@ private:
     // notion of time has changed.
     bool mTimeDiscontinuityPending;
 
-    // Status of flush responses from the decoder and renderer.
-    bool mFlushComplete[2][2];
-
     // Used by feedDecoderInputData to aggregate small buffers into
     // one large buffer.
     sp<ABuffer> mPendingAudioAccessUnit;
@@ -190,13 +187,6 @@ private:
         return audio ? mAudioDecoder : mVideoDecoder;
     }
 
-    inline void clearFlushComplete() {
-        mFlushComplete[0][0] = false;
-        mFlushComplete[0][1] = false;
-        mFlushComplete[1][0] = false;
-        mFlushComplete[1][1] = false;
-    }
-
     void openAudioSink(const sp<AMessage> &format, bool offloadOnly);
     void closeAudioSink();
 
@@ -211,7 +201,6 @@ private:
 
     void notifyListener(int msg, int ext1, int ext2, const Parcel *in = NULL);
 
-    void handleFlushComplete(bool audio, bool isDecoder);
     void finishFlushIfPossible();
 
     bool audioDecoderStillNeeded();
@@ -220,6 +209,8 @@ private:
             bool audio, bool needShutdown, const sp<AMessage> &newFormat = NULL);
     void updateDecoderFormatWithoutFlush(bool audio, const sp<AMessage> &format);
 
+    static bool IsFlushingState(FlushStatus state, bool *needShutdown = NULL);
+
     void postScanSources();
 
     void schedulePollDuration();
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
index c57955d..1a01d52 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
@@ -582,7 +582,7 @@ status_t NuPlayerDriver::getMetadata(
 }
 
 void NuPlayerDriver::notifyResetComplete() {
-    ALOGD("notifyResetComplete(%p)", this);
+    ALOGI("notifyResetComplete(%p)", this);
     Mutex::Autolock autoLock(mLock);
 
     CHECK_EQ(mState, STATE_RESET_IN_PROGRESS);
-- 
2.5.0

