From 6d07553f085150fbf4dc2fe0359d0907453a5b4c Mon Sep 17 00:00:00 2001
From: "Christopher N. Hesse" <raymanfx@gmail.com>
Date: Tue, 18 Oct 2016 20:56:33 +0200
Subject: [PATCH 57/57] libstagefright: Support legacy camera/encoder buffers

Android 7.1.2, the default way of passing buffers
between camera HAL, encoder and framework is via
Android Native Window (ANW) buffers.
---
 media/libmedia/include/media/IOMX.h                |  2 +
 media/libstagefright/ACodec.cpp                    | 78 +++++++++++++++-------
 .../include/media/stagefright/ACodec.h             |  8 ++-
 media/libstagefright/omx/OMXNodeInstance.cpp       | 42 ++++++++++--
 media/libstagefright/omx/OMXUtils.cpp              |  3 +
 .../media/stagefright/omx/OMXNodeInstance.h        |  3 +
 .../omx/include/media/stagefright/omx/OMXUtils.h   |  2 +
 7 files changed, 107 insertions(+), 31 deletions(-)

diff --git a/media/libmedia/include/media/IOMX.h b/media/libmedia/include/media/IOMX.h
index e69c02dda..906f42089 100644
--- a/media/libmedia/include/media/IOMX.h
+++ b/media/libmedia/include/media/IOMX.h
@@ -68,6 +68,8 @@ public:
         kPortModeDynamicANWBuffer,      // uses metadata mode kMetadataBufferTypeANWBuffer
                                         // or kMetadataBufferTypeGrallocSource
         kPortModeDynamicNativeHandle,   // uses metadata mode kMetadataBufferTypeNativeHandleSource
+        kPortModeDynamicGrallocSource,  // [Legacy Camera HAL1] uses kMetadataBufferTypeGrallocSource
+        kPortModeDynamicCameraSource,   // [Legacy Camera HAL1] uses kMetadataBufferTypeCameraSource
         kPortModeDynamicEnd,
     };
 
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 4d733845d..e9d8c7f27 100755
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -822,6 +822,15 @@ status_t ACodec::setPortMode(int32_t portIndex, IOMX::PortMode mode) {
     }
 
     mPortMode[portIndex] = mode;
+
+#ifdef METADATA_CAMERA_SOURCE
+    // For this specific case we could be using camera source even if storeMetaDataInBuffers
+    // returns Gralloc source. Pretend that we are; this will force us to use nBufferSize.
+    if (mode == IOMX::kPortModeDynamicGrallocSource) {
+        mPortMode[portIndex] = IOMX::kPortModeDynamicCameraSource;
+    }
+#endif
+
     return OK;
 }
 
@@ -857,20 +866,18 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
         if (err == OK) {
             const IOMX::PortMode &mode = mPortMode[portIndex];
             size_t bufSize = def.nBufferSize;
-#ifndef METADATA_CAMERA_SOURCE
             // Always allocate VideoNativeMetadata if using ANWBuffer.
             // OMX might use gralloc source internally, but we don't share
             // metadata buffer with OMX, OMX has its own headers.
             if (mode == IOMX::kPortModeDynamicANWBuffer) {
-#else
-            if (mode == IOMX::kPortModeDynamicANWBuffer) {
-                bufSize = sizeof(VideoGrallocMetadata);
-            } else if (mode == IOMX::kPortModeDynamicANWBuffer) {
-#endif
                 bufSize = sizeof(VideoNativeMetadata);
-#ifndef METADATA_CAMERA_SOURCE
             } else if (mode == IOMX::kPortModeDynamicNativeHandle) {
                 bufSize = sizeof(VideoNativeHandleMetadata);
+#ifdef METADATA_CAMERA_SOURCE
+            } else if (mode == IOMX::kPortModeDynamicGrallocSource) {
+                bufSize = max(sizeof(VideoGrallocMetadata), sizeof(VideoNativeMetadata));
+            } else if (portIndex == kPortIndexInput && mode == IOMX::kPortModeDynamicCameraSource) {
+                bufSize = max(sizeof(VideoGrallocMetadata), sizeof(VideoNativeMetadata));
 #endif
             }
 
@@ -975,6 +982,10 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
                         err = mOMXNode->useBuffer(
                                 portIndex, hidlMemToken, &info.mBufferID);
                     } else {
+                        if (bufSize == 8) {
+                            ALOGE("%s: wrong buffer size 8", __func__);
+                            continue;
+                        }
                         mem = mDealer[portIndex]->allocate(bufSize);
                         if (mem == NULL || mem->pointer() == NULL) {
                             return NO_MEMORY;
@@ -1003,7 +1014,7 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
 
                     // if we require conversion, allocate conversion buffer for client use;
                     // otherwise, reuse codec buffer
-                    if (mConverter[portIndex] != NULL) {
+                    if ((mConverter[portIndex] != NULL) && conversionBufferSize != 8) {
                         CHECK_GT(conversionBufferSize, (size_t)0);
                         if (getTrebleFlag()) {
                             bool success;
@@ -1778,30 +1789,39 @@ status_t ACodec::configureCodec(
     }
 
     int32_t storeMeta;
-#ifndef METADATA_CAMERA_SOURCE
     if (encoder
             && msg->findInt32("android._input-metadata-buffer-type", &storeMeta)
             && storeMeta != kMetadataBufferTypeInvalid) {
-#else
-    if (encoder
-            && msg->findInt32("store-metadata-in-buffers", &storeMeta)
-            && storeMeta != 0) {
-#warning TODO: implement kMetadataBufferTypeGrallocSource handling here
-#endif
         IOMX::PortMode mode;
         if (storeMeta == kMetadataBufferTypeNativeHandleSource) {
             mode = IOMX::kPortModeDynamicNativeHandle;
+#ifdef METADATA_CAMERA_SOURCE
+        } else if (storeMeta == kMetadataBufferTypeANWBuffer) {
+            mode = IOMX::kPortModeDynamicANWBuffer;
+        } else if (storeMeta == kMetadataBufferTypeGrallocSource) {
+            mode = IOMX::kPortModeDynamicGrallocSource;
+#else
         } else if (storeMeta == kMetadataBufferTypeANWBuffer ||
                 storeMeta == kMetadataBufferTypeGrallocSource) {
             mode = IOMX::kPortModeDynamicANWBuffer;
+#endif
         } else {
             return BAD_VALUE;
         }
+
         err = setPortMode(kPortIndexInput, mode);
         if (err != OK) {
             return err;
         }
 
+#ifdef METADATA_CAMERA_SOURCE
+        // For this specific case we could be using camera source even if storeMetaDataInBuffers
+        // returns Gralloc source. Pretend that we are; this will force us to use nBufferSize.
+        if (mode == IOMX::kPortModeDynamicGrallocSource) {
+            mode = IOMX::kPortModeDynamicANWBuffer;
+        }
+#endif
+
         uint32_t usageBits;
         if (mOMXNode->getParameter(
                 (OMX_INDEXTYPE)OMX_IndexParamConsumerUsageBits,
@@ -1842,22 +1862,22 @@ status_t ACodec::configureCodec(
     mIsVideo = video;
     if (encoder && video) {
         OMX_BOOL enable = (OMX_BOOL) (prependSPSPPS
-#ifndef METADATA_CAMERA_SOURCE
             && msg->findInt32("android._store-metadata-in-buffers-output", &storeMeta)
-#else
-            && msg->findInt32("store-metadata-in-buffers-output", &storeMeta)
-#endif
             && storeMeta != 0);
         if (mFlags & kFlagIsSecure) {
             enable = OMX_TRUE;
         }
+
 #ifdef METADATA_CAMERA_SOURCE
-#warning TODO: implement kMetadataBufferTypeGrallocSource handling here
-#endif
+        err = setPortMode(kPortIndexOutput, IOMX::kPortModeDynamicNativeHandle);
+#else
         err = setPortMode(kPortIndexOutput, enable ?
                 IOMX::kPortModePresetSecureBuffer : IOMX::kPortModePresetByteBuffer);
+#endif
         if (err != OK) {
-            return err;
+            ALOGE("[%s] storeMetaDataInBuffers (output) failed w/ err %d",
+                mComponentName.c_str(), err);
+            //return err;
         }
 
         if (!msg->findInt64(
@@ -1909,7 +1929,7 @@ status_t ACodec::configureCodec(
     }
     if (mFlags & kFlagIsSecure) {
         // use native_handles for secure input buffers
-        err = setPortMode(kPortIndexInput, IOMX::kPortModePresetSecureBuffer);
+        err = setPortMode(kPortIndexInput, IOMX::kPortModeDynamicNativeHandle);
 
         if (err != OK) {
             ALOGI("falling back to non-native_handles");
@@ -3234,6 +3254,7 @@ status_t ACodec::setSupportedOutputFormat(bool getLegacyFlexibleFormat) {
                 || format.eColorFormat == OMX_COLOR_FormatYUV420PackedPlanar
                 || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
                 || format.eColorFormat == OMX_COLOR_FormatYUV420PackedSemiPlanar
+                || format.eColorFormat == OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB
                 || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar) {
             break;
         }
@@ -5865,6 +5886,17 @@ void ACodec::BaseState::onInputBufferFilled(const sp<AMessage> &msg) {
                     }
                     break;
 #ifndef OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS
+#ifdef METADATA_CAMERA_SOURCE
+                case IOMX::kPortModeDynamicGrallocSource:
+                    if (info->mCodecData->size() >= sizeof(VideoGrallocMetadata)) {
+                        //VideoGrallocMetadata *vgmd =
+                        //    (VideoGrallocMetadata*)info->mCodecData->base();
+                        //native_handle_t* handle = (native_handle_t *)(uintptr_t)vgmd->pHandle;
+                        //err2 = mCodec->mOMXNode->emptyBuffer(
+                        //    bufferID, handle, flags, timeUs, info->mFenceFd);
+                    }
+                    break;
+#endif
                 case IOMX::kPortModeDynamicNativeHandle:
                     if (info->mCodecData->size() >= sizeof(VideoNativeHandleMetadata)) {
                         VideoNativeHandleMetadata *vnhmd =
diff --git a/media/libstagefright/include/media/stagefright/ACodec.h b/media/libstagefright/include/media/stagefright/ACodec.h
index ae6378110..a44c0c8d7 100644
--- a/media/libstagefright/include/media/stagefright/ACodec.h
+++ b/media/libstagefright/include/media/stagefright/ACodec.h
@@ -331,11 +331,15 @@ private:
     BufferInfo *dequeueBufferFromNativeWindow();
 
     inline bool storingMetadataInDecodedBuffers() {
-        return (mPortMode[kPortIndexOutput] == IOMX::kPortModeDynamicANWBuffer) && !mIsEncoder;
+        return (mPortMode[kPortIndexOutput] == IOMX::kPortModeDynamicANWBuffer ||
+                mPortMode[kPortIndexOutput] == IOMX::kPortModeDynamicGrallocSource ||
+                mPortMode[kPortIndexOutput] == IOMX::kPortModeDynamicCameraSource) && !mIsEncoder;
     }
 
     inline bool usingSecureBufferOnEncoderOutput() {
-        return (mPortMode[kPortIndexOutput] == IOMX::kPortModePresetSecureBuffer) && mIsEncoder;
+        return (mPortMode[kPortIndexOutput] == IOMX::kPortModePresetSecureBuffer ||
+                mPortMode[kPortIndexOutput] == IOMX::kPortModeDynamicGrallocSource ||
+                mPortMode[kPortIndexOutput] == IOMX::kPortModeDynamicCameraSource) && mIsEncoder;
     }
 
     BufferInfo *findBufferByID(
diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index f185a707e..05d1fdc2b 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -154,7 +154,17 @@ struct BufferMeta {
 
     // return the codec buffer
     sp<ABuffer> getBuffer(const OMX_BUFFERHEADERTYPE *header, bool limit) {
-        sp<ABuffer> buf = new ABuffer(header->pBuffer, header->nAllocLen);
+        return getBuffer(header, false, limit);
+    }
+
+    // return either the codec or the backup buffer
+    sp<ABuffer> getBuffer(const OMX_BUFFERHEADERTYPE *header, bool backup, bool limit) {
+        sp<ABuffer> buf;
+        if (backup && mMem != NULL) {
+            buf = new ABuffer(mMem->pointer(), mMem->size());
+        } else {
+            buf = new ABuffer(header->pBuffer, header->nAllocLen);
+        }
         if (limit) {
             if (header->nOffset + header->nFilledLen > header->nOffset
                     && header->nOffset + header->nFilledLen <= header->nAllocLen) {
@@ -702,6 +712,12 @@ status_t OMXNodeInstance::setPortMode(OMX_U32 portIndex, IOMX::PortMode mode) {
     CLOG_CONFIG(setPortMode, "%s(%d), port %d", asString(mode), mode, portIndex);
 
     switch (mode) {
+    case IOMX::kPortModeDynamicGrallocSource:
+    {
+        MetadataBufferType metaType = kMetadataBufferTypeGrallocSource;
+        return storeMetaDataInBuffers_l(portIndex, OMX_TRUE, &metaType);
+    }
+
     case IOMX::kPortModeDynamicANWBuffer:
     {
         if (portIndex == kPortIndexOutput) {
@@ -727,13 +743,17 @@ status_t OMXNodeInstance::setPortMode(OMX_U32 portIndex, IOMX::PortMode mode) {
         if (portIndex != kPortIndexInput) {
             CLOG_ERROR(setPortMode, BAD_VALUE,
                     "%s(%d) mode is only supported on input port", asString(mode), mode);
-            return BAD_VALUE;
+            //return BAD_VALUE;
         }
         (void)enableNativeBuffers_l(portIndex, OMX_TRUE /*graphic*/, OMX_FALSE);
         (void)enableNativeBuffers_l(portIndex, OMX_FALSE /*graphic*/, OMX_FALSE);
 
         MetadataBufferType metaType = kMetadataBufferTypeNativeHandleSource;
-        return storeMetaDataInBuffers_l(portIndex, OMX_TRUE, &metaType);
+        if (portIndex != kPortIndexInput) {
+            return storeMetaDataInBuffers_l(portIndex, OMX_FALSE, &metaType);
+        } else {
+            return storeMetaDataInBuffers_l(portIndex, OMX_TRUE, &metaType);
+        }
     }
 
     case IOMX::kPortModePresetSecureBuffer:
@@ -794,7 +814,7 @@ status_t OMXNodeInstance::setPortMode(OMX_U32 portIndex, IOMX::PortMode mode) {
         break;
     }
 
-    CLOG_ERROR(setPortMode, BAD_VALUE, "invalid port mode %d", mode);
+    CLOG_ERROR(setPortMode, BAD_VALUE, "invalid port mode %d / %d", mode, IOMX::kPortModeDynamicGrallocSource);
     return BAD_VALUE;
 }
 
@@ -880,6 +900,13 @@ status_t OMXNodeInstance::getGraphicBufferUsage(
     return OK;
 }
 
+status_t OMXNodeInstance::storeMetaDataInBuffers(
+        OMX_U32 portIndex, OMX_BOOL enable, MetadataBufferType *type) {
+    Mutex::Autolock autolock(mLock);
+    CLOG_CONFIG(storeMetaDataInBuffers, "%s:%u en:%d", portString(portIndex), portIndex, enable);
+    return storeMetaDataInBuffers_l(portIndex, enable, type);
+}
+
 status_t OMXNodeInstance::storeMetaDataInBuffers_l(
         OMX_U32 portIndex, OMX_BOOL enable, MetadataBufferType *type) {
 #ifndef METADATA_CAMERA_SOURCE
@@ -1137,6 +1164,9 @@ status_t OMXNodeInstance::useBuffer_l(
         ALOGD("%s: paramsPointer = %p", __func__, paramsPointer);
 
         paramsSize = params->size();
+        if (paramsSize == 8) {
+          return BAD_VALUE;
+        }
         ALOGD("%s: paramsSize = %d", __func__, paramsSize);
     } else if (hParams != NULL) {
         paramsPointer = hParams->getPointer();
@@ -1720,8 +1750,8 @@ status_t OMXNodeInstance::emptyBuffer_l(
         static_cast<BufferMeta *>(header->pAppPrivate);
 
 #ifdef CAMCORDER_GRALLOC_SOURCE
-    sp<ABuffer> backup = buffer_meta->getBuffer(header, false /* limit */);
-    sp<ABuffer> codec = buffer_meta->getBuffer(header, false /* limit */);
+    sp<ABuffer> backup = buffer_meta->getBuffer(header, true /* backup */, false /* limit */);
+    sp<ABuffer> codec = buffer_meta->getBuffer(header, false /* backup */, false /* limit */);
 
     // convert incoming ANW meta buffers if component is configured for gralloc metadata mode
     // ignore rangeOffset in this case
diff --git a/media/libstagefright/omx/OMXUtils.cpp b/media/libstagefright/omx/OMXUtils.cpp
index 0784a2c6a..2a81d5957 100644
--- a/media/libstagefright/omx/OMXUtils.cpp
+++ b/media/libstagefright/omx/OMXUtils.cpp
@@ -217,6 +217,7 @@ bool DescribeDefaultColorFormat(DescribeColorFormat2Params &params) {
         fmt != OMX_COLOR_FormatYUV420PackedPlanar &&
         fmt != OMX_COLOR_FormatYUV420SemiPlanar &&
         fmt != OMX_COLOR_FormatYUV420PackedSemiPlanar &&
+        fmt != OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB &&
         fmt != (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12) {
         ALOGW("do not know color format 0x%x = %d", fmt, fmt);
         return false;
@@ -292,6 +293,8 @@ bool DescribeDefaultColorFormat(DescribeColorFormat2Params &params) {
 
         case OMX_COLOR_FormatYUV420SemiPlanar:
             // FIXME: NV21 for sw-encoder, NV12 for decoder and hw-encoder
+        case OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB:
+            // FIXME: NV21 for sw-encoder, NV12 for decoder and hw-encoder
         case OMX_COLOR_FormatYUV420PackedSemiPlanar:
             // NV12
             image.mPlane[image.U].mOffset = params.nStride * params.nSliceHeight;
diff --git a/media/libstagefright/omx/include/media/stagefright/omx/OMXNodeInstance.h b/media/libstagefright/omx/include/media/stagefright/omx/OMXNodeInstance.h
index 6470b7ea5..df580496e 100644
--- a/media/libstagefright/omx/include/media/stagefright/omx/OMXNodeInstance.h
+++ b/media/libstagefright/omx/include/media/stagefright/omx/OMXNodeInstance.h
@@ -256,6 +256,9 @@ private:
     status_t enableNativeBuffers_l(
             OMX_U32 portIndex, OMX_BOOL graphic, OMX_BOOL enable);
 
+    status_t storeMetaDataInBuffers(
+            OMX_U32 portIndex, OMX_BOOL enable, MetadataBufferType *type);
+
     status_t storeMetaDataInBuffers_l(
             OMX_U32 portIndex, OMX_BOOL enable, MetadataBufferType *type);
 
diff --git a/media/libstagefright/omx/include/media/stagefright/omx/OMXUtils.h b/media/libstagefright/omx/include/media/stagefright/omx/OMXUtils.h
index 401d64b26..a4414946b 100644
--- a/media/libstagefright/omx/include/media/stagefright/omx/OMXUtils.h
+++ b/media/libstagefright/omx/include/media/stagefright/omx/OMXUtils.h
@@ -69,8 +69,10 @@ inline static const char *asString(IOMX::PortMode mode, const char *def = "??")
         case IOMX::kPortModePresetByteBuffer:   return "PresetByteBuffer";
         case IOMX::kPortModePresetANWBuffer:    return "PresetANWBuffer";
         case IOMX::kPortModePresetSecureBuffer: return "PresetSecureBuffer";
+        case IOMX::kPortModeDynamicGrallocSource: return "DynamicGrallocSource";
         case IOMX::kPortModeDynamicANWBuffer:   return "DynamicANWBuffer";
         case IOMX::kPortModeDynamicNativeHandle:return "DynamicNativeHandle";
+        case IOMX::kPortModeDynamicCameraSource:return "DynamicCameraSource";
         default:                                return def;
     }
 }
-- 
2.11.0

