From 5b994006746b39ebed23346889fd506c536ce2e7 Mon Sep 17 00:00:00 2001
From: Akhil Narang <akhilnarang.1999@gmail.com>
Date: Tue, 26 Jun 2018 16:55:14 +0530
Subject: [PATCH 262/296] Avoid the restart process for launching provider
 killed by AMS

The case is that a content provider process killed by LowmemoryKiller while the
provider launching time. And AMS will restart it for the launching provider,and
reuse the ProcessRecord, it may be killed by AMS#updateOomAdjLocked in the end
of attachApplicationLocked for empty cached process.

After that the process will restart again, and may be killed angian, another
restart, another restart...

So, we should give time for process to launch its provider, avoid the restart
and kill circle.
---
 services/core/java/com/android/server/am/ActivityManagerService.java | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index 429e8a86d42..e61f3992607 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -7074,6 +7074,7 @@ public class ActivityManagerService extends IActivityManager.Stub
 
         mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);
 
+        boolean didSomething = false;
         boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info);
         List<ProviderInfo> providers = normalMode ? generateApplicationProvidersLocked(app) : null;
 
@@ -7081,6 +7082,7 @@ public class ActivityManagerService extends IActivityManager.Stub
             Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);
             msg.obj = app;
             mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);
+            didSomething = true;
         }
 
         checkTime(startTime, "attachApplicationLocked: before bindApplication");
@@ -7237,7 +7239,6 @@ public class ActivityManagerService extends IActivityManager.Stub
         mProcessesOnHold.remove(app);
 
         boolean badApp = false;
-        boolean didSomething = false;
 
         // See if the top visible activity is waiting to run in this process...
         if (normalMode) {
-- 
2.11.0

