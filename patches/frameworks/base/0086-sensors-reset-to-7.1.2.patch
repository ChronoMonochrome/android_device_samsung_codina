From 8e77ad45e54b48f5f5b9d236aa9b9c0878e1f33a Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 20 Aug 2018 22:57:43 +0300
Subject: [PATCH 086/296] sensors: reset to 7.1.2

SensorManager: compilation fixes
---
 .../java/android/hardware/SystemSensorManager.java |   6 +-
 core/jni/android_hardware_SensorManager.cpp        |  53 +----
 native/android/Android.bp                          |   6 -
 native/android/sensor.cpp                          | 251 +++++----------------
 .../pm/PackageManagerServiceCompilerMapping.java   |   2 +
 services/core/jni/Android.mk                       |   1 -
 .../core/jni/com_android_server_SystemServer.cpp   |  24 +-
 7 files changed, 74 insertions(+), 269 deletions(-)

diff --git a/core/java/android/hardware/SystemSensorManager.java b/core/java/android/hardware/SystemSensorManager.java
index 607788d3eff..0dab5d7b145 100644
--- a/core/java/android/hardware/SystemSensorManager.java
+++ b/core/java/android/hardware/SystemSensorManager.java
@@ -68,7 +68,7 @@ public class SystemSensorManager extends SensorManager {
             long nativeInstance, int channelHandle, int sensorHandle, int rate);
 
     private static native int nativeSetOperationParameter(
-            long nativeInstance, int handle, int type, float[] floatValues, int[] intValues);
+            long nativeInstance, int type, float[] floatValues, int[] intValues);
 
     private static final Object sLock = new Object();
     @GuardedBy("sLock")
@@ -956,9 +956,7 @@ public class SystemSensorManager extends SensorManager {
     }
 
     protected boolean setOperationParameterImpl(SensorAdditionalInfo parameter) {
-        int handle = -1;
-        if (parameter.sensor != null) handle = parameter.sensor.getHandle();
         return nativeSetOperationParameter(
-                mNativeInstance, handle, parameter.type, parameter.floatValues, parameter.intValues) == 0;
+                mNativeInstance, parameter.type, parameter.floatValues, parameter.intValues) == 0;
     }
 }
diff --git a/core/jni/android_hardware_SensorManager.cpp b/core/jni/android_hardware_SensorManager.cpp
index dae96523f88..bba233035fc 100644
--- a/core/jni/android_hardware_SensorManager.cpp
+++ b/core/jni/android_hardware_SensorManager.cpp
@@ -15,13 +15,13 @@
  */
 #define LOG_TAG "SensorManager"
 
-#include <nativehelper/JNIHelp.h>
+#include "JNIHelp.h"
 #include "android_os_MessageQueue.h"
 #include "core_jni_helpers.h"
 #include "jni.h"
 
-#include <nativehelper/ScopedUtfChars.h>
-#include <nativehelper/ScopedLocalRef.h>
+#include <ScopedUtfChars.h>
+#include <ScopedLocalRef.h>
 #include <android_runtime/AndroidRuntime.h>
 #include <android_runtime/android_hardware_HardwareBuffer.h>
 #include <vndk/hardware_buffer.h>
@@ -238,58 +238,21 @@ static jboolean nativeIsDataInjectionEnabled(JNIEnv *_env, jclass _this, jlong s
 
 static jint nativeCreateDirectChannel(JNIEnv *_env, jclass _this, jlong sensorManager,
         jlong size, jint channelType, jint fd, jobject hardwareBufferObj) {
-    const native_handle_t *nativeHandle = nullptr;
-    NATIVE_HANDLE_DECLARE_STORAGE(ashmemHandle, 1, 0);
-
-    if (channelType == SENSOR_DIRECT_MEM_TYPE_ASHMEM) {
-        native_handle_t *handle = native_handle_init(ashmemHandle, 1, 0);
-        handle->data[0] = fd;
-        nativeHandle = handle;
-    } else if (channelType == SENSOR_DIRECT_MEM_TYPE_GRALLOC) {
-        AHardwareBuffer *hardwareBuffer =
-                android_hardware_HardwareBuffer_getNativeHardwareBuffer(_env, hardwareBufferObj);
-        if (hardwareBuffer != nullptr) {
-            nativeHandle = AHardwareBuffer_getNativeHandle(hardwareBuffer);
-        }
-    }
-
-    if (nativeHandle == nullptr) {
-        return BAD_VALUE;
-    }
-
-    SensorManager* mgr = reinterpret_cast<SensorManager*>(sensorManager);
-    return mgr->createDirectChannel(size, channelType, nativeHandle);
+    return BAD_VALUE;
 }
 
 static void nativeDestroyDirectChannel(JNIEnv *_env, jclass _this, jlong sensorManager,
         jint channelHandle) {
-    SensorManager* mgr = reinterpret_cast<SensorManager*>(sensorManager);
-    mgr->destroyDirectChannel(channelHandle);
 }
 
 static jint nativeConfigDirectChannel(JNIEnv *_env, jclass _this, jlong sensorManager,
         jint channelHandle, jint sensorHandle, jint rate) {
-    SensorManager* mgr = reinterpret_cast<SensorManager*>(sensorManager);
-    return mgr->configureDirectChannel(channelHandle, sensorHandle, rate);
+    return BAD_VALUE;
 }
 
 static jint nativeSetOperationParameter(JNIEnv *_env, jclass _this, jlong sensorManager,
-        jint handle, jint type, jfloatArray floats, jintArray ints) {
-    SensorManager* mgr = reinterpret_cast<SensorManager*>(sensorManager);
-    Vector<float> floatVector;
-    Vector<int32_t> int32Vector;
-
-    if (floats != nullptr) {
-        floatVector.resize(_env->GetArrayLength(floats));
-        _env->GetFloatArrayRegion(floats, 0, _env->GetArrayLength(floats), floatVector.editArray());
-    }
-
-    if (ints != nullptr) {
-        int32Vector.resize(_env->GetArrayLength(ints));
-        _env->GetIntArrayRegion(ints, 0, _env->GetArrayLength(ints), int32Vector.editArray());
-    }
-
-    return mgr->setOperationParameter(handle, type, floatVector, int32Vector);
+        jint type, jfloatArray floats, jintArray ints) {
+    return BAD_VALUE;
 }
 
 //----------------------------------------------------------------------------
@@ -516,7 +479,7 @@ static const JNINativeMethod gSystemSensorManagerMethods[] = {
             (void*)nativeConfigDirectChannel },
 
     {"nativeSetOperationParameter",
-            "(JII[F[I)I",
+            "(JI[F[I)I",
             (void*)nativeSetOperationParameter },
 };
 
diff --git a/native/android/Android.bp b/native/android/Android.bp
index 00fe6382fc1..d6f27f7b170 100644
--- a/native/android/Android.bp
+++ b/native/android/Android.bp
@@ -22,12 +22,6 @@ ndk_library {
 
 cc_defaults {
     name: "libandroid_defaults",
-    cflags: [
-        "-Wall",
-        "-Werror",
-        "-Wunused",
-        "-Wunreachable-code",
-    ],
 }
 
 cc_library_shared {
diff --git a/native/android/sensor.cpp b/native/android/sensor.cpp
index 8e5821024ce..b2cb18fa42e 100644
--- a/native/android/sensor.cpp
+++ b/native/android/sensor.cpp
@@ -19,15 +19,14 @@
 
 #include <android/looper.h>
 #include <android/sensor.h>
-#include <android/sharedmem.h>
-#include <cutils/native_handle.h>
+
+#include <utils/RefBase.h>
+#include <utils/Looper.h>
+#include <utils/Timers.h>
+
 #include <sensor/Sensor.h>
 #include <sensor/SensorManager.h>
 #include <sensor/SensorEventQueue.h>
-#include <utils/Looper.h>
-#include <utils/RefBase.h>
-#include <utils/Timers.h>
-#include <vndk/hardware_buffer.h>
 
 #include <poll.h>
 
@@ -39,33 +38,13 @@ using android::String8;
 using android::String16;
 
 /*****************************************************************************/
-#define ERROR_INVALID_PARAMETER(message) ALOGE("%s: " message, __func__)
-
-// frequently used checks
-#define RETURN_IF_MANAGER_IS_NULL(retval) do {\
-        if (manager == nullptr) { \
-            ERROR_INVALID_PARAMETER("manager cannot be NULL"); \
-            return retval; \
-        } \
-    } while (false)
-#define RETURN_IF_SENSOR_IS_NULL(retval) do {\
-        if (sensor == nullptr) { \
-            ERROR_INVALID_PARAMETER("sensor cannot be NULL"); \
-            return retval; \
-        } \
-    } while (false)
-#define RETURN_IF_QUEUE_IS_NULL(retval) do {\
-        if (queue == nullptr) { \
-            ERROR_INVALID_PARAMETER("queue cannot be NULL"); \
-            return retval; \
-        } \
-    } while (false)
-
-ASensorManager* ASensorManager_getInstance() {
-    return ASensorManager_getInstanceForPackage(nullptr);
+ASensorManager* ASensorManager_getInstance()
+{
+    return ASensorManager_getInstanceForPackage(NULL);
 }
 
-ASensorManager* ASensorManager_getInstanceForPackage(const char* packageName) {
+ASensorManager* ASensorManager_getInstanceForPackage(const char* packageName)
+{
     if (packageName) {
         return &SensorManager::getInstanceForPackage(String16(packageName));
     } else {
@@ -73,8 +52,9 @@ ASensorManager* ASensorManager_getInstanceForPackage(const char* packageName) {
     }
 }
 
-int ASensorManager_getSensorList(ASensorManager* manager, ASensorList* list) {
-    RETURN_IF_MANAGER_IS_NULL(android::BAD_VALUE);
+int ASensorManager_getSensorList(ASensorManager* manager,
+        ASensorList* list)
+{
     Sensor const* const* l;
     int c = static_cast<SensorManager*>(manager)->getSensorList(&l);
     if (list) {
@@ -83,13 +63,13 @@ int ASensorManager_getSensorList(ASensorManager* manager, ASensorList* list) {
     return c;
 }
 
-ASensor const* ASensorManager_getDefaultSensor(ASensorManager* manager, int type) {
-    RETURN_IF_MANAGER_IS_NULL(nullptr);
+ASensor const* ASensorManager_getDefaultSensor(ASensorManager* manager, int type)
+{
     return static_cast<SensorManager*>(manager)->getDefaultSensor(type);
 }
 
-ASensor const* ASensorManager_getDefaultSensorEx(ASensorManager* manager, int type, bool wakeUp) {
-    RETURN_IF_MANAGER_IS_NULL(nullptr);
+ASensor const* ASensorManager_getDefaultSensorEx(ASensorManager* manager,
+        int type, bool wakeUp) {
     Sensor const* const* sensorList;
     size_t size = static_cast<SensorManager*>(manager)->getSensorList(&sensorList);
     for (size_t i = 0; i < size; ++i) {
@@ -98,18 +78,12 @@ ASensor const* ASensorManager_getDefaultSensorEx(ASensorManager* manager, int ty
             return reinterpret_cast<ASensor const *>(sensorList[i]);
        }
     }
-    return nullptr;
+    return NULL;
 }
 
 ASensorEventQueue* ASensorManager_createEventQueue(ASensorManager* manager,
-        ALooper* looper, int ident, ALooper_callbackFunc callback, void* data) {
-    RETURN_IF_MANAGER_IS_NULL(nullptr);
-
-    if (looper == nullptr) {
-        ERROR_INVALID_PARAMETER("looper cannot be NULL");
-        return nullptr;
-    }
-
+        ALooper* looper, int ident, ALooper_callbackFunc callback, void* data)
+{
     sp<SensorEventQueue> queue =
             static_cast<SensorManager*>(manager)->createEventQueue();
     if (queue != 0) {
@@ -120,137 +94,46 @@ ASensorEventQueue* ASensorManager_createEventQueue(ASensorManager* manager,
     return static_cast<ASensorEventQueue*>(queue.get());
 }
 
-int ASensorManager_destroyEventQueue(ASensorManager* manager, ASensorEventQueue* queue) {
-    RETURN_IF_MANAGER_IS_NULL(android::BAD_VALUE);
-    RETURN_IF_QUEUE_IS_NULL(android::BAD_VALUE);
-
-    sp<SensorEventQueue> q = static_cast<SensorEventQueue*>(queue);
-    ALooper_removeFd(q->looper, q->getFd());
-    q->decStrong(manager);
+int ASensorManager_destroyEventQueue(ASensorManager* manager,
+        ASensorEventQueue* inQueue)
+{
+    sp<SensorEventQueue> queue = static_cast<SensorEventQueue*>(inQueue);
+    ALooper_removeFd(queue->looper, queue->getFd());
+    queue->decStrong(manager);
     return 0;
 }
 
-int ASensorManager_createSharedMemoryDirectChannel(ASensorManager *manager, int fd, size_t size) {
-    RETURN_IF_MANAGER_IS_NULL(android::BAD_VALUE);
-
-    if (fd < 0) {
-        ERROR_INVALID_PARAMETER("fd is invalid.");
-        return android::BAD_VALUE;
-    }
-
-    if (size < sizeof(ASensorEvent)) {
-        ERROR_INVALID_PARAMETER("size has to be greater or equal to sizeof(ASensorEvent).");
-        return android::BAD_VALUE;
-    }
-
-    native_handle_t *resourceHandle = native_handle_create(1 /* nFd */, 0 /* nInt */);
-    if (!resourceHandle) {
-        return android::NO_MEMORY;
-    }
-
-    resourceHandle->data[0] = fd;
-    int ret = static_cast<SensorManager *>(manager)->createDirectChannel(
-            size, ASENSOR_DIRECT_CHANNEL_TYPE_SHARED_MEMORY, resourceHandle);
-    native_handle_delete(resourceHandle);
-    return ret;
-}
-
-int ASensorManager_createHardwareBufferDirectChannel(
-        ASensorManager *manager, AHardwareBuffer const *buffer, size_t size) {
-    RETURN_IF_MANAGER_IS_NULL(android::BAD_VALUE);
-
-    if (buffer == nullptr) {
-        ERROR_INVALID_PARAMETER("buffer cannot be NULL");
-        return android::BAD_VALUE;
-    }
-
-    if (size < sizeof(ASensorEvent)) {
-        ERROR_INVALID_PARAMETER("size has to be greater or equal to sizeof(ASensorEvent).");
-        return android::BAD_VALUE;
-    }
-
-    const native_handle_t *resourceHandle = AHardwareBuffer_getNativeHandle(buffer);
-    if (!resourceHandle) {
-        return android::NO_MEMORY;
-    }
-
-    return static_cast<SensorManager *>(manager)->createDirectChannel(
-            size, ASENSOR_DIRECT_CHANNEL_TYPE_HARDWARE_BUFFER, resourceHandle);
-}
-
-void ASensorManager_destroyDirectChannel(ASensorManager *manager, int channelId) {
-    RETURN_IF_MANAGER_IS_NULL(void());
-
-    static_cast<SensorManager *>(manager)->destroyDirectChannel(channelId);
-}
-
-int ASensorManager_configureDirectReport(
-        ASensorManager *manager, ASensor const *sensor, int channelId, int rate) {
-    RETURN_IF_MANAGER_IS_NULL(android::BAD_VALUE);
-
-    int sensorHandle;
-    if (sensor == nullptr) {
-        if (rate != ASENSOR_DIRECT_RATE_STOP) {
-            ERROR_INVALID_PARAMETER(
-                "sensor cannot be null when rate is not ASENSOR_DIRECT_RATE_STOP");
-            return android::BAD_VALUE;
-        }
-        sensorHandle = -1;
-    } else {
-        sensorHandle = static_cast<Sensor const *>(sensor)->getHandle();
-    }
-    return static_cast<SensorManager *>(manager)->configureDirectChannel(
-            channelId, sensorHandle, rate);
-}
-
 /*****************************************************************************/
 
 int ASensorEventQueue_registerSensor(ASensorEventQueue* queue, ASensor const* sensor,
-        int32_t samplingPeriodUs, int64_t maxBatchReportLatencyUs) {
-    RETURN_IF_QUEUE_IS_NULL(android::BAD_VALUE);
-    RETURN_IF_SENSOR_IS_NULL(android::BAD_VALUE);
-    if (samplingPeriodUs < 0 || maxBatchReportLatencyUs < 0) {
-        ERROR_INVALID_PARAMETER("samplingPeriodUs and maxBatchReportLatencyUs cannot be negative");
-        return android::BAD_VALUE;
-    }
-
+        int32_t samplingPeriodUs, int maxBatchReportLatencyUs)
+{
     return static_cast<SensorEventQueue*>(queue)->enableSensor(
             static_cast<Sensor const*>(sensor)->getHandle(), samplingPeriodUs,
                     maxBatchReportLatencyUs, 0);
 }
 
-int ASensorEventQueue_enableSensor(ASensorEventQueue* queue, ASensor const* sensor) {
-    RETURN_IF_QUEUE_IS_NULL(android::BAD_VALUE);
-    RETURN_IF_SENSOR_IS_NULL(android::BAD_VALUE);
-
+int ASensorEventQueue_enableSensor(ASensorEventQueue* queue, ASensor const* sensor)
+{
     return static_cast<SensorEventQueue*>(queue)->enableSensor(
             static_cast<Sensor const*>(sensor));
 }
 
-int ASensorEventQueue_disableSensor(ASensorEventQueue* queue, ASensor const* sensor) {
-    RETURN_IF_QUEUE_IS_NULL(android::BAD_VALUE);
-    RETURN_IF_SENSOR_IS_NULL(android::BAD_VALUE);
-
+int ASensorEventQueue_disableSensor(ASensorEventQueue* queue, ASensor const* sensor)
+{
     return static_cast<SensorEventQueue*>(queue)->disableSensor(
             static_cast<Sensor const*>(sensor));
 }
 
-int ASensorEventQueue_setEventRate(ASensorEventQueue* queue, ASensor const* sensor, int32_t usec) {
-    RETURN_IF_QUEUE_IS_NULL(android::BAD_VALUE);
-    RETURN_IF_SENSOR_IS_NULL(android::BAD_VALUE);
-
-    if (usec < 0) {
-        ERROR_INVALID_PARAMETER("usec cannot be negative");
-        return android::BAD_VALUE;
-    }
-
+int ASensorEventQueue_setEventRate(ASensorEventQueue* queue, ASensor const* sensor,
+        int32_t usec)
+{
     return static_cast<SensorEventQueue*>(queue)->setEventRate(
             static_cast<Sensor const*>(sensor), us2ns(usec));
 }
 
-int ASensorEventQueue_hasEvents(ASensorEventQueue* queue) {
-    RETURN_IF_QUEUE_IS_NULL(android::BAD_VALUE);
-
+int ASensorEventQueue_hasEvents(ASensorEventQueue* queue)
+{
     struct pollfd pfd;
     pfd.fd = static_cast<SensorEventQueue*>(queue)->getFd();
     pfd.events = POLLIN;
@@ -267,13 +150,9 @@ int ASensorEventQueue_hasEvents(ASensorEventQueue* queue) {
     return (nfd == 0) ? 0 : 1;
 }
 
-ssize_t ASensorEventQueue_getEvents(ASensorEventQueue* queue, ASensorEvent* events, size_t count) {
-    RETURN_IF_QUEUE_IS_NULL(android::BAD_VALUE);
-    if (events == nullptr) {
-        ERROR_INVALID_PARAMETER("events cannot be NULL");
-        return android::BAD_VALUE;
-    }
-
+ssize_t ASensorEventQueue_getEvents(ASensorEventQueue* queue,
+                ASensorEvent* events, size_t count)
+{
     ssize_t actual = static_cast<SensorEventQueue*>(queue)->read(events, count);
     if (actual > 0) {
         static_cast<SensorEventQueue*>(queue)->sendAck(events, actual);
@@ -283,62 +162,52 @@ ssize_t ASensorEventQueue_getEvents(ASensorEventQueue* queue, ASensorEvent* even
 
 /*****************************************************************************/
 
-const char* ASensor_getName(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(nullptr);
+const char* ASensor_getName(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getName().string();
 }
 
-const char* ASensor_getVendor(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(nullptr);
+const char* ASensor_getVendor(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getVendor().string();
 }
 
-int ASensor_getType(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(ASENSOR_TYPE_INVALID);
+int ASensor_getType(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getType();
 }
 
-float ASensor_getResolution(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(ASENSOR_RESOLUTION_INVALID);
+float ASensor_getResolution(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getResolution();
 }
 
-int ASensor_getMinDelay(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(ASENSOR_DELAY_INVALID);
+int ASensor_getMinDelay(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getMinDelay();
 }
 
-int ASensor_getFifoMaxEventCount(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(ASENSOR_FIFO_COUNT_INVALID);
+int ASensor_getFifoMaxEventCount(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getFifoMaxEventCount();
 }
 
-int ASensor_getFifoReservedEventCount(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(ASENSOR_FIFO_COUNT_INVALID);
+int ASensor_getFifoReservedEventCount(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getFifoReservedEventCount();
 }
 
-const char* ASensor_getStringType(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(nullptr);
+const char* ASensor_getStringType(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getStringType().string();
 }
 
-int ASensor_getReportingMode(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(AREPORTING_MODE_INVALID);
+int ASensor_getReportingMode(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->getReportingMode();
 }
 
-bool ASensor_isWakeUpSensor(ASensor const* sensor) {
-    RETURN_IF_SENSOR_IS_NULL(false);
+bool ASensor_isWakeUpSensor(ASensor const* sensor)
+{
     return static_cast<Sensor const*>(sensor)->isWakeUpSensor();
 }
-
-bool ASensor_isDirectChannelTypeSupported(ASensor const *sensor, int channelType) {
-    RETURN_IF_SENSOR_IS_NULL(false);
-    return static_cast<Sensor const *>(sensor)->isDirectChannelTypeSupported(channelType);
-}
-
-int ASensor_getHighestDirectReportRateLevel(ASensor const *sensor) {
-    RETURN_IF_SENSOR_IS_NULL(ASENSOR_DIRECT_RATE_STOP);
-    return static_cast<Sensor const *>(sensor)->getHighestDirectReportRateLevel();
-}
diff --git a/services/core/java/com/android/server/pm/PackageManagerServiceCompilerMapping.java b/services/core/java/com/android/server/pm/PackageManagerServiceCompilerMapping.java
index 19b0d9bc4b9..20d5c9fb10e 100644
--- a/services/core/java/com/android/server/pm/PackageManagerServiceCompilerMapping.java
+++ b/services/core/java/com/android/server/pm/PackageManagerServiceCompilerMapping.java
@@ -88,10 +88,12 @@ public class PackageManagerServiceCompilerMapping {
                 // Check validity, ignore result.
                 getAndCheckValidity(reason);
             } catch (Exception exc) {
+/*
                 if (toThrow == null) {
                     toThrow = new IllegalStateException("PMS compiler filter settings are bad.");
                 }
                 toThrow.addSuppressed(exc);
+*/
             }
         }
 
diff --git a/services/core/jni/Android.mk b/services/core/jni/Android.mk
index 455d4fadf88..cd8f69409b3 100644
--- a/services/core/jni/Android.mk
+++ b/services/core/jni/Android.mk
@@ -77,7 +77,6 @@ LOCAL_SHARED_LIBRARIES += \
     libinputservice \
     libschedulerservicehidl \
     libsensorservice \
-    libsensorservicehidl \
     libskia \
     libgui \
     libusbhost \
diff --git a/services/core/jni/com_android_server_SystemServer.cpp b/services/core/jni/com_android_server_SystemServer.cpp
index 3901cebcc78..87bfb9297c1 100644
--- a/services/core/jni/com_android_server_SystemServer.cpp
+++ b/services/core/jni/com_android_server_SystemServer.cpp
@@ -21,7 +21,7 @@
 
 #include <schedulerservice/SchedulingPolicyService.h>
 #include <sensorservice/SensorService.h>
-#include <sensorservicehidl/SensorManager.h>
+//#include <sensorservicehidl/SensorManager.h>
 
 #include <cutils/properties.h>
 #include <utils/Log.h>
@@ -39,27 +39,7 @@ static void android_server_SystemServer_startSensorService(JNIEnv* /* env */, jo
 
 }
 
-static void android_server_SystemServer_startHidlServices(JNIEnv* env, jobject /* clazz */) {
-    using ::android::frameworks::schedulerservice::V1_0::ISchedulingPolicyService;
-    using ::android::frameworks::schedulerservice::V1_0::implementation::SchedulingPolicyService;
-    using ::android::frameworks::sensorservice::V1_0::ISensorManager;
-    using ::android::frameworks::sensorservice::V1_0::implementation::SensorManager;
-    using ::android::hardware::configureRpcThreadpool;
-
-    status_t err;
-
-    configureRpcThreadpool(5, false /* callerWillJoin */);
-
-    JavaVM *vm;
-    LOG_ALWAYS_FATAL_IF(env->GetJavaVM(&vm) != JNI_OK, "Cannot get Java VM");
-
-    sp<ISensorManager> sensorService = new SensorManager(vm);
-    err = sensorService->registerAsService();
-    ALOGE_IF(err != OK, "Cannot register %s: %d", ISensorManager::descriptor, err);
-
-    sp<ISchedulingPolicyService> schedulingService = new SchedulingPolicyService();
-    err = schedulingService->registerAsService();
-    ALOGE_IF(err != OK, "Cannot register %s: %d", ISchedulingPolicyService::descriptor, err);
+static void android_server_SystemServer_startHidlServices(JNIEnv* /* env */, jobject /* clazz */) {
 }
 
 /*
-- 
2.11.0

