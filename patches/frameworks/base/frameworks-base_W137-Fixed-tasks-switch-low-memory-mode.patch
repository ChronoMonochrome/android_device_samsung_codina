From af8430c8d7af51a9891381fd377bd937e833aede Mon Sep 17 00:00:00 2001
From: Alexey Derendyaev <alexxxdev@yandex.ru>
Date: Fri, 11 May 2018 10:22:09 +0700
Subject: [PATCH] SystemUI: Fixed exception on tasks switch in low-memory mode

Test: Test steps described as bleow

 1. Set phone in low-memory mode.
 2. Start recents.
 3. Press up & down key to switch tasks.

diff --git a/packages/SystemUI/src/com/android/systemui/recents/views/TaskStackView.java b/packages/SystemUI/src/com/android/systemui/recents/views/TaskStackView.java
index d32b220..2d07cf8 100644
--- a/packages/SystemUI/src/com/android/systemui/recents/views/TaskStackView.java
+++ b/packages/SystemUI/src/com/android/systemui/recents/views/TaskStackView.java
@@ -975,7 +975,9 @@
                 }
 
                 mLayoutAlgorithm.clearUnfocusedTaskOverrides();
-                willScroll = mAnimationHelper.startScrollToFocusedTaskAnimation(newFocusedTask,
+                willScroll = this.mKeyPatchWhenLowMemory.HandleScrollToTask(mStackScroller,
+                        newFocusedTaskIndex)
+                        || mAnimationHelper.startScrollToFocusedTaskAnimation(newFocusedTask,
                         requestViewFocus);
                 if (willScroll) {
                     sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_SCROLLED);
@@ -1037,7 +1039,8 @@
                     }
                 } else {
                     // Try the next task if it is a stack task
-                    int tmpNewIndex = newIndex + (forward ? -1 : 1);
+                    int tmpNewIndex = newIndex
+                        + mKeyPatchWhenLowMemory.GetIndexDelta((forward ? -1 : 1));
                     if (0 <= tmpNewIndex && tmpNewIndex < tasks.size()) {
                         Task t = tasks.get(tmpNewIndex);
                         if (!t.isFreeformTask()) {
@@ -1049,7 +1052,8 @@
                 // No restrictions, lets just move to the new task (looping forward/backwards if
                 // necessary)
                 int taskCount = mStack.getTaskCount();
-                newIndex = (newIndex + (forward ? -1 : 1) + taskCount) % taskCount;
+                newIndex = (newIndex
+                    + mKeyPatchWhenLowMemory.GetIndexDelta((forward ? -1 : 1)) + taskCount) % taskCount;
             }
         } else {
             // We don't have a focused task
@@ -1987,7 +1991,7 @@
         // Stop any scrolling
         mStackScroller.stopScroller();
         mStackScroller.stopBoundScrollAnimation();
-
+        if (mKeyPatchWhenLowMemory.HandleFocusNextTaskViewEvent(this, mFocusedTask)) return;
         setRelativeFocusedTask(true, false /* stackTasksOnly */, true /* animated */, false,
                 event.timerIndicatorDuration);
     }
@@ -1996,7 +2000,7 @@
         // Stop any scrolling
         mStackScroller.stopScroller();
         mStackScroller.stopBoundScrollAnimation();
-
+        if (mKeyPatchWhenLowMemory.HandleFocusPreviousTaskViewEvent(this, mFocusedTask)) return;
         setRelativeFocusedTask(false, false /* stackTasksOnly */, true /* animated */);
     }
 
@@ -2008,6 +2012,7 @@
                     currentIndex, event.direction);
             setFocusedTask(nextIndex, false, true);
         } else {
+            mKeyPatchWhenLowMemory.OnHandleUpAndDownEvent();
             switch (event.direction) {
                 case UP:
                     EventBus.getDefault().send(new FocusPreviousTaskViewEvent());
@@ -2017,6 +2022,7 @@
                         new FocusNextTaskViewEvent(0 /* timerIndicatorDuration */));
                     break;
             }
+            mKeyPatchWhenLowMemory.OnHandleUpAndDownEventOver();
         }
     }
 
@@ -2471,4 +2477,57 @@
         mLayoutAlgorithm.dump(innerPrefix, writer);
         mStackScroller.dump(innerPrefix, writer);
     }
+
+    KeyPatchWhenLowMemory mKeyPatchWhenLowMemory = new KeyPatchWhenLowMemory();
+
+    public static class KeyPatchWhenLowMemory {
+        boolean mEnabled;
+        boolean mHandlingKeyEvent;
+        int mCurrentFocusedViewIndex = -1;
+
+        public KeyPatchWhenLowMemory() {
+            mEnabled = Recents.getConfiguration().isLowRamDevice;
+        }
+
+        public void OnHandleUpAndDownEventOver() {
+            if (!mEnabled) return;
+            mHandlingKeyEvent = false;
+        }
+
+        public void OnHandleUpAndDownEvent() {
+            if (!mEnabled) return;
+            mHandlingKeyEvent = true;
+        }
+
+        public boolean HandleFocusPreviousTaskViewEvent(TaskStackView taskStackView,
+                Task focusedTask) {
+            return HandleKeyEvent(taskStackView, focusedTask, false);
+        }
+
+        public boolean HandleFocusNextTaskViewEvent(TaskStackView taskStackView, Task focusedTask) {
+            return HandleKeyEvent(taskStackView, focusedTask, true);
+        }
+
+        public boolean HandleScrollToTask(TaskStackViewScroller stackScroller,
+                int newFocusedTaskIndex) {
+            if (!mEnabled || !mHandlingKeyEvent) return false;
+            int v = newFocusedTaskIndex > mCurrentFocusedViewIndex? -1000 : 1000;
+            stackScroller.scrollToClosestTask(v);
+            return true;
+        }
+
+        private boolean HandleKeyEvent(TaskStackView stackView, Task focusedTask, boolean forward) {
+            if (!mEnabled || !mHandlingKeyEvent) return false;
+            if (focusedTask == null) return false;
+            int invalidIndex = forward? (stackView.getStack().getStackTasks().size() - 1) : 0;
+            mCurrentFocusedViewIndex = stackView.getStack().getStackTasks().indexOf(focusedTask);
+            return mCurrentFocusedViewIndex == invalidIndex;
+        }
+
+        public int GetIndexDelta(int srcValue) {
+            if (!mEnabled || !mHandlingKeyEvent) return srcValue;
+            return -srcValue;
+        }
+
+    }
 }
