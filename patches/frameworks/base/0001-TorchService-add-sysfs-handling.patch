From 0752e76c20417f6f6a615ede777514fd907846bc Mon Sep 17 00:00:00 2001
From: MarcKe <herderkewitz@googlemail.com>
Date: Tue, 17 Feb 2015 21:36:51 +0100
Subject: [PATCH] TorchService: add sysfs handling

Conflicts:
	core/res/res/values/config.xml
	core/res/res/values/symbols.xml

Conflicts:
	core/res/res/values/config.xml
	core/res/res/values/symbols.xml
	services/core/java/com/android/server/TorchService.java

Change-Id: I02dde50669298f92232096abff705c86325f5526
---
 core/res/res/values/config.xml                     |  8 ++
 core/res/res/values/symbols.xml                    |  4 +
 .../core/java/com/android/server/TorchService.java | 94 ++++++++++++++++------
 3 files changed, 82 insertions(+), 24 deletions(-)

diff --git a/core/res/res/values/config.xml b/core/res/res/values/config.xml
index f223b85..9689bfe 100755
--- a/core/res/res/values/config.xml
+++ b/core/res/res/values/config.xml
@@ -2257,4 +2257,12 @@
         config to 7. -->
     <integer name="config_deviceHardwareKeys">0</integer>
 
+    <!-- If there is no sysfs-based control mechanism, enable this -->
+    <bool name="useCameraInterface">true</bool>
+    <!-- Full path to the sysfs toggle -->
+    <string name="flashDevice"></string>  
+    <!-- Off setting -->
+    <integer name="valueOff">0</integer>
+    <!-- On setting -->
+    <integer name="valueOn">1</integer>
 </resources>
diff --git a/core/res/res/values/symbols.xml b/core/res/res/values/symbols.xml
index 4ecf97e..76ce63c 100755
--- a/core/res/res/values/symbols.xml
+++ b/core/res/res/values/symbols.xml
@@ -2283,4 +2283,8 @@
   <java-symbol type="string" name="adb_both_active_notification_title" />
   <java-symbol type="string" name="adb_active_generic_notification_message" />
 
+  <java-symbol type="bool" name="useCameraInterface" />
+  <java-symbol type="string" name="flashDevice" />
+  <java-symbol type="integer" name="valueOff" />
+  <java-symbol type="integer" name="valueOn" />
 </resources>
diff --git a/services/core/java/com/android/server/TorchService.java b/services/core/java/com/android/server/TorchService.java
index b7d1bf9..eab3aec 100644
--- a/services/core/java/com/android/server/TorchService.java
+++ b/services/core/java/com/android/server/TorchService.java
@@ -48,6 +48,11 @@ import android.view.Surface;
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 import java.util.ArrayList;
+import java.io.FileWriter;
+import java.io.File;
+import java.io.IOException;
+
+import com.android.internal.R;
 
 import com.android.internal.R;
 
@@ -96,6 +101,12 @@ public class TorchService extends ITorchService.Stub {
     private Surface mSurface;
 
     private boolean mReceiverRegistered;
+    private static int mValueOff;
+    private static int mValueOn;
+    private static String mFlashDevice;
+    private static boolean mUseCameraInterface;
+
+    private FileWriter mFlashDeviceWriter = null;
 
     private static class CameraUserRecord {
         IBinder token;
@@ -111,8 +122,14 @@ public class TorchService extends ITorchService.Stub {
 
     public TorchService(Context context) {
         mContext = context;
+
+        mValueOff = mContext.getResources().getInteger(R.integer.valueOff);
+        mValueOn = mContext.getResources().getInteger(R.integer.valueOn);
+        mFlashDevice = mContext.getResources().getString(R.string.flashDevice);
+        mUseCameraInterface = mContext.getResources().getBoolean(R.bool.useCameraInterface);
+
         mCamerasInUse = new SparseArray<CameraUserRecord>();
-        mCameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
+        mCameraManager = (CameraManager) mContext.getSystemService(Context.CAMERA_SERVICE);
         initialize();
     }
 
@@ -126,8 +143,10 @@ public class TorchService extends ITorchService.Stub {
 
         if (mTorchCameraId != -1) {
             ensureHandler();
-            mCameraManager.registerAvailabilityCallback(mAvailabilityCallback, mHandler);
-        }
+            if (mUseCameraInterface) {
+                mCameraManager.registerAvailabilityCallback(mAvailabilityCallback, mHandler);
+            }
+        }       
     }
 
     @Override
@@ -143,7 +162,7 @@ public class TorchService extends ITorchService.Stub {
                 // As a synchronous broadcast is an expensive operation, only
                 // attempt to kill torch if it actually grabbed the camera before
                 if (cameraId == mTorchCameraId) {
-                    if (mCamerasInUse.get(cameraId) != null) {
+                    if (!mUseCameraInterface || mCamerasInUse.get(cameraId) != null) {
                         if (DEBUG) Log.d(TAG, "Need to kill torch");
                         needTorchShutdown = true;
                     }
@@ -204,7 +223,12 @@ public class TorchService extends ITorchService.Stub {
     public synchronized boolean isAvailable() {
         mContext.enforceCallingOrSelfPermission(
                 Manifest.permission.ACCESS_TORCH_SERVICE, null);
-        return mTorchAvailable;
+        if (mUseCameraInterface) {
+            return mTorchAvailable;
+        } else {
+            File f = new File(mFlashDevice);
+            return f.exists() && f.canWrite();
+        }
     }
 
     @Override
@@ -364,31 +388,53 @@ public class TorchService extends ITorchService.Stub {
             synchronized (this) {
                 enabled = mTorchEnabled && !forceDisable;
             }
-            if (enabled) {
-                if (mCameraDevice == null) {
-                    if (!mOpeningCamera) {
+            if (mUseCameraInterface) {
+                if (enabled) {
+                    if (mCameraDevice == null) {
                         startDevice();
+                        return;
+                    }
+                    if (mSession == null) {
+                        startSession();
+                        return;
+                    }
+                    if (mFlashlightRequest == null) {
+                        CaptureRequest.Builder builder = mCameraDevice.createCaptureRequest(
+                                CameraDevice.TEMPLATE_PREVIEW);
+                        builder.set(CaptureRequest.FLASH_MODE, CameraMetadata.FLASH_MODE_TORCH);
+                        builder.addTarget(mSurface);
+                        CaptureRequest request = builder.build();
+                        mSession.capture(request, null, mHandler);
+                        mFlashlightRequest = request;
+                    }
+                } else {
+                    if (mCameraDevice != null) {
+                        mCameraDevice.close();
+                        teardownTorch();
                     }
-                    return;
                 }
-                if (mSession == null) {
-                    startSession();
-                    return;
+            } else {
+                // Devices with just a sysfs toggle
+                if (mFlashDeviceWriter == null) {
+                    try {
+                        mFlashDeviceWriter = new FileWriter(mFlashDevice);
+                    } catch (IOException e) {
+                        Log.e(TAG, "Error creating new mFlashDeviceWriter");
+                        handleError();
+                    }
                 }
-                if (mFlashlightRequest == null) {
-                    CaptureRequest.Builder builder = mCameraDevice.createCaptureRequest(
-                            CameraDevice.TEMPLATE_PREVIEW);
-                    builder.set(CaptureRequest.FLASH_MODE, CameraMetadata.FLASH_MODE_TORCH);
-                    builder.addTarget(mSurface);
-                    CaptureRequest request = builder.build();
-                    mSession.capture(request, null, mHandler);
-                    mFlashlightRequest = request;
-                    dispatchStateChange(true);
+                try {
+                    mFlashDeviceWriter.write(String.valueOf(enabled ? mValueOn : mValueOff));
+                    mFlashDeviceWriter.flush();
+                    if (!enabled) {                        
+                        mFlashDeviceWriter.close();
+                        mFlashDeviceWriter = null;
+                    }
+                } catch (IOException e) {
+                    Log.e(TAG, "Error writing to flashlight sysfs", e);
+                    handleError();
                 }
-            } else {
-                teardownTorch();
             }
-
         } catch (CameraAccessException|IllegalStateException|UnsupportedOperationException e) {
             Log.e(TAG, "Error in updateFlashlight", e);
             handleError();
-- 
1.9.1

