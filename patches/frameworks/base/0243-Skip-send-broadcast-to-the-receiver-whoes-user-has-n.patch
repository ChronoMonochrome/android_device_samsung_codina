From a46ae92e8a22112e4c49457c61505eebfa832a4e Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 20 Aug 2018 22:57:43 +0300
Subject: [PATCH 243/296] Skip send broadcast to the receiver whoes user has
 not started

After switch user from guest to owner,there may have some send
to all user broadcasts still need to deliver,and in the send
workflow may start process that relate to guest to receive the
broadcast, BUT if the process start service with the stopped user
AMS will throw SecurityException make the process crash.
---
 .../java/com/android/server/am/BroadcastQueue.java | 38 +++++++++++++++-------
 1 file changed, 27 insertions(+), 11 deletions(-)

diff --git a/services/core/java/com/android/server/am/BroadcastQueue.java b/services/core/java/com/android/server/am/BroadcastQueue.java
index 649e5ece446..61b18cd001e 100644
--- a/services/core/java/com/android/server/am/BroadcastQueue.java
+++ b/services/core/java/com/android/server/am/BroadcastQueue.java
@@ -1336,12 +1336,7 @@ public final class BroadcastQueue {
                     // from a client, so throwing an exception out from here
                     // will crash the entire system instead of just whoever
                     // sent the broadcast.
-                    logBroadcastReceiverDiscardLocked(r);
-                    finishReceiverLocked(r, r.resultCode, r.resultData,
-                            r.resultExtras, r.resultAbort, false);
-                    scheduleBroadcastsLocked();
-                    // We need to reset the state if we failed to start the receiver.
-                    r.state = BroadcastRecord.IDLE;
+                    resetBroadcastStateAndContinueDelivery(r);
                     return;
                 }
 
@@ -1353,6 +1348,11 @@ public final class BroadcastQueue {
             if (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,
                     "Need to start app ["
                     + mQueueName + "] " + targetProcess + " for broadcast " + r);
+            // skip send broadcast to the receiver whoes user has not started.
+            if (!isUserOfReceiverStarted(info)) {
+                resetBroadcastStateAndContinueDelivery(r);
+                return;
+            }
             if ((r.curApp=mService.startProcessLocked(targetProcess,
                     info.activityInfo.applicationInfo, true,
                     r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,
@@ -1365,11 +1365,7 @@ public final class BroadcastQueue {
                         + info.activityInfo.applicationInfo.packageName + "/"
                         + info.activityInfo.applicationInfo.uid + " for broadcast "
                         + r.intent + ": process is bad");
-                logBroadcastReceiverDiscardLocked(r);
-                finishReceiverLocked(r, r.resultCode, r.resultData,
-                        r.resultExtras, r.resultAbort, false);
-                scheduleBroadcastsLocked();
-                r.state = BroadcastRecord.IDLE;
+                resetBroadcastStateAndContinueDelivery(r);
                 return;
             }
 
@@ -1378,6 +1374,26 @@ public final class BroadcastQueue {
         }
     }
 
+    private final void resetBroadcastStateAndContinueDelivery(BroadcastRecord r) {
+        logBroadcastReceiverDiscardLocked(r);
+        finishReceiverLocked(r, r.resultCode, r.resultData,
+                r.resultExtras, r.resultAbort, false);
+        scheduleBroadcastsLocked();
+        // We need to reset the state if we failed to start or skip the receiver
+        r.state = BroadcastRecord.IDLE;
+    }
+
+    private final boolean isUserOfReceiverStarted(ResolveInfo info) {
+        // the process has not start yet, do not concern the isolated uid
+        final int userId = UserHandle.getUserId(info.activityInfo.applicationInfo.uid);
+        if (mService.mUserController.hasStartedUserState(userId)) {
+            return true;
+        }
+        Slog.w(TAG, "The user[" + userId + "] of receiver:"
+                + info + " is not started, skip it !");
+        return false;
+    }
+
     final void setBroadcastTimeoutLocked(long timeoutTime) {
         if (! mPendingBroadcastTimeoutMessage) {
             Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, this);
-- 
2.11.0

