From a0943bd277ed9b5ecaf1c7c1ace7590b1b6da37d Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 20 Aug 2018 22:57:43 +0300
Subject: [PATCH] Catch egl errors when drawIntoSurfaces

Cts test case: testAbandonRepeatingRequestSurface is
used to test the GPU for the ability of detecting the
interrupt release of surface. It may have a dequeue buffer
action in eglMakeCurrent, so it would return error
"EGL_BAD_NATIVE_WINDOW" after surfaceflinger has been
disconnected. In this case, the test can be passed
only when we catch the errors thrown from GPU when calling
eglMakeCurrent, or the test would be interrupted by
the error exception.

diff --git a/core/java/android/hardware/camera2/legacy/SurfaceTextureRenderer.java b/core/java/android/hardware/camera2/legacy/SurfaceTextureRenderer.java
index a05a8ec..2bc5856 100644
--- a/core/java/android/hardware/camera2/legacy/SurfaceTextureRenderer.java
+++ b/core/java/android/hardware/camera2/legacy/SurfaceTextureRenderer.java
@@ -521,9 +521,10 @@
         clearState();
     }
 
-    private void makeCurrent(EGLSurface surface) {
+    private void makeCurrent(EGLSurface surface)
+            throws LegacyExceptionUtils.BufferQueueAbandonedException {
         EGL14.eglMakeCurrent(mEGLDisplay, surface, surface, mEGLContext);
-        checkEglError("makeCurrent");
+        checkEglDrawError("makeCurrent");
     }
 
     private boolean swapBuffers(EGLSurface surface)
@@ -539,6 +540,18 @@
         return result;
     }
 
+    private void checkEglDrawError(String msg)
+            throws LegacyExceptionUtils.BufferQueueAbandonedException {
+        int error;
+        if ((error = EGL14.eglGetError()) == EGL14.EGL_BAD_NATIVE_WINDOW) {
+            Log.d(TAG, "workaround for EGL_BAD_NATIVE_WINDOW");
+            throw new LegacyExceptionUtils.BufferQueueAbandonedException();
+        }
+        if ((error = EGL14.eglGetError()) != EGL14.EGL_SUCCESS) {
+            throw new IllegalStateException(msg + ": EGL error: 0x" + Integer.toHexString(error));
+        }
+    }
+
     private void checkEglError(String msg) {
         int error;
         if ((error = EGL14.eglGetError()) != EGL14.EGL_SUCCESS) {
@@ -691,8 +704,14 @@
         if (mConversionSurfaces.size() > 0) {
             configureEGLPbufferSurfaces(mConversionSurfaces);
         }
-        makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface :
+
+        try {
+            makeCurrent((mSurfaces.size() > 0) ? mSurfaces.get(0).eglSurface :
                 mConversionSurfaces.get(0).eglSurface);
+        } catch (LegacyExceptionUtils.BufferQueueAbandonedException e) {
+                Log.w(TAG, "Surface abandoned, skipping configuration... ", e);
+        }
+
         initializeGLState();
         mSurfaceTexture = new SurfaceTexture(getTextureId());
 
@@ -780,9 +799,9 @@
         }
         for (EGLSurfaceHolder holder : mConversionSurfaces) {
             if (LegacyCameraDevice.containsSurfaceId(holder.surface, targetSurfaceIds)) {
-                makeCurrent(holder.eglSurface);
                 // glReadPixels reads from the bottom of the buffer, so add an extra vertical flip
                 try {
+                    makeCurrent(holder.eglSurface);
                     drawFrame(mSurfaceTexture, holder.width, holder.height,
                             (mFacing == CameraCharacteristics.LENS_FACING_FRONT) ?
                                     FLIP_TYPE_BOTH : FLIP_TYPE_VERTICAL);
