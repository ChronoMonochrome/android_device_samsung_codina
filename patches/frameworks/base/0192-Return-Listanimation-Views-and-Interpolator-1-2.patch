From fbcd78b106e7939b364c53ce86adafbdc1655d7e Mon Sep 17 00:00:00 2001
From: LorDClockaN <davor@losinj.com>
Date: Mon, 15 Dec 2014 16:35:01 +0100
Subject: [PATCH 192/296] Return: Listanimation Views and Interpolator [1/2]

PatchSet:
    - optimize more:
    - call provider values only when needed and do not fire them permanently.
      so just do it if scroll state changed.
    - as well go out of the setAnimation method as soon as possible. We
      handle here methods which get called 10000 times during scrolling
      so we need to be as fast as possible.

PS:
 - initialize the animation modes default to off just to be sure

PS:
 - move state change out of OnScrollListener
 - reduce the provider value call to only one call
---
 core/java/android/provider/Settings.java  |  29 +++++
 core/java/android/widget/AbsListView.java | 175 +++++++++++++++++++++++++++++-
 2 files changed, 201 insertions(+), 3 deletions(-)

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 08d6b64bdf4..ae5098c21a2 100755
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -3981,6 +3981,35 @@ public final class Settings {
         public static final String MEDIA_SCANNER_ON_BOOT = "media_scanner_on_boot";
 
         /**
+         * ListView Animations
+         * 0 == None
+         * 1 == Wave (Left)
+         * 2 == Wave (Right)
+         * 3 == Scale
+         * 4 == Alpha
+         * 5 == Stack (Top)
+         * 6 == Stack (Bottom)
+         * 7 == Translate (Left)
+         * 8 == Translate (Right)
+         * @hide
+         */
+        public static final String LISTVIEW_ANIMATION = "listview_animation";
+
+        /**
+         * ListView Interpolators
+         * 0 == None
+         * 1 == accelerate_interpolator
+         * 2 == decelerate_interpolator
+         * 3 == accelerate_decelerate_interpolator
+         * 4 == anticipate_interpolator
+         * 5 == overshoot_interpolator
+         * 6 == anticipate_overshoot_interpolator
+         * 7 == bounce_interpolator
+         * @hide
+         */
+        public static final String LISTVIEW_INTERPOLATOR = "listview_interpolator";
+
+        /**
          * Settings to backup. This is here so that it's in the same place as the settings
          * keys and easy to update.
          *
diff --git a/core/java/android/widget/AbsListView.java b/core/java/android/widget/AbsListView.java
index 4f1a456a668..0fd62722be9 100644
--- a/core/java/android/widget/AbsListView.java
+++ b/core/java/android/widget/AbsListView.java
@@ -29,12 +29,15 @@ import android.graphics.drawable.Drawable;
 import android.graphics.drawable.TransitionDrawable;
 import android.os.Bundle;
 import android.os.Debug;
+import android.os.Message;
 import android.os.Handler;
 import android.os.Parcel;
 import android.os.Parcelable;
 import android.os.SystemProperties;
 import android.os.StrictMode;
 import android.os.Trace;
+import android.os.UserHandle;
+import android.provider.Settings;
 import android.text.Editable;
 import android.text.InputType;
 import android.text.TextUtils;
@@ -69,8 +72,14 @@ import android.view.accessibility.AccessibilityManager;
 import android.view.accessibility.AccessibilityNodeInfo;
 import android.view.accessibility.AccessibilityNodeInfo.AccessibilityAction;
 import android.view.accessibility.AccessibilityNodeInfo.CollectionInfo;
+import android.os.Looper;
+import android.view.animation.AlphaAnimation;
+import android.view.animation.Animation;
+import android.view.animation.AnimationUtils;
 import android.view.animation.Interpolator;
 import android.view.animation.LinearInterpolator;
+import android.view.animation.ScaleAnimation;
+import android.view.animation.TranslateAnimation;
 import android.view.inputmethod.BaseInputConnection;
 import android.view.inputmethod.CompletionInfo;
 import android.view.inputmethod.CorrectionInfo;
@@ -749,6 +758,17 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
     private boolean mIsDetaching;
 
     /**
+     * for ListView Animations
+     */
+    private boolean mIsWidget;
+    private int mListAnimationMode = 0;
+    private int mListAnimationInterpolatorMode = 0;
+    private boolean mListAnimationModeSet = false;
+    private int mWidth, mHeight = 0;
+    private int mPositionV;
+    private boolean mIsTap = false;
+
+    /**
      * Interface definition for a callback to be invoked when the list or grid
      * has been scrolled.
      */
@@ -910,6 +930,9 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         mOverflingDistance = configuration.getScaledOverflingDistance();
 
         mDensityScale = getContext().getResources().getDisplayMetrics().density;
+
+        setPersistentDrawingCache(ViewGroup.PERSISTENT_ANIMATION_CACHE
+            | ViewGroup.PERSISTENT_SCROLLING_CACHE);
     }
 
     @Override
@@ -2190,6 +2213,8 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         layoutChildren();
 
         mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR;
+        mHeight = getHeight();
+        mWidth = getWidth();
 
         // TODO: Move somewhere sane. This doesn't belong in onLayout().
         if (mFastScroll != null) {
@@ -2388,8 +2413,13 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         }
 
         final View scrapView = mRecycler.getScrapView(position);
-        final View child = mAdapter.getView(position, scrapView, this);
+        View child = mAdapter.getView(position, scrapView, this);
+
         if (scrapView != null) {
+            if (mListAnimationMode != 0 && !mIsWidget) {
+                child = setAnimation(child);
+            }
+
             if (child != scrapView) {
                 // Failed to re-bind the data, return scrap to the heap.
                 mRecycler.addScrapView(scrapView, position);
@@ -2446,6 +2476,118 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         }
     }
 
+    private View setAnimation(View view) {
+        if (view == null) {
+            return view;
+        }
+
+        int scrollY = 0;
+        boolean down = false;
+        Animation anim = null;
+
+        try {
+            scrollY = getChildAt(0).getTop();
+        } catch (NullPointerException e) {
+            scrollY = mPositionV;
+        }
+
+        if (mPositionV < scrollY) {
+            down = true;
+        }
+
+        mPositionV = scrollY;
+
+        switch (mListAnimationMode) {
+            case 1:
+                anim = new ScaleAnimation(0.5f, 1.0f, 0.5f, 1.0f);
+                break;
+            case 2:
+                anim = new ScaleAnimation(0.5f, 1.0f, 0.5f, 1.0f,
+                    Animation.RELATIVE_TO_SELF, 1.0f,
+                    Animation.RELATIVE_TO_SELF, 1.0f);
+                break;
+            case 3:
+                anim = new ScaleAnimation(0.5f, 1.0f, 0.5f, 1.0f,
+                    Animation.RELATIVE_TO_SELF, 0.5f,
+                    Animation.RELATIVE_TO_SELF, 0.5f);
+                break;
+            case 4:
+                anim = new AlphaAnimation(0.0f, 1.0f);
+                break;
+            case 5:
+                anim = new TranslateAnimation(0.0f, 0.0f, -mHeight, 0.0f);
+                break;
+            case 6:
+                anim = new TranslateAnimation(0.0f, 0.0f, mHeight, 0.0f);
+                break;
+            case 7:
+                if (down) {
+                    anim = new TranslateAnimation(0.0f, 0.0f, -mHeight, 0.0f);
+                } else {
+                    anim = new TranslateAnimation(0.0f, 0.0f, mHeight, 0.0f);
+                }
+                break;
+            case 8:
+                if (down) {
+                    anim = new TranslateAnimation(0.0f, 0.0f, mHeight, 0.0f);
+                } else {
+                    anim = new TranslateAnimation(0.0f, 0.0f, -mHeight, 0.0f);
+                }
+                break;
+            case 9:
+                anim = new TranslateAnimation(-mWidth, 0.0f, 0.0f, 0.0f);
+                break;
+            case 10:
+                anim = new TranslateAnimation(mWidth, 0.0f, 0.0f, 0.0f);
+                break;
+        }
+
+        if (mListAnimationInterpolatorMode == 0) {
+            return applyAnimationToView(view, anim);
+        }
+
+        switch (mListAnimationInterpolatorMode) {
+            case 1:
+                anim.setInterpolator(AnimationUtils.loadInterpolator(
+                    mContext, android.R.anim.accelerate_interpolator));
+                break;
+            case 2:
+                anim.setInterpolator(AnimationUtils.loadInterpolator(
+                    mContext, android.R.anim.decelerate_interpolator));
+                break;
+            case 3:
+                anim.setInterpolator(AnimationUtils.loadInterpolator(
+                    mContext, android.R.anim.accelerate_decelerate_interpolator));
+                break;
+            case 4:
+                anim.setInterpolator(AnimationUtils.loadInterpolator(
+                    mContext, android.R.anim.anticipate_interpolator));
+                break;
+            case 5:
+                anim.setInterpolator(AnimationUtils.loadInterpolator(
+                    mContext, android.R.anim.overshoot_interpolator));
+                break;
+            case 6:
+                anim.setInterpolator(AnimationUtils.loadInterpolator(
+                    mContext, android.R.anim.anticipate_overshoot_interpolator));
+                break;
+            case 7:
+                anim.setInterpolator(AnimationUtils.loadInterpolator(
+                    mContext, android.R.anim.bounce_interpolator));
+                break;
+        }
+        return applyAnimationToView(view, anim);
+    }
+
+    private View applyAnimationToView(View view, Animation anim) {
+        if (anim == null) {
+            return view;
+        }
+        anim.setDuration(500);
+        view.startAnimation(anim);
+        return view;
+    }
+
     class ListItemAccessibilityDelegate extends AccessibilityDelegate {
         @Override
         public void onInitializeAccessibilityNodeInfo(View host, AccessibilityNodeInfo info) {
@@ -3555,6 +3697,7 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         int lastYCorrection = 0;
 
         if (mTouchMode == TOUCH_MODE_SCROLL) {
+            mIsWidget = false;
             if (PROFILE_SCROLLING) {
                 if (!mScrollProfilingStarted) {
                     Debug.startMethodTracing("AbsListViewScroll");
@@ -3783,6 +3926,12 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         }
     }
 
+    private final Handler mInverse = new Handler(mContext.getMainLooper()) {
+        public void handleMessage(Message msg) {
+            mIsTap = !mIsTap;
+        }
+    };
+
     /** @hide */
     @Override
     protected boolean handleScrollBarDragging(MotionEvent event) {
@@ -3890,8 +4039,10 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
     }
 
     private void onTouchDown(MotionEvent ev) {
+        mIsTap = true;
         mHasPerformedLongPress = false;
         mActivePointerId = ev.getPointerId(0);
+        mInverse.sendEmptyMessageDelayed(0, 100);
         hideSelector();
 
         if (mTouchMode == TOUCH_MODE_OVERFLING) {
@@ -4576,8 +4727,24 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
      */
     void reportScrollStateChange(int newState) {
         if (newState != mLastScrollState) {
+            mLastScrollState = newState;
+            if (newState == OnScrollListener.SCROLL_STATE_IDLE) {
+                mListAnimationModeSet = false;
+                mListAnimationMode = 0;
+            } else if (!mListAnimationModeSet) {
+                mListAnimationModeSet = true;
+                mListAnimationMode = Settings.System.getIntForUser(
+                        mContext.getContentResolver(),
+                        Settings.System.LISTVIEW_ANIMATION,
+                        0, UserHandle.USER_CURRENT_OR_SELF);
+                if (mListAnimationMode != 0) {
+                    mListAnimationInterpolatorMode = Settings.System.getIntForUser(
+                            mContext.getContentResolver(),
+                            Settings.System.LISTVIEW_INTERPOLATOR,
+                            0, UserHandle.USER_CURRENT_OR_SELF);
+                }
+            }
             if (mOnScrollListener != null) {
-                mLastScrollState = newState;
                 mOnScrollListener.onScrollStateChanged(this, newState);
             }
         }
@@ -4733,8 +4900,9 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
             if (!mSuppressIdleStateChangeCall) {
                 reportScrollStateChange(OnScrollListener.SCROLL_STATE_IDLE);
             }
-            if (clearCache)
+            if (clearCache) {
                 clearScrollingCache();
+            }
             mScroller.abortAnimation();
 
             if (mFlingStrictSpan != null) {
@@ -5560,6 +5728,7 @@ public abstract class AbsListView extends AdapterView<ListAdapter> implements Te
         int count = mItemCount;
         int lastHandledItemCount = mLastHandledItemCount;
         mLastHandledItemCount = mItemCount;
+        mIsWidget = true;
 
         if (mChoiceMode != CHOICE_MODE_NONE && mAdapter != null && mAdapter.hasStableIds()) {
             confirmCheckedPositionsById();
-- 
2.11.0

