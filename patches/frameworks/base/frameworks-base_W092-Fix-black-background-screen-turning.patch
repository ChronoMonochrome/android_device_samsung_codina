From a0943bd277ed9b5ecaf1c7c1ace7590b1b6da37d Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 20 Aug 2018 22:57:43 +0300
Subject: [PATCH] Keyguard: Fix black background while screen turning off/on quickly

 1.the screen will be turning off an on quickly while we multi-press power
key fastly.
 2.the screen is to turned on ,but the mColorFadeOffAnimator is still animating
 3.that will not setScreenState to Display.STATE_OFF,and the next step that
screen turning on will not block screen to drawn window
 4.when the screen is on ,the keyguard interface is black background

Also reverts: DisplayPowerController: Disable color fade on low-ram devices.

diff --git a/services/core/java/com/android/server/display/DisplayPowerController.java b/services/core/java/com/android/server/display/DisplayPowerController.java
index 80bdf1ffade6..507867585137 100644
--- a/services/core/java/com/android/server/display/DisplayPowerController.java
+++ b/services/core/java/com/android/server/display/DisplayPowerController.java
@@ -16,7 +16,6 @@
 
 package com.android.server.display;
 
-import android.app.ActivityManager;
 import com.android.internal.app.IBatteryStats;
 import com.android.server.LocalServices;
 import com.android.server.am.BatteryStatsService;
@@ -166,9 +165,6 @@
     // True if should use light sensor to automatically determine doze screen brightness.
     private final boolean mAllowAutoBrightnessWhileDozingConfig;
 
-    // Whether or not the color fade on screen on / off is enabled.
-    private final boolean mColorFadeEnabled;
-
     // True if we should fade the screen while turning it off, false if we should play
     // a stylish color fade animation instead.
     private boolean mColorFadeFadesConfig;
@@ -428,8 +424,6 @@ public DisplayPowerController(Context context,
 
         mScreenBrightnessRangeMinimum = screenBrightnessRangeMinimum;
 
-
-        mColorFadeEnabled = !ActivityManager.isLowRamDeviceStatic();
         mColorFadeFadesConfig = resources.getBoolean(
                 com.android.internal.R.bool.config_animateScreenLights);
 
@@ -526,19 +520,17 @@ private void initialize() {
         // Initialize the power state object for the default display.
         // In the future, we might manage multiple displays independently.
         mPowerState = new DisplayPowerState(mBlanker,
-                mColorFadeEnabled ? new ColorFade(Display.DEFAULT_DISPLAY) : null);
+                new ColorFade(Display.DEFAULT_DISPLAY));
 
-        if (mColorFadeEnabled) {
-            mColorFadeOnAnimator = ObjectAnimator.ofFloat(
-                    mPowerState, DisplayPowerState.COLOR_FADE_LEVEL, 0.0f, 1.0f);
-            mColorFadeOnAnimator.setDuration(COLOR_FADE_ON_ANIMATION_DURATION_MILLIS);
-            mColorFadeOnAnimator.addListener(mAnimatorListener);
+        mColorFadeOnAnimator = ObjectAnimator.ofFloat(
+                mPowerState, DisplayPowerState.COLOR_FADE_LEVEL, 0.0f, 1.0f);
+        mColorFadeOnAnimator.setDuration(COLOR_FADE_ON_ANIMATION_DURATION_MILLIS);
+        mColorFadeOnAnimator.addListener(mAnimatorListener);
 
-            mColorFadeOffAnimator = ObjectAnimator.ofFloat(
-                    mPowerState, DisplayPowerState.COLOR_FADE_LEVEL, 1.0f, 0.0f);
-            mColorFadeOffAnimator.setDuration(COLOR_FADE_OFF_ANIMATION_DURATION_MILLIS);
-            mColorFadeOffAnimator.addListener(mAnimatorListener);
-        }
+        mColorFadeOffAnimator = ObjectAnimator.ofFloat(
+                mPowerState, DisplayPowerState.COLOR_FADE_LEVEL, 1.0f, 0.0f);
+        mColorFadeOffAnimator.setDuration(COLOR_FADE_OFF_ANIMATION_DURATION_MILLIS);
+        mColorFadeOffAnimator.addListener(mAnimatorListener);
 
         mScreenBrightnessRampAnimator = new RampAnimator<DisplayPowerState>(
                 mPowerState, DisplayPowerState.SCREEN_BRIGHTNESS);
@@ -821,9 +813,9 @@ private void updatePowerState() {
         // Note that we do not wait for the brightness ramp animation to complete before
         // reporting the display is ready because we only need to ensure the screen is in the
         // right power state even as it continues to converge on the desired brightness.
-        final boolean ready = mPendingScreenOnUnblocker == null &&
-                (!mColorFadeEnabled ||
-                        (!mColorFadeOnAnimator.isStarted() && !mColorFadeOffAnimator.isStarted()))
+        final boolean ready = mPendingScreenOnUnblocker == null
+                && !mColorFadeOnAnimator.isStarted()
+                && !mColorFadeOffAnimator.isStarted()
                 && mPowerState.waitUntilClean(mCleanListener);
         final boolean finished = ready
                 && !mScreenBrightnessRampAnimator.isAnimating();
@@ -1006,13 +998,16 @@ private void animateScreenBrightness(int target, int rate) {
 
     private void animateScreenStateChange(int target, boolean performScreenOffTransition) {
         // If there is already an animation in progress, don't interfere with it.
-        if (mColorFadeEnabled &&
-                (mColorFadeOnAnimator.isStarted() || mColorFadeOffAnimator.isStarted())) {
+        if (mColorFadeOnAnimator.isStarted()) {
+            if (target == Display.STATE_ON) {
+                // If display state changed to on, proceed and stop the color fade and turn screen on.
+                mPendingScreenOff = false;
+                return;
+            }
+        }else if (mColorFadeOffAnimator.isStarted()){
             if (target != Display.STATE_ON) {
                 return;
             }
-            // If display state changed to on, proceed and stop the color fade and turn screen on.
-            mPendingScreenOff = false;
         }
 
         if (mDisplayBlanksAfterDozeConfig
@@ -1049,7 +1044,7 @@ private void animateScreenStateChange(int target, boolean performScreenOffTransi
             if (!setScreenState(Display.STATE_ON)) {
                 return; // screen on blocked
             }
-            if (USE_COLOR_FADE_ON_ANIMATION && mColorFadeEnabled && mPowerRequest.isBrightOrDim()) {
+            if (USE_COLOR_FADE_ON_ANIMATION && mPowerRequest.isBrightOrDim()) {
                 // Perform screen on animation.
                 if (mPowerState.getColorFadeLevel() == 1.0f) {
                     mPowerState.dismissColorFade();
@@ -1125,10 +1120,6 @@ private void animateScreenStateChange(int target, boolean performScreenOffTransi
         } else {
             // Want screen off.
             mPendingScreenOff = true;
-            if (!mColorFadeEnabled) {
-                mPowerState.setColorFadeLevel(0.0f);
-            }
-
             if (mPowerState.getColorFadeLevel() == 0.0f) {
                 // Turn the screen off.
                 // A black surface is already hiding the contents of the screen.
diff --git a/services/core/java/com/android/server/display/DisplayPowerState.java b/services/core/java/com/android/server/display/DisplayPowerState.java
index 763f56ff918f..efa4a1d4f501 100644
--- a/services/core/java/com/android/server/display/DisplayPowerState.java
+++ b/services/core/java/com/android/server/display/DisplayPowerState.java
@@ -176,7 +176,7 @@ public int getScreenBrightness() {
      * @return True if the electron beam was prepared.
      */
     public boolean prepareColorFade(Context context, int mode) {
-        if (mColorFade == null || !mColorFade.prepare(context, mode)) {
+        if (!mColorFade.prepare(context, mode)) {
             mColorFadePrepared = false;
             mColorFadeReady = true;
             return false;
@@ -193,7 +193,7 @@ public boolean prepareColorFade(Context context, int mode) {
      */
     public void dismissColorFade() {
         Trace.traceCounter(Trace.TRACE_TAG_POWER, COUNTER_COLOR_FADE, 100);
-        if (mColorFade != null) mColorFade.dismiss();
+        mColorFade.dismiss();
         mColorFadePrepared = false;
         mColorFadeReady = true;
     }
@@ -202,7 +202,7 @@ public void dismissColorFade() {
      * Dismisses the color fade resources.
      */
     public void dismissColorFadeResources() {
-        if (mColorFade != null) mColorFade.dismissResources();
+        mColorFade.dismissResources();
     }
 
     /**
@@ -272,7 +272,7 @@ public void dump(PrintWriter pw) {
         pw.println("  mColorFadeDrawPending=" + mColorFadeDrawPending);
 
         mPhotonicModulator.dump(pw);
-        if (mColorFade != null) mColorFade.dump(pw);
+        mColorFade.dump(pw);
     }
 
     private void scheduleScreenUpdate() {
