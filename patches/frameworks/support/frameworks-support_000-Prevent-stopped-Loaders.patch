From a0943bd277ed9b5ecaf1c7c1ace7590b1b6da37d Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 20 Aug 2018 22:57:43 +0300
FSubject: [PATCH] Prevent stopped Loaders from starting during configuration change

Allow the LoaderManager to be retained when already stopped.

diff --git a/fragment/java/android/support/v4/app/FragmentActivity.java b/fragment/java/android/support/v4/app/FragmentActivity.java
index e513ff7bf..4fbb747f1 100644
--- a/fragment/java/android/support/v4/app/FragmentActivity.java
+++ b/fragment/java/android/support/v4/app/FragmentActivity.java
@@ -662,10 +662,7 @@ void doReallyStop(boolean retaining) {
         } else if (retaining) {
             // We're already really stopped, but we've been asked to retain.
             // Our fragments are taken care of but we need to mark the loaders for retention.
-            // In order to do this correctly we need to restart the loaders first before
-            // handing them off to the next activity.
-            mFragments.doLoaderStart();
-            mFragments.doLoaderStop(true);
+            mFragments.doLoaderRetain();
         }
     }
 
diff --git a/fragment/java/android/support/v4/app/FragmentHostCallback.java b/fragment/java/android/support/v4/app/FragmentHostCallback.java
index 7dc9f5954..5bd4c3d5d 100644
--- a/fragment/java/android/support/v4/app/FragmentHostCallback.java
+++ b/fragment/java/android/support/v4/app/FragmentHostCallback.java
@@ -272,6 +272,8 @@ void doLoaderStop(boolean retain) {
     }
 
     void doLoaderRetain() {
+        mRetainLoaders = true;
+
         if (mLoaderManager == null) {
             return;
         }
@@ -317,8 +319,7 @@ LoaderManagerImpl getLoaderManager(String who, boolean started, boolean create)
     SimpleArrayMap<String, LoaderManager> retainLoaderNonConfig() {
         boolean retainLoaders = false;
         if (mAllLoaderManagers != null) {
-            // Restart any loader managers that were already stopped so that they
-            // will be ready to retain
+            // Retain any loader manager, including those that were already stopped
             final int N = mAllLoaderManagers.size();
             LoaderManagerImpl loaders[] = new LoaderManagerImpl[N];
             for (int i=N-1; i>=0; i--) {
@@ -328,9 +329,6 @@ LoaderManagerImpl getLoaderManager(String who, boolean started, boolean create)
             for (int i=0; i<N; i++) {
                 LoaderManagerImpl lm = loaders[i];
                 if (!lm.mRetaining && doRetainLoaders) {
-                    if (!lm.mStarted) {
-                        lm.doStart();
-                    }
                     lm.doRetain();
                 }
                 if (lm.mRetaining) {
diff --git a/fragment/java/android/support/v4/app/LoaderManager.java b/fragment/java/android/support/v4/app/LoaderManager.java
index 521b21842..4bc8f8c31 100644
--- a/fragment/java/android/support/v4/app/LoaderManager.java
+++ b/fragment/java/android/support/v4/app/LoaderManager.java
@@ -788,12 +788,6 @@ void doStop() {
 
     void doRetain() {
         if (DEBUG) Log.v(TAG, "Retaining in " + this);
-        if (!mStarted) {
-            RuntimeException e = new RuntimeException("here");
-            e.fillInStackTrace();
-            Log.w(TAG, "Called doRetain when not started: " + this, e);
-            return;
-        }
 
         mRetaining = true;
         mStarted = false;
