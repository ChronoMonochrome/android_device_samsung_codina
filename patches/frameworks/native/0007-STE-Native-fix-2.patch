From d8f7b51d2e09108bca6a387479e8b0c94b9a3d41 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 20 Aug 2018 22:57:43 +0300
Subject: [PATCH 07/43] STE Native fix [2]

---
 libs/binder/include/binder/SafeInterface.h    | 8 ++++----
 libs/gui/BufferItemConsumer.cpp               | 2 ++
 libs/gui/include/gui/FrameTimestamps.h        | 9 +++++++++
 libs/gui/include/gui/GLConsumer.h             | 1 +
 libs/gui/include/gui/IGraphicBufferProducer.h | 4 ++++
 libs/ui/include/ui/FenceTime.h                | 4 ++++
 services/surfaceflinger/DisplayDevice.cpp     | 2 ++
 7 files changed, 26 insertions(+), 4 deletions(-)

diff --git a/libs/binder/include/binder/SafeInterface.h b/libs/binder/include/binder/SafeInterface.h
index 3bfd46280..38ba7e1a0 100644
--- a/libs/binder/include/binder/SafeInterface.h
+++ b/libs/binder/include/binder/SafeInterface.h
@@ -60,23 +60,23 @@ public:
         return write(parcel, static_cast<typename std::underlying_type<E>::type>(e));
     }
     template <typename T>
-    typename std::enable_if<std::is_base_of<Flattenable<T>, T>::value, status_t>::type read(
+    typename std::enable_if<std::is_base_of<Flattenable, T>::value, status_t>::type read(
             const Parcel& parcel, T* t) const {
         return callParcel("read(Flattenable)", [&]() { return parcel.read(*t); });
     }
     template <typename T>
-    typename std::enable_if<std::is_base_of<Flattenable<T>, T>::value, status_t>::type write(
+    typename std::enable_if<std::is_base_of<Flattenable, T>::value, status_t>::type write(
             Parcel* parcel, const T& t) const {
         return callParcel("write(Flattenable)", [&]() { return parcel->write(t); });
     }
     template <typename T>
-    typename std::enable_if<std::is_base_of<Flattenable<T>, T>::value, status_t>::type read(
+    typename std::enable_if<std::is_base_of<Flattenable, T>::value, status_t>::type read(
             const Parcel& parcel, sp<T>* t) const {
         *t = new T{};
         return callParcel("read(sp<Flattenable>)", [&]() { return parcel.read(*(t->get())); });
     }
     template <typename T>
-    typename std::enable_if<std::is_base_of<Flattenable<T>, T>::value, status_t>::type write(
+    typename std::enable_if<std::is_base_of<Flattenable, T>::value, status_t>::type write(
             Parcel* parcel, const sp<T>& t) const {
         return callParcel("write(sp<Flattenable>)", [&]() { return parcel->write(*(t.get())); });
     }
diff --git a/libs/gui/BufferItemConsumer.cpp b/libs/gui/BufferItemConsumer.cpp
index da4295609..de4ed64a7 100644
--- a/libs/gui/BufferItemConsumer.cpp
+++ b/libs/gui/BufferItemConsumer.cpp
@@ -117,7 +117,9 @@ void BufferItemConsumer::freeBufferLocked(int slotIndex) {
     if (listener != NULL && mSlots[slotIndex].mGraphicBuffer != NULL) {
         // Fire callback if we have a listener registered and the buffer being freed is valid.
         BI_LOGV("actually calling onBufferFreed");
+#ifndef STE_HARDWARE
         listener->onBufferFreed(mSlots[slotIndex].mGraphicBuffer);
+#endif
     }
     ConsumerBase::freeBufferLocked(slotIndex);
 }
diff --git a/libs/gui/include/gui/FrameTimestamps.h b/libs/gui/include/gui/FrameTimestamps.h
index 9716be4bf..a1c7ee35e 100644
--- a/libs/gui/include/gui/FrameTimestamps.h
+++ b/libs/gui/include/gui/FrameTimestamps.h
@@ -242,7 +242,11 @@ private:
 // through Binder.
 // Although this may be sent multiple times for the same frame as new
 // timestamps are set, Fences only need to be sent once.
+#ifdef STE_HARDWARE
+class FrameEventsDelta : public Flattenable {
+#else
 class FrameEventsDelta : public Flattenable<FrameEventsDelta> {
+#endif
 friend class ProducerFrameEventHistory;
 public:
     FrameEventsDelta() = default;
@@ -300,8 +304,13 @@ private:
 
 // A collection of updates from consumer to producer that can be sent
 // through Binder.
+#ifdef STE_HARDWARE
+class FrameEventHistoryDelta
+        : public Flattenable {
+#else
 class FrameEventHistoryDelta
         : public Flattenable<FrameEventHistoryDelta> {
+#endif
 
 friend class ConsumerFrameEventHistory;
 friend class ProducerFrameEventHistory;
diff --git a/libs/gui/include/gui/GLConsumer.h b/libs/gui/include/gui/GLConsumer.h
index 7f111fe7b..6ddb979a0 100644
--- a/libs/gui/include/gui/GLConsumer.h
+++ b/libs/gui/include/gui/GLConsumer.h
@@ -20,6 +20,7 @@
 #include <EGL/egl.h>
 #include <EGL/eglext.h>
 
+#include <gui/BufferQueue.h>
 #include <gui/BufferQueueDefs.h>
 #include <gui/ConsumerBase.h>
 
diff --git a/libs/gui/include/gui/IGraphicBufferProducer.h b/libs/gui/include/gui/IGraphicBufferProducer.h
index f679ac429..f25e522ff 100644
--- a/libs/gui/include/gui/IGraphicBufferProducer.h
+++ b/libs/gui/include/gui/IGraphicBufferProducer.h
@@ -371,7 +371,11 @@ public:
         bool getFrameTimestamps{false};
     };
 
+#ifdef STE_HARDWARE
+    struct QueueBufferOutput : public Flattenable {
+#else
     struct QueueBufferOutput : public Flattenable<QueueBufferOutput> {
+#endif
         QueueBufferOutput() = default;
 
         // Moveable.
diff --git a/libs/ui/include/ui/FenceTime.h b/libs/ui/include/ui/FenceTime.h
index 871fcf2df..83e13cc26 100644
--- a/libs/ui/include/ui/FenceTime.h
+++ b/libs/ui/include/ui/FenceTime.h
@@ -42,7 +42,11 @@ public:
     // consistent for all steps of the flattening process.
     //
     // Not thread safe.
+#ifdef STE_HARDWARE
+    struct Snapshot : public Flattenable {
+#else
     struct Snapshot : public Flattenable<Snapshot> {
+#endif
         enum class State {
             EMPTY,
             FENCE,
diff --git a/services/surfaceflinger/DisplayDevice.cpp b/services/surfaceflinger/DisplayDevice.cpp
index c4703dfaa..c47df9102 100755
--- a/services/surfaceflinger/DisplayDevice.cpp
+++ b/services/surfaceflinger/DisplayDevice.cpp
@@ -197,9 +197,11 @@ DisplayDevice::DisplayDevice(
     // initialize the display orientation transform.
     setProjection(DisplayState::eOrientationDefault, mViewport, mFrame);
 
+#ifndef STE_HARDWARE
     if (useTripleFramebuffer) {
         surface->allocateBuffers();
     }
+#endif
 }
 
 DisplayDevice::~DisplayDevice() {
-- 
2.11.0

