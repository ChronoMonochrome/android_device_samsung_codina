From a0943bd277ed9b5ecaf1c7c1ace7590b1b6da37d Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 20 Aug 2018 22:57:43 +0300
Subject: [PATCH] Fix Sensors
diff --git a/libs/sensor/ISensorEventConnection.cpp b/libs/sensor/ISensorEventConnection.cpp
index 8a3a62398..b1867b1c4 100644
--- a/libs/sensor/ISensorEventConnection.cpp
+++ b/libs/sensor/ISensorEventConnection.cpp
@@ -35,8 +35,7 @@ enum {
     GET_SENSOR_CHANNEL = IBinder::FIRST_CALL_TRANSACTION,
     ENABLE_DISABLE,
     SET_EVENT_RATE,
-    FLUSH_SENSOR,
-    CONFIGURE_CHANNEL
+    FLUSH_SENSOR
 };
 
 class BpSensorEventConnection : public BpInterface<ISensorEventConnection>
@@ -87,15 +86,6 @@ class BpSensorEventConnection : public BpInterface<ISensorEventConnection>
         remote()->transact(FLUSH_SENSOR, data, &reply);
         return reply.readInt32();
     }
-
-    virtual int32_t configureChannel(int32_t handle, int32_t rateLevel) {
-        Parcel data, reply;
-        data.writeInterfaceToken(ISensorEventConnection::getInterfaceDescriptor());
-        data.writeInt32(handle);
-        data.writeInt32(rateLevel);
-        remote()->transact(CONFIGURE_CHANNEL, data, &reply);
-        return reply.readInt32();
-    }
 };
 
 // Out-of-line virtual method definition to trigger vtable emission in this
@@ -142,15 +132,6 @@ status_t BnSensorEventConnection::onTransact(
             reply->writeInt32(result);
             return NO_ERROR;
         }
-        case CONFIGURE_CHANNEL: {
-            CHECK_INTERFACE(ISensorEventConnection, data, reply);
-            int handle = data.readInt32();
-            int rateLevel = data.readInt32();
-            status_t result = configureChannel(handle, rateLevel);
-            reply->writeInt32(result);
-            return NO_ERROR;
-        }
-
     }
     return BBinder::onTransact(code, data, reply, flags);
 }
diff --git a/libs/sensor/ISensorServer.cpp b/libs/sensor/ISensorServer.cpp
index f41f18713..e14bfafeb 100644
--- a/libs/sensor/ISensorServer.cpp
+++ b/libs/sensor/ISensorServer.cpp
@@ -19,7 +19,6 @@
 #include <stdint.h>
 #include <sys/types.h>
 
-#include <cutils/native_handle.h>
 #include <utils/Errors.h>
 #include <utils/RefBase.h>
 #include <utils/Vector.h>
@@ -39,7 +38,6 @@ enum {
     CREATE_SENSOR_EVENT_CONNECTION,
     ENABLE_DATA_INJECTION,
     GET_DYNAMIC_SENSOR_LIST,
-    CREATE_SENSOR_DIRECT_CONNECTION,
 };
 
 class BpSensorServer : public BpInterface<ISensorServer>
@@ -104,19 +102,6 @@ class BpSensorServer : public BpInterface<ISensorServer>
         remote()->transact(ENABLE_DATA_INJECTION, data, &reply);
         return reply.readInt32();
     }
-
-    virtual sp<ISensorEventConnection> createSensorDirectConnection(const String16& opPackageName,
-            uint32_t size, int32_t type, int32_t format, const native_handle_t *resource) {
-        Parcel data, reply;
-        data.writeInterfaceToken(ISensorServer::getInterfaceDescriptor());
-        data.writeString16(opPackageName);
-        data.writeUint32(size);
-        data.writeInt32(type);
-        data.writeInt32(format);
-        data.writeNativeHandle(resource);
-        remote()->transact(CREATE_SENSOR_DIRECT_CONNECTION, data, &reply);
-        return interface_cast<ISensorEventConnection>(reply.readStrongBinder());
-    }
 };
 
 // Out-of-line virtual method definition to trigger vtable emission in this
@@ -169,20 +154,6 @@ status_t BnSensorServer::onTransact(
             }
             return NO_ERROR;
         }
-        case CREATE_SENSOR_DIRECT_CONNECTION: {
-            CHECK_INTERFACE(ISensorServer, data, reply);
-            const String16& opPackageName = data.readString16();
-            uint32_t size = data.readUint32();
-            int32_t type = data.readInt32();
-            int32_t format = data.readInt32();
-            native_handle_t *resource = data.readNativeHandle();
-            sp<ISensorEventConnection> ch =
-                    createSensorDirectConnection(opPackageName, size, type, format, resource);
-            native_handle_close(resource);
-            native_handle_delete(resource);
-            reply->writeStrongBinder(IInterface::asBinder(ch));
-            return NO_ERROR;
-        }
     }
     return BBinder::onTransact(code, data, reply, flags);
 }
diff --git a/libs/sensor/Sensor.cpp b/libs/sensor/Sensor.cpp
index c2d477e4b..8db48d972 100644
--- a/libs/sensor/Sensor.cpp
+++ b/libs/sensor/Sensor.cpp
@@ -298,15 +298,7 @@ Sensor::Sensor(struct sensor_t const& hwSensor, const uuid_t& uuid, int halVersi
     // Feature flags
     // Set DYNAMIC_SENSOR_MASK and ADDITIONAL_INFO_MASK flag here. Compatible with HAL 1_3.
     if (halVersion >= SENSORS_DEVICE_API_VERSION_1_3) {
-        mFlags |= hwSensor.flags & (DYNAMIC_SENSOR_MASK | ADDITIONAL_INFO_MASK);
-    }
-    // Set DIRECT_REPORT_MASK and DIRECT_CHANNEL_MASK flags. Compatible with HAL 1_3.
-    if (halVersion >= SENSORS_DEVICE_API_VERSION_1_3) {
-        // only on continuous sensors direct report mode is defined
-        if ((mFlags & REPORTING_MODE_MASK) == SENSOR_FLAG_CONTINUOUS_MODE) {
-            mFlags |= hwSensor.flags
-                & (SENSOR_FLAG_MASK_DIRECT_REPORT | SENSOR_FLAG_MASK_DIRECT_CHANNEL);
-        }
+        mFlags |= (hwSensor.flags & (DYNAMIC_SENSOR_MASK | ADDITIONAL_INFO_MASK));
     }
     // Set DATA_INJECTION flag here. Defined in HAL 1_4.
     if (halVersion >= SENSORS_DEVICE_API_VERSION_1_4) {
@@ -416,21 +408,6 @@ bool Sensor::hasAdditionalInfo() const {
     return (mFlags & SENSOR_FLAG_ADDITIONAL_INFO) != 0;
 }
 
-int32_t Sensor::getHighestDirectReportRateLevel() const {
-    return ((mFlags & SENSOR_FLAG_MASK_DIRECT_REPORT) >> SENSOR_FLAG_SHIFT_DIRECT_REPORT);
-}
-
-bool Sensor::isDirectChannelTypeSupported(int32_t sharedMemType) const {
-    switch (sharedMemType) {
-        case SENSOR_DIRECT_MEM_TYPE_ASHMEM:
-            return mFlags & SENSOR_FLAG_DIRECT_CHANNEL_ASHMEM;
-        case SENSOR_DIRECT_MEM_TYPE_GRALLOC:
-            return mFlags & SENSOR_FLAG_DIRECT_CHANNEL_GRALLOC;
-        default:
-            return false;
-    }
-}
-
 int32_t Sensor::getReportingMode() const {
     return ((mFlags & REPORTING_MODE_MASK) >> REPORTING_MODE_SHIFT);
 }
diff --git a/libs/sensor/SensorManager.cpp b/libs/sensor/SensorManager.cpp
index 8181fcade..301a1053f 100644
--- a/libs/sensor/SensorManager.cpp
+++ b/libs/sensor/SensorManager.cpp
@@ -21,7 +21,6 @@
 #include <stdint.h>
 #include <sys/types.h>
 
-#include <cutils/native_handle.h>
 #include <utils/Errors.h>
 #include <utils/RefBase.h>
 #include <utils/Singleton.h>
@@ -96,7 +95,7 @@ SensorManager& SensorManager::getInstanceForPackage(const String16& packageName)
 }
 
 SensorManager::SensorManager(const String16& opPackageName)
-    : mSensorList(0), mOpPackageName(opPackageName), mDirectConnectionHandle(1) {
+    : mSensorList(0), mOpPackageName(opPackageName) {
     // okay we're not locked here, but it's not needed during construction
     assertStateLocked();
 }
@@ -280,59 +279,5 @@ bool SensorManager::isDataInjectionEnabled() {
     return false;
 }
 
-int SensorManager::createDirectChannel(
-        size_t size, int channelType, const native_handle_t *resourceHandle) {
-    Mutex::Autolock _l(mLock);
-    if (assertStateLocked() != NO_ERROR) {
-        return NO_INIT;
-    }
-
-    if (channelType != SENSOR_DIRECT_MEM_TYPE_ASHMEM
-            && channelType != SENSOR_DIRECT_MEM_TYPE_GRALLOC) {
-        ALOGE("Bad channel shared memory type %d", channelType);
-        return BAD_VALUE;
-    }
-
-    sp<ISensorEventConnection> conn =
-              mSensorServer->createSensorDirectConnection(mOpPackageName,
-                  static_cast<uint32_t>(size),
-                  static_cast<int32_t>(channelType),
-                  SENSOR_DIRECT_FMT_SENSORS_EVENT, resourceHandle);
-    if (conn == nullptr) {
-        return NO_MEMORY;
-    }
-
-    int nativeHandle = mDirectConnectionHandle++;
-    mDirectConnection.emplace(nativeHandle, conn);
-    return nativeHandle;
-}
-
-void SensorManager::destroyDirectChannel(int channelNativeHandle) {
-    Mutex::Autolock _l(mLock);
-    if (assertStateLocked() == NO_ERROR) {
-        mDirectConnection.erase(channelNativeHandle);
-    }
-}
-
-int SensorManager::configureDirectChannel(int channelNativeHandle, int sensorHandle, int rateLevel) {
-    Mutex::Autolock _l(mLock);
-    if (assertStateLocked() != NO_ERROR) {
-        return NO_INIT;
-    }
-
-    auto i = mDirectConnection.find(channelNativeHandle);
-    if (i == mDirectConnection.end()) {
-        ALOGE("Cannot find the handle in client direct connection table");
-        return BAD_VALUE;
-    }
-
-    int ret;
-    ret = i->second->configureChannel(sensorHandle, rateLevel);
-    ALOGE_IF(ret < 0, "SensorManager::configureChannel (%d, %d) returns %d",
-            static_cast<int>(sensorHandle), static_cast<int>(rateLevel),
-            static_cast<int>(ret));
-    return ret;
-}
-
 // ----------------------------------------------------------------------------
 }; // namespace android
diff --git a/libs/sensor/include/sensor/ISensorEventConnection.h b/libs/sensor/include/sensor/ISensorEventConnection.h
index 07cc7e84a..774518924 100644
--- a/libs/sensor/include/sensor/ISensorEventConnection.h
+++ b/libs/sensor/include/sensor/ISensorEventConnection.h
@@ -41,7 +41,6 @@ class ISensorEventConnection : public IInterface
                                    nsecs_t maxBatchReportLatencyNs, int reservedFlags) = 0;
     virtual status_t setEventRate(int handle, nsecs_t ns) = 0;
     virtual status_t flush() = 0;
-    virtual int32_t configureChannel(int32_t handle, int32_t rateLevel) = 0;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/libs/sensor/include/sensor/ISensorServer.h b/libs/sensor/include/sensor/ISensorServer.h
index f922307e3..03a9d7bc2 100644
--- a/libs/sensor/include/sensor/ISensorServer.h
+++ b/libs/sensor/include/sensor/ISensorServer.h
@@ -25,8 +25,6 @@
 
 #include <binder/IInterface.h>
 
-struct native_handle;
-typedef struct native_handle native_handle_t;
 namespace android {
 // ----------------------------------------------------------------------------
 
@@ -47,9 +45,6 @@ class ISensorServer : public IInterface
     virtual sp<ISensorEventConnection> createSensorEventConnection(const String8& packageName,
              int mode, const String16& opPackageName) = 0;
     virtual int32_t isDataInjectionEnabled() = 0;
-
-    virtual sp<ISensorEventConnection> createSensorDirectConnection(const String16& opPackageName,
-            uint32_t size, int32_t type, int32_t format, const native_handle_t *resource) = 0;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/libs/sensor/include/sensor/Sensor.h b/libs/sensor/include/sensor/Sensor.h
index 043e6352a..dad18ed2a 100644
--- a/libs/sensor/include/sensor/Sensor.h
+++ b/libs/sensor/include/sensor/Sensor.h
@@ -91,8 +91,6 @@ class Sensor : public ASensor, public LightFlattenable<Sensor>
     bool isWakeUpSensor() const;
     bool isDynamicSensor() const;
     bool hasAdditionalInfo() const;
-    int32_t getHighestDirectReportRateLevel() const;
-    bool isDirectChannelTypeSupported(int32_t sharedMemType) const;
     int32_t getReportingMode() const;
 
     // Note that after setId() has been called, getUuid() no longer
diff --git a/libs/sensor/include/sensor/SensorManager.h b/libs/sensor/include/sensor/SensorManager.h
index 4accc57fe..1dff1c4f9 100644
--- a/libs/sensor/include/sensor/SensorManager.h
+++ b/libs/sensor/include/sensor/SensorManager.h
@@ -82,9 +82,6 @@ class SensorManager : public ASensorManager
     sp<SensorEventQueue> createEventQueue(String8 packageName = String8(""), int mode = 0);
 #endif
     bool isDataInjectionEnabled();
-    int createDirectChannel(size_t size, int channelType, const native_handle_t *channelData);
-    void destroyDirectChannel(int channelNativeHandle);
-    int configureDirectChannel(int channelNativeHandle, int sensorHandle, int rateLevel);
 
 private:
     // DeathRecipient interface
@@ -116,8 +113,6 @@ class SensorManager : public ASensorManager
     sp<IBinder::DeathRecipient> mDeathObserver;
 #endif
     const String16 mOpPackageName;
-    std::unordered_map<int, sp<ISensorEventConnection>> mDirectConnection;
-    int32_t mDirectConnectionHandle;
 };
 
 // ----------------------------------------------------------------------------
