From a0943bd277ed9b5ecaf1c7c1ace7590b1b6da37d Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 20 Aug 2018 22:57:43 +0300
Subject: [PATCH] Sensor: revert to 7.1.2

diff --git a/services/sensorservice/SensorService.cpp b/services/sensorservice/SensorService.cpp
index e5b6dcf..a1f07b2 100644
--- a/services/sensorservice/SensorService.cpp
+++ b/services/sensorservice/SensorService.cpp
@@ -191,10 +191,9 @@
                 // available in the HAL
                 bool needRotationVector =
                         (virtualSensorsNeeds & (1<<SENSOR_TYPE_ROTATION_VECTOR)) != 0;
-                bool needOrientation = orientationIndex == -1;
 
                 registerSensor(new RotationVectorSensor(), !needRotationVector, true);
-                registerSensor(new OrientationSensor(), !needOrientation, true);
+                registerSensor(new OrientationSensor(), !needRotationVector, true);
 
                 bool needLinearAcceleration =
                         (virtualSensorsNeeds & (1<<SENSOR_TYPE_LINEAR_ACCELERATION)) != 0;
diff --git a/services/sensorservice/SensorService.cpp b/services/sensorservice/SensorService.cpp
index 7d9b0b730..ac0374232 100644
--- a/services/sensorservice/SensorService.cpp
+++ b/services/sensorservice/SensorService.cpp
@@ -21,7 +21,6 @@
 #include <cutils/properties.h>
 #include <hardware/sensors.h>
 #include <hardware_legacy/power.h>
-#include <log/log.h>
 #include <openssl/digest.h>
 #include <openssl/hmac.h>
 #include <openssl/rand.h>
@@ -996,15 +995,10 @@ sp<ISensorEventConnection> SensorService::createSensorDirectConnection(
     // check specific to memory type
     switch(type) {
         case SENSOR_DIRECT_MEM_TYPE_ASHMEM: { // channel backed by ashmem
-            if (resource->numFds < 1) {
-                ALOGE("Ashmem direct channel requires a memory region to be supplied");
-                android_errorWriteLog(0x534e4554, "70986337");  // SafetyNet
-                return nullptr;
-            }
             int fd = resource->data[0];
             int size2 = ashmem_get_size_region(fd);
             // check size consistency
-            if (size2 < static_cast<int64_t>(size)) {
+            if (size2 < static_cast<int>(size)) {
                 ALOGE("Ashmem direct channel size %" PRIu32 " greater than shared memory size %d",
                       size, size2);
                 return nullptr;
diff --git a/services/sensorservice/RecentEventLogger.h b/services/sensorservice/RecentEventLogger.h
index bf1f65570..8b15e5a00 100644
--- a/services/sensorservice/RecentEventLogger.h
+++ b/services/sensorservice/RecentEventLogger.h
@@ -35,7 +35,7 @@ namespace SensorServiceUtil {
 // behavior.
 class RecentEventLogger : public Dumpable {
 public:
-    explicit RecentEventLogger(int sensorType);
+    RecentEventLogger(int sensorType);
     void addEvent(const sensors_event_t& event);
     bool populateLastEvent(sensors_event_t *event) const;
     bool isEmpty() const;
@@ -47,7 +47,7 @@ class RecentEventLogger : public Dumpable {
 
 protected:
     struct SensorEventLog {
-        explicit SensorEventLog(const sensors_event_t& e);
+        SensorEventLog(const sensors_event_t& e);
         timespec mWallTime;
         sensors_event_t mEvent;
     };
diff --git a/services/sensorservice/RingBuffer.h b/services/sensorservice/RingBuffer.h
index a60eb9005..ec98a0141 100644
--- a/services/sensorservice/RingBuffer.h
+++ b/services/sensorservice/RingBuffer.h
@@ -39,7 +39,7 @@ class RingBuffer final {
     /**
      * Construct a RingBuffer that can grow up to the given length.
      */
-    explicit RingBuffer(size_t length);
+    RingBuffer(size_t length);
 
     /**
      * Forward iterator to this class.  Implements an std:forward_iterator.
diff --git a/services/sensorservice/RotationVectorSensor.h b/services/sensorservice/RotationVectorSensor.h
index 34deaa9ba..3cc224888 100644
--- a/services/sensorservice/RotationVectorSensor.h
+++ b/services/sensorservice/RotationVectorSensor.h
@@ -34,7 +34,7 @@ namespace android {
 
 class RotationVectorSensor : public VirtualSensor {
 public:
-    explicit RotationVectorSensor(int mode = FUSION_9AXIS);
+    RotationVectorSensor(int mode = FUSION_9AXIS);
     virtual bool process(sensors_event_t* outEvent, const sensors_event_t& event) override;
     virtual status_t activate(void* ident, bool enabled) override;
     virtual status_t setDelay(void* ident, int handle, int64_t ns) override;
diff --git a/services/sensorservice/SensorDevice.cpp b/services/sensorservice/SensorDevice.cpp
index 7d9b0b730..ac0374232 100644
--- a/services/sensorservice/SensorDevice.cpp
+++ b/services/sensorservice/SensorDevice.cpp
@@ -13,213 +13,133 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-#include "SensorDevice.h"
-#include "SensorService.h"
 
-#include <android-base/logging.h>
-#include <sensors/convert.h>
+#include <inttypes.h>
+#include <math.h>
+#include <stdint.h>
+#include <sys/types.h>
+
 #include <utils/Atomic.h>
 #include <utils/Errors.h>
 #include <utils/Singleton.h>
 
-#include <chrono>
-#include <cinttypes>
-#include <thread>
-
-using android::hardware::hidl_vec;
+#include <binder/BinderService.h>
+#include <binder/Parcel.h>
+#include <binder/IServiceManager.h>
 
-using namespace android::hardware::sensors::V1_0;
-using namespace android::hardware::sensors::V1_0::implementation;
+#include <hardware/sensors.h>
 
+#include "SensorDevice.h"
+#include "SensorService.h"
 
 namespace android {
 // ---------------------------------------------------------------------------
 
 ANDROID_SINGLETON_STATIC_INSTANCE(SensorDevice)
 
-static status_t StatusFromResult(Result result) {
-    switch (result) {
-        case Result::OK:
-            return OK;
-        case Result::BAD_VALUE:
-            return BAD_VALUE;
-        case Result::PERMISSION_DENIED:
-            return PERMISSION_DENIED;
-        case Result::INVALID_OPERATION:
-            return INVALID_OPERATION;
-        case Result::NO_MEMORY:
-            return NO_MEMORY;
-    }
-}
-
-SensorDevice::SensorDevice() : mHidlTransportErrors(20) {
-    if (!connectHidlService()) {
-        return;
-    }
-
-    float minPowerMa = 0.001; // 1 microAmp
-
-    checkReturn(mSensors->getSensorsList(
-            [&](const auto &list) {
-                const size_t count = list.size();
+SensorDevice::SensorDevice()
+    :  mSensorDevice(0),
+       mSensorModule(0) {
+    status_t err = hw_get_module(SENSORS_HARDWARE_MODULE_ID,
+            (hw_module_t const**)&mSensorModule);
 
-                mActivationCount.setCapacity(count);
-                Info model;
-                for (size_t i=0 ; i < count; i++) {
-                    sensor_t sensor;
-                    convertToSensor(list[i], &sensor);
-                    // Sanity check and clamp power if it is 0 (or close)
-                    if (sensor.power < minPowerMa) {
-                        ALOGE("Reported power %f not deemed sane, clamping to %f",
-                              sensor.power, minPowerMa);
-                        sensor.power = minPowerMa;
-                    }
-                    mSensorList.push_back(sensor);
+    ALOGE_IF(err, "couldn't load %s module (%s)",
+            SENSORS_HARDWARE_MODULE_ID, strerror(-err));
 
-                    mActivationCount.add(list[i].sensorHandle, model);
+    if (mSensorModule) {
+        err = sensors_open_1(&mSensorModule->common, &mSensorDevice);
 
-                    checkReturn(mSensors->activate(list[i].sensorHandle, 0 /* enabled */));
-                }
-            }));
-
-    mIsDirectReportSupported =
-           (checkReturn(mSensors->unregisterDirectChannel(-1)) != Result::INVALID_OPERATION);
-}
+        ALOGE_IF(err, "couldn't open device for module %s (%s)",
+                SENSORS_HARDWARE_MODULE_ID, strerror(-err));
 
-bool SensorDevice::connectHidlService() {
-    // SensorDevice may wait upto 100ms * 10 = 1s for hidl service.
-    constexpr auto RETRY_DELAY = std::chrono::milliseconds(100);
-    size_t retry = 10;
-
-    while (true) {
-        int initStep = 0;
-        mSensors = ISensors::getService();
-        if (mSensors != nullptr) {
-            ++initStep;
-            // Poke ISensor service. If it has lingering connection from previous generation of
-            // system server, it will kill itself. There is no intention to handle the poll result,
-            // which will be done since the size is 0.
-            if(mSensors->poll(0, [](auto, const auto &, const auto &) {}).isOk()) {
-                // ok to continue
-                break;
+        if (mSensorDevice) {
+            if (mSensorDevice->common.version == SENSORS_DEVICE_API_VERSION_1_1 ||
+                mSensorDevice->common.version == SENSORS_DEVICE_API_VERSION_1_2) {
+                ALOGE(">>>> WARNING <<< Upgrade sensor HAL to version 1_3");
             }
-            // hidl service is restarting, pointer is invalid.
-            mSensors = nullptr;
-        }
 
-        if (--retry <= 0) {
-            ALOGE("Cannot connect to ISensors hidl service!");
-            break;
+            sensor_t const* list;
+            ssize_t count = mSensorModule->get_sensors_list(mSensorModule, &list);
+            mActivationCount.setCapacity(count);
+            Info model;
+            for (size_t i=0 ; i<size_t(count) ; i++) {
+                mActivationCount.add(list[i].handle, model);
+                mSensorDevice->activate(
+                        reinterpret_cast<struct sensors_poll_device_t *>(mSensorDevice),
+                        list[i].handle, 0);
+            }
         }
-        // Delay 100ms before retry, hidl service is expected to come up in short time after
-        // crash.
-        ALOGI("%s unsuccessful, try again soon (remaining retry %zu).",
-                (initStep == 0) ? "getService()" : "poll() check", retry);
-        std::this_thread::sleep_for(RETRY_DELAY);
     }
-    return (mSensors != nullptr);
 }
 
 void SensorDevice::handleDynamicSensorConnection(int handle, bool connected) {
-    // not need to check mSensors because this is is only called after successful poll()
     if (connected) {
         Info model;
         mActivationCount.add(handle, model);
-        checkReturn(mSensors->activate(handle, 0 /* enabled */));
+        mSensorDevice->activate(
+                reinterpret_cast<struct sensors_poll_device_t *>(mSensorDevice), handle, 0);
     } else {
         mActivationCount.removeItem(handle);
     }
 }
 
 std::string SensorDevice::dump() const {
-    if (mSensors == nullptr) return "HAL not initialized\n";
+    if (!mSensorModule) return "HAL not initialized\n";
 
     String8 result;
-    result.appendFormat("Total %zu h/w sensors, %zu running:\n",
-                        mSensorList.size(), mActivationCount.size());
+    sensor_t const* list;
+    int count = mSensorModule->get_sensors_list(mSensorModule, &list);
+
+    result.appendFormat("HAL: %s (%s), version %#010x\n",
+                        mSensorModule->common.name,
+                        mSensorModule->common.author,
+                        getHalDeviceVersion());
+    result.appendFormat("Total %d h/w sensors, %zu running:\n", count, mActivationCount.size());
 
     Mutex::Autolock _l(mLock);
-    for (const auto & s : mSensorList) {
-        int32_t handle = s.handle;
-        const Info& info = mActivationCount.valueFor(handle);
+    for (int i = 0 ; i < count ; i++) {
+        const Info& info = mActivationCount.valueFor(list[i].handle);
         if (info.batchParams.isEmpty()) continue;
-
-        result.appendFormat("0x%08x) active-count = %zu; ", handle, info.batchParams.size());
+        result.appendFormat("0x%08x) active-count = %zu; ", list[i].handle,
+                            info.batchParams.size());
 
         result.append("sampling_period(ms) = {");
         for (size_t j = 0; j < info.batchParams.size(); j++) {
-            const BatchParams& params = info.batchParams[j];
-            result.appendFormat("%.1f%s", params.mTSample / 1e6f,
-                j < info.batchParams.size() - 1 ? ", " : "");
+            const BatchParams& params = info.batchParams.valueAt(j);
+            result.appendFormat("%.1f%s", params.batchDelay / 1e6f,
+                                j < info.batchParams.size() - 1 ? ", " : "");
         }
-        result.appendFormat("}, selected = %.2f ms; ", info.bestBatchParams.mTSample / 1e6f);
+        result.appendFormat("}, selected = %.1f ms; ", info.bestBatchParams.batchDelay / 1e6f);
 
         result.append("batching_period(ms) = {");
         for (size_t j = 0; j < info.batchParams.size(); j++) {
-            const BatchParams& params = info.batchParams[j];
-            result.appendFormat("%.1f%s", params.mTBatch / 1e6f,
-                    j < info.batchParams.size() - 1 ? ", " : "");
+            BatchParams params = info.batchParams.valueAt(j);
+            result.appendFormat("%.1f%s", params.batchTimeout / 1e6f,
+                                j < info.batchParams.size() - 1 ? ", " : "");
         }
-        result.appendFormat("}, selected = %.2f ms\n", info.bestBatchParams.mTBatch / 1e6f);
+        result.appendFormat("}, selected = %.1f ms\n", info.bestBatchParams.batchTimeout / 1e6f);
     }
-
     return result.string();
 }
 
 ssize_t SensorDevice::getSensorList(sensor_t const** list) {
-    *list = &mSensorList[0];
-
-    return mSensorList.size();
+    if (!mSensorModule) return NO_INIT;
+    ssize_t count = mSensorModule->get_sensors_list(mSensorModule, list);
+    return count;
 }
 
 status_t SensorDevice::initCheck() const {
-    return mSensors != NULL ? NO_ERROR : NO_INIT;
+    return mSensorDevice && mSensorModule ? NO_ERROR : NO_INIT;
 }
 
 ssize_t SensorDevice::poll(sensors_event_t* buffer, size_t count) {
-    if (mSensors == nullptr) return NO_INIT;
-
-    ssize_t err;
-    int numHidlTransportErrors = 0;
-    bool hidlTransportError = false;
-
+    if (!mSensorDevice) return NO_INIT;
+    ssize_t c;
     do {
-        auto ret = mSensors->poll(
-                count,
-                [&](auto result,
-                    const auto &events,
-                    const auto &dynamicSensorsAdded) {
-                    if (result == Result::OK) {
-                        convertToSensorEvents(events, dynamicSensorsAdded, buffer);
-                        err = (ssize_t)events.size();
-                    } else {
-                        err = StatusFromResult(result);
-                    }
-                });
-
-        if (ret.isOk())  {
-            hidlTransportError = false;
-        } else {
-            hidlTransportError = true;
-            numHidlTransportErrors++;
-            if (numHidlTransportErrors > 50) {
-                // Log error and bail
-                ALOGE("Max Hidl transport errors this cycle : %d", numHidlTransportErrors);
-                handleHidlDeath(ret.description());
-            } else {
-                std::this_thread::sleep_for(std::chrono::milliseconds(10));
-            }
-        }
-    } while (hidlTransportError);
-
-    if(numHidlTransportErrors > 0) {
-        ALOGE("Saw %d Hidl transport failures", numHidlTransportErrors);
-        HidlTransportErrorLog errLog(time(NULL), numHidlTransportErrors);
-        mHidlTransportErrors.add(errLog);
-        mTotalHidlTransportErrors++;
-    }
-
-    return err;
+        c = mSensorDevice->poll(reinterpret_cast<struct sensors_poll_device_t *> (mSensorDevice),
+                                buffer, count);
+    } while (c == -EINTR);
+    return c;
 }
 
 void SensorDevice::autoDisable(void *ident, int handle) {
@@ -229,8 +149,7 @@ void SensorDevice::autoDisable(void *ident, int handle) {
 }
 
 status_t SensorDevice::activate(void* ident, int handle, int enabled) {
-    if (mSensors == nullptr) return NO_INIT;
-
+    if (!mSensorDevice) return NO_INIT;
     status_t err(NO_ERROR);
     bool actuateHardware = false;
 
@@ -245,8 +164,6 @@ status_t SensorDevice::activate(void* ident, int handle, int enabled) {
         ALOGD_IF(DEBUG_CONNECTIONS, "enable index=%zd", info.batchParams.indexOfKey(ident));
 
         if (isClientDisabledLocked(ident)) {
-            ALOGE("SensorDevice::activate, isClientDisabledLocked(%p):true, handle:%d",
-                    ident, handle);
             return INVALID_OPERATION;
         }
 
@@ -262,27 +179,24 @@ status_t SensorDevice::activate(void* ident, int handle, int enabled) {
     } else {
         ALOGD_IF(DEBUG_CONNECTIONS, "disable index=%zd", info.batchParams.indexOfKey(ident));
 
-        // If a connected dynamic sensor is deactivated, remove it from the
-        // dictionary.
-        auto it = mConnectedDynamicSensors.find(handle);
-        if (it != mConnectedDynamicSensors.end()) {
-            delete it->second;
-            mConnectedDynamicSensors.erase(it);
-        }
-
         if (info.removeBatchParamsForIdent(ident) >= 0) {
             if (info.numActiveClients() == 0) {
                 // This is the last connection, we need to de-activate the underlying h/w sensor.
                 actuateHardware = true;
             } else {
-                // Call batch for this sensor with the previously calculated best effort
-                // batch_rate and timeout. One of the apps has unregistered for sensor
-                // events, and the best effort batch parameters might have changed.
-                ALOGD_IF(DEBUG_CONNECTIONS,
-                         "\t>>> actuating h/w batch 0x%08x %" PRId64 " %" PRId64, handle,
-                         info.bestBatchParams.mTSample, info.bestBatchParams.mTBatch);
-                checkReturn(mSensors->batch(
-                        handle, info.bestBatchParams.mTSample, info.bestBatchParams.mTBatch));
+                const int halVersion = getHalDeviceVersion();
+                if (halVersion >= SENSORS_DEVICE_API_VERSION_1_1) {
+                    // Call batch for this sensor with the previously calculated best effort
+                    // batch_rate and timeout. One of the apps has unregistered for sensor
+                    // events, and the best effort batch parameters might have changed.
+                    ALOGD_IF(DEBUG_CONNECTIONS,
+                             "\t>>> actuating h/w batch %d %d %" PRId64 " %" PRId64, handle,
+                             info.bestBatchParams.flags, info.bestBatchParams.batchDelay,
+                             info.bestBatchParams.batchTimeout);
+                    mSensorDevice->batch(mSensorDevice, handle,info.bestBatchParams.flags,
+                                         info.bestBatchParams.batchDelay,
+                                         info.bestBatchParams.batchTimeout);
+                }
             }
         } else {
             // sensor wasn't enabled for this ident
@@ -296,7 +210,8 @@ status_t SensorDevice::activate(void* ident, int handle, int enabled) {
     if (actuateHardware) {
         ALOGD_IF(DEBUG_CONNECTIONS, "\t>>> actuating h/w activate handle=%d enabled=%d", handle,
                  enabled);
-        err = StatusFromResult(checkReturn(mSensors->activate(handle, enabled)));
+        err = mSensorDevice->activate(
+                reinterpret_cast<struct sensors_poll_device_t *> (mSensorDevice), handle, enabled);
         ALOGE_IF(err, "Error %s sensor %d (%s)", enabled ? "activating" : "disabling", handle,
                  strerror(-err));
 
@@ -306,22 +221,29 @@ status_t SensorDevice::activate(void* ident, int handle, int enabled) {
         }
     }
 
+    // On older devices which do not support batch, call setDelay().
+    if (getHalDeviceVersion() < SENSORS_DEVICE_API_VERSION_1_1 && info.numActiveClients() > 0) {
+        ALOGD_IF(DEBUG_CONNECTIONS, "\t>>> actuating h/w setDelay %d %" PRId64, handle,
+                 info.bestBatchParams.batchDelay);
+        mSensorDevice->setDelay(
+                reinterpret_cast<struct sensors_poll_device_t *>(mSensorDevice),
+                handle, info.bestBatchParams.batchDelay);
+    }
     return err;
 }
 
-status_t SensorDevice::batch(
-        void* ident,
-        int handle,
-        int flags,
-        int64_t samplingPeriodNs,
-        int64_t maxBatchReportLatencyNs) {
-    if (mSensors == nullptr) return NO_INIT;
+status_t SensorDevice::batch(void* ident, int handle, int flags, int64_t samplingPeriodNs,
+                             int64_t maxBatchReportLatencyNs) {
+    if (!mSensorDevice) return NO_INIT;
 
     if (samplingPeriodNs < MINIMUM_EVENTS_PERIOD) {
         samplingPeriodNs = MINIMUM_EVENTS_PERIOD;
     }
-    if (maxBatchReportLatencyNs < 0) {
-        maxBatchReportLatencyNs = 0;
+
+    const int halVersion = getHalDeviceVersion();
+    if (halVersion < SENSORS_DEVICE_API_VERSION_1_1 && maxBatchReportLatencyNs != 0) {
+        // Batch is not supported on older devices return invalid operation.
+        return INVALID_OPERATION;
     }
 
     ALOGD_IF(DEBUG_CONNECTIONS,
@@ -332,7 +254,7 @@ status_t SensorDevice::batch(
     Info& info(mActivationCount.editValueFor(handle));
 
     if (info.batchParams.indexOfKey(ident) < 0) {
-        BatchParams params(samplingPeriodNs, maxBatchReportLatencyNs);
+        BatchParams params(flags, samplingPeriodNs, maxBatchReportLatencyNs);
         info.batchParams.add(ident, params);
     } else {
         // A batch has already been called with this ident. Update the batch parameters.
@@ -346,21 +268,29 @@ status_t SensorDevice::batch(
     ALOGD_IF(DEBUG_CONNECTIONS,
              "\t>>> curr_period=%" PRId64 " min_period=%" PRId64
              " curr_timeout=%" PRId64 " min_timeout=%" PRId64,
-             prevBestBatchParams.mTSample, info.bestBatchParams.mTSample,
-             prevBestBatchParams.mTBatch, info.bestBatchParams.mTBatch);
+             prevBestBatchParams.batchDelay, info.bestBatchParams.batchDelay,
+             prevBestBatchParams.batchTimeout, info.bestBatchParams.batchTimeout);
 
     status_t err(NO_ERROR);
     // If the min period or min timeout has changed since the last batch call, call batch.
     if (prevBestBatchParams != info.bestBatchParams) {
-        ALOGD_IF(DEBUG_CONNECTIONS, "\t>>> actuating h/w BATCH 0x%08x %" PRId64 " %" PRId64, handle,
-                 info.bestBatchParams.mTSample, info.bestBatchParams.mTBatch);
-        err = StatusFromResult(
-                checkReturn(mSensors->batch(
-                    handle, info.bestBatchParams.mTSample, info.bestBatchParams.mTBatch)));
+        if (halVersion >= SENSORS_DEVICE_API_VERSION_1_1) {
+            ALOGD_IF(DEBUG_CONNECTIONS, "\t>>> actuating h/w BATCH %d %d %" PRId64 " %" PRId64, handle,
+                     info.bestBatchParams.flags, info.bestBatchParams.batchDelay,
+                     info.bestBatchParams.batchTimeout);
+            err = mSensorDevice->batch(mSensorDevice, handle, info.bestBatchParams.flags,
+                                       info.bestBatchParams.batchDelay,
+                                       info.bestBatchParams.batchTimeout);
+        } else {
+            // For older devices which do not support batch, call setDelay() after activate() is
+            // called. Some older devices may not support calling setDelay before activate(), so
+            // call setDelay in SensorDevice::activate() method.
+        }
         if (err != NO_ERROR) {
-            ALOGE("sensor batch failed %p 0x%08x %" PRId64 " %" PRId64 " err=%s",
-                  mSensors.get(), handle, info.bestBatchParams.mTSample,
-                  info.bestBatchParams.mTBatch, strerror(-err));
+            ALOGE("sensor batch failed %p %d %d %" PRId64 " %" PRId64 " err=%s",
+                  mSensorDevice, handle,
+                  info.bestBatchParams.flags, info.bestBatchParams.batchDelay,
+                  info.bestBatchParams.batchTimeout, strerror(-err));
             info.removeBatchParamsForIdent(ident);
         }
     }
@@ -368,19 +298,41 @@ status_t SensorDevice::batch(
 }
 
 status_t SensorDevice::setDelay(void* ident, int handle, int64_t samplingPeriodNs) {
-    return batch(ident, handle, 0, samplingPeriodNs, 0);
+    if (!mSensorDevice) return NO_INIT;
+    if (samplingPeriodNs < MINIMUM_EVENTS_PERIOD) {
+        samplingPeriodNs = MINIMUM_EVENTS_PERIOD;
+    }
+    Mutex::Autolock _l(mLock);
+    if (isClientDisabledLocked(ident)) return INVALID_OPERATION;
+    Info& info( mActivationCount.editValueFor(handle) );
+    // If the underlying sensor is NOT in continuous mode, setDelay() should return an error.
+    // Calling setDelay() in batch mode is an invalid operation.
+    if (info.bestBatchParams.batchTimeout != 0) {
+      return INVALID_OPERATION;
+    }
+    ssize_t index = info.batchParams.indexOfKey(ident);
+    if (index < 0) {
+        return BAD_INDEX;
+    }
+    BatchParams& params = info.batchParams.editValueAt(index);
+    params.batchDelay = samplingPeriodNs;
+    info.selectBatchParams();
+    return mSensorDevice->setDelay(reinterpret_cast<struct sensors_poll_device_t *>(mSensorDevice),
+                                   handle, info.bestBatchParams.batchDelay);
 }
 
 int SensorDevice::getHalDeviceVersion() const {
-    if (mSensors == nullptr) return -1;
-    return SENSORS_DEVICE_API_VERSION_1_4;
+    if (!mSensorDevice) return -1;
+    return mSensorDevice->common.version;
 }
 
 status_t SensorDevice::flush(void* ident, int handle) {
-    if (mSensors == nullptr) return NO_INIT;
+    if (getHalDeviceVersion() < SENSORS_DEVICE_API_VERSION_1_1) {
+        return INVALID_OPERATION;
+    }
     if (isClientDisabled(ident)) return INVALID_OPERATION;
     ALOGD_IF(DEBUG_CONNECTIONS, "\t>>> actuating h/w flush %d", handle);
-    return StatusFromResult(checkReturn(mSensors->flush(handle)));
+    return mSensorDevice->flush(mSensorDevice, handle);
 }
 
 bool SensorDevice::isClientDisabled(void* ident) {
@@ -393,10 +345,9 @@ bool SensorDevice::isClientDisabledLocked(void* ident) {
 }
 
 void SensorDevice::enableAllSensors() {
-    if (mSensors == nullptr) return;
     Mutex::Autolock _l(mLock);
     mDisabledClients.clear();
-    ALOGI("cleared mDisabledClients");
+    const int halVersion = getHalDeviceVersion();
     for (size_t i = 0; i< mActivationCount.size(); ++i) {
         Info& info = mActivationCount.editValueAt(i);
         if (info.batchParams.isEmpty()) continue;
@@ -404,152 +355,70 @@ void SensorDevice::enableAllSensors() {
         const int sensor_handle = mActivationCount.keyAt(i);
         ALOGD_IF(DEBUG_CONNECTIONS, "\t>> reenable actuating h/w sensor enable handle=%d ",
                    sensor_handle);
-        status_t err = StatusFromResult(
-                checkReturn(mSensors->batch(
-                    sensor_handle,
-                    info.bestBatchParams.mTSample,
-                    info.bestBatchParams.mTBatch)));
-        ALOGE_IF(err, "Error calling batch on sensor %d (%s)", sensor_handle, strerror(-err));
+        status_t err(NO_ERROR);
+        if (halVersion > SENSORS_DEVICE_API_VERSION_1_0) {
+            err = mSensorDevice->batch(mSensorDevice, sensor_handle,
+                 info.bestBatchParams.flags, info.bestBatchParams.batchDelay,
+                 info.bestBatchParams.batchTimeout);
+            ALOGE_IF(err, "Error calling batch on sensor %d (%s)", sensor_handle, strerror(-err));
+        }
 
         if (err == NO_ERROR) {
-            err = StatusFromResult(
-                    checkReturn(mSensors->activate(sensor_handle, 1 /* enabled */)));
+            err = mSensorDevice->activate(
+                    reinterpret_cast<struct sensors_poll_device_t *>(mSensorDevice),
+                    sensor_handle, 1);
             ALOGE_IF(err, "Error activating sensor %d (%s)", sensor_handle, strerror(-err));
         }
+
+        if (halVersion <= SENSORS_DEVICE_API_VERSION_1_0) {
+             err = mSensorDevice->setDelay(
+                    reinterpret_cast<struct sensors_poll_device_t *>(mSensorDevice),
+                    sensor_handle, info.bestBatchParams.batchDelay);
+             ALOGE_IF(err, "Error calling setDelay sensor %d (%s)", sensor_handle, strerror(-err));
+        }
     }
 }
 
 void SensorDevice::disableAllSensors() {
-    if (mSensors == nullptr) return;
     Mutex::Autolock _l(mLock);
-    for (size_t i = 0; i< mActivationCount.size(); ++i) {
+   for (size_t i = 0; i< mActivationCount.size(); ++i) {
         const Info& info = mActivationCount.valueAt(i);
         // Check if this sensor has been activated previously and disable it.
         if (info.batchParams.size() > 0) {
            const int sensor_handle = mActivationCount.keyAt(i);
            ALOGD_IF(DEBUG_CONNECTIONS, "\t>> actuating h/w sensor disable handle=%d ",
                    sensor_handle);
-           checkReturn(mSensors->activate(sensor_handle, 0 /* enabled */));
-
+           mSensorDevice->activate(
+                   reinterpret_cast<struct sensors_poll_device_t *> (mSensorDevice),
+                   sensor_handle, 0);
            // Add all the connections that were registered for this sensor to the disabled
            // clients list.
            for (size_t j = 0; j < info.batchParams.size(); ++j) {
                mDisabledClients.add(info.batchParams.keyAt(j));
-               ALOGI("added %p to mDisabledClients", info.batchParams.keyAt(j));
            }
         }
     }
 }
 
-status_t SensorDevice::injectSensorData(
-        const sensors_event_t *injected_sensor_event) {
-    if (mSensors == nullptr) return NO_INIT;
-    ALOGD_IF(DEBUG_CONNECTIONS,
-            "sensor_event handle=%d ts=%" PRId64 " data=%.2f, %.2f, %.2f %.2f %.2f %.2f",
-            injected_sensor_event->sensor,
-            injected_sensor_event->timestamp, injected_sensor_event->data[0],
-            injected_sensor_event->data[1], injected_sensor_event->data[2],
-            injected_sensor_event->data[3], injected_sensor_event->data[4],
-            injected_sensor_event->data[5]);
-
-    Event ev;
-    convertFromSensorEvent(*injected_sensor_event, &ev);
-
-    return StatusFromResult(checkReturn(mSensors->injectSensorData(ev)));
+status_t SensorDevice::injectSensorData(const sensors_event_t *injected_sensor_event) {
+      ALOGD_IF(DEBUG_CONNECTIONS,
+              "sensor_event handle=%d ts=%" PRId64 " data=%.2f, %.2f, %.2f %.2f %.2f %.2f",
+               injected_sensor_event->sensor,
+               injected_sensor_event->timestamp, injected_sensor_event->data[0],
+               injected_sensor_event->data[1], injected_sensor_event->data[2],
+               injected_sensor_event->data[3], injected_sensor_event->data[4],
+               injected_sensor_event->data[5]);
+      if (getHalDeviceVersion() < SENSORS_DEVICE_API_VERSION_1_4) {
+          return INVALID_OPERATION;
+      }
+      return mSensorDevice->inject_sensor_data(mSensorDevice, injected_sensor_event);
 }
 
 status_t SensorDevice::setMode(uint32_t mode) {
-    if (mSensors == nullptr) return NO_INIT;
-    return StatusFromResult(
-            checkReturn(mSensors->setOperationMode(
-                    static_cast<hardware::sensors::V1_0::OperationMode>(mode))));
-}
-
-int32_t SensorDevice::registerDirectChannel(const sensors_direct_mem_t* memory) {
-    if (mSensors == nullptr) return NO_INIT;
-    Mutex::Autolock _l(mLock);
-
-    SharedMemType type;
-    switch (memory->type) {
-        case SENSOR_DIRECT_MEM_TYPE_ASHMEM:
-            type = SharedMemType::ASHMEM;
-            break;
-        case SENSOR_DIRECT_MEM_TYPE_GRALLOC:
-            type = SharedMemType::GRALLOC;
-            break;
-        default:
-            return BAD_VALUE;
-    }
-
-    SharedMemFormat format;
-    if (memory->format != SENSOR_DIRECT_FMT_SENSORS_EVENT) {
-        return BAD_VALUE;
-    }
-    format = SharedMemFormat::SENSORS_EVENT;
-
-    SharedMemInfo mem = {
-        .type = type,
-        .format = format,
-        .size = static_cast<uint32_t>(memory->size),
-        .memoryHandle = memory->handle,
-    };
-
-    int32_t ret;
-    checkReturn(mSensors->registerDirectChannel(mem,
-            [&ret](auto result, auto channelHandle) {
-                if (result == Result::OK) {
-                    ret = channelHandle;
-                } else {
-                    ret = StatusFromResult(result);
-                }
-            }));
-    return ret;
-}
-
-void SensorDevice::unregisterDirectChannel(int32_t channelHandle) {
-    if (mSensors == nullptr) return;
-    Mutex::Autolock _l(mLock);
-    checkReturn(mSensors->unregisterDirectChannel(channelHandle));
-}
-
-int32_t SensorDevice::configureDirectChannel(int32_t sensorHandle,
-        int32_t channelHandle, const struct sensors_direct_cfg_t *config) {
-    if (mSensors == nullptr) return NO_INIT;
-    Mutex::Autolock _l(mLock);
-
-    RateLevel rate;
-    switch(config->rate_level) {
-        case SENSOR_DIRECT_RATE_STOP:
-            rate = RateLevel::STOP;
-            break;
-        case SENSOR_DIRECT_RATE_NORMAL:
-            rate = RateLevel::NORMAL;
-            break;
-        case SENSOR_DIRECT_RATE_FAST:
-            rate = RateLevel::FAST;
-            break;
-        case SENSOR_DIRECT_RATE_VERY_FAST:
-            rate = RateLevel::VERY_FAST;
-            break;
-        default:
-            return BAD_VALUE;
-    }
-
-    int32_t ret;
-    checkReturn(mSensors->configDirectReport(sensorHandle, channelHandle, rate,
-            [&ret, rate] (auto result, auto token) {
-                if (rate == RateLevel::STOP) {
-                    ret = StatusFromResult(result);
-                } else {
-                    if (result == Result::OK) {
-                        ret = token;
-                    } else {
-                        ret = StatusFromResult(result);
-                    }
-                }
-            }));
-
-    return ret;
+     if (getHalDeviceVersion() < SENSORS_DEVICE_API_VERSION_1_4) {
+          return INVALID_OPERATION;
+     }
+     return mSensorModule->set_operation_mode(mode);
 }
 
 // ---------------------------------------------------------------------------
@@ -565,35 +434,35 @@ int SensorDevice::Info::numActiveClients() {
     return num;
 }
 
-status_t SensorDevice::Info::setBatchParamsForIdent(void* ident, int,
+status_t SensorDevice::Info::setBatchParamsForIdent(void* ident, int flags,
                                                     int64_t samplingPeriodNs,
                                                     int64_t maxBatchReportLatencyNs) {
     ssize_t index = batchParams.indexOfKey(ident);
     if (index < 0) {
-        ALOGE("Info::setBatchParamsForIdent(ident=%p, period_ns=%" PRId64
-              " timeout=%" PRId64 ") failed (%s)",
+        ALOGE("Info::setBatchParamsForIdent(ident=%p, period_ns=%" PRId64 " timeout=%" PRId64 ") failed (%s)",
               ident, samplingPeriodNs, maxBatchReportLatencyNs, strerror(-index));
         return BAD_INDEX;
     }
     BatchParams& params = batchParams.editValueAt(index);
-    params.mTSample = samplingPeriodNs;
-    params.mTBatch = maxBatchReportLatencyNs;
+    params.flags = flags;
+    params.batchDelay = samplingPeriodNs;
+    params.batchTimeout = maxBatchReportLatencyNs;
     return NO_ERROR;
 }
 
 void SensorDevice::Info::selectBatchParams() {
-    BatchParams bestParams; // default to max Tsample and max Tbatch
+    BatchParams bestParams(0, -1, -1);
     SensorDevice& device(SensorDevice::getInstance());
 
     for (size_t i = 0; i < batchParams.size(); ++i) {
-        if (device.isClientDisabledLocked(batchParams.keyAt(i))) {
-            continue;
+        if (device.isClientDisabledLocked(batchParams.keyAt(i))) continue;
+        BatchParams params = batchParams.valueAt(i);
+        if (bestParams.batchDelay == -1 || params.batchDelay < bestParams.batchDelay) {
+            bestParams.batchDelay = params.batchDelay;
+        }
+        if (bestParams.batchTimeout == -1 || params.batchTimeout < bestParams.batchTimeout) {
+            bestParams.batchTimeout = params.batchTimeout;
         }
-        bestParams.merge(batchParams[i]);
-    }
-    // if mTBatch <= mTSample, it is in streaming mode. set mTbatch to 0 to demand this explicitly.
-    if (bestParams.mTBatch <= bestParams.mTSample) {
-        bestParams.mTBatch = 0;
     }
     bestBatchParams = bestParams;
 }
@@ -611,61 +480,6 @@ void SensorDevice::notifyConnectionDestroyed(void* ident) {
     mDisabledClients.remove(ident);
 }
 
-bool SensorDevice::isDirectReportSupported() const {
-    return mIsDirectReportSupported;
-}
-
-void SensorDevice::convertToSensorEvent(
-        const Event &src, sensors_event_t *dst) {
-    ::android::hardware::sensors::V1_0::implementation::convertToSensorEvent(
-            src, dst);
-
-    if (src.sensorType == SensorType::DYNAMIC_SENSOR_META) {
-        const DynamicSensorInfo &dyn = src.u.dynamic;
-
-        dst->dynamic_sensor_meta.connected = dyn.connected;
-        dst->dynamic_sensor_meta.handle = dyn.sensorHandle;
-        if (dyn.connected) {
-            auto it = mConnectedDynamicSensors.find(dyn.sensorHandle);
-            CHECK(it != mConnectedDynamicSensors.end());
-
-            dst->dynamic_sensor_meta.sensor = it->second;
-
-            memcpy(dst->dynamic_sensor_meta.uuid,
-                   dyn.uuid.data(),
-                   sizeof(dst->dynamic_sensor_meta.uuid));
-        }
-    }
-}
-
-void SensorDevice::convertToSensorEvents(
-        const hidl_vec<Event> &src,
-        const hidl_vec<SensorInfo> &dynamicSensorsAdded,
-        sensors_event_t *dst) {
-    // Allocate a sensor_t structure for each dynamic sensor added and insert
-    // it into the dictionary of connected dynamic sensors keyed by handle.
-    for (size_t i = 0; i < dynamicSensorsAdded.size(); ++i) {
-        const SensorInfo &info = dynamicSensorsAdded[i];
-
-        auto it = mConnectedDynamicSensors.find(info.sensorHandle);
-        CHECK(it == mConnectedDynamicSensors.end());
-
-        sensor_t *sensor = new sensor_t;
-        convertToSensor(info, sensor);
-
-        mConnectedDynamicSensors.insert(
-                std::make_pair(sensor->handle, sensor));
-    }
-
-    for (size_t i = 0; i < src.size(); ++i) {
-        convertToSensorEvent(src[i], &dst[i]);
-    }
-}
-
-void SensorDevice::handleHidlDeath(const std::string & detail) {
-    // restart is the only option at present.
-    LOG_ALWAYS_FATAL("Abort due to ISensors hidl service failure, detail: %s.", detail.c_str());
-}
-
 // ---------------------------------------------------------------------------
 }; // namespace android
+
diff --git a/services/sensorservice/SensorDevice.h b/services/sensorservice/SensorDevice.h
index fd6cee67e..d340da31c 100644
--- a/services/sensorservice/SensorDevice.h
+++ b/services/sensorservice/SensorDevice.h
@@ -19,66 +19,27 @@
 
 #include "SensorServiceUtils.h"
 
-#include <sensor/Sensor.h>
-#include <stdint.h>
-#include <sys/types.h>
+#include <sensor/Sensor.h>
 #include <utils/KeyedVector.h>
 #include <utils/Singleton.h>
 #include <utils/String8.h>
 
-#include <string>
-#include <unordered_map>
-#include <algorithm> //std::max std::min
-
-#include "android/hardware/sensors/1.0/ISensors.h"
-
-#include "RingBuffer.h"
+#include <stdint.h>
+#include <sys/types.h>
 
 // ---------------------------------------------------------------------------
 
 namespace android {
-
 // ---------------------------------------------------------------------------
 using SensorServiceUtil::Dumpable;
-using hardware::Return;
 
 class SensorDevice : public Singleton<SensorDevice>, public Dumpable {
 public:
-
-    class HidlTransportErrorLog {
-     public:
-
-        HidlTransportErrorLog() {
-            mTs = 0;
-            mCount = 0;
-        }
-
-        HidlTransportErrorLog(time_t ts, int count) {
-            mTs = ts;
-            mCount = count;
-        }
-
-        String8 toString() const {
-            String8 result;
-            struct tm *timeInfo = localtime(&mTs);
-            result.appendFormat("%02d:%02d:%02d :: %d", timeInfo->tm_hour, timeInfo->tm_min,
-                                timeInfo->tm_sec, mCount);
-            return result;
-        }
-
-    private:
-        time_t mTs; // timestamp of the error
-        int mCount;   // number of transport errors observed
-    };
-
     ssize_t getSensorList(sensor_t const** list);
-
     void handleDynamicSensorConnection(int handle, bool connected);
     status_t initCheck() const;
     int getHalDeviceVersion() const;
-
     ssize_t poll(sensors_event_t* buffer, size_t count);
-
     status_t activate(void* ident, int handle, int enabled);
     status_t batch(void* ident, int handle, int flags, int64_t samplingPeriodNs,
                    int64_t maxBatchReportLatencyNs);
@@ -86,17 +47,9 @@ class SensorDevice : public Singleton<SensorDevice>, public Dumpable {
     status_t setDelay(void* ident, int handle, int64_t ns);
     status_t flush(void* ident, int handle);
     status_t setMode(uint32_t mode);
-
-    bool isDirectReportSupported() const;
-    int32_t registerDirectChannel(const sensors_direct_mem_t *memory);
-    void unregisterDirectChannel(int32_t channelHandle);
-    int32_t configureDirectChannel(int32_t sensorHandle,
-            int32_t channelHandle, const struct sensors_direct_cfg_t *config);
-
     void disableAllSensors();
     void enableAllSensors();
     void autoDisable(void *ident, int handle);
-
     status_t injectSensorData(const sensors_event_t *event);
     void notifyConnectionDestroyed(void *ident);
 
@@ -104,11 +57,8 @@ class SensorDevice : public Singleton<SensorDevice>, public Dumpable {
     virtual std::string dump() const;
 private:
     friend class Singleton<SensorDevice>;
-
-    sp<android::hardware::sensors::V1_0::ISensors> mSensors;
-    Vector<sensor_t> mSensorList;
-    std::unordered_map<int32_t, sensor_t*> mConnectedDynamicSensors;
-
+    sensors_poll_device_1_t* mSensorDevice;
+    struct sensors_module_t* mSensorModule;
     static const nsecs_t MINIMUM_EVENTS_PERIOD =   1000000; // 1000 Hz
     mutable Mutex mLock; // protect mActivationCount[].batchParams
     // fixed-size array after construction
@@ -116,18 +66,15 @@ class SensorDevice : public Singleton<SensorDevice>, public Dumpable {
     // Struct to store all the parameters(samplingPeriod, maxBatchReportLatency and flags) from
     // batch call. For continous mode clients, maxBatchReportLatency is set to zero.
     struct BatchParams {
-      nsecs_t mTSample, mTBatch;
-      BatchParams() : mTSample(INT64_MAX), mTBatch(INT64_MAX) {}
-      BatchParams(nsecs_t tSample, nsecs_t tBatch): mTSample(tSample), mTBatch(tBatch) {}
+      // TODO: Get rid of flags parameter everywhere.
+      int flags;
+      nsecs_t batchDelay, batchTimeout;
+      BatchParams() : flags(0), batchDelay(0), batchTimeout(0) {}
+      BatchParams(int flag, nsecs_t delay, nsecs_t timeout): flags(flag), batchDelay(delay),
+          batchTimeout(timeout) { }
       bool operator != (const BatchParams& other) {
-          return !(mTSample == other.mTSample && mTBatch == other.mTBatch);
-      }
-      // Merge another parameter with this one. The updated mTSample will be the min of the two.
-      // The update mTBatch will be the min of original mTBatch and the apparent batch period
-      // of the other. the apparent batch is the maximum of mTBatch and mTSample,
-      void merge(const BatchParams &other) {
-          mTSample = std::min(mTSample, other.mTSample);
-          mTBatch = std::min(mTBatch, std::max(other.mTBatch, other.mTSample));
+          return other.batchDelay != batchDelay || other.batchTimeout != batchTimeout ||
+                 other.flags != flags;
       }
     };
 
@@ -143,6 +90,7 @@ class SensorDevice : public Singleton<SensorDevice>, public Dumpable {
         // requested by the client.
         KeyedVector<void*, BatchParams> batchParams;
 
+        Info() : bestBatchParams(0, -1, -1) {}
         // Sets batch parameters for this ident. Returns error if this ident is not already present
         // in the KeyedVector above.
         status_t setBatchParamsForIdent(void* ident, int flags, int64_t samplingPeriodNs,
@@ -157,38 +105,12 @@ class SensorDevice : public Singleton<SensorDevice>, public Dumpable {
     };
     DefaultKeyedVector<int, Info> mActivationCount;
 
-    // Keep track of any hidl transport failures
-    SensorServiceUtil::RingBuffer<HidlTransportErrorLog> mHidlTransportErrors;
-    int mTotalHidlTransportErrors;
-
     // Use this vector to determine which client is activated or deactivated.
     SortedVector<void *> mDisabledClients;
     SensorDevice();
-    bool connectHidlService();
-
-    static void handleHidlDeath(const std::string &detail);
-    template<typename T>
-    static Return<T> checkReturn(Return<T> &&ret) {
-        if (!ret.isOk()) {
-            handleHidlDeath(ret.description());
-        }
-        return std::move(ret);
-    }
 
     bool isClientDisabled(void* ident);
     bool isClientDisabledLocked(void* ident);
-
-    using Event = hardware::sensors::V1_0::Event;
-    using SensorInfo = hardware::sensors::V1_0::SensorInfo;
-
-    void convertToSensorEvent(const Event &src, sensors_event_t *dst);
-
-    void convertToSensorEvents(
-            const hardware::hidl_vec<Event> &src,
-            const hardware::hidl_vec<SensorInfo> &dynamicSensorsAdded,
-            sensors_event_t *dst);
-
-    bool mIsDirectReportSupported;
 };
 
 // ---------------------------------------------------------------------------
diff --git a/services/sensorservice/SensorEventAckReceiver.h b/services/sensorservice/SensorEventAckReceiver.h
index 20fa4c791..998597a84 100644
--- a/services/sensorservice/SensorEventAckReceiver.h
+++ b/services/sensorservice/SensorEventAckReceiver.h
@@ -27,7 +27,7 @@ class SensorService::SensorEventAckReceiver : public Thread {
     sp<SensorService> const mService;
 public:
     virtual bool threadLoop();
-    explicit SensorEventAckReceiver(const sp<SensorService>& service)
+    SensorEventAckReceiver(const sp<SensorService>& service)
             : mService(service) {
     }
 };
diff --git a/services/sensorservice/SensorEventConnection.cpp b/services/sensorservice/SensorEventConnection.cpp
index bfe4c0924..f2f144412 100644
--- a/services/sensorservice/SensorEventConnection.cpp
+++ b/services/sensorservice/SensorEventConnection.cpp
@@ -17,14 +17,12 @@
 #include <sys/socket.h>
 #include <utils/threads.h>
 
-#include <sensor/SensorEventQueue.h>
+#include <sensor/SensorEventQueue.h>
 
 #include "vec.h"
 #include "SensorEventConnection.h"
 #include "SensorDevice.h"
 
-#define UNUSED(x) (void)(x)
-
 namespace android {
 
 SensorService::SensorEventConnection::SensorEventConnection(
@@ -477,14 +475,7 @@ void SensorService::SensorEventConnection::countFlushCompleteEventsLocked(
     // separately before the next batch of events.
     for (int j = 0; j < numEventsDropped; ++j) {
         if (scratch[j].type == SENSOR_TYPE_META_DATA) {
-            ssize_t index = mSensorInfo.indexOfKey(scratch[j].meta_data.sensor);
-            if (index < 0) {
-                ALOGW("%s: sensor 0x%x is not found in connection",
-                      __func__, scratch[j].meta_data.sensor);
-                continue;
-            }
-
-            FlushInfo& flushInfo = mSensorInfo.editValueAt(index);
+            FlushInfo& flushInfo = mSensorInfo.editValueFor(scratch[j].meta_data.sensor);
             flushInfo.mPendingFlushEventsToSend++;
             ALOGD_IF(DEBUG_CONNECTIONS, "increment pendingFlushCount %d",
                      flushInfo.mPendingFlushEventsToSend);
@@ -533,13 +524,6 @@ status_t  SensorService::SensorEventConnection::flush() {
     return  mService->flushSensor(this, mOpPackageName);
 }
 
-int32_t SensorService::SensorEventConnection::configureChannel(int handle, int rateLevel) {
-    // SensorEventConnection does not support configureChannel, parameters not used
-    UNUSED(handle);
-    UNUSED(rateLevel);
-    return INVALID_OPERATION;
-}
-
 int SensorService::SensorEventConnection::handleEvent(int fd, int events, void* /*data*/) {
     if (events & ALOOPER_EVENT_HANGUP || events & ALOOPER_EVENT_ERROR) {
         {
diff --git a/services/sensorservice/SensorEventConnection.h b/services/sensorservice/SensorEventConnection.h
index c81e015db..883c16e23 100644
--- a/services/sensorservice/SensorEventConnection.h
+++ b/services/sensorservice/SensorEventConnection.h
@@ -74,8 +74,6 @@ class SensorService::SensorEventConnection:
                                    nsecs_t maxBatchReportLatencyNs, int reservedFlags);
     virtual status_t setEventRate(int handle, nsecs_t samplingPeriodNs);
     virtual status_t flush();
-    virtual int32_t configureChannel(int handle, int rateLevel);
-
     // Count the number of flush complete events which are about to be dropped in the buffer.
     // Increment mPendingFlushEventsToSend in mSensorInfo. These flush complete events will be sent
     // separately before the next batch of events.
diff --git a/services/sensorservice/SensorFusion.cpp b/services/sensorservice/SensorFusion.cpp
index 414f67327..9863f6285 100644
--- a/services/sensorservice/SensorFusion.cpp
+++ b/services/sensorservice/SensorFusion.cpp
@@ -163,7 +163,7 @@ status_t SensorFusion::setDelay(int mode, void* ident, int64_t ns) {
     }
     mSensorDevice.batch(ident, mAcc.getHandle(), 0, ns, 0);
     if (mode != FUSION_NOMAG) {
-        mSensorDevice.batch(ident, mMag.getHandle(), 0, ms2ns(10), 0);
+        mSensorDevice.batch(ident, mMag.getHandle(), 0, ms2ns(20), 0);
     }
     if (mode != FUSION_NOGYRO) {
         mSensorDevice.batch(ident, mGyro.getHandle(), 0, mTargetDelayNs, 0);
diff --git a/services/sensorservice/SensorInterface.h b/services/sensorservice/SensorInterface.h
index b5375cb9e..4c22c54d4 100644
--- a/services/sensorservice/SensorInterface.h
+++ b/services/sensorservice/SensorInterface.h
@@ -47,7 +47,7 @@ class SensorInterface : public VirtualLightRefBase {
 
 class BaseSensor : public SensorInterface {
 public:
-    explicit BaseSensor(const sensor_t& sensor);
+    BaseSensor(const sensor_t& sensor);
     BaseSensor(const sensor_t& sensor, const uint8_t (&uuid)[16]);
 
     // Not all sensors need to support batching.
@@ -74,7 +74,7 @@ class BaseSensor : public SensorInterface {
 
 class HardwareSensor : public BaseSensor {
 public:
-    explicit HardwareSensor(const sensor_t& sensor);
+    HardwareSensor(const sensor_t& sensor);
     HardwareSensor(const sensor_t& sensor, const uint8_t (&uuid)[16]);
 
     virtual ~HardwareSensor();
diff --git a/services/sensorservice/SensorList.cpp b/services/sensorservice/SensorList.cpp
index aa306d885..e0101c1f1 100644
--- a/services/sensorservice/SensorList.cpp
+++ b/services/sensorservice/SensorList.cpp
@@ -124,28 +124,26 @@ std::string SensorList::dump() const {
     forEachSensor([&result] (const Sensor& s) -> bool {
             result.appendFormat(
                     "%#010x) %-25s | %-15s | ver: %" PRId32 " | type: %20s(%" PRId32
-                        ") | perm: %s | flags: 0x%08x\n",
+                        ") | perm: %s\n\t",
                     s.getHandle(),
                     s.getName().string(),
                     s.getVendor().string(),
                     s.getVersion(),
                     s.getStringType().string(),
                     s.getType(),
-                    s.getRequiredPermission().size() ? s.getRequiredPermission().string() : "n/a",
-                    static_cast<int>(s.getFlags()));
+                    s.getRequiredPermission().size() ? s.getRequiredPermission().string() : "n/a");
 
-            result.append("\t");
             const int reportingMode = s.getReportingMode();
             if (reportingMode == AREPORTING_MODE_CONTINUOUS) {
-                result.append("continuous | ");
+                result.append(" continuous | ");
             } else if (reportingMode == AREPORTING_MODE_ON_CHANGE) {
-                result.append("on-change | ");
+                result.append(" on-change | ");
             } else if (reportingMode == AREPORTING_MODE_ONE_SHOT) {
-                result.append("one-shot | ");
+                result.append(" one-shot | ");
             } else if (reportingMode == AREPORTING_MODE_SPECIAL_TRIGGER) {
-                result.append("special-trigger | ");
+                result.append(" special-trigger | ");
             } else {
-                result.append("unknown-mode | ");
+                result.append(" unknown-mode | ");
             }
 
             if (s.getMaxDelay() > 0) {
@@ -174,30 +172,14 @@ std::string SensorList::dump() const {
                 result.appendFormat("non-wakeUp | ");
             }
 
-            if (s.isDataInjectionSupported()) {
-                result.appendFormat("data-injection, ");
-            }
-
             if (s.isDynamicSensor()) {
                 result.appendFormat("dynamic, ");
             }
-
             if (s.hasAdditionalInfo()) {
                 result.appendFormat("has-additional-info, ");
             }
-            result.append("\n");
 
-            if (s.getHighestDirectReportRateLevel() > SENSOR_DIRECT_RATE_STOP) {
-                result.appendFormat("\thighest rate level = %d, support shared mem: ",
-                        s.getHighestDirectReportRateLevel());
-                if (s.isDirectChannelTypeSupported(SENSOR_DIRECT_MEM_TYPE_ASHMEM)) {
-                    result.append("ashmem, ");
-                }
-                if (s.isDirectChannelTypeSupported(SENSOR_DIRECT_MEM_TYPE_GRALLOC)) {
-                    result.append("gralloc, ");
-                }
-                result.append("\n");
-            }
+            result.append("\n");
             return true;
         });
     return std::string(result.string());
diff --git a/services/sensorservice/SensorRegistrationInfo.h b/services/sensorservice/SensorRegistrationInfo.h
index 75e898938..54d815b72 100644
--- a/services/sensorservice/SensorRegistrationInfo.h
+++ b/services/sensorservice/SensorRegistrationInfo.h
@@ -17,76 +17,29 @@
 #ifndef ANDROID_SENSOR_REGISTRATION_INFO_H
 #define ANDROID_SENSOR_REGISTRATION_INFO_H
 
-#include "SensorServiceUtils.h"
-#include <utils/Thread.h>
-#include <iomanip>
-#include <sstream>
-
 namespace android {
 
 class SensorService;
 
-class SensorService::SensorRegistrationInfo : public SensorServiceUtil::Dumpable {
-public:
+struct SensorService::SensorRegistrationInfo {
+    int32_t mSensorHandle;
+    String8 mPackageName;
+    bool mActivated;
+    int32_t mSamplingRateUs;
+    int32_t mMaxReportLatencyUs;
+    int32_t mHour, mMin, mSec;
+
     SensorRegistrationInfo() : mPackageName() {
         mSensorHandle = mSamplingRateUs = mMaxReportLatencyUs = INT32_MIN;
-        mHour = mMin = mSec = INT8_MIN;
+        mHour = mMin = mSec = INT32_MIN;
         mActivated = false;
     }
 
-    SensorRegistrationInfo(int32_t handle, const String8 &packageName,
-                           int32_t samplingRateNs, int32_t maxReportLatencyNs, bool activate) {
-        mSensorHandle = handle;
-        mPackageName = packageName;
-
-        mSamplingRateUs = static_cast<int32_t>(samplingRateNs/1000);
-        mMaxReportLatencyUs = static_cast<int32_t>(maxReportLatencyNs/1000);
-        mActivated = activate;
-
-        IPCThreadState *thread = IPCThreadState::self();
-        mPid = (thread != nullptr) ? thread->getCallingPid() : -1;
-        mUid = (thread != nullptr) ? thread->getCallingUid() : -1;
-
-        time_t rawtime = time(NULL);
-        struct tm * timeinfo = localtime(&rawtime);
-        mHour = static_cast<int8_t>(timeinfo->tm_hour);
-        mMin = static_cast<int8_t>(timeinfo->tm_min);
-        mSec = static_cast<int8_t>(timeinfo->tm_sec);
-    }
-
     static bool isSentinel(const SensorRegistrationInfo& info) {
-       return (info.mHour == INT8_MIN &&
-               info.mMin == INT8_MIN &&
-               info.mSec == INT8_MIN);
-    }
-
-    // Dumpable interface
-    virtual std::string dump() const override {
-        std::ostringstream ss;
-        ss << std::setfill('0') << std::setw(2) << static_cast<int>(mHour) << ":"
-           << std::setw(2) << static_cast<int>(mMin) << ":"
-           << std::setw(2) << static_cast<int>(mSec)
-           << (mActivated ? " +" : " -")
-           << " 0x" << std::hex << std::setw(8) << mSensorHandle << std::dec
-           << std::setfill(' ') << " pid=" << std::setw(5) << mPid
-           << " uid=" << std::setw(5) << mUid << " package=" << mPackageName;
-        if (mActivated) {
-           ss  << " samplingPeriod=" << mSamplingRateUs << "us"
-               << " batchingPeriod=" << mMaxReportLatencyUs << "us";
-        };
-        return ss.str();
+       return (info.mHour == INT32_MIN &&
+               info.mMin == INT32_MIN &&
+               info.mSec == INT32_MIN);
     }
-
-private:
-    int32_t mSensorHandle;
-    String8 mPackageName;
-    pid_t   mPid;
-    uid_t   mUid;
-    int32_t mSamplingRateUs;
-    int32_t mMaxReportLatencyUs;
-    bool mActivated;
-    int8_t mHour, mMin, mSec;
-
 };
 
 } // namespace android;
diff --git a/services/sensorservice/SensorService.cpp b/services/sensorservice/SensorService.cpp
index 9a3da2699..d8e08775a 100644
--- a/services/sensorservice/SensorService.cpp
+++ b/services/sensorservice/SensorService.cpp
@@ -13,19 +13,22 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
+#include <cutils/properties.h>
+
 #include <binder/AppOpsManager.h>
 #include <binder/BinderService.h>
 #include <binder/IServiceManager.h>
 #include <binder/PermissionCache.h>
-#include <cutils/ashmem.h>
-#include <cutils/properties.h>
+
+#include <sensor/SensorEventQueue.h>
+
 #include <hardware/sensors.h>
 #include <hardware_legacy/power.h>
+
 #include <openssl/digest.h>
 #include <openssl/hmac.h>
 #include <openssl/rand.h>
-#include <sensor/SensorEventQueue.h>
-#include <utils/SystemClock.h>
 
 #include "BatteryService.h"
 #include "CorrectedGyroSensor.h"
@@ -37,7 +40,6 @@
 #include "SensorInterface.h"
 
 #include "SensorService.h"
-#include "SensorDirectConnection.h"
 #include "SensorEventAckReceiver.h"
 #include "SensorEventConnection.h"
 #include "SensorRecord.h"
@@ -73,8 +75,7 @@ bool SensorService::sHmacGlobalKeyIsValid = false;
 #define SENSOR_SERVICE_SCHED_FIFO_PRIORITY 10
 
 // Permissions.
-static const String16 sDumpPermission("android.permission.DUMP");
-static const String16 sLocationHardwarePermission("android.permission.LOCATION_HARDWARE");
+static const String16 sDump("android.permission.DUMP");
 
 SensorService::SensorService()
     : mInitCheck(NO_INIT), mSocketBufferSize(SOCKET_BUFFER_SIZE_NON_BATCHED),
@@ -190,9 +191,10 @@ void SensorService::onFirstRef() {
                 // available in the HAL
                 bool needRotationVector =
                         (virtualSensorsNeeds & (1<<SENSOR_TYPE_ROTATION_VECTOR)) != 0;
+                bool needOrientation = orientationIndex == -1;
 
                 registerSensor(new RotationVectorSensor(), !needRotationVector, true);
-                registerSensor(new OrientationSensor(), !needRotationVector, true);
+                registerSensor(new OrientationSensor(), !needOrientation, true);
 
                 bool needLinearAcceleration =
                         (virtualSensorsNeeds & (1<<SENSOR_TYPE_LINEAR_ACCELERATION)) != 0;
@@ -272,10 +274,8 @@ void SensorService::onFirstRef() {
             mAckReceiver->run("SensorEventAckReceiver", PRIORITY_URGENT_DISPLAY);
             run("SensorService", PRIORITY_URGENT_DISPLAY);
 
-#ifndef HARDWARE_FIFO_SENSOR_SERVICE
             // priority can only be changed after run
             enableSchedFifoMode();
-#endif
         }
     }
 }
@@ -318,7 +318,7 @@ SensorService::~SensorService() {
 
 status_t SensorService::dump(int fd, const Vector<String16>& args) {
     String8 result;
-    if (!PermissionCache::checkCallingPermission(sDumpPermission)) {
+    if (!PermissionCache::checkCallingPermission(sDump)) {
         result.appendFormat("Permission Denial: can't dump SensorService from pid=%d, uid=%d\n",
                 IPCThreadState::self()->getCallingPid(),
                 IPCThreadState::self()->getCallingUid());
@@ -338,16 +338,7 @@ status_t SensorService::dump(int fd, const Vector<String16>& args) {
             if (mCurrentOperatingMode != NORMAL) {
                 return INVALID_OPERATION;
             }
-
             mCurrentOperatingMode = RESTRICTED;
-            // temporarily stop all sensor direct report
-            for (auto &i : mDirectConnections) {
-                sp<SensorDirectConnection> connection(i.promote());
-                if (connection != nullptr) {
-                    connection->stopAll(true /* backupRecord */);
-                }
-            }
-
             dev.disableAllSensors();
             // Clear all pending flush connections for all active sensors. If one of the active
             // connections has called flush() and the underlying sensor has been disabled before a
@@ -362,13 +353,6 @@ status_t SensorService::dump(int fd, const Vector<String16>& args) {
             if (mCurrentOperatingMode == RESTRICTED) {
                 mCurrentOperatingMode = NORMAL;
                 dev.enableAllSensors();
-                // recover all sensor direct report
-                for (auto &i : mDirectConnections) {
-                    sp<SensorDirectConnection> connection(i.promote());
-                    if (connection != nullptr) {
-                        connection->recoverAll();
-                    }
-                }
             }
             if (mCurrentOperatingMode == DATA_INJECTION) {
                resetToNormalModeLocked();
@@ -396,7 +380,6 @@ status_t SensorService::dump(int fd, const Vector<String16>& args) {
             }
         } else if (!mSensors.hasAnySensor()) {
             result.append("No Sensors on the device\n");
-            result.appendFormat("devInitCheck : %d\n", SensorDevice::getInstance().initCheck());
         } else {
             // Default dump the sensor list and debugging information.
             //
@@ -448,8 +431,8 @@ status_t SensorService::dump(int fd, const Vector<String16>& args) {
                case DATA_INJECTION:
                    result.appendFormat(" DATA_INJECTION : %s\n", mWhiteListedPackage.string());
             }
-
             result.appendFormat("%zd active connections\n", mActiveConnections.size());
+
             for (size_t i=0 ; i < mActiveConnections.size() ; i++) {
                 sp<SensorEventConnection> connection(mActiveConnections[i].promote());
                 if (connection != 0) {
@@ -458,15 +441,6 @@ status_t SensorService::dump(int fd, const Vector<String16>& args) {
                 }
             }
 
-            result.appendFormat("%zd direct connections\n", mDirectConnections.size());
-            for (size_t i = 0 ; i < mDirectConnections.size() ; i++) {
-                sp<SensorDirectConnection> connection(mDirectConnections[i].promote());
-                if (connection != nullptr) {
-                    result.appendFormat("Direct connection %zu:\n", i);
-                    connection->dump(result);
-                }
-            }
-
             result.appendFormat("Previous Registrations:\n");
             // Log in the reverse chronological order.
             int currentIndex = (mNextSensorRegIndex - 1 + SENSOR_REGISTRATIONS_BUF_SIZE) %
@@ -480,7 +454,17 @@ status_t SensorService::dump(int fd, const Vector<String16>& args) {
                         SENSOR_REGISTRATIONS_BUF_SIZE;
                     continue;
                 }
-                result.appendFormat("%s\n", reg_info.dump().c_str());
+                if (reg_info.mActivated) {
+                   result.appendFormat("%02d:%02d:%02d activated handle=0x%08x "
+                           "samplingRate=%dus maxReportLatency=%dus package=%s\n",
+                           reg_info.mHour, reg_info.mMin, reg_info.mSec, reg_info.mSensorHandle,
+                           reg_info.mSamplingRateUs, reg_info.mMaxReportLatencyUs,
+                           reg_info.mPackageName.string());
+                } else {
+                   result.appendFormat("%02d:%02d:%02d de-activated handle=0x%08x package=%s\n",
+                           reg_info.mHour, reg_info.mMin, reg_info.mSec,
+                           reg_info.mSensorHandle, reg_info.mPackageName.string());
+                }
                 currentIndex = (currentIndex - 1 + SENSOR_REGISTRATIONS_BUF_SIZE) %
                         SENSOR_REGISTRATIONS_BUF_SIZE;
             } while(startIndex != currentIndex);
@@ -885,7 +869,7 @@ void SensorService::makeUuidsIntoIdsForSensorList(Vector<Sensor> &sensorList) co
     }
 }
 
-Vector<Sensor> SensorService::getSensorList(const String16& /* opPackageName */) {
+Vector<Sensor> SensorService::getSensorList(const String16& opPackageName) {
     char value[PROPERTY_VALUE_MAX];
     property_get("debug.sensors", value, "0");
     const Vector<Sensor>& initialSensorList = (atoi(value)) ?
@@ -893,7 +877,14 @@ Vector<Sensor> SensorService::getSensorList(const String16& /* opPackageName */)
     Vector<Sensor> accessibleSensorList;
     for (size_t i = 0; i < initialSensorList.size(); i++) {
         Sensor sensor = initialSensorList[i];
-        accessibleSensorList.add(sensor);
+        if (canAccessSensor(sensor, "getSensorList", opPackageName)) {
+            accessibleSensorList.add(sensor);
+        } else {
+            ALOGI("Skipped sensor %s because it requires permission %s and app op %d",
+                  sensor.getName().string(),
+                  sensor.getRequiredPermission().string(),
+                  sensor.getRequiredAppOp());
+        }
     }
     makeUuidsIntoIdsForSensorList(accessibleSensorList);
     return accessibleSensorList;
@@ -935,14 +926,8 @@ sp<ISensorEventConnection> SensorService::createSensorEventConnection(const Stri
     }
 
     uid_t uid = IPCThreadState::self()->getCallingUid();
-    pid_t pid = IPCThreadState::self()->getCallingPid();
-
-    String8 connPackageName =
-            (packageName == "") ? String8::format("unknown_package_pid_%d", pid) : packageName;
-    String16 connOpPackageName =
-            (opPackageName == String16("")) ? String16(connPackageName) : opPackageName;
-    sp<SensorEventConnection> result(new SensorEventConnection(this, uid, connPackageName,
-            requestedMode == DATA_INJECTION, connOpPackageName));
+    sp<SensorEventConnection> result(new SensorEventConnection(this, uid, packageName,
+            requestedMode == DATA_INJECTION, opPackageName));
     if (requestedMode == DATA_INJECTION) {
         if (mActiveConnections.indexOf(result) < 0) {
             mActiveConnections.add(result);
@@ -959,178 +944,6 @@ int SensorService::isDataInjectionEnabled() {
     return (mCurrentOperatingMode == DATA_INJECTION);
 }
 
-sp<ISensorEventConnection> SensorService::createSensorDirectConnection(
-        const String16& opPackageName, uint32_t size, int32_t type, int32_t format,
-        const native_handle *resource) {
-    Mutex::Autolock _l(mLock);
-
-    struct sensors_direct_mem_t mem = {
-        .type = type,
-        .format = format,
-        .size = size,
-        .handle = resource,
-    };
-    uid_t uid = IPCThreadState::self()->getCallingUid();
-
-    if (mem.handle == nullptr) {
-        ALOGE("Failed to clone resource handle");
-        return nullptr;
-    }
-
-    // check format
-    if (format != SENSOR_DIRECT_FMT_SENSORS_EVENT) {
-        ALOGE("Direct channel format %d is unsupported!", format);
-        return nullptr;
-    }
-
-    // check for duplication
-    for (auto &i : mDirectConnections) {
-        sp<SensorDirectConnection> connection(i.promote());
-        if (connection != nullptr && connection->isEquivalent(&mem)) {
-            ALOGE("Duplicate create channel request for the same share memory");
-            return nullptr;
-        }
-    }
-
-    // check specific to memory type
-    switch(type) {
-        case SENSOR_DIRECT_MEM_TYPE_ASHMEM: { // channel backed by ashmem
-            int fd = resource->data[0];
-            int size2 = ashmem_get_size_region(fd);
-            // check size consistency
-            if (size2 < static_cast<int>(size)) {
-                ALOGE("Ashmem direct channel size %" PRIu32 " greater than shared memory size %d",
-                      size, size2);
-                return nullptr;
-            }
-            break;
-        }
-        case SENSOR_DIRECT_MEM_TYPE_GRALLOC:
-            // no specific checks for gralloc
-            break;
-        default:
-            ALOGE("Unknown direct connection memory type %d", type);
-            return nullptr;
-    }
-
-    native_handle_t *clone = native_handle_clone(resource);
-    if (!clone) {
-        return nullptr;
-    }
-
-    SensorDirectConnection* conn = nullptr;
-    SensorDevice& dev(SensorDevice::getInstance());
-    int channelHandle = dev.registerDirectChannel(&mem);
-
-    if (channelHandle <= 0) {
-        ALOGE("SensorDevice::registerDirectChannel returns %d", channelHandle);
-    } else {
-        mem.handle = clone;
-        conn = new SensorDirectConnection(this, uid, &mem, channelHandle, opPackageName);
-    }
-
-    if (conn == nullptr) {
-        native_handle_close(clone);
-        native_handle_delete(clone);
-    } else {
-        // add to list of direct connections
-        // sensor service should never hold pointer or sp of SensorDirectConnection object.
-        mDirectConnections.add(wp<SensorDirectConnection>(conn));
-    }
-    return conn;
-}
-
-int SensorService::setOperationParameter(
-            int32_t handle, int32_t type,
-            const Vector<float> &floats, const Vector<int32_t> &ints) {
-    Mutex::Autolock _l(mLock);
-
-    if (!checkCallingPermission(sLocationHardwarePermission, nullptr, nullptr)) {
-        return PERMISSION_DENIED;
-    }
-
-    bool isFloat = true;
-    bool isCustom = false;
-    size_t expectSize = INT32_MAX;
-    switch (type) {
-        case AINFO_LOCAL_GEOMAGNETIC_FIELD:
-            isFloat = true;
-            expectSize = 3;
-            break;
-        case AINFO_LOCAL_GRAVITY:
-            isFloat = true;
-            expectSize = 1;
-            break;
-        case AINFO_DOCK_STATE:
-        case AINFO_HIGH_PERFORMANCE_MODE:
-        case AINFO_MAGNETIC_FIELD_CALIBRATION:
-            isFloat = false;
-            expectSize = 1;
-            break;
-        default:
-            // CUSTOM events must only contain float data; it may have variable size
-            if (type < AINFO_CUSTOM_START || type >= AINFO_DEBUGGING_START ||
-                    ints.size() ||
-                    sizeof(additional_info_event_t::data_float)/sizeof(float) < floats.size() ||
-                    handle < 0) {
-                return BAD_VALUE;
-            }
-            isFloat = true;
-            isCustom = true;
-            expectSize = floats.size();
-            break;
-    }
-
-    if (!isCustom && handle != -1) {
-        return BAD_VALUE;
-    }
-
-    // three events: first one is begin tag, last one is end tag, the one in the middle
-    // is the payload.
-    sensors_event_t event[3];
-    int64_t timestamp = elapsedRealtimeNano();
-    for (sensors_event_t* i = event; i < event + 3; i++) {
-        *i = (sensors_event_t) {
-            .version = sizeof(sensors_event_t),
-            .sensor = handle,
-            .type = SENSOR_TYPE_ADDITIONAL_INFO,
-            .timestamp = timestamp++,
-            .additional_info = (additional_info_event_t) {
-                .serial = 0
-            }
-        };
-    }
-
-    event[0].additional_info.type = AINFO_BEGIN;
-    event[1].additional_info.type = type;
-    event[2].additional_info.type = AINFO_END;
-
-    if (isFloat) {
-        if (floats.size() != expectSize) {
-            return BAD_VALUE;
-        }
-        for (size_t i = 0; i < expectSize; ++i) {
-            event[1].additional_info.data_float[i] = floats[i];
-        }
-    } else {
-        if (ints.size() != expectSize) {
-            return BAD_VALUE;
-        }
-        for (size_t i = 0; i < expectSize; ++i) {
-            event[1].additional_info.data_int32[i] = ints[i];
-        }
-    }
-
-    SensorDevice& dev(SensorDevice::getInstance());
-    for (sensors_event_t* i = event; i < event + 3; i++) {
-        int ret = dev.injectSensorData(i);
-        if (ret != NO_ERROR) {
-            return ret;
-        }
-    }
-    return NO_ERROR;
-}
-
 status_t SensorService::resetToNormalMode() {
     Mutex::Autolock _l(mLock);
     return resetToNormalModeLocked();
@@ -1138,11 +951,9 @@ status_t SensorService::resetToNormalMode() {
 
 status_t SensorService::resetToNormalModeLocked() {
     SensorDevice& dev(SensorDevice::getInstance());
+    dev.enableAllSensors();
     status_t err = dev.setMode(NORMAL);
-    if (err == NO_ERROR) {
-        mCurrentOperatingMode = NORMAL;
-        dev.enableAllSensors();
-    }
+    mCurrentOperatingMode = NORMAL;
     return err;
 }
 
@@ -1190,18 +1001,11 @@ void SensorService::cleanupConnection(SensorEventConnection* c) {
     dev.notifyConnectionDestroyed(c);
 }
 
-void SensorService::cleanupConnection(SensorDirectConnection* c) {
-    Mutex::Autolock _l(mLock);
-
-    SensorDevice& dev(SensorDevice::getInstance());
-    dev.unregisterDirectChannel(c->getHalChannelHandle());
-    mDirectConnections.remove(c);
-}
-
 sp<SensorInterface> SensorService::getSensorInterfaceFromHandle(int handle) const {
     return mSensors.getInterface(handle);
 }
 
+
 status_t SensorService::enable(const sp<SensorEventConnection>& connection,
         int handle, nsecs_t samplingPeriodNs, nsecs_t maxBatchReportLatencyNs, int reservedFlags,
         const String16& opPackageName) {
@@ -1215,7 +1019,7 @@ status_t SensorService::enable(const sp<SensorEventConnection>& connection,
     }
 
     Mutex::Autolock _l(mLock);
-    if (mCurrentOperatingMode != NORMAL
+    if ((mCurrentOperatingMode == RESTRICTED || mCurrentOperatingMode == DATA_INJECTION)
            && !isWhiteListedPackage(connection->getPackageName())) {
         return INVALID_OPERATION;
     }
@@ -1271,12 +1075,6 @@ status_t SensorService::enable(const sp<SensorEventConnection>& connection,
             handle, connection.get());
     }
 
-    // Check maximum delay for the sensor.
-    nsecs_t maxDelayNs = sensor->getSensor().getMaxDelay() * 1000LL;
-    if (maxDelayNs > 0 && (samplingPeriodNs > maxDelayNs)) {
-        samplingPeriodNs = maxDelayNs;
-    }
-
     nsecs_t minDelayNs = sensor->getSensor().getMinDelayNs();
     if (samplingPeriodNs < minDelayNs) {
         samplingPeriodNs = minDelayNs;
@@ -1315,10 +1113,18 @@ status_t SensorService::enable(const sp<SensorEventConnection>& connection,
 
     if (err == NO_ERROR) {
         connection->updateLooperRegistration(mLooper);
-
-        mLastNSensorRegistrations.editItemAt(mNextSensorRegIndex) =
-                SensorRegistrationInfo(handle, connection->getPackageName(),
-                                       samplingPeriodNs, maxBatchReportLatencyNs, true);
+        SensorRegistrationInfo &reg_info =
+            mLastNSensorRegistrations.editItemAt(mNextSensorRegIndex);
+        reg_info.mSensorHandle = handle;
+        reg_info.mSamplingRateUs = samplingPeriodNs/1000;
+        reg_info.mMaxReportLatencyUs = maxBatchReportLatencyNs/1000;
+        reg_info.mActivated = true;
+        reg_info.mPackageName = connection->getPackageName();
+        time_t rawtime = time(NULL);
+        struct tm * timeinfo = localtime(&rawtime);
+        reg_info.mHour = timeinfo->tm_hour;
+        reg_info.mMin = timeinfo->tm_min;
+        reg_info.mSec = timeinfo->tm_sec;
         mNextSensorRegIndex = (mNextSensorRegIndex + 1) % SENSOR_REGISTRATIONS_BUF_SIZE;
     }
 
@@ -1341,8 +1147,16 @@ status_t SensorService::disable(const sp<SensorEventConnection>& connection, int
 
     }
     if (err == NO_ERROR) {
-        mLastNSensorRegistrations.editItemAt(mNextSensorRegIndex) =
-                SensorRegistrationInfo(handle, connection->getPackageName(), 0, 0, false);
+        SensorRegistrationInfo &reg_info =
+            mLastNSensorRegistrations.editItemAt(mNextSensorRegIndex);
+        reg_info.mActivated = false;
+        reg_info.mPackageName= connection->getPackageName();
+        reg_info.mSensorHandle = handle;
+        time_t rawtime = time(NULL);
+        struct tm * timeinfo = localtime(&rawtime);
+        reg_info.mHour = timeinfo->tm_hour;
+        reg_info.mMin = timeinfo->tm_min;
+        reg_info.mSec = timeinfo->tm_sec;
         mNextSensorRegIndex = (mNextSensorRegIndex + 1) % SENSOR_REGISTRATIONS_BUF_SIZE;
     }
     return err;
@@ -1523,13 +1337,5 @@ bool SensorService::isWhiteListedPackage(const String8& packageName) {
     return (packageName.contains(mWhiteListedPackage.string()));
 }
 
-bool SensorService::isOperationRestricted(const String16& opPackageName) {
-    Mutex::Autolock _l(mLock);
-    if (mCurrentOperatingMode != RESTRICTED) {
-        String8 package(opPackageName);
-        return !isWhiteListedPackage(package);
-    }
-    return false;
-}
-
 }; // namespace android
+
diff --git a/services/sensorservice/SensorService.h b/services/sensorservice/SensorService.h
index 3e183942f..3ed7b9769 100644
--- a/services/sensorservice/SensorService.h
+++ b/services/sensorservice/SensorService.h
@@ -49,9 +49,9 @@
 #define IGNORE_HARDWARE_FUSION  false
 #define DEBUG_CONNECTIONS   false
 // Max size is 100 KB which is enough to accept a batch of about 1000 events.
-#define MAX_SOCKET_BUFFER_SIZE_BATCHED (100 * 1024)
+#define MAX_SOCKET_BUFFER_SIZE_BATCHED 100 * 1024
 // For older HALs which don't support batching, use a smaller socket buffer size.
-#define SOCKET_BUFFER_SIZE_NON_BATCHED (4 * 1024)
+#define SOCKET_BUFFER_SIZE_NON_BATCHED 4 * 1024
 
 #define SENSOR_REGISTRATIONS_BUF_SIZE 200
 
@@ -67,11 +67,9 @@ class SensorService :
 {
     // nested class/struct for internal use
     class SensorEventConnection;
-    class SensorDirectConnection;
 
 public:
     void cleanupConnection(SensorEventConnection* connection);
-    void cleanupConnection(SensorDirectConnection* c);
 
     status_t enable(const sp<SensorEventConnection>& connection, int handle,
                     nsecs_t samplingPeriodNs,  nsecs_t maxBatchReportLatencyNs, int reservedFlags,
@@ -91,7 +89,7 @@ class SensorService :
     // nested class/struct for internal use
     class SensorRecord;
     class SensorEventAckReceiver;
-    class SensorRegistrationInfo;
+    struct SensorRegistrationInfo;
 
     enum Mode {
        // The regular operating mode where any application can register/unregister/call flush on
@@ -156,10 +154,6 @@ class SensorService :
             const String8& packageName,
             int requestedMode, const String16& opPackageName);
     virtual int isDataInjectionEnabled();
-    virtual sp<ISensorEventConnection> createSensorDirectConnection(const String16& opPackageName,
-            uint32_t size, int32_t type, int32_t format, const native_handle *resource);
-    virtual int setOperationParameter(
-            int32_t handle, int32_t type, const Vector<float> &floats, const Vector<int32_t> &ints);
     virtual status_t dump(int fd, const Vector<String16>& args);
 
     String8 getSensorName(int handle) const;
@@ -209,7 +203,6 @@ class SensorService :
     // allowed to register for or call flush on sensors. Typically only cts test packages are
     // allowed.
     bool isWhiteListedPackage(const String8& packageName);
-    bool isOperationRestricted(const String16& opPackageName);
 
     // Reset the state of SensorService to NORMAL mode.
     status_t resetToNormalMode();
@@ -246,7 +239,6 @@ class SensorService :
     sensors_event_t *mSensorEventBuffer, *mSensorEventScratch;
     wp<const SensorEventConnection> * mMapFlushEventsToConnections;
     std::unordered_map<int, RecentEventLogger*> mRecentEvent;
-    SortedVector< wp<SensorDirectConnection> > mDirectConnections;
     Mode mCurrentOperatingMode;
 
     // This packagaName is set when SensorService is in RESTRICTED or DATA_INJECTION mode. Only
diff --git a/services/sensorservice/SensorServiceUtils.cpp b/services/sensorservice/SensorServiceUtils.cpp
index 34cd8ddd7..1996a00ed 100644
--- a/services/sensorservice/SensorServiceUtils.cpp
+++ b/services/sensorservice/SensorServiceUtils.cpp
@@ -54,7 +54,6 @@ size_t eventSizeBySensorType(int type) {
         case SENSOR_TYPE_STATIONARY_DETECT:
         case SENSOR_TYPE_MOTION_DETECT:
         case SENSOR_TYPE_HEART_BEAT:
-        case SENSOR_TYPE_LOW_LATENCY_OFFBODY_DETECT:
             return 1;
 
         default:
diff --git a/services/sensorservice/mat.h b/services/sensorservice/mat.h
index 495c14e67..a76fc91cb 100644
--- a/services/sensorservice/mat.h
+++ b/services/sensorservice/mat.h
@@ -139,13 +139,13 @@ class mat : public vec< vec<TYPE, R>, C > {
 
     mat() { }
     mat(const mat& rhs)  : base(rhs) { }
-    mat(const base& rhs) : base(rhs) { }  // NOLINT(implicit)
+    mat(const base& rhs) : base(rhs) { }
 
     // -----------------------------------------------------------------------
     // conversion constructors
 
     // sets the diagonal to the value, off-diagonal to zero
-    mat(pTYPE rhs) {  // NOLINT(implicit)
+    mat(pTYPE rhs) {
         helpers::doAssign(*this, rhs);
     }
 
@@ -220,7 +220,7 @@ class mat : public vec< vec<TYPE, R>, C > {
     template<size_t PREV_COLUMN>
     struct column_builder {
         mat& matrix;
-        explicit column_builder(mat& matrix) : matrix(matrix) { }
+        column_builder(mat& matrix) : matrix(matrix) { }
     };
 
     // operator << is not a method of column_builder<> so we can
@@ -265,9 +265,9 @@ class mat<TYPE, 1, R> : public vec<TYPE, R> {
     enum { ROWS = R, COLS = 1 };
 
     mat() { }
-    explicit mat(const base& rhs) : base(rhs) { }
+    mat(const base& rhs) : base(rhs) { }
     mat(const mat& rhs) : base(rhs) { }
-    explicit mat(const TYPE& rhs) { helpers::doAssign(*this, rhs); }
+    mat(const TYPE& rhs) { helpers::doAssign(*this, rhs); }
     mat& operator=(const mat& rhs) { base::operator=(rhs); return *this; }
     mat& operator=(const base& rhs) { base::operator=(rhs); return *this; }
     mat& operator=(const TYPE& rhs) { return helpers::doAssign(*this, rhs); }
diff --git a/services/sensorservice/vec.h b/services/sensorservice/vec.h
index 9e5d2809c..a142bad3a 100644
--- a/services/sensorservice/vec.h
+++ b/services/sensorservice/vec.h
@@ -322,12 +322,12 @@ class vec : public vbase<TYPE, SIZE>
 
     vec() { }
     vec(const vec& rhs)  : base(rhs) { }
-    vec(const base& rhs) : base(rhs) { }  // NOLINT(implicit)
+    vec(const base& rhs) : base(rhs) { }
 
     // -----------------------------------------------------------------------
     // conversion constructors
 
-    vec(pTYPE rhs) {  // NOLINT(implicit)
+    vec(pTYPE rhs) {
         for (size_t i=0 ; i<SIZE ; i++)
             base::operator[](i) = rhs;
     }
diff --git a/services/sensorservice/SensorService.cpp b/services/sensorservice/SensorService.cpp
index 9a3da2699..d8e08775a 100644
--- a/services/sensorservice/SensorService.cpp
+++ b/services/sensorservice/SensorService.cpp
@@ -274,8 +274,10 @@ void SensorService::onFirstRef() {
             mAckReceiver->run("SensorEventAckReceiver", PRIORITY_URGENT_DISPLAY);
             run("SensorService", PRIORITY_URGENT_DISPLAY);
 
+#ifndef HARDWARE_FIFO_SENSOR_SERVICE
             // priority can only be changed after run
             enableSchedFifoMode();
+#endif
         }
     }
 }
