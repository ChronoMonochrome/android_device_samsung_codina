From f0d93fac3508b8a70a6d86a40a3813903b9991e7 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Sun, 4 Sep 2016 21:35:39 +0700
Subject: [PATCH 7/7] Revert "native fix: always assume STE_HARDWARE defined"

This reverts commit ce6dcb1c572bb6cdea68109b58bff75127fced42.

Change-Id: Icda58c2e27badaa9e28edf5b3c16d58cabe72cc6
---
 include/binder/MemoryBase.h               |  2 ++
 include/binder/Parcel.h                   | 42 +++++++++++++++++++++++++++
 include/gui/BufferQueue.h                 |  2 ++
 include/gui/ConsumerBase.h                |  2 ++
 include/gui/GLConsumer.h                  | 10 +++++++
 include/gui/IGraphicBufferProducer.h      |  5 ++++
 include/media/openmax/OMX_IVCommon.h      |  2 ++
 include/ui/Fence.h                        |  4 +++
 include/ui/GraphicBuffer.h                |  8 ++++++
 include/ui/PixelFormat.h                  |  2 ++
 include/ui/Region.h                       |  4 +++
 libs/binder/MemoryBase.cpp                |  4 +++
 libs/binder/Parcel.cpp                    |  4 +++
 libs/gui/GLConsumer.cpp                   | 16 +++++++++++
 opengl/include/EGL/eglext.h               | 15 ++++++++++
 opengl/libs/EGL/eglApi.cpp                | 48 +++++++++++++++++++++++++++++++
 opengl/libs/EGL/egl_entries.in            |  7 +++++
 services/surfaceflinger/DisplayDevice.cpp | 19 ++++++++++++
 services/surfaceflinger/DisplayDevice.h   |  3 ++
 19 files changed, 199 insertions(+)

diff --git a/include/binder/MemoryBase.h b/include/binder/MemoryBase.h
index f55f7a9..5bf104b 100644
--- a/include/binder/MemoryBase.h
+++ b/include/binder/MemoryBase.h
@@ -38,7 +38,9 @@ protected:
     size_t getSize() const { return mSize; }
     ssize_t getOffset() const { return mOffset; }
     const sp<IMemoryHeap>& getHeap() const { return mHeap; }
+#ifdef STE_HARDWARE
     virtual sp<IMemoryHeap> getMemory(long* offset, unsigned int* size) const;
+#endif
 
 private:
     size_t          mSize;
diff --git a/include/binder/Parcel.h b/include/binder/Parcel.h
index fce5da2..20d4974 100644
--- a/include/binder/Parcel.h
+++ b/include/binder/Parcel.h
@@ -36,7 +36,11 @@
 namespace android {
 
 template <typename T> class LightFlattenable;
+#ifdef STE_HARDWARE
 class Flattenable;
+#else
+template <typename T> class Flattenable;
+#endif
 class IBinder;
 class IPCThreadState;
 class ProcessState;
@@ -160,7 +164,12 @@ public:
 
     status_t            writeParcelable(const Parcelable& parcelable);
 
+#ifdef STE_HARDWARE
     status_t            write(const Flattenable& val);
+#else
+    template<typename T>
+    status_t            write(const Flattenable<T>& val);
+#endif
 
     template<typename T>
     status_t            write(const LightFlattenable<T>& val);
@@ -293,7 +302,12 @@ public:
                             std::unique_ptr<std::vector<std::unique_ptr<std::string>>>* val) const;
     status_t            readUtf8VectorFromUtf16Vector(std::vector<std::string>* val) const;
 
+#ifdef STE_HARDWARE
     status_t            read(Flattenable& val) const;
+#else
+    template<typename T>
+    status_t            read(Flattenable<T>& val) const;
+#endif
 
     template<typename T>
     status_t            read(LightFlattenable<T>& val) const;
@@ -457,10 +471,18 @@ private:
         virtual status_t unflatten(void const* buffer, size_t size, int const* fds, size_t count) = 0;
     };
 
+#ifndef STE_HARDWARE
+    template<typename T>
+#endif
     class FlattenableHelper : public FlattenableHelperInterface {
         friend class Parcel;
+#ifdef STE_HARDWARE
         const Flattenable& val;
         explicit FlattenableHelper(const Flattenable& val) : val(val) { }
+#else
+        const Flattenable<T>& val;
+        explicit FlattenableHelper(const Flattenable<T>& val) : val(val) { }
+#endif
 
     public:
         virtual size_t getFlattenedSize() const {
@@ -473,7 +495,11 @@ private:
             return val.flatten(buffer, size, fds, count);
         }
         virtual status_t unflatten(void const* buffer, size_t size, int const* fds, size_t count) {
+#ifdef STE_HARDWARE
             return const_cast<Flattenable&>(val).unflatten(buffer, size, fds, count);
+#else
+            return const_cast<Flattenable<T>&>(val).unflatten(buffer, size, fds, count);
+#endif
         }
     };
     status_t write(const FlattenableHelperInterface& val);
@@ -506,6 +532,14 @@ public:
 
 // ---------------------------------------------------------------------------
 
+#ifndef STE_HARDWARE
+template<typename T>
+status_t Parcel::write(const Flattenable<T>& val) {
+    const FlattenableHelper<T> helper(val);
+    return write(helper);
+}
+#endif
+
 template<typename T>
 status_t Parcel::write(const LightFlattenable<T>& val) {
     size_t size(val.getFlattenedSize());
@@ -524,6 +558,14 @@ status_t Parcel::write(const LightFlattenable<T>& val) {
     return NO_ERROR;
 }
 
+#ifndef STE_HARDWARE
+template<typename T>
+status_t Parcel::read(Flattenable<T>& val) const {
+    FlattenableHelper<T> helper(val);
+    return read(helper);
+}
+#endif
+
 template<typename T>
 status_t Parcel::read(LightFlattenable<T>& val) const {
     size_t size;
diff --git a/include/gui/BufferQueue.h b/include/gui/BufferQueue.h
index 3f8c0e6..dacdf9e 100644
--- a/include/gui/BufferQueue.h
+++ b/include/gui/BufferQueue.h
@@ -42,7 +42,9 @@ public:
         PRESENT_LATER = IGraphicBufferConsumer::PRESENT_LATER,
     };
 
+#ifdef STE_HARDWARE
     enum { NUM_BLIT_BUFFER_SLOTS = 2 };
+#endif
 
     // When in async mode we reserve two slots in order to guarantee that the
     // producer and consumer can run asynchronously.
diff --git a/include/gui/ConsumerBase.h b/include/gui/ConsumerBase.h
index 9e4086a..19158ac 100644
--- a/include/gui/ConsumerBase.h
+++ b/include/gui/ConsumerBase.h
@@ -179,7 +179,9 @@ protected:
             EGLDisplay display, EGLSyncKHR eglFence);
 
     // returns true if the slot still has the graphicBuffer in it.
+#ifdef STE_HARDWARE
     virtual
+#endif
     bool stillTracking(int slot, const sp<GraphicBuffer> graphicBuffer);
 
     // addReleaseFence* adds the sync points associated with a fence to the set
diff --git a/include/gui/GLConsumer.h b/include/gui/GLConsumer.h
index 29092ab..6d82d55 100644
--- a/include/gui/GLConsumer.h
+++ b/include/gui/GLConsumer.h
@@ -30,8 +30,10 @@
 #include <utils/Vector.h>
 #include <utils/threads.h>
 
+#ifdef STE_HARDWARE
 #include <hardware/copybit.h>
 #include <gui/IGraphicBufferAlloc.h>
+#endif
 
 namespace android {
 // ----------------------------------------------------------------------------
@@ -92,8 +94,10 @@ public:
     GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t texureTarget,
             bool useFenceSync, bool isControlledByApp);
 
+#ifdef STE_HARDWARE
     // Method for closing copybit device while abandoning the surface 
     virtual ~GLConsumer();
+#endif
 
     // updateTexImage acquires the most recently queued buffer, and sets the
     // image contents of the target texture to it.
@@ -260,8 +264,10 @@ protected:
             const sp<GraphicBuffer> graphicBuffer,
             EGLDisplay display, EGLSyncKHR eglFence);
 
+#ifdef STE_HARDWARE
     // returns true if the slot still has the graphicBuffer in it.
     virtual bool stillTracking(int slot, const sp<GraphicBuffer> graphicBuffer);
+#endif
 
     status_t releaseBufferLocked(int slot,
             const sp<GraphicBuffer> graphicBuffer, EGLSyncKHR eglFence) {
@@ -338,8 +344,10 @@ private:
         EGLImageKHR createImage(EGLDisplay dpy,
                 const sp<GraphicBuffer>& graphicBuffer, const Rect& crop);
 
+#ifdef STE_HARDWARE
     // converts buffer to a suitable color format
     status_t convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf);
+#endif
 
         // Disallow copying
         EglImage(const EglImage& rhs);
@@ -496,6 +504,7 @@ private:
     // reset mCurrentTexture to INVALID_BUFFER_SLOT.
     int mCurrentTexture;
 
+#ifdef STE_HARDWARE
     // mBlitEngine is the handle to the copybit device which will be used in
     // case color transform is needed before the EGL image is created.
     copybit_device_t* mBlitEngine;
@@ -509,6 +518,7 @@ private:
     // filled in with the result of GLConsumer::updateAndReleaseLocked
     sp<GraphicBuffer> mBlitSlots[BufferQueue::NUM_BLIT_BUFFER_SLOTS];
     int mNextBlitSlot;
+#endif
 
     // mAttached indicates whether the ConsumerBase is currently attached to
     // an OpenGL ES context.  For legacy reasons, this is initialized to true,
diff --git a/include/gui/IGraphicBufferProducer.h b/include/gui/IGraphicBufferProducer.h
index 7439c11..68137f7 100644
--- a/include/gui/IGraphicBufferProducer.h
+++ b/include/gui/IGraphicBufferProducer.h
@@ -290,7 +290,12 @@ public:
     //              * the slot was enqueued without requesting a buffer
     //              * crop rect is out of bounds of the buffer dimensions
 
+#ifdef STE_HARDWARE
     struct QueueBufferInput : public Flattenable {
+#else
+    struct QueueBufferInput : public Flattenable<QueueBufferInput> {
+        friend class Flattenable<QueueBufferInput>;
+#endif
         inline QueueBufferInput(const Parcel& parcel);
         // timestamp - a monotonically increasing value in nanoseconds
         // isAutoTimestamp - if the timestamp was synthesized at queue time
diff --git a/include/media/openmax/OMX_IVCommon.h b/include/media/openmax/OMX_IVCommon.h
index a2f5418..7ce89ab 100644
--- a/include/media/openmax/OMX_IVCommon.h
+++ b/include/media/openmax/OMX_IVCommon.h
@@ -166,7 +166,9 @@ typedef enum OMX_COLOR_FORMATTYPE {
     OMX_COLOR_FormatYUV420Flexible = 0x7F420888,
 
     OMX_TI_COLOR_FormatYUV420PackedSemiPlanar = 0x7F000100,
+#ifdef STE_HARDWARE
     OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB = 0x7FA00000,
+#endif
     OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00,
     OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03,
     OMX_SEC_COLOR_FormatNV12Tiled = 0x7FC00002,
diff --git a/include/ui/Fence.h b/include/ui/Fence.h
index 095745d..69a8061 100644
--- a/include/ui/Fence.h
+++ b/include/ui/Fence.h
@@ -36,7 +36,11 @@ namespace android {
 // ===========================================================================
 
 class Fence
+#ifdef STE_HARDWARE
     : public LightRefBase<Fence>, public Flattenable
+#else
+    : public LightRefBase<Fence>, public Flattenable<Fence>
+#endif
 {
 public:
     static const sp<Fence> NO_FENCE;
diff --git a/include/ui/GraphicBuffer.h b/include/ui/GraphicBuffer.h
index 74a5ba4..ae8bac5 100644
--- a/include/ui/GraphicBuffer.h
+++ b/include/ui/GraphicBuffer.h
@@ -39,9 +39,17 @@ class GraphicBufferMapper;
 
 class GraphicBuffer
     : public ANativeObjectBase< ANativeWindowBuffer, GraphicBuffer,
+#ifdef STE_HARDWARE
     LightRefBase<GraphicBuffer> >,
       public Flattenable
+#else
+    RefBase >,
+      public Flattenable<GraphicBuffer>
+#endif
 {
+#ifndef STE_HARDWARE
+    friend class Flattenable<GraphicBuffer>;
+#endif
 public:
 
     enum {
diff --git a/include/ui/PixelFormat.h b/include/ui/PixelFormat.h
index 138f023..90f57cd 100644
--- a/include/ui/PixelFormat.h
+++ b/include/ui/PixelFormat.h
@@ -61,11 +61,13 @@ enum {
     PIXEL_FORMAT_RGBA_5551   = 6,                            // 16-bit ARGB
     PIXEL_FORMAT_RGBA_4444   = 7,                            // 16-bit ARGB
 
+#ifdef STE_HARDWARE
     // Added Support for YUV42XMBN,
     // Required for Copybit CC acceleration
     PIXEL_FORMAT_YCBCR42XMBN = HAL_PIXEL_FORMAT_YCBCR42XMBN,
     PIXEL_FORMAT_YCbCr_420_SP = HAL_PIXEL_FORMAT_YCbCr_420_SP,
     PIXEL_FORMAT_YCbCr_420_P = HAL_PIXEL_FORMAT_YCbCr_420_P,
+#endif
 
 };
 
diff --git a/include/ui/Region.h b/include/ui/Region.h
index 6f07f0a..383e8ed 100644
--- a/include/ui/Region.h
+++ b/include/ui/Region.h
@@ -25,7 +25,9 @@
 #include <ui/Rect.h>
 #include <utils/Flattenable.h>
 
+#ifdef STE_HARDWARE
 #include <hardware/copybit.h>
+#endif
 
 namespace android {
 // ---------------------------------------------------------------------------
@@ -213,6 +215,7 @@ Region& Region::operator += (const Point& pt) {
     return translateSelf(pt.x, pt.y);
 }
 // ---------------------------------------------------------------------------
+#ifdef STE_HARDWARE
 struct region_iterator : public copybit_region_t {
     region_iterator(const Region& region)
         : b(region.begin()), e(region.end()) {
@@ -230,6 +233,7 @@ private:
     mutable Region::const_iterator b;
     Region::const_iterator const e;
 };
+#endif
 // ---------------------------------------------------------------------------
 }; // namespace android
 
diff --git a/libs/binder/MemoryBase.cpp b/libs/binder/MemoryBase.cpp
index f9e7285..e6d6401 100644
--- a/libs/binder/MemoryBase.cpp
+++ b/libs/binder/MemoryBase.cpp
@@ -25,7 +25,9 @@ namespace android {
 
 // ---------------------------------------------------------------------------
 
+#ifdef STE_HARDWARE
 extern "C" void _ZN7android10MemoryBaseC2ERKNS_2spINS_11IMemoryHeapEEElj() __attribute__((alias("_ZN7android10MemoryBaseC1ERKNS_2spINS_11IMemoryHeapEEElj")));
+#endif
 
 MemoryBase::MemoryBase(const sp<IMemoryHeap>& heap,
         ssize_t offset, size_t size)
@@ -44,6 +46,7 @@ MemoryBase::~MemoryBase()
 {
 }
 
+#ifdef STE_HARDWARE
 sp<IMemoryHeap> android::MemoryBase::getMemory(long* offset, unsigned int* size) const
 {
     ssize_t offset_o;
@@ -56,6 +59,7 @@ sp<IMemoryHeap> android::MemoryBase::getMemory(long* offset, unsigned int* size)
 
     return res;
 }
+#endif
 
 // ---------------------------------------------------------------------------
 }; // namespace android
diff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp
index 0e92074..b9d3c23 100644
--- a/libs/binder/Parcel.cpp
+++ b/libs/binder/Parcel.cpp
@@ -1267,10 +1267,12 @@ status_t Parcel::writeDupImmutableBlobFileDescriptor(int fd)
     return writeDupFileDescriptor(fd);
 }
 
+#ifdef STE_HARDWARE
 status_t Parcel::write(const Flattenable& val) {
     const FlattenableHelper helper(val);
     return write(helper);
 }
+#endif
 
 status_t Parcel::write(const FlattenableHelperInterface& val)
 {
@@ -2060,10 +2062,12 @@ status_t Parcel::readBlob(size_t len, ReadableBlob* outBlob) const
     return NO_ERROR;
 }
 
+#ifdef STE_HARDWARE
 status_t Parcel::read(Flattenable& val) const {
     FlattenableHelper helper(val);
     return read(helper);
 }
+#endif
 
 status_t Parcel::read(FlattenableHelperInterface& val) const
 {
diff --git a/libs/gui/GLConsumer.cpp b/libs/gui/GLConsumer.cpp
index a5b827f..bb2f344 100644
--- a/libs/gui/GLConsumer.cpp
+++ b/libs/gui/GLConsumer.cpp
@@ -167,7 +167,9 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex,
     mEglDisplay(EGL_NO_DISPLAY),
     mEglContext(EGL_NO_CONTEXT),
     mCurrentTexture(BufferQueue::INVALID_BUFFER_SLOT),
+#ifdef STE_HARDWARE
     mNextBlitSlot(0),
+#endif
     mAttached(true)
 {
     GLC_LOGV("GLConsumer");
@@ -175,6 +177,7 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex,
     memcpy(mCurrentTransformMatrix, mtxIdentity,
             sizeof(mCurrentTransformMatrix));
 
+#ifdef STE_HARDWARE
     hw_module_t const* module;
     mBlitEngine = 0;
     if (hw_get_module(COPYBIT_HARDWARE_MODULE_ID, &module) == 0) {
@@ -187,6 +190,7 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex,
     if (mGraphicBufferAlloc == 0) {
         GLC_LOGE("createGraphicBufferAlloc() failed in SurfaceTexture()");
     }
+#endif
 
     mConsumer->setConsumerUsageBits(DEFAULT_USAGE_FLAGS);
 }
@@ -209,7 +213,9 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t texTarget,
     mEglDisplay(EGL_NO_DISPLAY),
     mEglContext(EGL_NO_CONTEXT),
     mCurrentTexture(BufferQueue::INVALID_BUFFER_SLOT),
+#ifdef STE_HARDWARE
     mNextBlitSlot(0),
+#endif
     mAttached(false)
 {
     GLC_LOGV("GLConsumer");
@@ -217,6 +223,7 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t texTarget,
     memcpy(mCurrentTransformMatrix, mtxIdentity,
             sizeof(mCurrentTransformMatrix));
 
+#ifdef STE_HARDWARE
     hw_module_t const* module;
     mBlitEngine = 0;
     if (hw_get_module(COPYBIT_HARDWARE_MODULE_ID, &module) == 0) {
@@ -229,10 +236,12 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t texTarget,
     if (mGraphicBufferAlloc == 0) {
         GLC_LOGE("createGraphicBufferAlloc() failed in SurfaceTexture()");
     }
+#endif
 
     mConsumer->setConsumerUsageBits(DEFAULT_USAGE_FLAGS);
 }
 
+#ifdef STE_HARDWARE
 GLConsumer::~GLConsumer() {
     GLC_LOGV("~GLConsumer");
     abandon();
@@ -241,6 +250,7 @@ GLConsumer::~GLConsumer() {
         copybit_close(mBlitEngine);
     }
 }
+#endif
 
 status_t GLConsumer::setDefaultBufferSize(uint32_t w, uint32_t h)
 {
@@ -433,6 +443,7 @@ status_t GLConsumer::releaseBufferLocked(int buf,
     return err;
 }
 
+#ifdef STE_HARDWARE
 bool GLConsumer::stillTracking(int slot,
         const sp<GraphicBuffer> graphicBuffer) {
     if (slot < 0 || slot >= BufferQueue::NUM_BUFFER_SLOTS) {
@@ -448,6 +459,7 @@ bool GLConsumer::stillTracking(int slot,
             (mBlitSlots[0] != NULL && mBlitSlots[0]->handle == graphicBuffer->handle) ||
             (mBlitSlots[1] != NULL && mBlitSlots[1]->handle == graphicBuffer->handle));
 }
+#endif
 
 status_t GLConsumer::updateAndReleaseLocked(const BufferItem& item,
         PendingRelease* pendingRelease)
@@ -472,6 +484,7 @@ status_t GLConsumer::updateAndReleaseLocked(const BufferItem& item,
         return err;
     }
 
+#ifdef STE_HARDWARE
     sp<GraphicBuffer> textureBuffer;
     if (mSlots[slot].mGraphicBuffer->getPixelFormat() == HAL_PIXEL_FORMAT_YCBCR42XMBN
      || mSlots[slot].mGraphicBuffer->getPixelFormat() == HAL_PIXEL_FORMAT_YCbCr_420_P) {
@@ -523,6 +536,7 @@ status_t GLConsumer::updateAndReleaseLocked(const BufferItem& item,
         mEglSlots[slot].mEglImage = new EglImage(textureBuffer);
         mNextBlitSlot = (mNextBlitSlot + 1) % BufferQueue::NUM_BLIT_BUFFER_SLOTS;
     } 
+#endif
 
     // Ensure we have a valid EglImageKHR for the slot, creating an EglImage
     // if nessessary, for the gralloc buffer currently in the slot in
@@ -1234,6 +1248,7 @@ void GLConsumer::dumpLocked(String8& result, const char* prefix) const
     ConsumerBase::dumpLocked(result, prefix);
 }
 
+#ifdef STE_HARDWARE
 status_t GLConsumer::convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf) {
 
     /* For some reason mBlitEngine is not being initialized in
@@ -1284,6 +1299,7 @@ status_t GLConsumer::convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBu
     }
     return OK;
 }
+#endif
 
 static void mtxMul(float out[16], const float a[16], const float b[16]) {
     out[0] = a[0]*b[0] + a[4]*b[1] + a[8]*b[2] + a[12]*b[3];
diff --git a/opengl/include/EGL/eglext.h b/opengl/include/EGL/eglext.h
index f8d3830..4ccdbb7 100644
--- a/opengl/include/EGL/eglext.h
+++ b/opengl/include/EGL/eglext.h
@@ -321,6 +321,21 @@ typedef EGLBoolean (EGLAPIENTRYP PFNEGLQUERYSURFACEPOINTERANGLEPROC) (EGLDisplay
 #define EGL_COVERAGE_SAMPLE_RESOLVE_NONE_NV	0x3133
 #endif
 
+#if KHRONOS_SUPPORT_INT64   /* EGLuint64NV requires 64-bit uint support */
+#ifndef STE_HARDWARE
+#ifndef EGL_NV_system_time
+#define EGL_NV_system_time 1
+typedef khronos_utime_nanoseconds_t EGLuint64NV;
+#ifdef EGL_EGLEXT_PROTOTYPES
+EGLAPI EGLuint64NV EGLAPIENTRY eglGetSystemTimeFrequencyNV(void);
+EGLAPI EGLuint64NV EGLAPIENTRY eglGetSystemTimeNV(void);
+#endif /* EGL_EGLEXT_PROTOTYPES */
+typedef EGLuint64NV (EGLAPIENTRYP PFNEGLGETSYSTEMTIMEFREQUENCYNVPROC) (void);
+typedef EGLuint64NV (EGLAPIENTRYP PFNEGLGETSYSTEMTIMENVPROC) (void);
+#endif
+#endif
+#endif
+
 #if KHRONOS_SUPPORT_INT64 /* EGLuint64KHR requires 64-bit uint support */
 #ifndef EGL_KHR_stream
 #define EGL_KHR_stream 1
diff --git a/opengl/libs/EGL/eglApi.cpp b/opengl/libs/EGL/eglApi.cpp
index 3593d8e..31efc11 100644
--- a/opengl/libs/EGL/eglApi.cpp
+++ b/opengl/libs/EGL/eglApi.cpp
@@ -157,6 +157,13 @@ static const extention_map_t sExtensionMap[] = {
     { "eglGetSyncAttribKHR",
             (__eglMustCastToProperFunctionPointerType)&eglGetSyncAttribKHR },
 
+#ifndef STE_HARDWARE
+    // EGL_NV_system_time
+    { "eglGetSystemTimeFrequencyNV",
+            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
+    { "eglGetSystemTimeNV",
+            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
+#endif
 
     // EGL_KHR_wait_sync
     { "eglWaitSyncKHR",
@@ -1873,6 +1880,47 @@ EGLClientBuffer eglCreateNativeClientBufferANDROID(const EGLint *attrib_list)
 }
 
 // ----------------------------------------------------------------------------
+// NVIDIA extensions
+// ----------------------------------------------------------------------------
+#ifndef STE_HARDWARE
+EGLuint64NV eglGetSystemTimeFrequencyNV()
+{
+    clearError();
+
+    if (egl_init_drivers() == EGL_FALSE) {
+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
+    }
+
+    EGLuint64NV ret = 0;
+    egl_connection_t* const cnx = &gEGLImpl;
+
+    if (cnx->dso && cnx->egl.eglGetSystemTimeFrequencyNV) {
+        return cnx->egl.eglGetSystemTimeFrequencyNV();
+    }
+
+    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
+}
+
+EGLuint64NV eglGetSystemTimeNV()
+{
+    clearError();
+
+    if (egl_init_drivers() == EGL_FALSE) {
+        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
+    }
+
+    EGLuint64NV ret = 0;
+    egl_connection_t* const cnx = &gEGLImpl;
+
+    if (cnx->dso && cnx->egl.eglGetSystemTimeNV) {
+        return cnx->egl.eglGetSystemTimeNV();
+    }
+
+    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
+}
+#endif
+
+// ----------------------------------------------------------------------------
 // Partial update extension
 // ----------------------------------------------------------------------------
 EGLBoolean eglSetDamageRegionKHR(EGLDisplay dpy, EGLSurface surface,
diff --git a/opengl/libs/EGL/egl_entries.in b/opengl/libs/EGL/egl_entries.in
index eda5645..5351154 100644
--- a/opengl/libs/EGL/egl_entries.in
+++ b/opengl/libs/EGL/egl_entries.in
@@ -82,6 +82,13 @@ EGL_ENTRY(EGLClientBuffer, eglGetRenderBufferANDROID, EGLDisplay, EGLSurface)
 EGL_ENTRY(EGLint, eglDupNativeFenceFDANDROID, EGLDisplay, EGLSyncKHR)
 EGL_ENTRY(EGLClientBuffer, eglCreateNativeClientBufferANDROID, const EGLint *)
 
+/* NVIDIA extensions */
+
+#ifndef STE_HARDWARE
+EGL_ENTRY(EGLuint64NV, eglGetSystemTimeFrequencyNV, void)
+EGL_ENTRY(EGLuint64NV, eglGetSystemTimeNV, void)
+#endif
+
 /* IMG extensions */
 
 EGL_ENTRY(EGLBoolean, eglHibernateProcessIMG, void)
diff --git a/services/surfaceflinger/DisplayDevice.cpp b/services/surfaceflinger/DisplayDevice.cpp
index 49d1063..ec275b4 100755
--- a/services/surfaceflinger/DisplayDevice.cpp
+++ b/services/surfaceflinger/DisplayDevice.cpp
@@ -30,7 +30,9 @@
 
 #include <ui/DisplayInfo.h>
 #include <ui/PixelFormat.h>
+#ifdef STE_HARDWARE
 #include <ui/FramebufferNativeWindow.h>
+#endif
 
 #include <gui/Surface.h>
 
@@ -104,7 +106,13 @@ DisplayDevice::DisplayDevice(
       mPowerMode(HWC_POWER_MODE_OFF),
       mActiveConfig(0)
 {
+#ifdef STE_HARDWARE
     ANativeWindow* const window = new FramebufferNativeWindow();
+#else
+    Surface* surface;
+    mNativeWindow = surface = new Surface(producer, false);
+    ANativeWindow* const window = mNativeWindow.get();
+#endif
     char property[PROPERTY_VALUE_MAX];
 
     /*
@@ -500,7 +508,12 @@ void DisplayDevice::setDisplaySize(const int newWidth, const int newHeight) {
 
     mDisplaySurface->resizeBuffers(newWidth, newHeight);
 
+#ifdef STE_HARDWARE
     ANativeWindow* const window = new FramebufferNativeWindow();
+#else
+    mNativeWindow = new Surface(producer, false);
+    ANativeWindow* const window = mNativeWindow.get();
+#endif
     mSurface = eglCreateWindowSurface(mDisplay, mConfig, window, NULL);
     eglQuerySurface(mDisplay, mSurface, EGL_WIDTH,  &mDisplayWidth);
     eglQuerySurface(mDisplay, mSurface, EGL_HEIGHT, &mDisplayHeight);
@@ -615,12 +628,18 @@ void DisplayDevice::dump(String8& result) const {
     result.appendFormat(
         "+ DisplayDevice: %s\n"
         "   type=%x, hwcId=%d, layerStack=%u, (%4dx%4d),"
+#ifndef STE_HARDWARE
+	" ANativeWindow=%p,"
+#endif
 	" orient=%2d (type=%08x),\n"
         "flips=%u, isSecure=%d, powerMode=%d, activeConfig=%d, numLayers=%zu\n"
         "   v:[%d,%d,%d,%d], f:[%d,%d,%d,%d], s:[%d,%d,%d,%d],"
         "transform:[[%0.3f,%0.3f,%0.3f][%0.3f,%0.3f,%0.3f][%0.3f,%0.3f,%0.3f]]\n",
         mDisplayName.string(), mType, mHwcDisplayId,
         mLayerStack, mDisplayWidth, mDisplayHeight, 
+#ifndef STE_HARDWARE
+	mNativeWindow.get(),
+#endif
         mOrientation, tr.getType(), getPageFlipCount(),
         mIsSecure, mPowerMode, mActiveConfig,
         mVisibleLayersSortedByZ.size(),
diff --git a/services/surfaceflinger/DisplayDevice.h b/services/surfaceflinger/DisplayDevice.h
index 2a6d838..2e60aa0 100644
--- a/services/surfaceflinger/DisplayDevice.h
+++ b/services/surfaceflinger/DisplayDevice.h
@@ -211,6 +211,9 @@ private:
     wp<IBinder> mDisplayToken;
 
     // ANativeWindow this display is rendering into
+#ifndef STE_HARDWARE
+    sp<ANativeWindow> mNativeWindow;
+#endif
     sp<DisplaySurface> mDisplaySurface;
 
     EGLConfig       mConfig;
-- 
2.5.0

