From 84928157671c7b3316d8b96177611dd92c33b119 Mon Sep 17 00:00:00 2001
From: OliverG96 <oliverarafo@gmail.com>
Date: Mon, 29 Jul 2013 19:01:18 +0100
Subject: [PATCH 1/2] native: Add support for STE multimedia - Part 1

Change-Id: I3f22fe921828f08e86497b9ff81509377846856f
---
 include/gui/BufferQueue.h            |  16 +++
 include/gui/SurfaceTexture.h         |  73 +++++++++++
 include/media/openmax/OMX_IVCommon.h |   3 +
 include/ui/PixelFormat.h             |  14 ++
 include/ui/Region.h                  |  27 ++++
 libs/gui/Android.mk                  |   1 +
 libs/gui/BufferQueue.cpp             |  47 +++++++
 libs/gui/SurfaceTexture.cpp          | 242 +++++++++++++++++++++++++++++++++++
 libs/ui/PixelFormat.cpp              |  11 ++
 services/surfaceflinger/Layer.cpp    |  16 +++
 10 files changed, 450 insertions(+)

diff --git a/include/gui/BufferQueue.h b/include/gui/BufferQueue.h
index cd38cfe..6b2f676 100644
--- a/include/gui/BufferQueue.h
+++ b/include/gui/BufferQueue.h
@@ -54,6 +54,9 @@ class BufferQueue : public BnSurfaceTexture {
 public:
     enum { MIN_UNDEQUEUED_BUFFERS = 2 };
     enum { NUM_BUFFER_SLOTS = 32 };
+#ifdef STE_HARDWARE
+    enum { NUM_BLIT_BUFFER_SLOTS = 2 };
+#endif
     enum { NO_CONNECTED_API = 0 };
     enum { INVALID_BUFFER_SLOT = -1 };
     enum { STALE_BUFFER_SLOT = 1, NO_BUFFER_AVAILABLE };
@@ -319,6 +322,12 @@ private:
     // for the given slot.
     void freeBufferLocked(int index);
 
+#ifdef STE_HARDWARE
+    // freeBlitBufferLocked frees the resources for mBlitSlots (both GraphicBuffer and EGLImage)
+    // for the given slot.
+    void freeBlitBufferLocked(int index);
+#endif
+
     // freeAllBuffersLocked frees the resources (both GraphicBuffer and
     // EGLImage) for all slots.
     void freeAllBuffersLocked();
@@ -479,6 +488,13 @@ private:
     // for a slot when requestBuffer is called with that slot's index.
     BufferSlot mSlots[NUM_BUFFER_SLOTS];
 
+#ifdef STE_HARDWARE
+    // mBlitSlots contains several buffers which will
+    // be rendered alternately in case color transform is needed (instead
+    // of rendering the buffers in mSlots).
+    BufferSlot mBlitSlots[NUM_BLIT_BUFFER_SLOTS];
+#endif
+
     // mDefaultWidth holds the default width of allocated buffers. It is used
     // in requestBuffers() if a width and height of zero is specified.
     uint32_t mDefaultWidth;
diff --git a/include/gui/SurfaceTexture.h b/include/gui/SurfaceTexture.h
index 7c519ae..89fbb4f 100644
--- a/include/gui/SurfaceTexture.h
+++ b/include/gui/SurfaceTexture.h
@@ -32,6 +32,11 @@
 #include <utils/Vector.h>
 #include <utils/threads.h>
 
+#ifdef STE_HARDWARE
+#include <hardware/copybit.h>
+#include <gui/IGraphicBufferAlloc.h>
+#endif
+
 #define ANDROID_GRAPHICS_SURFACETEXTURE_JNI_ID "mSurfaceTexture"
 
 namespace android {
@@ -82,6 +87,13 @@ public:
     // before issuing OpenGL ES commands that access the texture contents.
     status_t updateTexImage();
 
+#ifdef STE_HARDWARE
+    // convert() performs the deferred texture conversion as scheduled
+    // by updateTexImage(bool deferConversion).
+    // The method returns immediately if no conversion is necessary.
+    status_t convert();
+#endif
+
     // setReleaseFence stores a fence file descriptor that will signal when the
     // current buffer is no longer being read. This fence will be returned to
     // the producer when the current buffer is released by updateTexImage().
@@ -246,12 +258,27 @@ private:
         virtual ~BufferRejecter() { }
     };
     friend class Layer;
+#ifndef STE_HARDWARE
     status_t updateTexImage(BufferRejecter* rejecter, bool skipSync);
+#else
+    // A surface that uses a non-native format requires conversion of
+    // its buffers. This conversion can be deferred until the layer
+    // based on this surface is drawn.
+    status_t updateTexImage(BufferRejecter* rejecter, bool skipSync, bool deferConversion);
+#endif
 
     // createImage creates a new EGLImage from a GraphicBuffer.
     EGLImageKHR createImage(EGLDisplay dpy,
             const sp<GraphicBuffer>& graphicBuffer);
 
+#ifdef STE_HARDWARE
+    // returns TRUE if buffer needs color format conversion
+    bool conversionIsNeeded(const sp<GraphicBuffer>& graphicBuffer);
+
+    // converts buffer to a suitable color format
+    status_t convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf);
+#endif
+
     // freeBufferLocked frees up the given buffer slot.  If the slot has been
     // initialized this will release the reference to the GraphicBuffer in that
     // slot and destroy the EGLImage in that slot.  Otherwise it has no effect.
@@ -348,6 +375,10 @@ private:
           mEglFence(EGL_NO_SYNC_KHR) {
         }
 
+#ifdef STE_HARDWARE
+        sp<GraphicBuffer> mGraphicBuffer;
+#endif
+
         // mEglImage is the EGLImage created from mGraphicBuffer.
         EGLImageKHR mEglImage;
 
@@ -356,6 +387,14 @@ private:
         // to EGL_NO_SYNC_KHR when the buffer is created and (optionally, based
         // on a compile-time option) set to a new sync object in updateTexImage.
         EGLSyncKHR mEglFence;
+
+#ifdef STE_HARDWARE
+        // mEglDisplay is the EGLDisplay with which this SurfaceTexture is currently
+        // associated.  It is intialized to EGL_NO_DISPLAY and gets set to the
+        // current display when updateTexImage is called for the first time and when
+        // attachToContext is called.
+        EGLDisplay mEglDisplay;
+#endif
     };
 
     // mEglDisplay is the EGLDisplay with which this SurfaceTexture is currently
@@ -364,6 +403,40 @@ private:
     // attachToContext is called.
     EGLDisplay mEglDisplay;
 
+#ifdef STE_HARDWARE
+    // mBlitEngine is the handle to the copybit device which will be used in
+    // case color transform is needed before the EGL image is created.
+    copybit_device_t* mBlitEngine;
+
+    // mBlitSlots contains several buffers which will
+    // be rendered alternately in case color transform is needed (instead
+    // of rendering the buffers in mSlots).
+    EGLSlot mBlitSlots[BufferQueue::NUM_BLIT_BUFFER_SLOTS];
+
+    // mGraphicBufferAlloc is the connection to SurfaceFlinger that is used to
+    // allocate new GraphicBuffer objects.
+    sp<IGraphicBufferAlloc> mGraphicBufferAlloc;
+
+    // mNextBlitSlot is the index of the blitter buffer (in mBlitSlots) which
+    // will be used in the next color transform.
+    int mNextBlitSlot;
+
+    // mConversionSrcSlot designates the slot where source buffer
+    // for the last deferred updateTexImage is located.
+    int mConversionSrcSlot;
+
+    // mConversionBltSlot designates the slot where destination buffer
+    // for the last deferred updateTexImage is located.
+    int mConversionBltSlot;
+
+    // mNeedsConversion indicates that a format conversion is necessary
+    // before the layer based on this surface is drawn.
+    // This flag is set whenever updateTexImage() with deferred conversion
+    // is called. It is cleared once the layer is drawn,
+    // or when updateTexImage() w/o deferred conversion is called.
+    bool mNeedsConversion;
+#endif
+
     // mEglContext is the OpenGL ES context with which this SurfaceTexture is
     // currently associated.  It is initialized to EGL_NO_CONTEXT and gets set
     // to the current GL context when updateTexImage is called for the first
diff --git a/include/media/openmax/OMX_IVCommon.h b/include/media/openmax/OMX_IVCommon.h
index 24f91ce..3e33585 100644
--- a/include/media/openmax/OMX_IVCommon.h
+++ b/include/media/openmax/OMX_IVCommon.h
@@ -158,6 +158,9 @@ typedef enum OMX_COLOR_FORMATTYPE {
      * */
     OMX_COLOR_FormatAndroidOpaque = 0x7F000789,
     OMX_TI_COLOR_FormatYUV420PackedSemiPlanar = 0x7F000100,
+#ifdef STE_HARDWARE
+    OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB = 0x7FA00000,
+#endif
     OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00,
     OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03,
     OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar32m = 0x7FA30C04,
diff --git a/include/ui/PixelFormat.h b/include/ui/PixelFormat.h
index 9f3e267..4206fec 100644
--- a/include/ui/PixelFormat.h
+++ b/include/ui/PixelFormat.h
@@ -64,6 +64,20 @@ enum {
     PIXEL_FORMAT_RGBA_5551   = HAL_PIXEL_FORMAT_RGBA_5551,  // 16-bit ARGB
     PIXEL_FORMAT_RGBA_4444   = HAL_PIXEL_FORMAT_RGBA_4444,  // 16-bit ARGB
     PIXEL_FORMAT_A_8         = 8,                           // 8-bit A
+#ifdef STE_HARDWARE
+    PIXEL_FORMAT_YCbCr_422_SP = HAL_PIXEL_FORMAT_YCbCr_422_SP,
+    PIXEL_FORMAT_YCbCr_420_SP = HAL_PIXEL_FORMAT_YCbCr_420_SP,
+    PIXEL_FORMAT_YCbCr_422_P  = HAL_PIXEL_FORMAT_YCbCr_422_P,
+    PIXEL_FORMAT_YCbCr_420_P  = HAL_PIXEL_FORMAT_YCbCr_420_P,
+    PIXEL_FORMAT_YCrCb_422_SP = HAL_PIXEL_FORMAT_YCrCb_422_SP,
+    PIXEL_FORMAT_YCrCb_420_SP = HAL_PIXEL_FORMAT_YCrCb_420_SP,
+    PIXEL_FORMAT_YCrCb_422_P  = HAL_PIXEL_FORMAT_YCrCb_422_P,
+    PIXEL_FORMAT_YCrCb_420_P  = HAL_PIXEL_FORMAT_YCrCb_420_P,
+    /* STE: Added Support for YUV42XMBN, required for Copybit CC acceleration */
+    PIXEL_FORMAT_YCBCR42XMBN  = HAL_PIXEL_FORMAT_YCBCR42XMBN,
+    /* STE: Added for YCbCr422R -> RGB888 use-case */
+    PIXEL_FORMAT_YCbCr_422_I  = HAL_PIXEL_FORMAT_YCbCr_422_I,
+#endif
 };
 
 typedef int32_t PixelFormat;
diff --git a/include/ui/Region.h b/include/ui/Region.h
index 43a4450..ea211dc 100644
--- a/include/ui/Region.h
+++ b/include/ui/Region.h
@@ -23,6 +23,11 @@
 #include <utils/Vector.h>
 
 #include <ui/Rect.h>
+
+#ifdef STE_HARDWARE
+#include <hardware/copybit.h>
+#endif
+
 #include <utils/Flattenable.h>
 
 namespace android {
@@ -204,6 +209,28 @@ Region& Region::operator -= (const Region& rhs) {
 Region& Region::operator += (const Point& pt) {
     return translateSelf(pt.x, pt.y);
 }
+
+#ifdef STE_HARDWARE
+// ---------------------------------------------------------------------------
+
+struct region_iterator : public copybit_region_t {
+    region_iterator(const Region& region)
+        : b(region.begin()), e(region.end()) {
+        this->next = iterate;
+    }
+private:
+    static int iterate(copybit_region_t const * self, copybit_rect_t* rect) {
+        region_iterator const* me = static_cast<region_iterator const*>(self);
+        if (me->b != me->e) {
+            *reinterpret_cast<Rect*>(rect) = *me->b++;
+            return 1;
+        }
+        return 0;
+    }
+    mutable Region::const_iterator b;
+    Region::const_iterator const e;
+};
+#endif
 // ---------------------------------------------------------------------------
 }; // namespace android
 
diff --git a/libs/gui/Android.mk b/libs/gui/Android.mk
index 084ea0d..d278257 100644
--- a/libs/gui/Android.mk
+++ b/libs/gui/Android.mk
@@ -29,6 +29,7 @@ LOCAL_SRC_FILES:= \
 
 LOCAL_SHARED_LIBRARIES := \
 	libbinder \
+	libhardware \
 	libcutils \
 	libEGL \
 	libGLESv2 \
diff --git a/libs/gui/BufferQueue.cpp b/libs/gui/BufferQueue.cpp
index acf6cec..146044f 100644
--- a/libs/gui/BufferQueue.cpp
+++ b/libs/gui/BufferQueue.cpp
@@ -919,9 +919,31 @@ void BufferQueue::freeBufferLocked(int slot) {
         eglDestroySyncKHR(mSlots[slot].mEglDisplay, mSlots[slot].mEglFence);
         mSlots[slot].mEglFence = EGL_NO_SYNC_KHR;
     }
+
     mSlots[slot].mFence.clear();
 }
 
+#ifdef STE_HARDWARE
+void BufferQueue::freeBlitBufferLocked(int slot) {
+    ST_LOGV("freeBufferLocked: slot=%d", slot);
+    mBlitSlots[slot].mGraphicBuffer = 0;
+    if (mBlitSlots[slot].mBufferState == BufferSlot::ACQUIRED) {
+        mBlitSlots[slot].mNeedsCleanupOnRelease = true;
+    }
+    mBlitSlots[slot].mBufferState = BufferSlot::FREE;
+    mBlitSlots[slot].mFrameNumber = 0;
+    mBlitSlots[slot].mAcquireCalled = false;
+
+    // destroy fence as BufferQueue now takes ownership
+    if (mBlitSlots[slot].mEglFence != EGL_NO_SYNC_KHR) {
+        eglDestroySyncKHR(mBlitSlots[slot].mEglDisplay, mBlitSlots[slot].mEglFence);
+        mBlitSlots[slot].mEglFence = EGL_NO_SYNC_KHR;
+    }
+
+    mBlitSlots[slot].mFence.clear();
+}
+#endif
+
 void BufferQueue::freeAllBuffersLocked() {
     ALOGW_IF(!mQueue.isEmpty(),
             "freeAllBuffersLocked called but mQueue is not empty");
@@ -930,6 +952,11 @@ void BufferQueue::freeAllBuffersLocked() {
     for (int i = 0; i < NUM_BUFFER_SLOTS; i++) {
         freeBufferLocked(i);
     }
+#ifdef STE_HARDWARE
+    for (int i = 0; i < NUM_BLIT_BUFFER_SLOTS; i++) {
+        freeBlitBufferLocked(i);
+    }
+#endif
 }
 
 status_t BufferQueue::acquireBuffer(BufferItem *buffer) {
@@ -946,10 +973,30 @@ status_t BufferQueue::acquireBuffer(BufferItem *buffer) {
             numAcquiredBuffers++;
         }
     }
+
+#ifdef STE_HARDWARE
+    int numBlitAcquiredBuffers = 0;
+    for (int i = 0; i < NUM_BLIT_BUFFER_SLOTS; i++) {
+        if (mBlitSlots[i].mBufferState == BufferSlot::ACQUIRED) {
+            numBlitAcquiredBuffers++;
+        }
+    }
+#endif
+
     if (numAcquiredBuffers >= mMaxAcquiredBufferCount+1) {
+#ifdef STE_HARDWARE
+       // We assume we are using blit slots if the normal slots exceed the max count
+       // TODO: Make a way to check the one in use instead of checking both.
+        if (numBlitAcquiredBuffers >= mMaxAcquiredBufferCount+1) {
+            ST_LOGE("acquireBuffer: max acquired blit buffer count reached: %d (max=%d)",
+                    numBlitAcquiredBuffers, mMaxAcquiredBufferCount);
+            return INVALID_OPERATION;
+        }
+#else
         ST_LOGE("acquireBuffer: max acquired buffer count reached: %d (max=%d)",
                 numAcquiredBuffers, mMaxAcquiredBufferCount);
         return INVALID_OPERATION;
+#endif
     }
 
     // check if queue is empty
diff --git a/libs/gui/SurfaceTexture.cpp b/libs/gui/SurfaceTexture.cpp
index b4dfb5e..7c8a01d 100644
--- a/libs/gui/SurfaceTexture.cpp
+++ b/libs/gui/SurfaceTexture.cpp
@@ -126,16 +126,43 @@ SurfaceTexture::SurfaceTexture(GLuint tex, bool allowSynchronousMode,
     mUseFenceSync(false),
 #endif
     mTexTarget(texTarget),
+#ifdef STE_HARDWARE
+    mNextBlitSlot(0),
+    mNeedsConversion(false),
+#endif
     mEglDisplay(EGL_NO_DISPLAY),
     mEglContext(EGL_NO_CONTEXT),
     mCurrentTexture(BufferQueue::INVALID_BUFFER_SLOT),
     mAttached(true)
 {
+
+#ifdef STE_HARDWARE
+    sp<ISurfaceComposer> composer(ComposerService::getComposerService());
+    mGraphicBufferAlloc = composer->createGraphicBufferAlloc();
+    if (mGraphicBufferAlloc == 0) {
+        ST_LOGE("createGraphicBufferAlloc() failed in SurfaceTexture()");
+    }
+#endif
+
     ST_LOGV("SurfaceTexture");
 
     memcpy(mCurrentTransformMatrix, mtxIdentity,
             sizeof(mCurrentTransformMatrix));
 
+#ifdef STE_HARDWARE
+    for (int i = 0; i < BufferQueue::NUM_BLIT_BUFFER_SLOTS; i++) {
+        mBlitSlots[i].mEglImage = EGL_NO_IMAGE_KHR;
+        mBlitSlots[i].mEglDisplay = EGL_NO_DISPLAY;
+    }
+
+    hw_module_t const* module;
+    mBlitEngine = 0;
+    if (hw_get_module(COPYBIT_HARDWARE_MODULE_ID, &module) == 0) {
+        copybit_open(module, &mBlitEngine);
+    }
+    ALOGE_IF(!mBlitEngine, "Cannot open copybit mBlitEngine=%p", mBlitEngine);
+#endif
+
     mBufferQueue->setConsumerUsageBits(DEFAULT_USAGE_FLAGS);
 }
 
@@ -154,7 +181,12 @@ status_t SurfaceTexture::setDefaultBufferSize(uint32_t w, uint32_t h)
 }
 
 status_t SurfaceTexture::updateTexImage() {
+#ifndef STE_HARDWARE
     return SurfaceTexture::updateTexImage(NULL, false);
+#else
+    return SurfaceTexture::updateTexImage(NULL, false, false);
+#define STE_DEFERDBG 0
+#endif
 }
 
 status_t SurfaceTexture::acquireBufferLocked(BufferQueue::BufferItem *item) {
@@ -171,6 +203,7 @@ status_t SurfaceTexture::acquireBufferLocked(BufferQueue::BufferItem *item) {
         }
     }
 
+#ifndef STE_HARDWARE
     // Update the GL texture object. We may have to do this even when
     // item.mGraphicBuffer == NULL, if we destroyed the EGLImage when
     // detaching from a context but the buffer has not been re-allocated.
@@ -181,6 +214,7 @@ status_t SurfaceTexture::acquireBufferLocked(BufferQueue::BufferItem *item) {
         }
         mEglSlots[slot].mEglImage = image;
     }
+#endif
 
     return NO_ERROR;
 }
@@ -195,7 +229,11 @@ status_t SurfaceTexture::releaseBufferLocked(int buf, EGLDisplay display,
     return err;
 }
 
+#ifndef STE_HARDWARE
 status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool skipSync) {
+#else
+status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool skipSync, bool deferConversion) {
+#endif
     ATRACE_CALL();
     ST_LOGV("updateTexImage");
     Mutex::Autolock lock(mMutex);
@@ -239,10 +277,110 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool skipSync)
     if (err == NO_ERROR) {
         int buf = item.mBuf;
 
+#ifdef STE_HARDWARE
+        EGLImageKHR image;
+        if (conversionIsNeeded(mSlots[buf].mGraphicBuffer)) {
+            mNeedsConversion = deferConversion;
+            // If color conversion is needed we can't use the graphic buffers
+            // located in mSlots for the textures (wrong color format). Instead
+            // color convert it into a buffer in mBlitSlots and use that instead.
+            image = mBlitSlots[mNextBlitSlot].mEglImage;
+
+            // If there exists an image already, make sure that
+            // the dimensions match the current source buffer.
+            // Otherwise, destroy the buffer and let a new one be allocated.
+            if (image != EGL_NO_IMAGE_KHR &&
+                    mSlots[buf].mGraphicBuffer != NULL &&
+                    mBlitSlots[mNextBlitSlot].mGraphicBuffer != NULL) {
+                sp<GraphicBuffer> &srcBuf = mSlots[buf].mGraphicBuffer;
+                sp<GraphicBuffer> &bltBuf =
+                    mBlitSlots[mNextBlitSlot].mGraphicBuffer;
+                if (srcBuf->getWidth() != bltBuf->getWidth() ||
+                        srcBuf->getHeight() != bltBuf->getHeight()) {
+                    eglDestroyImageKHR(mBlitSlots[mNextBlitSlot].mEglDisplay,
+                        image);
+                    mBlitSlots[mNextBlitSlot].mEglImage = EGL_NO_IMAGE_KHR;
+                    mBlitSlots[mNextBlitSlot].mGraphicBuffer = NULL;
+                    image = EGL_NO_IMAGE_KHR;
+                }
+            }
+            if (image == EGL_NO_IMAGE_KHR) {
+                sp<GraphicBuffer> &srcBuf = mSlots[buf].mGraphicBuffer;
+                status_t res = 0;
+
+                sp<GraphicBuffer> blitBuffer(
+                        mGraphicBufferAlloc->createGraphicBuffer(
+                                srcBuf->getWidth(), srcBuf->getHeight(),
+                                PIXEL_FORMAT_RGBA_8888, srcBuf->getUsage(),
+                                &res));
+                if (blitBuffer == 0) {
+                    ST_LOGE("updateTexImage: SurfaceComposer::createGraphicBuffer failed");
+                    return NO_MEMORY;
+                }
+                if (res != NO_ERROR) {
+                    ST_LOGW("updateTexImage: SurfaceComposer::createGraphicBuffer error=%#04x", res);
+                }
+                mBlitSlots[mNextBlitSlot].mGraphicBuffer = blitBuffer;
+
+                EGLDisplay dpy = eglGetCurrentDisplay();
+                image = createImage(dpy, blitBuffer);
+                mBlitSlots[mNextBlitSlot].mEglImage = image;
+                mBlitSlots[mNextBlitSlot].mEglDisplay = dpy;
+            }
+
+            if (deferConversion) {
+                item.mGraphicBuffer = mSlots[buf].mGraphicBuffer;
+                mConversionSrcSlot = buf;
+                mConversionBltSlot = mNextBlitSlot;
+                // At this point item.mGraphicBuffer and image do not point
+                // at matching buffers. This is intentional as this
+                // surface might end up being taken care of by HWComposer,
+                // which needs access to the original buffer.
+                // GL however, is fed an EGLImage that is created from
+                // a conversion buffer. It will have its
+                // content updated once the surface is actually drawn
+                // in Layer::onDraw()
+            } else {
+                if (convert(mSlots[buf].mGraphicBuffer,
+                        mBlitSlots[mNextBlitSlot].mGraphicBuffer) != OK) {
+                    ALOGE("updateTexImage: convert failed");
+                    return UNKNOWN_ERROR;
+                }
+                item.mGraphicBuffer = mBlitSlots[mNextBlitSlot].mGraphicBuffer;
+            }
+            // mBlitSlots contains several buffers (NUM_BLIT_BUFFER_SLOTS),
+            // advance (potentially wrap) the index
+            mNextBlitSlot = (mNextBlitSlot + 1) % BufferQueue::NUM_BLIT_BUFFER_SLOTS;
+        } else {
+            mNeedsConversion = false;
+            image = mEglSlots[buf].mEglImage;
+            item.mGraphicBuffer = mSlots[buf].mGraphicBuffer;
+            if (image == EGL_NO_IMAGE_KHR) {
+                EGLDisplay dpy = eglGetCurrentDisplay();
+                if (item.mGraphicBuffer == 0) {
+                    ST_LOGE("buffer at slot %d is null", buf);
+                    return BAD_VALUE;
+                }
+                image = createImage(dpy, item.mGraphicBuffer);
+                mEglSlots[buf].mEglImage = image;
+                mEglDisplay = dpy;
+                if (image == EGL_NO_IMAGE_KHR) {
+                    // NOTE: if dpy was invalid, createImage() is guaranteed to
+                    // fail. so we'd end up here.
+                    return -EINVAL;
+                }
+            }
+        }
+#endif
+
         // we call the rejecter here, in case the caller has a reason to
         // not accept this buffer. this is used by SurfaceFlinger to
         // reject buffers which have the wrong size
+#ifdef STE_HARDWARE
+        if (rejecter && rejecter->reject(item.mGraphicBuffer, item)) {
+#else
         if (rejecter && rejecter->reject(mSlots[buf].mGraphicBuffer, item)) {
+#endif
             releaseBufferLocked(buf, dpy, EGL_NO_SYNC_KHR);
             glBindTexture(mTexTarget, mTexName);
             return NO_ERROR;
@@ -253,7 +391,9 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool skipSync)
             ST_LOGW("updateTexImage: clearing GL error: %#04x", error);
         }
 
+#ifndef STE_HARDWARE
         EGLImageKHR image = mEglSlots[buf].mEglImage;
+#endif
         glBindTexture(mTexTarget, mTexName);
         glEGLImageTargetTexture2DOES(mTexTarget, (GLeglImageOES)image);
 
@@ -292,7 +432,11 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool skipSync)
 
         // Update the SurfaceTexture state.
         mCurrentTexture = buf;
+#ifndef STE_HARDWARE
         mCurrentTextureBuf = mSlots[buf].mGraphicBuffer;
+#else
+        mCurrentTextureBuf = item.mGraphicBuffer;
+#endif
         mCurrentCrop = item.mCrop;
         mCurrentTransform = item.mTransform;
         mCurrentScalingMode = item.mScalingMode;
@@ -383,6 +527,12 @@ status_t SurfaceTexture::detachFromContext() {
         }
     }
 
+#ifdef STE_HARDWARE
+    if (mBlitEngine) {
+        copybit_close(mBlitEngine);
+    }
+#endif
+
     mEglDisplay = EGL_NO_DISPLAY;
     mEglContext = EGL_NO_CONTEXT;
     mAttached = false;
@@ -533,7 +683,15 @@ bool SurfaceTexture::isExternalFormat(uint32_t format)
     case HAL_PIXEL_FORMAT_YV12:
     // Legacy/deprecated YUV formats
     case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+#ifdef STE_HARDWARE
+    case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+    case HAL_PIXEL_FORMAT_YCrCb_422_SP:
+    case HAL_PIXEL_FORMAT_YCrCb_422_P:
+    case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+    case HAL_PIXEL_FORMAT_YCrCb_420_P:
+#else
     case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+#endif
     case HAL_PIXEL_FORMAT_YCbCr_422_I:
         return true;
     }
@@ -882,6 +1040,90 @@ void SurfaceTexture::dumpLocked(String8& result, const char* prefix,
     ConsumerBase::dumpLocked(result, prefix, buffer, size);
 }
 
+#ifdef STE_HARDWARE
+bool SurfaceTexture::conversionIsNeeded(const sp<GraphicBuffer>& graphicBuffer) {
+    int fmt = graphicBuffer->getPixelFormat();
+    return (fmt == PIXEL_FORMAT_YCBCR42XMBN) || (fmt == PIXEL_FORMAT_YCbCr_420_P);
+}
+
+status_t SurfaceTexture::convert() {
+    if (!mNeedsConversion)
+        return NO_ERROR;
+
+    if (mConversionBltSlot < 0 ||
+            mConversionBltSlot >= BufferQueue::NUM_BLIT_BUFFER_SLOTS ||
+            mConversionSrcSlot < 0 ||
+            mConversionSrcSlot >= BufferQueue::NUM_BUFFER_SLOTS) {
+        ALOGE_IF(STE_DEFERDBG, "%s: Incorrect setup for deferred "
+            "texture conversion:\n"
+            "mConversionSrcSlot=%d mConversionBltSlot=%d", __FUNCTION__,
+            mConversionSrcSlot, mConversionBltSlot);
+        return BAD_VALUE;
+    }
+
+    if (mEglSlots[mConversionSrcSlot].mGraphicBuffer == NULL) {
+        ALOGI_IF(STE_DEFERDBG, "%s: NULL source for deferred texture conversion.",
+            __FUNCTION__);
+        return OK;
+    }
+
+    if (mBlitSlots[mConversionBltSlot].mGraphicBuffer == NULL) {
+        ALOGI_IF(STE_DEFERDBG, "%s: NULL destination for deferred "
+            "texture conversion.", __FUNCTION__);
+        return OK;
+    }
+
+    return convert(mEglSlots[mConversionSrcSlot].mGraphicBuffer,
+        mBlitSlots[mConversionBltSlot].mGraphicBuffer);
+}
+
+status_t SurfaceTexture::convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf) {
+    copybit_image_t dstImg;
+    dstImg.w = dstBuf->getWidth();
+    dstImg.h = dstBuf->getHeight();
+    dstImg.format = dstBuf->getPixelFormat();
+    dstImg.handle = (native_handle_t*) dstBuf->getNativeBuffer()->handle;
+
+    copybit_image_t srcImg;
+    srcImg.w = srcBuf->getWidth();
+    srcImg.h = srcBuf->getHeight();
+    srcImg.format = srcBuf->getPixelFormat();
+    srcImg.base = NULL;
+    srcImg.handle = (native_handle_t*) srcBuf->getNativeBuffer()->handle;
+
+    copybit_rect_t dstCrop;
+    dstCrop.l = 0;
+    dstCrop.t = 0;
+    dstCrop.r = dstBuf->getWidth();
+    dstCrop.b = dstBuf->getHeight();
+
+    copybit_rect_t srcCrop;
+    srcCrop.l = 0;
+    srcCrop.t = 0;
+    srcCrop.r = srcBuf->getWidth();
+    srcCrop.b = srcBuf->getHeight();
+
+    region_iterator clip(Region(Rect(dstCrop.r, dstCrop.b)));
+    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_TRANSFORM, 0);
+    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_PLANE_ALPHA, 0xFF);
+    mBlitEngine->set_parameter(mBlitEngine, COPYBIT_DITHER, COPYBIT_ENABLE);
+
+    int err = mBlitEngine->stretch(
+            mBlitEngine, &dstImg, &srcImg, &dstCrop, &srcCrop, &clip);
+    if (err != 0) {
+        ALOGE("Error: Blit stretch operation failed, retry once (err:%d)", err);
+        // TODO: Bad boy doing hacks here, blit stretch operation should be completely fixed.
+        int err = mBlitEngine->stretch(
+            mBlitEngine, &dstImg, &srcImg, &dstCrop, &srcCrop, &clip);
+        if (err != 0) {
+            ALOGE("Error: Blit stretch operation failed (err:%d)", err);
+            return UNKNOWN_ERROR;
+        }
+    }
+    return OK;
+}
+#endif
+
 static void mtxMul(float out[16], const float a[16], const float b[16]) {
     out[0] = a[0]*b[0] + a[4]*b[1] + a[8]*b[2] + a[12]*b[3];
     out[1] = a[1]*b[0] + a[5]*b[1] + a[9]*b[2] + a[13]*b[3];
diff --git a/libs/ui/PixelFormat.cpp b/libs/ui/PixelFormat.cpp
index 3ced41d..5b24b73 100644
--- a/libs/ui/PixelFormat.cpp
+++ b/libs/ui/PixelFormat.cpp
@@ -101,10 +101,21 @@ status_t getPixelFormatInfo(PixelFormat format, PixelFormatInfo* info)
     switch (format) {
     case HAL_PIXEL_FORMAT_YCbCr_422_SP:
     case HAL_PIXEL_FORMAT_YCbCr_422_I:
+#ifdef STE_HARDWARE
+    case HAL_PIXEL_FORMAT_YCrCb_422_SP:
+    case HAL_PIXEL_FORMAT_YCbCr_422_P:
+    case HAL_PIXEL_FORMAT_YCrCb_422_P:
+#endif
         info->bitsPerPixel = 16;
         goto done;
     case HAL_PIXEL_FORMAT_YCrCb_420_SP:
     case HAL_PIXEL_FORMAT_YV12:
+#ifdef STE_HARDWARE
+    case HAL_PIXEL_FORMAT_YCbCr_420_SP:
+    case HAL_PIXEL_FORMAT_YCbCr_420_P:
+    case HAL_PIXEL_FORMAT_YCrCb_420_P:
+    case HAL_PIXEL_FORMAT_YCBCR42XMBN:
+#endif
         info->bitsPerPixel = 12;
      done:
         info->format = format;
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index c1561b2..1475d23 100644
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -328,6 +328,18 @@ void Layer::setAcquireFence(const sp<const DisplayDevice>& hw,
 
 void Layer::onDraw(const sp<const DisplayDevice>& hw, const Region& clip) const
 {
+#ifdef STE_HARDWARE
+    // Convert the texture to a native format if need be.
+    // convert() returns immediately if no conversion is necessary.
+    if (mSurfaceTexture != NULL) {
+        status_t res = mSurfaceTexture->convert();
+        if (res != NO_ERROR) {
+            ALOGE("Layer::onDraw: texture conversion failed. "
+                "Texture content for this layer will not be initialized.");
+        }
+    }
+#endif
+
     ATRACE_CALL();
 
     if (CC_UNLIKELY(mActiveBuffer == 0)) {
@@ -662,7 +674,11 @@ Region Layer::latchBuffer(bool& recomputeVisibleRegions)
 
         Reject r(mDrawingState, currentState(), recomputeVisibleRegions);
 
+#ifndef STE_HARDWARE
         if (mSurfaceTexture->updateTexImage(&r, true) < NO_ERROR) {
+#else
+        if (mSurfaceTexture->updateTexImage(&r, true, true) < NO_ERROR) {
+#endif
             // something happened!
             recomputeVisibleRegions = true;
             return outDirtyRegion;
-- 
2.5.0

