From 044283d4288598dcfe5dcab16dbfc26298a4d036 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 20 Aug 2018 22:57:43 +0300
Subject: [PATCH 35/44] sensors: reset to 7.1.2

---
 libs/sensor/Sensor.cpp                             | 21 ++++++
 services/sensorservice/Android.bp                  | 77 +---------------------
 services/sensorservice/Android.mk                  | 66 +++++++++++++++++++
 services/sensorservice/hidl/Android.bp             |  2 +-
 services/sensorservice/hidl/SensorManager.cpp      | 73 ++++++++------------
 .../hidl/include/sensorservicehidl/SensorManager.h | 10 +--
 6 files changed, 120 insertions(+), 129 deletions(-)
 create mode 100644 services/sensorservice/Android.mk

diff --git a/libs/sensor/Sensor.cpp b/libs/sensor/Sensor.cpp
index 8db48d972..1f36b0702 100644
--- a/libs/sensor/Sensor.cpp
+++ b/libs/sensor/Sensor.cpp
@@ -553,3 +553,24 @@ bool Sensor::unflattenString8(void const*& buffer, size_t& size, String8& output
 
 // ----------------------------------------------------------------------------
 }; // namespace android
+
+extern "C" void _ZN7android13SensorManager19createDirectChannelEjiPK13native_handle(unsigned int, int, native_handle const*)
+{
+}
+
+extern "C" void _ZN7android13SensorManager20destroyDirectChannelEi(int)
+{
+}
+
+extern "C" void _ZN7android13SensorManager22configureDirectChannelEiii(int, int, int)
+{
+}
+
+extern "C" void _ZN7android13SensorManager21setOperationParameterEiRKNS_6VectorIfEERKNS1_IiEE(int, android::Vector<float> const&, android::Vector<int> const&)
+{
+}
+
+extern "C" bool _ZNK7android6Sensor28isDirectChannelTypeSupportedEi(int)
+{
+	return false;
+}
diff --git a/services/sensorservice/Android.bp b/services/sensorservice/Android.bp
index 49e95ad92..a8f766b1d 100644
--- a/services/sensorservice/Android.bp
+++ b/services/sensorservice/Android.bp
@@ -1,74 +1,3 @@
-subdirs = [
-    "hidl"
-]
-cc_library_shared {
-    name: "libsensorservice",
-
-    srcs: [
-        "BatteryService.cpp",
-        "CorrectedGyroSensor.cpp",
-        "Fusion.cpp",
-        "GravitySensor.cpp",
-        "LinearAccelerationSensor.cpp",
-        "OrientationSensor.cpp",
-        "RecentEventLogger.cpp",
-        "RotationVectorSensor.cpp",
-        "SensorDevice.cpp",
-        "SensorDirectConnection.cpp",
-        "SensorEventConnection.cpp",
-        "SensorFusion.cpp",
-        "SensorInterface.cpp",
-        "SensorList.cpp",
-        "SensorRecord.cpp",
-        "SensorService.cpp",
-        "SensorServiceUtils.cpp",
-    ],
-
-    cflags: [
-        "-DLOG_TAG=\"SensorService\"",
-        "-Wall",
-        "-Werror",
-        "-Wextra",
-        "-DHARDWARE_FIFO_SENSOR_SERVICE",
-        "-fvisibility=hidden"
-    ],
-
-    shared_libs: [
-        "libcutils",
-        "libhardware",
-        "libhardware_legacy",
-        "libutils",
-        "liblog",
-        "libbinder",
-        "libsensor",
-        "libcrypto",
-        "libbase",
-        "libhidlbase",
-        "libhidltransport",
-        "libhwbinder",
-        "android.hardware.sensors@1.0",
-    ],
-
-    static_libs: ["android.hardware.sensors@1.0-convert"],
-
-    // our public headers depend on libsensor
-    export_shared_lib_headers: ["libsensor"],
-}
-
-cc_binary {
-    name: "sensorservice",
-
-    srcs: ["main_sensorservice.cpp"],
-
-    shared_libs: [
-        "libsensorservice",
-        "libbinder",
-        "libutils",
-    ],
-
-    cflags: [
-        "-Wall",
-        "-Werror",
-        "-Wextra",
-    ],
-}
+//subdirs = [
+//    "hidl"
+//]
diff --git a/services/sensorservice/Android.mk b/services/sensorservice/Android.mk
new file mode 100644
index 000000000..5fe622eb7
--- /dev/null
+++ b/services/sensorservice/Android.mk
@@ -0,0 +1,66 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+    BatteryService.cpp \
+    CorrectedGyroSensor.cpp \
+    Fusion.cpp \
+    GravitySensor.cpp \
+    LinearAccelerationSensor.cpp \
+    OrientationSensor.cpp \
+    RecentEventLogger.cpp \
+    RotationVectorSensor.cpp \
+    SensorDevice.cpp \
+    SensorEventConnection.cpp \
+    SensorFusion.cpp \
+    SensorInterface.cpp \
+    SensorList.cpp \
+    SensorRecord.cpp \
+    SensorService.cpp \
+    SensorServiceUtils.cpp \
+
+LOCAL_CFLAGS:= -DLOG_TAG=\"SensorService\"
+
+LOCAL_CFLAGS += -Wall -Werror -Wextra
+
+LOCAL_CFLAGS += -fvisibility=hidden
+
+LOCAL_SHARED_LIBRARIES := \
+    libcutils \
+    libhardware \
+    libhardware_legacy \
+    libutils \
+    liblog \
+    libbinder \
+    libsensor \
+    libcrypto \
+    libbase
+
+
+# our public headers depend on libsensor
+LOCAL_EXPORT_SHARED_LIBRARY_HEADERS := \
+    libsensor \
+
+LOCAL_MODULE:= libsensorservice
+
+include $(BUILD_SHARED_LIBRARY)
+
+#####################################################################
+# build executable
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:= \
+    main_sensorservice.cpp
+
+LOCAL_SHARED_LIBRARIES := \
+    libsensorservice \
+    libbinder \
+    libutils
+
+LOCAL_CFLAGS := -Wall -Werror -Wextra
+
+LOCAL_MODULE_TAGS := optional
+
+LOCAL_MODULE:= sensorservice
+
+include $(BUILD_EXECUTABLE)
diff --git a/services/sensorservice/hidl/Android.bp b/services/sensorservice/hidl/Android.bp
index e480566d5..19f714f1c 100644
--- a/services/sensorservice/hidl/Android.bp
+++ b/services/sensorservice/hidl/Android.bp
@@ -15,11 +15,11 @@ cc_library_shared {
         "libbase",
         "libhidlbase",
         "libhidltransport",
-        "libhwbinder",
         "libutils",
         "libsensor",
         "android.frameworks.sensorservice@1.0",
         "android.hardware.sensors@1.0",
+        "android.hidl.base@1.0",
     ],
     static_libs: [
         "android.hardware.sensors@1.0-convert",
diff --git a/services/sensorservice/hidl/SensorManager.cpp b/services/sensorservice/hidl/SensorManager.cpp
index ed30b79a1..af220dac2 100644
--- a/services/sensorservice/hidl/SensorManager.cpp
+++ b/services/sensorservice/hidl/SensorManager.cpp
@@ -24,14 +24,12 @@
 
 #include <sched.h>
 
+#include <thread>
 
 #include "EventQueue.h"
 #include "DirectReportChannel.h"
 #include "utils.h"
 
-#include <hwbinder/IPCThreadState.h>
-#include <utils/String8.h>
-
 namespace android {
 namespace frameworks {
 namespace sensorservice {
@@ -42,24 +40,20 @@ using ::android::hardware::sensors::V1_0::SensorInfo;
 using ::android::hardware::sensors::V1_0::SensorsEventFormatOffset;
 using ::android::hardware::hidl_vec;
 using ::android::hardware::Void;
+using ::android::sp;
 
 static const char* POLL_THREAD_NAME = "hidl_ssvc_poll";
 
 SensorManager::SensorManager(JavaVM* vm)
-        : mLooper(new Looper(false /*allowNonCallbacks*/)), mStopThread(true), mJavaVm(vm) {
+        : mJavaVm(vm) {
 }
 
 SensorManager::~SensorManager() {
     // Stops pollAll inside the thread.
-    std::lock_guard<std::mutex> lock(mThreadMutex);
-
-    mStopThread = true;
+    std::unique_lock<std::mutex> lock(mLooperMutex);
     if (mLooper != nullptr) {
         mLooper->wake();
     }
-    if (mPollThread.joinable()) {
-        mPollThread.join();
-    }
 }
 
 // Methods from ::android::frameworks::sensorservice::V1_0::ISensorManager follow.
@@ -134,13 +128,12 @@ Return<void> SensorManager::createGrallocDirectChannel(
 }
 
 /* One global looper for all event queues created from this SensorManager. */
-sp<Looper> SensorManager::getLooper() {
-    std::lock_guard<std::mutex> lock(mThreadMutex);
+sp<::android::Looper> SensorManager::getLooper() {
+    std::unique_lock<std::mutex> lock(mLooperMutex);
+    if (mLooper == nullptr) {
+        std::condition_variable looperSet;
 
-    if (!mPollThread.joinable()) {
-        // if thread not initialized, start thread
-        mStopThread = false;
-        std::thread pollThread{[&stopThread = mStopThread, looper = mLooper, javaVm = mJavaVm] {
+        std::thread{[&mutex = mLooperMutex, &looper = mLooper, &looperSet, javaVm = mJavaVm] {
 
 #ifndef HARDWARE_FIFO_SENSOR_SERVICE
             struct sched_param p = {0};
@@ -151,11 +144,16 @@ sp<Looper> SensorManager::getLooper() {
             }
 #endif
 
-            // set looper
-            Looper::setForThread(looper);
+            std::unique_lock<std::mutex> lock(mutex);
+            if (looper != nullptr) {
+                LOG(INFO) << "Another thread has already set the looper, exiting this one.";
+                return;
+            }
+            looper = Looper::prepare(ALOOPER_PREPARE_ALLOW_NON_CALLBACKS /* opts */);
+            lock.unlock();
 
-            // Attach the thread to JavaVM so that pollAll do not crash if the thread
-            // eventually calls into Java.
+            // Attach the thread to JavaVM so that pollAll do not crash if the event
+            // is from Java.
             JavaVMAttachArgs args{
                 .version = JNI_VERSION_1_2,
                 .name = POLL_THREAD_NAME,
@@ -166,30 +164,19 @@ sp<Looper> SensorManager::getLooper() {
                 LOG(FATAL) << "Cannot attach SensorManager looper thread to Java VM.";
             }
 
-            LOG(INFO) << POLL_THREAD_NAME << " started.";
-            for (;;) {
-                int pollResult = looper->pollAll(-1 /* timeout */);
-                if (pollResult == Looper::POLL_WAKE) {
-                    if (stopThread == true) {
-                        LOG(INFO) << POLL_THREAD_NAME << ": requested to stop";
-                        break;
-                    } else {
-                        LOG(INFO) << POLL_THREAD_NAME << ": spurious wake up, back to work";
-                    }
-                } else {
-                    LOG(ERROR) << POLL_THREAD_NAME << ": Looper::pollAll returns unexpected "
-                               << pollResult;
-                    break;
-                }
+            looperSet.notify_one();
+            int pollResult = looper->pollAll(-1 /* timeout */);
+            if (pollResult != ALOOPER_POLL_WAKE) {
+                LOG(ERROR) << "Looper::pollAll returns unexpected " << pollResult;
             }
 
             if (javaVm->DetachCurrentThread() != JNI_OK) {
                 LOG(ERROR) << "Cannot detach SensorManager looper thread from Java VM.";
             }
 
-            LOG(INFO) << POLL_THREAD_NAME << " is terminated.";
-        }};
-        mPollThread = std::move(pollThread);
+            LOG(INFO) << "Looper thread is terminated.";
+        }}.detach();
+        looperSet.wait(lock, [this]{ return this->mLooper != nullptr; });
     }
     return mLooper;
 }
@@ -211,15 +198,7 @@ Return<void> SensorManager::createEventQueue(
     }
 
     sp<::android::Looper> looper = getLooper();
-    if (looper == nullptr) {
-        LOG(ERROR) << "::android::SensorManager::createEventQueue cannot initialize looper";
-        _hidl_cb(nullptr, Result::UNKNOWN_ERROR);
-        return Void();
-    }
-
-    String8 package(String8::format("hidl_client_pid_%d",
-                                    android::hardware::IPCThreadState::self()->getCallingPid()));
-    sp<::android::SensorEventQueue> internalQueue = getInternalManager().createEventQueue(package);
+    sp<::android::SensorEventQueue> internalQueue = getInternalManager().createEventQueue();
     if (internalQueue == nullptr) {
         LOG(WARNING) << "::android::SensorManager::createEventQueue returns nullptr.";
         _hidl_cb(nullptr, Result::UNKNOWN_ERROR);
diff --git a/services/sensorservice/hidl/include/sensorservicehidl/SensorManager.h b/services/sensorservice/hidl/include/sensorservicehidl/SensorManager.h
index ddcee288e..e66c8e5d2 100644
--- a/services/sensorservice/hidl/include/sensorservicehidl/SensorManager.h
+++ b/services/sensorservice/hidl/include/sensorservicehidl/SensorManager.h
@@ -20,7 +20,6 @@
 #include <jni.h>
 
 #include <mutex>
-#include <thread>
 
 #include <android/frameworks/sensorservice/1.0/ISensorManager.h>
 #include <android/frameworks/sensorservice/1.0/types.h>
@@ -39,7 +38,6 @@ using ::android::hardware::sensors::V1_0::SensorType;
 using ::android::hardware::hidl_handle;
 using ::android::hardware::hidl_memory;
 using ::android::hardware::Return;
-using ::android::sp;
 
 struct SensorManager final : public ISensorManager {
 
@@ -56,15 +54,13 @@ struct SensorManager final : public ISensorManager {
 private:
     // Block until ::android::SensorManager is initialized.
     ::android::SensorManager& getInternalManager();
-    sp<Looper> getLooper();
+    sp<::android::Looper> getLooper();
 
     std::mutex mInternalManagerMutex;
     ::android::SensorManager* mInternalManager = nullptr; // does not own
-    sp<Looper> mLooper;
 
-    volatile bool mStopThread;
-    std::mutex mThreadMutex; //protects mPollThread
-    std::thread mPollThread;
+    std::mutex mLooperMutex;
+    sp<::android::Looper> mLooper;
 
     JavaVM* mJavaVm;
 };
-- 
2.11.0

