From bc7bc812d721d7e9587cce1a02ee4e0f5c5dc5da Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Thu, 28 Jan 2016 08:51:55 +0700
Subject: [PATCH 07/10] 0008-native-graphicbuffer-fixup.patch

Change-Id: I6883f80258d13053de135802dee85f26bf42b5ed
---
 libs/gui/BufferQueueProducer.cpp |  4 +++-
 libs/gui/GLConsumer.cpp          | 18 ++++++++++++++++++
 2 files changed, 21 insertions(+), 1 deletion(-)

diff --git a/libs/gui/BufferQueueProducer.cpp b/libs/gui/BufferQueueProducer.cpp
index d2fd3b0..d40d2df 100644
--- a/libs/gui/BufferQueueProducer.cpp
+++ b/libs/gui/BufferQueueProducer.cpp
@@ -272,7 +272,9 @@ status_t BufferQueueProducer::dequeueBuffer(int *outSlot,
         if (format == 0) {
             format = mCore->mDefaultBufferFormat;
         }
-
+        if (format == 0x7FA00000) {
+            format = HAL_PIXEL_FORMAT_YCBCR42XMBN;
+        }
         // Enable the usage bits the consumer requested
         usage |= mCore->mConsumerUsageBits;
 
diff --git a/libs/gui/GLConsumer.cpp b/libs/gui/GLConsumer.cpp
index 1aff195..e2a0790 100644
--- a/libs/gui/GLConsumer.cpp
+++ b/libs/gui/GLConsumer.cpp
@@ -444,6 +444,13 @@ status_t GLConsumer::updateAndReleaseLocked(const BufferQueue::BufferItem& item)
         }
         /* allocate convert buffer if needed */
         if (mBlitSlots[mNextBlitSlot] == NULL) {
+            if(mGraphicBufferAlloc == NULL) {
+
+                /* For some reason this is not being initialized in the constructor.
+                   So, we will create it here if it's null. */
+                sp<ISurfaceComposer> composer(ComposerService::getComposerService());
+                mGraphicBufferAlloc = composer->createGraphicBufferAlloc();
+            }
             status_t res;
             sp<GraphicBuffer> srcBuf = mSlots[buf].mGraphicBuffer;
             sp<GraphicBuffer> dstBuf(mGraphicBufferAlloc->createGraphicBuffer(srcBuf->getWidth(),
@@ -467,6 +474,7 @@ status_t GLConsumer::updateAndReleaseLocked(const BufferQueue::BufferItem& item)
             return UNKNOWN_ERROR;
         }
         textureBuffer = mBlitSlots[mNextBlitSlot];
+        mEglSlots[buf].mEglImage = new EglImage(textureBuffer);
         mNextBlitSlot = (mNextBlitSlot + 1) % BufferQueue::NUM_BLIT_BUFFER_SLOTS;
     }
     else {
@@ -1138,6 +1146,16 @@ void GLConsumer::dumpLocked(String8& result, const char* prefix) const
 
 #ifdef STE_HARDWARE
 status_t GLConsumer::convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf) {
+
+    /* For some reason mBlitEngine is not being initialized in
+    the constructor so we init' it before we use it. */
+    hw_module_t const* module;
+    if(mBlitEngine == NULL) {
+        if (hw_get_module(COPYBIT_HARDWARE_MODULE_ID, &module) == 0) {
+            copybit_open(module, &mBlitEngine);
+        }
+    }
+
     copybit_image_t dstImg;
     dstImg.w = dstBuf->getWidth();
     dstImg.h = dstBuf->getHeight();
-- 
2.5.0

