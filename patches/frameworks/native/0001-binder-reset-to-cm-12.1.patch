From cc0a8b2e1fc87f67eb0247db4ca022f786549a3d Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Tue, 29 Sep 2015 15:56:02 +0300
Subject: [PATCH 1/8] binder: reset to cm-12.1

Change-Id: I7534754cda4f273a2f50365fd8a8dbcbf4794b15

Conflicts:
	include/binder/IMemory.h
	include/binder/Parcel.h
	libs/binder/Android.mk
	libs/binder/MemoryDealer.cpp
	libs/binder/Parcel.cpp
---
 include/binder/IMemory.h     |   7 +-
 include/binder/Parcel.h      |  47 +++---
 libs/binder/Android.mk       |  56 +++++++-
 libs/binder/MemoryBase.cpp   |   8 ++
 libs/binder/MemoryDealer.cpp |   7 +
 libs/binder/Parcel.cpp       | 330 +++++++++++++------------------------------
 6 files changed, 188 insertions(+), 267 deletions(-)

diff --git a/include/binder/IMemory.h b/include/binder/IMemory.h
index 2d0db00..178ef85 100644
--- a/include/binder/IMemory.h
+++ b/include/binder/IMemory.h
@@ -36,7 +36,12 @@ public:
 
     // flags returned by getFlags()
     enum {
-        READ_ONLY   = 0x00000001
+        READ_ONLY   = 0x00000001,
+#ifdef USE_MEMORY_HEAP_ION
+        USE_ION_FD  = 0x00008000
+#else
+        USE_ION_FD  = 0x00000008
+#endif
     };
 
     virtual int         getHeapID() const = 0;
diff --git a/include/binder/Parcel.h b/include/binder/Parcel.h
index 3ada1e9..6e098bf 100644
--- a/include/binder/Parcel.h
+++ b/include/binder/Parcel.h
@@ -60,7 +60,6 @@ public:
     status_t            appendFrom(const Parcel *parcel,
                                    size_t start, size_t len);
 
-    bool                allowFds() const;
     bool                pushAllowFds(bool allowFds);
     void                restoreAllowFds(bool lastValue);
 
@@ -95,9 +94,7 @@ public:
     void*               writeInplace(size_t len);
     status_t            writeUnpadded(const void* data, size_t len);
     status_t            writeInt32(int32_t val);
-    status_t            writeUint32(uint32_t val);
     status_t            writeInt64(int64_t val);
-    status_t            writeUint64(uint64_t val);
     status_t            writeFloat(float val);
     status_t            writeDouble(double val);
     status_t            writeCString(const char* str);
@@ -131,18 +128,16 @@ public:
     // will be closed once the parcel is destroyed.
     status_t            writeDupFileDescriptor(int fd);
 
+    // Writes a raw fd and optional comm channel fd to the parcel as a ParcelFileDescriptor.
+    // A dup's of the fds are made, which will be closed once the parcel is destroyed.
+    // Null values are passed as -1.
+    status_t            writeParcelFileDescriptor(int fd, int commChannel = -1);
+
     // Writes a blob to the parcel.
     // If the blob is small, then it is stored in-place, otherwise it is
-    // transferred by way of an anonymous shared memory region.  Prefer sending
-    // immutable blobs if possible since they may be subsequently transferred between
-    // processes without further copying whereas mutable blobs always need to be copied.
+    // transferred by way of an anonymous shared memory region.
     // The caller should call release() on the blob after writing its contents.
-    status_t            writeBlob(size_t len, bool mutableCopy, WritableBlob* outBlob);
-
-    // Write an existing immutable blob file descriptor to the parcel.
-    // This allows the client to send the same blob to multiple processes
-    // as long as it keeps a dup of the blob file descriptor handy for later.
-    status_t            writeDupImmutableBlobFileDescriptor(int fd);
+    status_t            writeBlob(size_t len, WritableBlob* outBlob);
 
     status_t            writeObject(const flat_binder_object& val, bool nullMetaData);
 
@@ -157,12 +152,11 @@ public:
     const void*         readInplace(size_t len) const;
     int32_t             readInt32() const;
     status_t            readInt32(int32_t *pArg) const;
-    uint32_t            readUint32() const;
-    status_t            readUint32(uint32_t *pArg) const;
     int64_t             readInt64() const;
     status_t            readInt64(int64_t *pArg) const;
-    uint64_t            readUint64() const;
-    status_t            readUint64(uint64_t *pArg) const;
+#ifdef NEEDS_LGE_RIL_SYMBOLS
+    status_t            readuInt64(uint64_t *pArg) const;
+#endif
     float               readFloat() const;
     status_t            readFloat(float *pArg) const;
     double              readDouble() const;
@@ -201,6 +195,11 @@ public:
     // in the parcel, which you do not own -- use dup() to get your own copy.
     int                 readFileDescriptor() const;
 
+    // Reads a ParcelFileDescriptor from the parcel.  Returns the raw fd as
+    // the result, and the optional comm channel fd in outCommChannel.
+    // Null values are returned as -1.
+    int                 readParcelFileDescriptor(int& outCommChannel) const;
+
     // Reads a blob from the parcel.
     // The caller should call release() on the blob after reading its contents.
     status_t            readBlob(size_t len, ReadableBlob* outBlob) const;
@@ -278,19 +277,16 @@ private:
         Blob();
         ~Blob();
 
-        void clear();
         void release();
         inline size_t size() const { return mSize; }
-        inline int fd() const { return mFd; };
-        inline bool isMutable() const { return mMutable; }
 
     protected:
-        void init(int fd, void* data, size_t size, bool isMutable);
+        void init(bool mapped, void* data, size_t size);
+        void clear();
 
-        int mFd; // owned by parcel so not closed when released
+        bool mMapped;
         void* mData;
         size_t mSize;
-        bool mMutable;
     };
 
     class FlattenableHelperInterface {
@@ -331,7 +327,6 @@ public:
         friend class Parcel;
     public:
         inline const void* data() const { return mData; }
-        inline void* mutableData() { return isMutable() ? mData : NULL; }
     };
 
     class WritableBlob : public Blob {
@@ -339,12 +334,6 @@ public:
     public:
         inline void* data() { return mData; }
     };
-
-private:
-    size_t mBlobAshmemSize;
-
-public:
-    size_t getBlobAshmemSize() const;
 };
 
 // ---------------------------------------------------------------------------
diff --git a/libs/binder/Android.mk b/libs/binder/Android.mk
index d5860ef..9a789ee 100644
--- a/libs/binder/Android.mk
+++ b/libs/binder/Android.mk
@@ -26,8 +26,6 @@ sources := \
     IMemory.cpp \
     IPCThreadState.cpp \
     IPermissionController.cpp \
-    IProcessInfoService.cpp \
-    ProcessInfoService.cpp \
     IServiceManager.cpp \
     MemoryDealer.cpp \
     MemoryBase.cpp \
@@ -38,12 +36,43 @@ sources := \
     Static.cpp \
     TextOutput.cpp \
 
+ifeq ($(BOARD_NEEDS_MEMORYHEAPPMEM),true)
+sources += \
+    MemoryHeapPmem.cpp
+endif
+
+ifeq ($(BOARD_NEEDS_MEMORYHEAPION),true)
+sources += \
+    MemoryHeapIon.cpp
+endif
+
 LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
+
+ifeq ($(BOARD_NEEDS_MEMORYHEAPION),true)
+LOCAL_SHARED_LIBRARIES += libion_exynos
+LOCAL_CFLAGS += -DUSE_MEMORY_HEAP_ION
+
+ifeq ($(TARGET_SLSI_VARIANT),cm)
+SLSI_DIR := samsung_slsi-cm
+PLATFORM_DIR := $(TARGET_BOARD_PLATFORM)
+else
+SLSI_DIR := samsung_slsi
+PLATFORM_DIR := $(TARGET_BOARD_PLATFORM)-$(TARGET_SLSI_VARIANT)
+endif
+LOCAL_C_INCLUDES += hardware/$(SLSI_DIR)/$(PLATFORM_DIR)/include
+endif
+
 LOCAL_MODULE := libbinder
-LOCAL_SHARED_LIBRARIES := liblog libcutils libutils
+LOCAL_SHARED_LIBRARIES += liblog libcutils libutils
 LOCAL_SRC_FILES := $(sources)
+ifeq ($(BOARD_NEEDS_MEMORYHEAPPMEM),true)
+LOCAL_C_INCLUDES += \
+    $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include
+LOCAL_ADDITIONAL_DEPENDENCIES := \
+    $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr
+endif
 ifneq ($(TARGET_USES_64_BIT_BINDER),true)
 ifneq ($(TARGET_IS_64_BIT),true)
 LOCAL_CFLAGS += -DBINDER_IPC_32BIT=1
@@ -53,9 +82,30 @@ LOCAL_CFLAGS += -Werror
 include $(BUILD_SHARED_LIBRARY)
 
 include $(CLEAR_VARS)
+
+ifeq ($(BOARD_NEEDS_MEMORYHEAPION),true)
+LOCAL_SHARED_LIBRARIES += libion_exynos
+LOCAL_CFLAGS += -DUSE_MEMORY_HEAP_ION
+
+ifeq ($(TARGET_SLSI_VARIANT),cm)
+SLSI_DIR := samsung_slsi-cm
+PLATFORM_DIR := $(TARGET_BOARD_PLATFORM)
+else
+SLSI_DIR := samsung_slsi
+PLATFORM_DIR := $(TARGET_BOARD_PLATFORM)-$(TARGET_SLSI_VARIANT)
+endif
+LOCAL_C_INCLUDES += hardware/$(SLSI_DIR)/$(PLATFORM_DIR)/include
+endif
+
 LOCAL_MODULE := libbinder
 LOCAL_STATIC_LIBRARIES += libutils
 LOCAL_SRC_FILES := $(sources)
+ifeq ($(BOARD_NEEDS_MEMORYHEAPPMEM),true)
+LOCAL_C_INCLUDES += \
+    $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr/include
+LOCAL_ADDITIONAL_DEPENDENCIES := \
+    $(TARGET_OUT_INTERMEDIATES)/KERNEL_OBJ/usr
+endif
 ifneq ($(TARGET_USES_64_BIT_BINDER),true)
 ifneq ($(TARGET_IS_64_BIT),true)
 LOCAL_CFLAGS += -DBINDER_IPC_32BIT=1
diff --git a/libs/binder/MemoryBase.cpp b/libs/binder/MemoryBase.cpp
index 033066b..6604757 100644
--- a/libs/binder/MemoryBase.cpp
+++ b/libs/binder/MemoryBase.cpp
@@ -44,3 +44,11 @@ MemoryBase::~MemoryBase()
 
 // ---------------------------------------------------------------------------
 }; // namespace android
+
+#ifndef __LP64__
+// Backwards compatibility for libdatabase_sqlcipher (http://b/8253769).
+extern "C" void _ZN7android10MemoryBaseC1ERKNS_2spINS_11IMemoryHeapEEEij(void*, void*, ssize_t, size_t);
+extern "C" void _ZN7android10MemoryBaseC1ERKNS_2spINS_11IMemoryHeapEEElj(void* obj, void* h, long o, unsigned int size) {
+    _ZN7android10MemoryBaseC1ERKNS_2spINS_11IMemoryHeapEEEij(obj, h, o, size);
+}
+#endif
diff --git a/libs/binder/MemoryDealer.cpp b/libs/binder/MemoryDealer.cpp
index 8739625..878f287 100644
--- a/libs/binder/MemoryDealer.cpp
+++ b/libs/binder/MemoryDealer.cpp
@@ -225,6 +225,13 @@ Allocation::~Allocation()
 
 // ----------------------------------------------------------------------------
 
+#ifdef ADD_LEGACY_MEMORY_DEALER_CONSTRUCTOR_SYMBOL
+extern "C" void _ZN7android12MemoryDealerC2EjPKcj(void* obj, size_t size, const char* name, uint32_t flags);
+extern "C" void _ZN7android12MemoryDealerC1EjPKc(void* obj, size_t size, const char* name) {
+    _ZN7android12MemoryDealerC2EjPKcj(obj, size, name, 0);
+}
+#endif
+
 MemoryDealer::MemoryDealer(size_t size, const char* name, uint32_t flags)
     : mHeap(new MemoryHeapBase(size, flags, name)),
     mAllocator(new SimpleBestFitAllocator(size))
diff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp
index 7a4ddc4..343b2f9 100644
--- a/libs/binder/Parcel.cpp
+++ b/libs/binder/Parcel.cpp
@@ -54,24 +54,17 @@
 
 // ---------------------------------------------------------------------------
 
-// This macro should never be used at runtime, as a too large value
-// of s could cause an integer overflow. Instead, you should always
-// use the wrapper function pad_size()
-#define PAD_SIZE_UNSAFE(s) (((s)+3)&~3)
-
-static size_t pad_size(size_t s) {
-    if (s > (SIZE_T_MAX - 3)) {
-        abort();
-    }
-    return PAD_SIZE_UNSAFE(s);
-}
+#define PAD_SIZE(s) (((s)+3)&~3)
 
 // Note: must be kept in sync with android/os/StrictMode.java's PENALTY_GATHER
-#define STRICT_MODE_PENALTY_GATHER (0x40 << 16)
+#define STRICT_MODE_PENALTY_GATHER 0x100
 
 // Note: must be kept in sync with android/os/Parcel.java's EX_HAS_REPLY_HEADER
 #define EX_HAS_REPLY_HEADER -128
 
+// Maximum size of a blob to transfer in-place.
+static const size_t IN_PLACE_BLOB_LIMIT = 40 * 1024;
+
 // XXX This can be made public if we want to provide
 // support for typed data.
 struct small_flat_data
@@ -86,15 +79,6 @@ static pthread_mutex_t gParcelGlobalAllocSizeLock = PTHREAD_MUTEX_INITIALIZER;
 static size_t gParcelGlobalAllocSize = 0;
 static size_t gParcelGlobalAllocCount = 0;
 
-// Maximum size of a blob to transfer in-place.
-static const size_t BLOB_INPLACE_LIMIT = 16 * 1024;
-
-enum {
-    BLOB_INPLACE = 0,
-    BLOB_ASHMEM_IMMUTABLE = 1,
-    BLOB_ASHMEM_MUTABLE = 2,
-};
-
 void acquire_object(const sp<ProcessState>& proc,
     const flat_binder_object& obj, const void* who)
 {
@@ -371,12 +355,6 @@ size_t Parcel::dataCapacity() const
 
 status_t Parcel::setDataSize(size_t size)
 {
-    if (size > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
     status_t err;
     err = continueWrite(size);
     if (err == NO_ERROR) {
@@ -388,36 +366,18 @@ status_t Parcel::setDataSize(size_t size)
 
 void Parcel::setDataPosition(size_t pos) const
 {
-    if (pos > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        abort();
-    }
-
     mDataPos = pos;
     mNextObjectHint = 0;
 }
 
 status_t Parcel::setDataCapacity(size_t size)
 {
-    if (size > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
     if (size > mDataCapacity) return continueWrite(size);
     return NO_ERROR;
 }
 
 status_t Parcel::setData(const uint8_t* buffer, size_t len)
 {
-    if (len > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
     status_t err = restartWrite(len);
     if (err == NO_ERROR) {
         memcpy(const_cast<uint8_t*>(data()), buffer, len);
@@ -441,12 +401,6 @@ status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
         return NO_ERROR;
     }
 
-    if (len > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
     // range checks against the source parcel size
     if ((offset > parcel->mDataSize)
             || (len > parcel->mDataSize)
@@ -484,8 +438,7 @@ status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
     if (numObjects > 0) {
         // grow objects
         if (mObjectsCapacity < mObjectsSize + numObjects) {
-            size_t newSize = ((mObjectsSize + numObjects)*3)/2;
-            if (newSize < mObjectsSize) return NO_MEMORY;   // overflow
+            int newSize = ((mObjectsSize + numObjects)*3)/2;
             binder_size_t *objects =
                 (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
             if (objects == (binder_size_t*)0) {
@@ -523,11 +476,6 @@ status_t Parcel::appendFrom(const Parcel *parcel, size_t offset, size_t len)
     return err;
 }
 
-bool Parcel::allowFds() const
-{
-    return mAllowFds;
-}
-
 bool Parcel::pushAllowFds(bool allowFds)
 {
     const bool origValue = mAllowFds;
@@ -613,12 +561,6 @@ void Parcel::setError(status_t err)
 
 status_t Parcel::finishWrite(size_t len)
 {
-    if (len > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
     //printf("Finish write of %d\n", len);
     mDataPos += len;
     ALOGV("finishWrite Setting data pos of %p to %zu", this, mDataPos);
@@ -632,12 +574,6 @@ status_t Parcel::finishWrite(size_t len)
 
 status_t Parcel::writeUnpadded(const void* data, size_t len)
 {
-    if (len > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
     size_t end = mDataPos + len;
     if (end < mDataPos) {
         // integer overflow
@@ -657,12 +593,6 @@ restart_write:
 
 status_t Parcel::write(const void* data, size_t len)
 {
-    if (len > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
     void* const d = writeInplace(len);
     if (d) {
         memcpy(d, data, len);
@@ -673,13 +603,7 @@ status_t Parcel::write(const void* data, size_t len)
 
 void* Parcel::writeInplace(size_t len)
 {
-    if (len > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return NULL;
-    }
-
-    const size_t padded = pad_size(len);
+    const size_t padded = PAD_SIZE(len);
 
     // sanity check for integer overflow
     if (mDataPos+padded < mDataPos) {
@@ -721,39 +645,21 @@ status_t Parcel::writeInt32(int32_t val)
 {
     return writeAligned(val);
 }
-
-status_t Parcel::writeUint32(uint32_t val)
-{
-    return writeAligned(val);
-}
-
 status_t Parcel::writeInt32Array(size_t len, const int32_t *val) {
-    if (len > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
     if (!val) {
-        return writeInt32(-1);
+        return writeAligned(-1);
     }
-    status_t ret = writeInt32(static_cast<uint32_t>(len));
+    status_t ret = writeAligned(len);
     if (ret == NO_ERROR) {
         ret = write(val, len * sizeof(*val));
     }
     return ret;
 }
 status_t Parcel::writeByteArray(size_t len, const uint8_t *val) {
-    if (len > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
     if (!val) {
-        return writeInt32(-1);
+        return writeAligned(-1);
     }
-    status_t ret = writeInt32(static_cast<uint32_t>(len));
+    status_t ret = writeAligned(len);
     if (ret == NO_ERROR) {
         ret = write(val, len * sizeof(*val));
     }
@@ -765,11 +671,6 @@ status_t Parcel::writeInt64(int64_t val)
     return writeAligned(val);
 }
 
-status_t Parcel::writeUint64(uint64_t val)
-{
-    return writeAligned(val);
-}
-
 status_t Parcel::writePointer(uintptr_t val)
 {
     return writeAligned<binder_uintptr_t>(val);
@@ -898,24 +799,45 @@ status_t Parcel::writeDupFileDescriptor(int fd)
     return err;
 }
 
-status_t Parcel::writeBlob(size_t len, bool mutableCopy, WritableBlob* outBlob)
-{
-    if (len > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
+// WARNING: This method must stay in sync with
+// Parcelable.Creator<ParcelFileDescriptor> CREATOR
+// in frameworks/base/core/java/android/os/ParcelFileDescriptor.java
+status_t Parcel::writeParcelFileDescriptor(int fd, int commChannel) {
+    status_t status;
+
+    if (fd < 0) {
+        status = writeInt32(0); // ParcelFileDescriptor is null
+        if (status) return status;
+    } else {
+        status = writeInt32(1); // ParcelFileDescriptor is not null
+        if (status) return status;
+        status = writeDupFileDescriptor(fd);
+        if (status) return status;
+        if (commChannel < 0) {
+            status = writeInt32(0); // commChannel is null
+            if (status) return status;
+        } else {
+            status = writeInt32(1); // commChannel is not null
+            if (status) return status;
+            status = writeDupFileDescriptor(commChannel);
+        }
     }
+    return status;
+}
 
+status_t Parcel::writeBlob(size_t len, WritableBlob* outBlob)
+{
     status_t status;
-    if (!mAllowFds || len <= BLOB_INPLACE_LIMIT) {
+
+    if (!mAllowFds || len <= IN_PLACE_BLOB_LIMIT) {
         ALOGV("writeBlob: write in place");
-        status = writeInt32(BLOB_INPLACE);
+        status = writeInt32(0);
         if (status) return status;
 
         void* ptr = writeInplace(len);
         if (!ptr) return NO_MEMORY;
 
-        outBlob->init(-1, ptr, len, false);
+        outBlob->init(false /*mapped*/, ptr, len);
         return NO_ERROR;
     }
 
@@ -923,8 +845,6 @@ status_t Parcel::writeBlob(size_t len, bool mutableCopy, WritableBlob* outBlob)
     int fd = ashmem_create_region("Parcel Blob", len);
     if (fd < 0) return NO_MEMORY;
 
-    mBlobAshmemSize += len;
-
     int result = ashmem_set_prot_region(fd, PROT_READ | PROT_WRITE);
     if (result < 0) {
         status = result;
@@ -933,17 +853,15 @@ status_t Parcel::writeBlob(size_t len, bool mutableCopy, WritableBlob* outBlob)
         if (ptr == MAP_FAILED) {
             status = -errno;
         } else {
-            if (!mutableCopy) {
-                result = ashmem_set_prot_region(fd, PROT_READ);
-            }
+            result = ashmem_set_prot_region(fd, PROT_READ);
             if (result < 0) {
                 status = result;
             } else {
-                status = writeInt32(mutableCopy ? BLOB_ASHMEM_MUTABLE : BLOB_ASHMEM_IMMUTABLE);
+                status = writeInt32(1);
                 if (!status) {
                     status = writeFileDescriptor(fd, true /*takeOwnership*/);
                     if (!status) {
-                        outBlob->init(fd, ptr, len, mutableCopy);
+                        outBlob->init(true /*mapped*/, ptr, len);
                         return NO_ERROR;
                     }
                 }
@@ -955,15 +873,6 @@ status_t Parcel::writeBlob(size_t len, bool mutableCopy, WritableBlob* outBlob)
     return status;
 }
 
-status_t Parcel::writeDupImmutableBlobFileDescriptor(int fd)
-{
-    // Must match up with what's done in writeBlob.
-    if (!mAllowFds) return FDS_NOT_ALLOWED;
-    status_t status = writeInt32(BLOB_ASHMEM_IMMUTABLE);
-    if (status) return status;
-    return writeDupFileDescriptor(fd);
-}
-
 status_t Parcel::write(const FlattenableHelperInterface& val)
 {
     status_t err;
@@ -972,12 +881,6 @@ status_t Parcel::write(const FlattenableHelperInterface& val)
     const size_t len = val.getFlattenedSize();
     const size_t fd_count = val.getFdCount();
 
-    if ((len > INT32_MAX) || (fd_count > INT32_MAX)) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
     err = this->writeInt32(len);
     if (err) return err;
 
@@ -985,7 +888,7 @@ status_t Parcel::write(const FlattenableHelperInterface& val)
     if (err) return err;
 
     // payload
-    void* const buf = this->writeInplace(pad_size(len));
+    void* const buf = this->writeInplace(PAD_SIZE(len));
     if (buf == NULL)
         return BAD_VALUE;
 
@@ -1014,22 +917,21 @@ status_t Parcel::writeObject(const flat_binder_object& val, bool nullMetaData)
 restart_write:
         *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;
 
+        // Need to write meta-data?
+        if (nullMetaData || val.binder != 0) {
+            mObjects[mObjectsSize] = mDataPos;
+            acquire_object(ProcessState::self(), val, this);
+            mObjectsSize++;
+        }
+
         // remember if it's a file descriptor
         if (val.type == BINDER_TYPE_FD) {
             if (!mAllowFds) {
-                // fail before modifying our object index
                 return FDS_NOT_ALLOWED;
             }
             mHasFds = mFdsKnown = true;
         }
 
-        // Need to write meta-data?
-        if (nullMetaData || val.binder != 0) {
-            mObjects[mObjectsSize] = mDataPos;
-            acquire_object(ProcessState::self(), val, this);
-            mObjectsSize++;
-        }
-
         return finishWrite(sizeof(flat_binder_object));
     }
 
@@ -1039,7 +941,6 @@ restart_write:
     }
     if (!enoughObjects) {
         size_t newSize = ((mObjectsSize+2)*3)/2;
-        if (newSize < mObjectsSize) return NO_MEMORY;   // overflow
         binder_size_t* objects = (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
         if (objects == NULL) return NO_MEMORY;
         mObjects = objects;
@@ -1061,16 +962,10 @@ void Parcel::remove(size_t /*start*/, size_t /*amt*/)
 
 status_t Parcel::read(void* outData, size_t len) const
 {
-    if (len > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
-    if ((mDataPos+pad_size(len)) >= mDataPos && (mDataPos+pad_size(len)) <= mDataSize
-            && len <= pad_size(len)) {
+    if ((mDataPos+PAD_SIZE(len)) >= mDataPos && (mDataPos+PAD_SIZE(len)) <= mDataSize
+            && len <= PAD_SIZE(len)) {
         memcpy(outData, mData+mDataPos, len);
-        mDataPos += pad_size(len);
+        mDataPos += PAD_SIZE(len);
         ALOGV("read Setting data pos of %p to %zu", this, mDataPos);
         return NO_ERROR;
     }
@@ -1079,16 +974,10 @@ status_t Parcel::read(void* outData, size_t len) const
 
 const void* Parcel::readInplace(size_t len) const
 {
-    if (len > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return NULL;
-    }
-
-    if ((mDataPos+pad_size(len)) >= mDataPos && (mDataPos+pad_size(len)) <= mDataSize
-            && len <= pad_size(len)) {
+    if ((mDataPos+PAD_SIZE(len)) >= mDataPos && (mDataPos+PAD_SIZE(len)) <= mDataSize
+            && len <= PAD_SIZE(len)) {
         const void* data = mData+mDataPos;
-        mDataPos += pad_size(len);
+        mDataPos += PAD_SIZE(len);
         ALOGV("readInplace Setting data pos of %p to %zu", this, mDataPos);
         return data;
     }
@@ -1097,7 +986,7 @@ const void* Parcel::readInplace(size_t len) const
 
 template<class T>
 status_t Parcel::readAligned(T *pArg) const {
-    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE_UNSAFE(sizeof(T)) == sizeof(T));
+    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(sizeof(T)) == sizeof(T));
 
     if ((mDataPos+sizeof(T)) <= mDataSize) {
         const void* data = mData+mDataPos;
@@ -1121,7 +1010,7 @@ T Parcel::readAligned() const {
 
 template<class T>
 status_t Parcel::writeAligned(T val) {
-    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE_UNSAFE(sizeof(T)) == sizeof(T));
+    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE(sizeof(T)) == sizeof(T));
 
     if ((mDataPos+sizeof(val)) <= mDataCapacity) {
 restart_write:
@@ -1144,15 +1033,6 @@ int32_t Parcel::readInt32() const
     return readAligned<int32_t>();
 }
 
-status_t Parcel::readUint32(uint32_t *pArg) const
-{
-    return readAligned(pArg);
-}
-
-uint32_t Parcel::readUint32() const
-{
-    return readAligned<uint32_t>();
-}
 
 status_t Parcel::readInt64(int64_t *pArg) const
 {
@@ -1165,15 +1045,14 @@ int64_t Parcel::readInt64() const
     return readAligned<int64_t>();
 }
 
-status_t Parcel::readUint64(uint64_t *pArg) const
+
+#ifdef NEEDS_LGE_RIL_SYMBOLS
+status_t Parcel::readuInt64(uint64_t *pArg) const
 {
     return readAligned(pArg);
 }
+#endif
 
-uint64_t Parcel::readUint64() const
-{
-    return readAligned<uint64_t>();
-}
 
 status_t Parcel::readPointer(uintptr_t *pArg) const
 {
@@ -1262,7 +1141,7 @@ const char* Parcel::readCString() const
         const char* eos = reinterpret_cast<const char*>(memchr(str, 0, avail));
         if (eos) {
             const size_t len = eos - str;
-            mDataPos += pad_size(len+1);
+            mDataPos += PAD_SIZE(len+1);
             ALOGV("readCString Setting data pos of %p to %zu", this, mDataPos);
             return str;
         }
@@ -1376,31 +1255,46 @@ int Parcel::readFileDescriptor() const
     return BAD_TYPE;
 }
 
+// WARNING: This method must stay in sync with writeToParcel()
+// in frameworks/base/core/java/android/os/ParcelFileDescriptor.java
+int Parcel::readParcelFileDescriptor(int& outCommChannel) const {
+    int fd;
+    outCommChannel = -1;
+
+    if (readInt32() == 0) {
+        fd = -1;
+    } else {
+        fd = readFileDescriptor();
+        if (fd >= 0 && readInt32() != 0) {
+            outCommChannel = readFileDescriptor();
+        }
+    }
+    return fd;
+}
+
 status_t Parcel::readBlob(size_t len, ReadableBlob* outBlob) const
 {
-    int32_t blobType;
-    status_t status = readInt32(&blobType);
+    int32_t useAshmem;
+    status_t status = readInt32(&useAshmem);
     if (status) return status;
 
-    if (blobType == BLOB_INPLACE) {
+    if (!useAshmem) {
         ALOGV("readBlob: read in place");
         const void* ptr = readInplace(len);
         if (!ptr) return BAD_VALUE;
 
-        outBlob->init(-1, const_cast<void*>(ptr), len, false);
+        outBlob->init(false /*mapped*/, const_cast<void*>(ptr), len);
         return NO_ERROR;
     }
 
     ALOGV("readBlob: read from ashmem");
-    bool isMutable = (blobType == BLOB_ASHMEM_MUTABLE);
     int fd = readFileDescriptor();
     if (fd == int(BAD_TYPE)) return BAD_VALUE;
 
-    void* ptr = ::mmap(NULL, len, isMutable ? PROT_READ | PROT_WRITE : PROT_READ,
-            MAP_SHARED, fd, 0);
+    void* ptr = ::mmap(NULL, len, PROT_READ, MAP_SHARED, fd, 0);
     if (ptr == MAP_FAILED) return NO_MEMORY;
 
-    outBlob->init(fd, ptr, len, isMutable);
+    outBlob->init(true /*mapped*/, ptr, len);
     return NO_ERROR;
 }
 
@@ -1410,14 +1304,8 @@ status_t Parcel::read(FlattenableHelperInterface& val) const
     const size_t len = this->readInt32();
     const size_t fd_count = this->readInt32();
 
-    if (len > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
     // payload
-    void const* const buf = this->readInplace(pad_size(len));
+    void const* const buf = this->readInplace(PAD_SIZE(len));
     if (buf == NULL)
         return BAD_VALUE;
 
@@ -1563,7 +1451,7 @@ void Parcel::ipcSetDataReference(const uint8_t* data, size_t dataSize,
     for (size_t i = 0; i < mObjectsSize; i++) {
         binder_size_t offset = mObjects[i];
         if (offset < minOffset) {
-            ALOGE("%s: bad object offset %" PRIu64 " < %" PRIu64 "\n",
+            ALOGE("%s: bad object offset %"PRIu64" < %"PRIu64"\n",
                   __func__, (uint64_t)offset, (uint64_t)minOffset);
             mObjectsSize = 0;
             break;
@@ -1656,12 +1544,6 @@ void Parcel::freeDataNoInit()
 
 status_t Parcel::growData(size_t len)
 {
-    if (len > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
     size_t newSize = ((mDataSize+len)*3)/2;
     return (newSize <= mDataSize)
             ? (status_t) NO_MEMORY
@@ -1670,12 +1552,6 @@ status_t Parcel::growData(size_t len)
 
 status_t Parcel::restartWrite(size_t desired)
 {
-    if (desired > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
     if (mOwner) {
         freeData();
         return continueWrite(desired);
@@ -1716,12 +1592,6 @@ status_t Parcel::restartWrite(size_t desired)
 
 status_t Parcel::continueWrite(size_t desired)
 {
-    if (desired > INT32_MAX) {
-        // don't accept size_t values which may have come from an
-        // inadvertent conversion from a negative int.
-        return BAD_VALUE;
-    }
-
     // If shrinking, first adjust for any objects that appear
     // after the new data size.
     size_t objectsSize = mObjectsSize;
@@ -1754,7 +1624,7 @@ status_t Parcel::continueWrite(size_t desired)
         binder_size_t* objects = NULL;
 
         if (objectsSize) {
-            objects = (binder_size_t*)calloc(objectsSize, sizeof(binder_size_t));
+            objects = (binder_size_t*)malloc(objectsSize*sizeof(binder_size_t));
             if (!objects) {
                 free(data);
 
@@ -1890,7 +1760,6 @@ void Parcel::initState()
     mFdsKnown = true;
     mAllowFds = true;
     mOwner = NULL;
-    mBlobAshmemSize = 0;
 }
 
 void Parcel::scanForFds() const
@@ -1908,15 +1777,10 @@ void Parcel::scanForFds() const
     mFdsKnown = true;
 }
 
-size_t Parcel::getBlobAshmemSize() const
-{
-    return mBlobAshmemSize;
-}
-
 // --- Parcel::Blob ---
 
 Parcel::Blob::Blob() :
-        mFd(-1), mData(NULL), mSize(0), mMutable(false) {
+        mMapped(false), mData(NULL), mSize(0) {
 }
 
 Parcel::Blob::~Blob() {
@@ -1924,24 +1788,22 @@ Parcel::Blob::~Blob() {
 }
 
 void Parcel::Blob::release() {
-    if (mFd != -1 && mData) {
+    if (mMapped && mData) {
         ::munmap(mData, mSize);
     }
     clear();
 }
 
-void Parcel::Blob::init(int fd, void* data, size_t size, bool isMutable) {
-    mFd = fd;
+void Parcel::Blob::init(bool mapped, void* data, size_t size) {
+    mMapped = mapped;
     mData = data;
     mSize = size;
-    mMutable = isMutable;
 }
 
 void Parcel::Blob::clear() {
-    mFd = -1;
+    mMapped = false;
     mData = NULL;
     mSize = 0;
-    mMutable = false;
 }
 
 }; // namespace android
-- 
1.9.1

