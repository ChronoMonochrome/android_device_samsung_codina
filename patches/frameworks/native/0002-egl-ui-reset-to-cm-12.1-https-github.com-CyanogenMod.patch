From 918763adf11d030ba1f82df138d66d8814a60631 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Tue, 29 Sep 2015 00:01:43 +0300
Subject: [PATCH 2/8] egl, ui: reset to cm-12.1
 (https://github.com/CyanogenMod/android_frameworks_native/commit/b5f98d71e8b37c7a90401128e19887e66913b666)

Change-Id: Iaaba235cacf286e68641967fa85dd572a5eef75e

Conflicts:
	libs/ui/Region.cpp
	opengl/libs/EGL/eglApi.cpp
	opengl/libs/EGL/egl_entries.in

Conflicts:
	include/ui/DisplayInfo.h
	include/ui/GraphicBuffer.h
	include/ui/GraphicBufferMapper.h
	libs/ui/GraphicBuffer.cpp
	libs/ui/GraphicBufferAllocator.cpp
	libs/ui/Region.cpp
	opengl/libs/EGL/eglApi.cpp
---
 include/gui/BufferItem.h                       |   42 +-
 include/gui/BufferItemConsumer.h               |   14 +-
 include/gui/BufferQueue.h                      |   11 +-
 include/gui/BufferQueueConsumer.h              |   14 +-
 include/gui/BufferQueueCore.h                  |   54 +-
 include/gui/BufferQueueProducer.h              |   20 +-
 include/gui/ConsumerBase.h                     |   47 +-
 include/gui/CpuConsumer.h                      |   21 +-
 include/gui/GLConsumer.h                       |   15 +-
 include/gui/GraphicBufferAlloc.h               |    5 +-
 include/gui/IGraphicBufferAlloc.h              |    8 +-
 include/gui/IGraphicBufferConsumer.h           |   93 +-
 include/gui/IGraphicBufferProducer.h           |   62 +-
 include/gui/ISensorServer.h                    |    7 +-
 include/gui/ISurfaceComposer.h                 |   12 +-
 include/gui/Sensor.h                           |   16 +-
 include/gui/SensorEventQueue.h                 |    5 +-
 include/gui/SensorManager.h                    |   68 +-
 include/gui/Surface.h                          |   73 +-
 include/gui/SurfaceComposerClient.h            |    2 +-
 include/gui/SurfaceControl.h                   |    7 +-
 include/ui/DisplayInfo.h                       |    4 +
 include/ui/Fence.h                             |    2 +-
 include/ui/FramebufferNativeWindow.h           |    6 +-
 include/ui/GraphicBuffer.h                     |   66 +-
 include/ui/GraphicBufferAllocator.h            |   46 +-
 include/ui/GraphicBufferMapper.h               |   15 +-
 include/ui/PixelFormat.h                       |   62 +-
 include/ui/Rect.h                              |   19 -
 include/ui/Region.h                            |   17 +-
 libs/gui/Android.mk                            |   44 +-
 libs/gui/BitTube.cpp                           |    8 +-
 libs/gui/BufferItem.cpp                        |  143 +-
 libs/gui/BufferItemConsumer.cpp                |   26 +-
 libs/gui/BufferQueue.cpp                       |   10 +-
 libs/gui/BufferQueueConsumer.cpp               |  307 ++-
 libs/gui/BufferQueueCore.cpp                   |   67 +-
 libs/gui/BufferQueueProducer.cpp               |  246 +--
 libs/gui/BufferSlot.cpp                        |    2 +-
 libs/gui/ConsumerBase.cpp                      |   68 +-
 libs/gui/CpuConsumer.cpp                       |   55 +-
 libs/gui/GLConsumer.cpp                        |  230 +-
 libs/gui/GraphicBufferAlloc.cpp                |    9 +-
 libs/gui/IConsumerListener.cpp                 |    6 -
 libs/gui/IDisplayEventConnection.cpp           |   16 +-
 libs/gui/IGraphicBufferAlloc.cpp               |   47 +-
 libs/gui/IGraphicBufferConsumer.cpp            |  268 ++-
 libs/gui/IGraphicBufferProducer.cpp            |  152 +-
 libs/gui/IProducerListener.cpp                 |    6 -
 libs/gui/ISensorEventConnection.cpp            |   16 +-
 libs/gui/ISensorServer.cpp                     |   50 +-
 libs/gui/ISurfaceComposer.cpp                  |   91 +-
 libs/gui/ISurfaceComposerClient.cpp            |   40 +-
 libs/gui/LayerState.cpp                        |   52 +-
 libs/gui/Sensor.cpp                            |   58 +-
 libs/gui/SensorEventQueue.cpp                  |   31 +-
 libs/gui/SensorManager.cpp                     |   38 +-
 libs/gui/StreamSplitter.cpp                    |    8 +-
 libs/gui/Surface.cpp                           |  332 +--
 libs/gui/SurfaceComposerClient.cpp             |   29 +-
 libs/gui/SurfaceControl.cpp                    |   11 +-
 libs/gui/SyncFeatures.cpp                      |    4 +-
 libs/gui/tests/Android.mk                      |   10 +-
 libs/gui/tests/BufferQueue_test.cpp            |  132 +-
 libs/gui/tests/CpuConsumer_test.cpp            |   37 +-
 libs/gui/tests/IGraphicBufferProducer_test.cpp |   56 +-
 libs/gui/tests/SRGB_test.cpp                   |   30 +-
 libs/gui/tests/StreamSplitter_test.cpp         |   18 +-
 libs/gui/tests/SurfaceTextureClient_test.cpp   |   67 +-
 libs/gui/tests/SurfaceTextureFBO_test.cpp      |    6 +-
 libs/gui/tests/SurfaceTextureGLToGL_test.cpp   |   19 +-
 libs/gui/tests/SurfaceTextureGL_test.cpp       |   36 +-
 libs/gui/tests/Surface_test.cpp                |   73 -
 libs/ui/Android.mk                             |   28 +-
 libs/ui/Fence.cpp                              |   19 +-
 libs/ui/FramebufferNativeWindow.cpp            |  130 +-
 libs/ui/GraphicBuffer.cpp                      |  198 +-
 libs/ui/GraphicBufferAllocator.cpp             |   64 +-
 libs/ui/GraphicBufferMapper.cpp                |   62 +-
 libs/ui/PixelFormat.cpp                        |  119 +-
 libs/ui/Rect.cpp                               |    2 -
 libs/ui/Region.cpp                             |  249 +--
 libs/ui/UiConfig.cpp                           |    3 -
 libs/ui/tests/Android.mk                       |   59 +-
 libs/ui/tests/vec_test.cpp                     |    7 +-
 opengl/libs/Android.mk                         |   18 +-
 opengl/libs/EGL/Loader.cpp                     |   29 +
 opengl/libs/EGL/egl.cpp                        |   38 -
 opengl/libs/EGL/eglApi.cpp                     |  491 ++---
 opengl/libs/EGL/egl_display.h                  |    2 +-
 opengl/libs/EGL/egl_entries.in                 |   35 +-
 opengl/libs/EGL/egl_object.cpp                 |   11 -
 opengl/libs/EGL/egl_object.h                   |    2 -
 opengl/libs/EGL/getProcAddress.cpp             |   50 +-
 opengl/libs/GLES2/gl2.cpp                      |  135 +-
 opengl/libs/GLES2/gl2_api.in                   |   10 +-
 opengl/libs/GLES_CM/gl.cpp                     |   53 +-
 opengl/libs/GLES_trace/Android.mk              |   19 +-
 opengl/libs/GLES_trace/dev.make                |    5 +
 opengl/libs/GLES_trace/gltrace.proto           |  851 ++++++++
 opengl/libs/GLES_trace/src/gltrace.pb.cpp      | 2715 ++++++++++++++++++++++++
 opengl/libs/GLES_trace/src/gltrace.pb.h        | 2525 ++++++++++++++++++++++
 opengl/libs/GLES_trace/src/gltrace_api.cpp     |    2 +-
 opengl/libs/GLES_trace/src/gltrace_egl.cpp     |    2 +-
 opengl/libs/GLES_trace/src/gltrace_fixup.cpp   |    2 +-
 opengl/libs/GLES_trace/src/gltrace_fixup.h     |    2 +-
 opengl/libs/GLES_trace/src/gltrace_transport.h |    2 +-
 opengl/libs/egl_impl.h                         |    3 -
 108 files changed, 8256 insertions(+), 3473 deletions(-)
 mode change 100644 => 100755 libs/ui/Region.cpp
 create mode 100644 opengl/libs/GLES_trace/gltrace.proto
 create mode 100644 opengl/libs/GLES_trace/src/gltrace.pb.cpp
 create mode 100644 opengl/libs/GLES_trace/src/gltrace.pb.h

diff --git a/include/gui/BufferItem.h b/include/gui/BufferItem.h
index 145efe6..01b6ff4 100644
--- a/include/gui/BufferItem.h
+++ b/include/gui/BufferItem.h
@@ -20,10 +20,9 @@
 #include <EGL/egl.h>
 #include <EGL/eglext.h>
 
-#include <ui/Rect.h>
-#include <ui/Region.h>
+#include <gui/IGraphicBufferConsumer.h>
 
-#include <system/graphics.h>
+#include <ui/Rect.h>
 
 #include <utils/Flattenable.h>
 #include <utils/StrongPointer.h>
@@ -46,6 +45,7 @@ class BufferItem : public Flattenable<BufferItem> {
     enum { INVALID_BUFFER_SLOT = -1 };
     BufferItem();
     ~BufferItem();
+    operator IGraphicBufferConsumer::BufferItem() const;
 
     static const char* scalingModeName(uint32_t scalingMode);
 
@@ -72,39 +72,17 @@ class BufferItem : public Flattenable<BufferItem> {
     // to set by queueBuffer each time this slot is queued. This value
     // is guaranteed to be monotonically increasing for each newly
     // acquired buffer.
-    union {
-        int64_t mTimestamp;
-        struct {
-            uint32_t mTimestampLo;
-            uint32_t mTimestampHi;
-        };
-    };
+    int64_t mTimestamp;
 
     // mIsAutoTimestamp indicates whether mTimestamp was generated
     // automatically when the buffer was queued.
     bool mIsAutoTimestamp;
 
-    // mDataSpace is the current dataSpace value for this buffer slot. This gets
-    // set by queueBuffer each time this slot is queued. The meaning of the
-    // dataSpace is format-dependent.
-    android_dataspace mDataSpace;
-
     // mFrameNumber is the number of the queued frame for this slot.
-    union {
-        uint64_t mFrameNumber;
-        struct {
-            uint32_t mFrameNumberLo;
-            uint32_t mFrameNumberHi;
-        };
-    };
-
-    union {
-        // mSlot is the slot index of this buffer (default INVALID_BUFFER_SLOT).
-        int mSlot;
-
-        // mBuf is the former name for mSlot
-        int mBuf;
-    };
+    uint64_t mFrameNumber;
+
+    // mSlot is the slot index of this buffer (default INVALID_BUFFER_SLOT).
+    int mSlot;
 
     // mIsDroppable whether this buffer was queued with the
     // property that it can be replaced by a new buffer for the purpose of
@@ -119,10 +97,6 @@ class BufferItem : public Flattenable<BufferItem> {
     // Indicates this buffer must be transformed by the inverse transform of the screen
     // it is displayed onto. This is applied after mTransform.
     bool mTransformToDisplayInverse;
-
-    // Describes the portion of the surface that has been modified since the
-    // previous frame
-    Region mSurfaceDamage;
 };
 
 } // namespace android
diff --git a/include/gui/BufferItemConsumer.h b/include/gui/BufferItemConsumer.h
index 56c7a3f..5494ff1 100644
--- a/include/gui/BufferItemConsumer.h
+++ b/include/gui/BufferItemConsumer.h
@@ -42,6 +42,8 @@ class BufferItemConsumer: public ConsumerBase
   public:
     typedef ConsumerBase::FrameAvailableListener FrameAvailableListener;
 
+    typedef BufferQueue::BufferItem BufferItem;
+
     enum { DEFAULT_MAX_BUFFERS = -1 };
     enum { INVALID_BUFFER_SLOT = BufferQueue::INVALID_BUFFER_SLOT };
     enum { NO_BUFFER_AVAILABLE = BufferQueue::NO_BUFFER_AVAILABLE };
@@ -74,8 +76,8 @@ class BufferItemConsumer: public ConsumerBase
     //
     // If waitForFence is true, and the acquired BufferItem has a valid fence object,
     // acquireBuffer will wait on the fence with no timeout before returning.
-    status_t acquireBuffer(BufferItem* item, nsecs_t presentWhen,
-            bool waitForFence = true);
+    status_t acquireBuffer(BufferItem *item, nsecs_t presentWhen,
+        bool waitForFence = true);
 
     // Returns an acquired buffer to the queue, allowing it to be reused. Since
     // only a fixed number of buffers may be acquired at a time, old buffers
@@ -86,6 +88,14 @@ class BufferItemConsumer: public ConsumerBase
     status_t releaseBuffer(const BufferItem &item,
             const sp<Fence>& releaseFence = Fence::NO_FENCE);
 
+    // setDefaultBufferSize is used to set the size of buffers returned by
+    // requestBuffers when a with and height of zero is requested.
+    status_t setDefaultBufferSize(uint32_t w, uint32_t h);
+
+    // setDefaultBufferFormat allows the BufferQueue to create
+    // GraphicBuffers of a defaultFormat if no format is specified
+    // in dequeueBuffer
+    status_t setDefaultBufferFormat(uint32_t defaultFormat);
 };
 
 } // namespace android
diff --git a/include/gui/BufferQueue.h b/include/gui/BufferQueue.h
index 09300a2..1188837 100644
--- a/include/gui/BufferQueue.h
+++ b/include/gui/BufferQueue.h
@@ -17,7 +17,6 @@
 #ifndef ANDROID_GUI_BUFFERQUEUE_H
 #define ANDROID_GUI_BUFFERQUEUE_H
 
-#include <gui/BufferItem.h>
 #include <gui/BufferQueueDefs.h>
 #include <gui/IGraphicBufferConsumer.h>
 #include <gui/IGraphicBufferProducer.h>
@@ -35,7 +34,7 @@ public:
     // Attempts at runtime to increase the number of buffers past this will fail.
     enum { NUM_BUFFER_SLOTS = BufferQueueDefs::NUM_BUFFER_SLOTS };
     // Used as a placeholder slot# when the value isn't pointing to an existing buffer.
-    enum { INVALID_BUFFER_SLOT = BufferItem::INVALID_BUFFER_SLOT };
+    enum { INVALID_BUFFER_SLOT = IGraphicBufferConsumer::BufferItem::INVALID_BUFFER_SLOT };
     // Alias to <IGraphicBufferConsumer.h> -- please scope from there in future code!
     enum {
         NO_BUFFER_AVAILABLE = IGraphicBufferConsumer::NO_BUFFER_AVAILABLE,
@@ -48,6 +47,7 @@ public:
 
     // for backward source compatibility
     typedef ::android::ConsumerListener ConsumerListener;
+    typedef IGraphicBufferConsumer::BufferItem BufferItem;
 
     // ProxyConsumerListener is a ConsumerListener implementation that keeps a weak
     // reference to the actual consumer object.  It forwards all calls to that
@@ -62,10 +62,9 @@ public:
     public:
         ProxyConsumerListener(const wp<ConsumerListener>& consumerListener);
         virtual ~ProxyConsumerListener();
-        virtual void onFrameAvailable(const BufferItem& item) override;
-        virtual void onFrameReplaced(const BufferItem& item) override;
-        virtual void onBuffersReleased() override;
-        virtual void onSidebandStreamChanged() override;
+        virtual void onFrameAvailable(const android::BufferItem& item);
+        virtual void onBuffersReleased();
+        virtual void onSidebandStreamChanged();
     private:
         // mConsumerListener is a weak reference to the IConsumerListener.  This is
         // the raison d'etre of ProxyConsumerListener.
diff --git a/include/gui/BufferQueueConsumer.h b/include/gui/BufferQueueConsumer.h
index cde302f..1912ed0 100644
--- a/include/gui/BufferQueueConsumer.h
+++ b/include/gui/BufferQueueConsumer.h
@@ -47,7 +47,7 @@ public:
     // returned.  The presentation time is in nanoseconds, and the time base
     // is CLOCK_MONOTONIC.
     virtual status_t acquireBuffer(BufferItem* outBuffer,
-            nsecs_t expectedPresent, uint64_t maxFrameNumber = 0) override;
+            nsecs_t expectedPresent);
 
     // See IGraphicBufferConsumer::detachBuffer
     virtual status_t detachBuffer(int slot);
@@ -125,15 +125,9 @@ public:
 
     // setDefaultBufferFormat allows the BufferQueue to create
     // GraphicBuffers of a defaultFormat if no format is specified
-    // in dequeueBuffer. The initial default is HAL_PIXEL_FORMAT_RGBA_8888.
-    virtual status_t setDefaultBufferFormat(PixelFormat defaultFormat);
-
-    // setDefaultBufferDataSpace allows the BufferQueue to create
-    // GraphicBuffers of a defaultDataSpace if no data space is specified
-    // in queueBuffer.
-    // The initial default is HAL_DATASPACE_UNKNOWN
-    virtual status_t setDefaultBufferDataSpace(
-            android_dataspace defaultDataSpace);
+    // in dequeueBuffer.  Formats are enumerated in graphics.h; the
+    // initial default is HAL_PIXEL_FORMAT_RGBA_8888.
+    virtual status_t setDefaultBufferFormat(uint32_t defaultFormat);
 
     // setConsumerUsageBits will turn on additional usage bits for dequeueBuffer.
     // These are merged with the bits passed to dequeueBuffer.  The values are
diff --git a/include/gui/BufferQueueCore.h b/include/gui/BufferQueueCore.h
index 99134ea..1050e3b 100644
--- a/include/gui/BufferQueueCore.h
+++ b/include/gui/BufferQueueCore.h
@@ -17,7 +17,6 @@
 #ifndef ANDROID_GUI_BUFFERQUEUECORE_H
 #define ANDROID_GUI_BUFFERQUEUECORE_H
 
-#include <gui/BufferItem.h>
 #include <gui/BufferQueueDefs.h>
 #include <gui/BufferSlot.h>
 
@@ -30,14 +29,11 @@
 #include <utils/Trace.h>
 #include <utils/Vector.h>
 
-#include <list>
-#include <set>
-
-#define BQ_LOGV(x, ...) ALOGV("[%s] " x, mConsumerName.string(), ##__VA_ARGS__)
-#define BQ_LOGD(x, ...) ALOGD("[%s] " x, mConsumerName.string(), ##__VA_ARGS__)
-#define BQ_LOGI(x, ...) ALOGI("[%s] " x, mConsumerName.string(), ##__VA_ARGS__)
-#define BQ_LOGW(x, ...) ALOGW("[%s] " x, mConsumerName.string(), ##__VA_ARGS__)
-#define BQ_LOGE(x, ...) ALOGE("[%s] " x, mConsumerName.string(), ##__VA_ARGS__)
+#define BQ_LOGV(x, ...) ALOGV("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
+#define BQ_LOGD(x, ...) ALOGD("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
+#define BQ_LOGI(x, ...) ALOGI("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
+#define BQ_LOGW(x, ...) ALOGW("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
+#define BQ_LOGE(x, ...) ALOGE("[%s] "x, mConsumerName.string(), ##__VA_ARGS__)
 
 #define ATRACE_BUFFER_INDEX(index)                                   \
     if (ATRACE_ENABLED()) {                                          \
@@ -49,6 +45,7 @@
 
 namespace android {
 
+class BufferItem;
 class IConsumerListener;
 class IGraphicBufferAlloc;
 class IProducerListener;
@@ -61,7 +58,7 @@ class BufferQueueCore : public virtual RefBase {
 public:
     // Used as a placeholder slot number when the value isn't pointing to an
     // existing buffer.
-    enum { INVALID_BUFFER_SLOT = BufferItem::INVALID_BUFFER_SLOT };
+    enum { INVALID_BUFFER_SLOT = -1 }; // TODO: Extract from IGBC::BufferItem
 
     // We reserve two slots in order to guarantee that the producer and
     // consumer can run asynchronously.
@@ -126,10 +123,6 @@ private:
     // waitWhileAllocatingLocked blocks until mIsAllocating is false.
     void waitWhileAllocatingLocked() const;
 
-    // validateConsistencyLocked ensures that the free lists are in sync with
-    // the information stored in mSlots
-    void validateConsistencyLocked() const;
-
     // mAllocator is the connection to SurfaceFlinger that is used to allocate
     // new GraphicBuffer objects.
     sp<IGraphicBufferAlloc> mAllocator;
@@ -184,14 +177,6 @@ private:
     // mQueue is a FIFO of queued buffers used in synchronous mode.
     Fifo mQueue;
 
-    // mFreeSlots contains all of the slots which are FREE and do not currently
-    // have a buffer attached
-    std::set<int> mFreeSlots;
-
-    // mFreeBuffers contains all of the slots which are FREE and currently have
-    // a buffer attached
-    std::list<int> mFreeBuffers;
-
     // mOverrideMaxBufferCount is the limit on the number of buffers that will
     // be allocated at one time. This value is set by the producer by calling
     // setBufferCount. The default is 0, which means that the producer doesn't
@@ -214,20 +199,15 @@ private:
 
     // mDefaultBufferFormat can be set so it will override the buffer format
     // when it isn't specified in dequeueBuffer.
-    PixelFormat mDefaultBufferFormat;
+    uint32_t mDefaultBufferFormat;
 
     // mDefaultWidth holds the default width of allocated buffers. It is used
     // in dequeueBuffer if a width and height of 0 are specified.
-    uint32_t mDefaultWidth;
+    int mDefaultWidth;
 
     // mDefaultHeight holds the default height of allocated buffers. It is used
     // in dequeueBuffer if a width and height of 0 are specified.
-    uint32_t mDefaultHeight;
-
-    // mDefaultBufferDataSpace holds the default dataSpace of queued buffers.
-    // It is used in queueBuffer if a dataspace of 0 (HAL_DATASPACE_UNKNOWN)
-    // is specified.
-    android_dataspace mDefaultBufferDataSpace;
+    int mDefaultHeight;
 
     // mDefaultMaxBufferCount is the default limit on the number of buffers that
     // will be allocated at one time. This default limit is set by the consumer.
@@ -266,20 +246,6 @@ private:
     // mIsAllocatingCondition is a condition variable used by producers to wait until mIsAllocating
     // becomes false.
     mutable Condition mIsAllocatingCondition;
-
-    // mAllowAllocation determines whether dequeueBuffer is allowed to allocate
-    // new buffers
-    bool mAllowAllocation;
-
-    // mBufferAge tracks the age of the contents of the most recently dequeued
-    // buffer as the number of frames that have elapsed since it was last queued
-    uint64_t mBufferAge;
-
-    // mGenerationNumber stores the current generation number of the attached
-    // producer. Any attempt to attach a buffer with a different generation
-    // number will fail.
-    uint32_t mGenerationNumber;
-
 }; // class BufferQueueCore
 
 } // namespace android
diff --git a/include/gui/BufferQueueProducer.h b/include/gui/BufferQueueProducer.h
index 9754a89..ed1056a 100644
--- a/include/gui/BufferQueueProducer.h
+++ b/include/gui/BufferQueueProducer.h
@@ -73,7 +73,9 @@ public:
     // updateTexImage() is called.  If width and height are both zero, the
     // default values specified by setDefaultBufferSize() are used instead.
     //
-    // If the format is 0, the default format will be used.
+    // The pixel formats are enumerated in graphics.h, e.g.
+    // HAL_PIXEL_FORMAT_RGBA_8888.  If the format is 0, the default format
+    // will be used.
     //
     // The usage argument specifies gralloc buffer usage flags.  The values
     // are enumerated in gralloc.h, e.g. GRALLOC_USAGE_HW_RENDER.  These
@@ -91,9 +93,8 @@ public:
     //
     // In both cases, the producer will need to call requestBuffer to get a
     // GraphicBuffer handle for the returned slot.
-    virtual status_t dequeueBuffer(int *outSlot, sp<Fence>* outFence,
-            bool async, uint32_t width, uint32_t height, PixelFormat format,
-            uint32_t usage);
+    virtual status_t dequeueBuffer(int *outSlot, sp<Fence>* outFence, bool async,
+            uint32_t width, uint32_t height, uint32_t format, uint32_t usage);
 
     // See IGraphicBufferProducer::detachBuffer
     virtual status_t detachBuffer(int slot);
@@ -170,16 +171,7 @@ public:
 
     // See IGraphicBufferProducer::allocateBuffers
     virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
-            PixelFormat format, uint32_t usage);
-
-    // See IGraphicBufferProducer::allowAllocation
-    virtual status_t allowAllocation(bool allow);
-
-    // See IGraphicBufferProducer::setGenerationNumber
-    virtual status_t setGenerationNumber(uint32_t generationNumber);
-
-    // See IGraphicBufferProducer::getConsumerName
-    virtual String8 getConsumerName() const override;
+            uint32_t format, uint32_t usage);
 
 private:
     // This is required by the IBinder::DeathRecipient interface
diff --git a/include/gui/ConsumerBase.h b/include/gui/ConsumerBase.h
index 9307a26..f7ab5ac 100644
--- a/include/gui/ConsumerBase.h
+++ b/include/gui/ConsumerBase.h
@@ -38,9 +38,15 @@ class ConsumerBase : public virtual RefBase,
         protected ConsumerListener {
 public:
     struct FrameAvailableListener : public virtual RefBase {
-        // See IConsumerListener::onFrame{Available,Replaced}
+        // onFrameAvailable() is called each time an additional frame becomes
+        // available for consumption. This means that frames that are queued
+        // while in asynchronous mode only trigger the callback if no previous
+        // frames are pending. Frames queued while in synchronous mode always
+        // trigger the callback.
+        //
+        // This is called without any lock held and can be called concurrently
+        // by multiple threads.
         virtual void onFrameAvailable(const BufferItem& item) = 0;
-        virtual void onFrameReplaced(const BufferItem& /* item */) {}
     };
 
     virtual ~ConsumerBase();
@@ -56,9 +62,6 @@ public:
     // or by OpenGL ES as a texture) then those buffer will remain allocated.
     void abandon();
 
-    // Returns true if the ConsumerBase is in the 'abandoned' state
-    bool isAbandoned();
-
     // set the name of the ConsumerBase that will be used to identify it in
     // log messages.
     void setName(const String8& name);
@@ -73,18 +76,6 @@ public:
     // when a new frame becomes available.
     void setFrameAvailableListener(const wp<FrameAvailableListener>& listener);
 
-    // See IGraphicBufferConsumer::detachBuffer
-    status_t detachBuffer(int slot);
-
-    // See IGraphicBufferConsumer::setDefaultBufferSize
-    status_t setDefaultBufferSize(uint32_t width, uint32_t height);
-
-    // See IGraphicBufferConsumer::setDefaultBufferFormat
-    status_t setDefaultBufferFormat(PixelFormat defaultFormat);
-
-    // See IGraphicBufferConsumer::setDefaultBufferDataSpace
-    status_t setDefaultBufferDataSpace(android_dataspace defaultDataSpace);
-
 private:
     ConsumerBase(const ConsumerBase&);
     void operator=(const ConsumerBase&);
@@ -110,16 +101,14 @@ protected:
 
     // Implementation of the IConsumerListener interface.  These
     // calls are used to notify the ConsumerBase of asynchronous events in the
-    // BufferQueue.  The onFrameAvailable, onFrameReplaced, and
-    // onBuffersReleased methods should not need to be overridden by derived
-    // classes, but if they are overridden the ConsumerBase implementation must
-    // be called from the derived class. The ConsumerBase version of
-    // onSidebandStreamChanged does nothing and can be overriden by derived
-    // classes if they want the notification.
-    virtual void onFrameAvailable(const BufferItem& item) override;
-    virtual void onFrameReplaced(const BufferItem& item) override;
-    virtual void onBuffersReleased() override;
-    virtual void onSidebandStreamChanged() override;
+    // BufferQueue.  The onFrameAvailable and onBuffersReleased methods should
+    // not need to be overridden by derived classes, but if they are overridden
+    // the ConsumerBase implementation must be called from the derived class.
+    // The ConsumerBase version of onSidebandStreamChanged does nothing and can
+    // be overriden by derived classes if they want the notification.
+    virtual void onFrameAvailable(const BufferItem& item);
+    virtual void onBuffersReleased();
+    virtual void onSidebandStreamChanged();
 
     // freeBufferLocked frees up the given buffer slot.  If the slot has been
     // initialized this will release the reference to the GraphicBuffer in that
@@ -164,8 +153,8 @@ protected:
     // initialization that must take place the first time a buffer is assigned
     // to a slot.  If it is overridden the derived class's implementation must
     // call ConsumerBase::acquireBufferLocked.
-    virtual status_t acquireBufferLocked(BufferItem *item, nsecs_t presentWhen,
-            uint64_t maxFrameNumber = 0);
+    virtual status_t acquireBufferLocked(IGraphicBufferConsumer::BufferItem *item,
+        nsecs_t presentWhen);
 
     // releaseBufferLocked relinquishes control over a buffer, returning that
     // control to the BufferQueue.
diff --git a/include/gui/CpuConsumer.h b/include/gui/CpuConsumer.h
index 3b07a31..4c6822a 100644
--- a/include/gui/CpuConsumer.h
+++ b/include/gui/CpuConsumer.h
@@ -53,7 +53,6 @@ class CpuConsumer : public ConsumerBase
         uint32_t    transform;
         uint32_t    scalingMode;
         int64_t     timestamp;
-        android_dataspace dataSpace;
         uint64_t    frameNumber;
         // this is the same as format, except for formats that are compatible with
         // a flexible format (e.g. HAL_PIXEL_FORMAT_YCbCr_420_888). In the latter
@@ -72,7 +71,7 @@ class CpuConsumer : public ConsumerBase
     // Create a new CPU consumer. The maxLockedBuffers parameter specifies
     // how many buffers can be locked for user access at the same time.
     CpuConsumer(const sp<IGraphicBufferConsumer>& bq,
-            size_t maxLockedBuffers, bool controlledByApp = false);
+            uint32_t maxLockedBuffers, bool controlledByApp = false);
 
     virtual ~CpuConsumer();
 
@@ -80,6 +79,18 @@ class CpuConsumer : public ConsumerBase
     // log messages.
     void setName(const String8& name);
 
+    // setDefaultBufferSize is used to set the size of buffers returned by
+    // requestBuffers when a width and height of zero is requested.
+    // A call to setDefaultBufferSize() may trigger requestBuffers() to
+    // be called from the client. Default size is 1x1.
+    status_t setDefaultBufferSize(uint32_t width, uint32_t height);
+
+    // setDefaultBufferFormat allows CpuConsumer's BufferQueue to create buffers
+    // of a defaultFormat if no format is specified by producer. Formats are
+    // enumerated in graphics.h; the initial default is
+    // HAL_PIXEL_FORMAT_RGBA_8888.
+    status_t setDefaultBufferFormat(uint32_t defaultFormat);
+
     // Gets the next graphics buffer from the producer and locks it for CPU use,
     // filling out the passed-in locked buffer structure with the native pointer
     // and metadata. Returns BAD_VALUE if no new buffer is available, and
@@ -99,9 +110,9 @@ class CpuConsumer : public ConsumerBase
 
   private:
     // Maximum number of buffers that can be locked at a time
-    size_t mMaxLockedBuffers;
+    uint32_t mMaxLockedBuffers;
 
-    status_t releaseAcquiredBufferLocked(size_t lockedIdx);
+    status_t releaseAcquiredBufferLocked(int lockedIdx);
 
     virtual void freeBufferLocked(int slotIndex);
 
@@ -122,7 +133,7 @@ class CpuConsumer : public ConsumerBase
     Vector<AcquiredBuffer> mAcquiredBuffers;
 
     // Count of currently locked buffers
-    size_t mCurrentLockedBuffers;
+    uint32_t mCurrentLockedBuffers;
 
 };
 
diff --git a/include/gui/GLConsumer.h b/include/gui/GLConsumer.h
index c35c7be..f91fe46 100644
--- a/include/gui/GLConsumer.h
+++ b/include/gui/GLConsumer.h
@@ -150,7 +150,7 @@ public:
     //
     // The frame number is an incrementing counter set to 0 at the creation of
     // the BufferQueue associated with this consumer.
-    uint64_t getFrameNumber();
+    int64_t getFrameNumber();
 
     // setDefaultBufferSize is used to set the size of buffers returned by
     // requestBuffers when a with and height of zero is requested.
@@ -197,8 +197,7 @@ public:
 
     // These functions call the corresponding BufferQueue implementation
     // so the refactoring can proceed smoothly
-    status_t setDefaultBufferFormat(PixelFormat defaultFormat);
-    status_t setDefaultBufferDataSpace(android_dataspace defaultDataSpace);
+    status_t setDefaultBufferFormat(uint32_t defaultFormat);
     status_t setConsumerUsageBits(uint32_t usage);
     status_t setTransformHint(uint32_t hint);
 
@@ -241,8 +240,8 @@ protected:
 
     // acquireBufferLocked overrides the ConsumerBase method to update the
     // mEglSlots array in addition to the ConsumerBase behavior.
-    virtual status_t acquireBufferLocked(BufferItem *item, nsecs_t presentWhen,
-            uint64_t maxFrameNumber = 0) override;
+    virtual status_t acquireBufferLocked(BufferQueue::BufferItem *item,
+        nsecs_t presentWhen);
 
     // releaseBufferLocked overrides the ConsumerBase method to update the
     // mEglSlots array in addition to the ConsumerBase.
@@ -255,12 +254,12 @@ protected:
         return releaseBufferLocked(slot, graphicBuffer, mEglDisplay, eglFence);
     }
 
-    static bool isExternalFormat(PixelFormat format);
+    static bool isExternalFormat(uint32_t format);
 
     // This releases the buffer in the slot referenced by mCurrentTexture,
     // then updates state to refer to the BufferItem, which must be a
     // newly-acquired buffer.
-    status_t updateAndReleaseLocked(const BufferItem& item);
+    status_t updateAndReleaseLocked(const BufferQueue::BufferItem& item);
 
     // Binds mTexName and the current buffer to mTexTarget.  Uses
     // mCurrentTexture if it's set, mCurrentTextureImage if not.  If the
@@ -392,7 +391,7 @@ private:
 
     // mCurrentFrameNumber is the frame counter for the current texture.
     // It gets set each time updateTexImage is called.
-    uint64_t mCurrentFrameNumber;
+    int64_t mCurrentFrameNumber;
 
     uint32_t mDefaultWidth, mDefaultHeight;
 
diff --git a/include/gui/GraphicBufferAlloc.h b/include/gui/GraphicBufferAlloc.h
index 69fe51e..b08750c 100644
--- a/include/gui/GraphicBufferAlloc.h
+++ b/include/gui/GraphicBufferAlloc.h
@@ -33,9 +33,8 @@ class GraphicBufferAlloc : public BnGraphicBufferAlloc {
 public:
     GraphicBufferAlloc();
     virtual ~GraphicBufferAlloc();
-    virtual sp<GraphicBuffer> createGraphicBuffer(uint32_t width,
-            uint32_t height, PixelFormat format, uint32_t usage,
-            status_t* error);
+    virtual sp<GraphicBuffer> createGraphicBuffer(uint32_t w, uint32_t h,
+        PixelFormat format, uint32_t usage, status_t* error);
 };
 
 
diff --git a/include/gui/IGraphicBufferAlloc.h b/include/gui/IGraphicBufferAlloc.h
index f3c46ec..cee41d9 100644
--- a/include/gui/IGraphicBufferAlloc.h
+++ b/include/gui/IGraphicBufferAlloc.h
@@ -45,10 +45,10 @@ public:
 class BnGraphicBufferAlloc : public BnInterface<IGraphicBufferAlloc>
 {
 public:
-    virtual status_t onTransact(uint32_t code,
-                                const Parcel& data,
-                                Parcel* reply,
-                                uint32_t flags = 0);
+    virtual status_t    onTransact( uint32_t code,
+                                    const Parcel& data,
+                                    Parcel* reply,
+                                    uint32_t flags = 0);
 };
 
 // ----------------------------------------------------------------------------
diff --git a/include/gui/IGraphicBufferConsumer.h b/include/gui/IGraphicBufferConsumer.h
index 60ec9cc..15f51fe 100644
--- a/include/gui/IGraphicBufferConsumer.h
+++ b/include/gui/IGraphicBufferConsumer.h
@@ -25,7 +25,6 @@
 #include <utils/Timers.h>
 
 #include <binder/IInterface.h>
-#include <ui/PixelFormat.h>
 #include <ui/Rect.h>
 
 #include <EGL/egl.h>
@@ -34,7 +33,6 @@
 namespace android {
 // ----------------------------------------------------------------------------
 
-class BufferItem;
 class Fence;
 class GraphicBuffer;
 class IConsumerListener;
@@ -43,6 +41,71 @@ class NativeHandle;
 class IGraphicBufferConsumer : public IInterface {
 
 public:
+
+    // public facing structure for BufferSlot
+    class BufferItem : public Flattenable<BufferItem> {
+        friend class Flattenable<BufferItem>;
+        size_t getPodSize() const;
+        size_t getFlattenedSize() const;
+        size_t getFdCount() const;
+        status_t flatten(void*& buffer, size_t& size, int*& fds, size_t& count) const;
+        status_t unflatten(void const*& buffer, size_t& size, int const*& fds, size_t& count);
+
+    public:
+        // The default value of mBuf, used to indicate this doesn't correspond to a slot.
+        enum { INVALID_BUFFER_SLOT = -1 };
+        BufferItem();
+
+        // mGraphicBuffer points to the buffer allocated for this slot, or is NULL
+        // if the buffer in this slot has been acquired in the past (see
+        // BufferSlot.mAcquireCalled).
+        sp<GraphicBuffer> mGraphicBuffer;
+
+        // mFence is a fence that will signal when the buffer is idle.
+        sp<Fence> mFence;
+
+        // mCrop is the current crop rectangle for this buffer slot.
+        Rect mCrop;
+
+        // mTransform is the current transform flags for this buffer slot.
+        // refer to NATIVE_WINDOW_TRANSFORM_* in <window.h>
+        uint32_t mTransform;
+
+        // mScalingMode is the current scaling mode for this buffer slot.
+        // refer to NATIVE_WINDOW_SCALING_* in <window.h>
+        uint32_t mScalingMode;
+
+        // mTimestamp is the current timestamp for this buffer slot. This gets
+        // to set by queueBuffer each time this slot is queued. This value
+        // is guaranteed to be monotonically increasing for each newly
+        // acquired buffer.
+        int64_t mTimestamp;
+
+        // mIsAutoTimestamp indicates whether mTimestamp was generated
+        // automatically when the buffer was queued.
+        bool mIsAutoTimestamp;
+
+        // mFrameNumber is the number of the queued frame for this slot.
+        uint64_t mFrameNumber;
+
+        // mBuf is the slot index of this buffer (default INVALID_BUFFER_SLOT).
+        int mBuf;
+
+        // mIsDroppable whether this buffer was queued with the
+        // property that it can be replaced by a new buffer for the purpose of
+        // making sure dequeueBuffer() won't block.
+        // i.e.: was the BufferQueue in "mDequeueBufferCannotBlock" when this buffer
+        // was queued.
+        bool mIsDroppable;
+
+        // Indicates whether this buffer has been seen by a consumer yet
+        bool mAcquireCalled;
+
+        // Indicates this buffer must be transformed by the inverse transform of the screen
+        // it is displayed onto. This is applied after mTransform.
+        bool mTransformToDisplayInverse;
+    };
+
     enum {
         // Returned by releaseBuffer, after which the consumer must
         // free any references to the just-released buffer that it might have.
@@ -69,12 +132,6 @@ public:
     // returned.  The presentation time is in nanoseconds, and the time base
     // is CLOCK_MONOTONIC.
     //
-    // If maxFrameNumber is non-zero, it indicates that acquireBuffer should
-    // only return a buffer with a frame number less than or equal to
-    // maxFrameNumber. If no such frame is available (such as when a buffer has
-    // been replaced but the consumer has not received the onFrameReplaced
-    // callback), then PRESENT_LATER will be returned.
-    //
     // Return of NO_ERROR means the operation completed as normal.
     //
     // Return of a positive value means the operation could not be completed
@@ -84,8 +141,7 @@ public:
     //
     // Return of a negative value means an error has occurred:
     // * INVALID_OPERATION - too many buffers have been acquired
-    virtual status_t acquireBuffer(BufferItem* buffer, nsecs_t presentWhen,
-            uint64_t maxFrameNumber = 0) = 0;
+    virtual status_t acquireBuffer(BufferItem* buffer, nsecs_t presentWhen) = 0;
 
     // detachBuffer attempts to remove all ownership of the buffer in the given
     // slot from the buffer queue. If this call succeeds, the slot will be
@@ -110,8 +166,7 @@ public:
     // will be deallocated as stale.
     //
     // Return of a value other than NO_ERROR means an error has occurred:
-    // * BAD_VALUE - outSlot or buffer were NULL, or the generation number of
-    //               the buffer did not match the buffer queue.
+    // * BAD_VALUE - outSlot or buffer were NULL
     // * INVALID_OPERATION - cannot attach the buffer because it would cause too
     //                       many buffers to be acquired.
     // * NO_MEMORY - no free slots available
@@ -225,19 +280,11 @@ public:
 
     // setDefaultBufferFormat allows the BufferQueue to create
     // GraphicBuffers of a defaultFormat if no format is specified
-    // in dequeueBuffer.
-    // The initial default is PIXEL_FORMAT_RGBA_8888.
-    //
-    // Return of a value other than NO_ERROR means an unknown error has occurred.
-    virtual status_t setDefaultBufferFormat(PixelFormat defaultFormat) = 0;
-
-    // setDefaultBufferDataSpace is a request to the producer to provide buffers
-    // of the indicated dataSpace. The producer may ignore this request.
-    // The initial default is HAL_DATASPACE_UNKNOWN.
+    // in dequeueBuffer.  Formats are enumerated in graphics.h; the
+    // initial default is HAL_PIXEL_FORMAT_RGBA_8888.
     //
     // Return of a value other than NO_ERROR means an unknown error has occurred.
-    virtual status_t setDefaultBufferDataSpace(
-            android_dataspace defaultDataSpace) = 0;
+    virtual status_t setDefaultBufferFormat(uint32_t defaultFormat) = 0;
 
     // setConsumerUsageBits will turn on additional usage bits for dequeueBuffer.
     // These are merged with the bits passed to dequeueBuffer.  The values are
diff --git a/include/gui/IGraphicBufferProducer.h b/include/gui/IGraphicBufferProducer.h
index 9530de1..4e9e810 100644
--- a/include/gui/IGraphicBufferProducer.h
+++ b/include/gui/IGraphicBufferProducer.h
@@ -28,7 +28,6 @@
 #include <ui/Fence.h>
 #include <ui/GraphicBuffer.h>
 #include <ui/Rect.h>
-#include <ui/Region.h>
 
 namespace android {
 // ----------------------------------------------------------------------------
@@ -135,7 +134,9 @@ public:
     // updateTexImage() is called.  If width and height are both zero, the
     // default values specified by setDefaultBufferSize() are used instead.
     //
-    // If the format is 0, the default format will be used.
+    // The pixel formats are enumerated in <graphics.h>, e.g.
+    // HAL_PIXEL_FORMAT_RGBA_8888.  If the format is 0, the default format
+    // will be used.
     //
     // The usage argument specifies gralloc buffer usage flags.  The values
     // are enumerated in <gralloc.h>, e.g. GRALLOC_USAGE_HW_RENDER.  These
@@ -166,7 +167,7 @@ public:
     // All other negative values are an unknown error returned downstream
     // from the graphics allocator (typically errno).
     virtual status_t dequeueBuffer(int* slot, sp<Fence>* fence, bool async,
-            uint32_t w, uint32_t h, PixelFormat format, uint32_t usage) = 0;
+            uint32_t w, uint32_t h, uint32_t format, uint32_t usage) = 0;
 
     // detachBuffer attempts to remove all ownership of the buffer in the given
     // slot from the buffer queue. If this call succeeds, the slot will be
@@ -218,9 +219,8 @@ public:
     //
     // Return of a negative value means an error has occurred:
     // * NO_INIT - the buffer queue has been abandoned.
-    // * BAD_VALUE - outSlot or buffer were NULL, invalid combination of
-    //               async mode and buffer count override, or the generation
-    //               number of the buffer did not match the buffer queue.
+    // * BAD_VALUE - outSlot or buffer were NULL or invalid combination of
+    //               async mode and buffer count override.
     // * INVALID_OPERATION - cannot attach the buffer because it would cause
     //                       too many buffers to be dequeued, either because
     //                       the producer already has a single buffer dequeued
@@ -267,7 +267,6 @@ public:
         inline QueueBufferInput(const Parcel& parcel);
         // timestamp - a monotonically increasing value in nanoseconds
         // isAutoTimestamp - if the timestamp was synthesized at queue time
-        // dataSpace - description of the contents, interpretation depends on format
         // crop - a crop rectangle that's used as a hint to the consumer
         // scalingMode - a set of flags from NATIVE_WINDOW_SCALING_* in <window.h>
         // transform - a set of flags from NATIVE_WINDOW_TRANSFORM_* in <window.h>
@@ -277,21 +276,17 @@ public:
         // sticky - the sticky transform set in Surface (only used by the LEGACY
         //          camera mode).
         inline QueueBufferInput(int64_t timestamp, bool isAutoTimestamp,
-                android_dataspace dataSpace, const Rect& crop, int scalingMode,
-                uint32_t transform, bool async, const sp<Fence>& fence,
-                uint32_t sticky = 0)
-                : timestamp(timestamp), isAutoTimestamp(isAutoTimestamp),
-                  dataSpace(dataSpace), crop(crop), scalingMode(scalingMode),
-                  transform(transform), stickyTransform(sticky),
-                  async(async), fence(fence), surfaceDamage() { }
+                const Rect& crop, int scalingMode, uint32_t transform, bool async,
+                const sp<Fence>& fence, uint32_t sticky = 0)
+        : timestamp(timestamp), isAutoTimestamp(isAutoTimestamp), crop(crop),
+          scalingMode(scalingMode), transform(transform), stickyTransform(sticky),
+          async(async), fence(fence) { }
         inline void deflate(int64_t* outTimestamp, bool* outIsAutoTimestamp,
-                android_dataspace* outDataSpace,
-                Rect* outCrop, int* outScalingMode,
-                uint32_t* outTransform, bool* outAsync, sp<Fence>* outFence,
+                Rect* outCrop, int* outScalingMode, uint32_t* outTransform,
+                bool* outAsync, sp<Fence>* outFence,
                 uint32_t* outStickyTransform = NULL) const {
             *outTimestamp = timestamp;
             *outIsAutoTimestamp = bool(isAutoTimestamp);
-            *outDataSpace = dataSpace;
             *outCrop = crop;
             *outScalingMode = scalingMode;
             *outTransform = transform;
@@ -308,20 +303,15 @@ public:
         status_t flatten(void*& buffer, size_t& size, int*& fds, size_t& count) const;
         status_t unflatten(void const*& buffer, size_t& size, int const*& fds, size_t& count);
 
-        const Region& getSurfaceDamage() const { return surfaceDamage; }
-        void setSurfaceDamage(const Region& damage) { surfaceDamage = damage; }
-
     private:
         int64_t timestamp;
         int isAutoTimestamp;
-        android_dataspace dataSpace;
         Rect crop;
         int scalingMode;
         uint32_t transform;
         uint32_t stickyTransform;
         int async;
         sp<Fence> fence;
-        Region surfaceDamage;
     };
 
     // QueueBufferOutput must be a POD structure
@@ -458,31 +448,7 @@ public:
     // dequeueBuffer. If there are already the maximum number of buffers
     // allocated, this function has no effect.
     virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
-            PixelFormat format, uint32_t usage) = 0;
-
-    // Sets whether dequeueBuffer is allowed to allocate new buffers.
-    //
-    // Normally dequeueBuffer does not discriminate between free slots which
-    // already have an allocated buffer and those which do not, and will
-    // allocate a new buffer if the slot doesn't have a buffer or if the slot's
-    // buffer doesn't match the requested size, format, or usage. This method
-    // allows the producer to restrict the eligible slots to those which already
-    // have an allocated buffer of the correct size, format, and usage. If no
-    // eligible slot is available, dequeueBuffer will block or return an error
-    // as usual.
-    virtual status_t allowAllocation(bool allow) = 0;
-
-    // Sets the current generation number of the BufferQueue.
-    //
-    // This generation number will be inserted into any buffers allocated by the
-    // BufferQueue, and any attempts to attach a buffer with a different
-    // generation number will fail. Buffers already in the queue are not
-    // affected and will retain their current generation number. The generation
-    // number defaults to 0.
-    virtual status_t setGenerationNumber(uint32_t generationNumber) = 0;
-
-    // Returns the name of the connected consumer.
-    virtual String8 getConsumerName() const = 0;
+            uint32_t format, uint32_t usage) = 0;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/include/gui/ISensorServer.h b/include/gui/ISensorServer.h
index 3dca2a3..9c8afc5 100644
--- a/include/gui/ISensorServer.h
+++ b/include/gui/ISensorServer.h
@@ -30,17 +30,14 @@ namespace android {
 
 class Sensor;
 class ISensorEventConnection;
-class String8;
 
 class ISensorServer : public IInterface
 {
 public:
     DECLARE_META_INTERFACE(SensorServer);
 
-    virtual Vector<Sensor> getSensorList(const String16& opPackageName) = 0;
-    virtual sp<ISensorEventConnection> createSensorEventConnection(const String8& packageName,
-             int mode, const String16& opPackageName) = 0;
-    virtual int32_t isDataInjectionEnabled() = 0;
+    virtual Vector<Sensor> getSensorList() = 0;
+    virtual sp<ISensorEventConnection> createSensorEventConnection() = 0;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/include/gui/ISurfaceComposer.h b/include/gui/ISurfaceComposer.h
index 8c3d49e..44aba7e 100644
--- a/include/gui/ISurfaceComposer.h
+++ b/include/gui/ISurfaceComposer.h
@@ -28,17 +28,24 @@
 #include <binder/IInterface.h>
 
 #include <ui/FrameStats.h>
+#include <ui/PixelFormat.h>
 
 #include <gui/IGraphicBufferAlloc.h>
 #include <gui/ISurfaceComposerClient.h>
 
+#ifndef FORCE_SCREENSHOT_CPU_PATH
+#define SS_CPU_CONSUMER false
+#else
+#define SS_CPU_CONSUMER true
+#endif
+
 namespace android {
 // ----------------------------------------------------------------------------
 
 class ComposerState;
 class DisplayState;
 struct DisplayInfo;
-struct DisplayStatInfo;
+class DisplayStatInfo;
 class IDisplayEventConnection;
 class IMemoryHeap;
 class Rect;
@@ -144,7 +151,8 @@ public:
             Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
             uint32_t minLayerZ, uint32_t maxLayerZ,
             bool useIdentityTransform,
-            Rotation rotation = eRotateNone) = 0;
+            Rotation rotation = eRotateNone,
+            bool isCpuConsumer = SS_CPU_CONSUMER) = 0;
 
     /* Clears the frame statistics for animations.
      *
diff --git a/include/gui/Sensor.h b/include/gui/Sensor.h
index 8142be6..28a08e2 100644
--- a/include/gui/Sensor.h
+++ b/include/gui/Sensor.h
@@ -67,14 +67,12 @@ public:
     int32_t getMinDelay() const;
     nsecs_t getMinDelayNs() const;
     int32_t getVersion() const;
-    uint32_t getFifoReservedEventCount() const;
-    uint32_t getFifoMaxEventCount() const;
+    int32_t getFifoReservedEventCount() const;
+    int32_t getFifoMaxEventCount() const;
     const String8& getStringType() const;
     const String8& getRequiredPermission() const;
-    bool isRequiredPermissionRuntime() const;
-    int32_t getRequiredAppOp() const;
     int32_t getMaxDelay() const;
-    uint32_t getFlags() const;
+    int32_t getFlags() const;
     bool isWakeUpSensor() const;
     int32_t getReportingMode() const;
 
@@ -95,14 +93,12 @@ private:
     float   mPower;
     int32_t mMinDelay;
     int32_t mVersion;
-    uint32_t mFifoReservedEventCount;
-    uint32_t mFifoMaxEventCount;
+    int32_t mFifoReservedEventCount;
+    int32_t mFifoMaxEventCount;
     String8 mStringType;
     String8 mRequiredPermission;
-    bool mRequiredPermissionRuntime = false;
-    int32_t mRequiredAppOp;
     int32_t mMaxDelay;
-    uint32_t mFlags;
+    int32_t mFlags;
     static void flattenString8(void*& buffer, size_t& size, const String8& string8);
     static bool unflattenString8(void const*& buffer, size_t& size, String8& outputString8);
 };
diff --git a/include/gui/SensorEventQueue.h b/include/gui/SensorEventQueue.h
index e5b9fc5..02b3d38 100644
--- a/include/gui/SensorEventQueue.h
+++ b/include/gui/SensorEventQueue.h
@@ -23,7 +23,6 @@
 #include <utils/Errors.h>
 #include <utils/RefBase.h>
 #include <utils/Timers.h>
-#include <utils/String16.h>
 
 #include <gui/BitTube.h>
 
@@ -53,7 +52,7 @@ public:
 
     enum { MAX_RECEIVE_BUFFER_EVENT_COUNT = 256 };
 
-    SensorEventQueue(const sp<ISensorEventConnection>& connection);
+            SensorEventQueue(const sp<ISensorEventConnection>& connection);
     virtual ~SensorEventQueue();
     virtual void onFirstRef();
 
@@ -78,8 +77,6 @@ public:
     status_t flush() const;
     // Send an ack for every wake_up sensor event that is set to WAKE_UP_SENSOR_EVENT_NEEDS_ACK.
     void sendAck(const ASensorEvent* events, int count);
-
-    status_t injectSensorEvent(const ASensorEvent& event);
 private:
     sp<Looper> getLooper() const;
     sp<ISensorEventConnection> mSensorEventConnection;
diff --git a/include/gui/SensorManager.h b/include/gui/SensorManager.h
index 3796067..3176462 100644
--- a/include/gui/SensorManager.h
+++ b/include/gui/SensorManager.h
@@ -17,20 +17,15 @@
 #ifndef ANDROID_GUI_SENSOR_MANAGER_H
 #define ANDROID_GUI_SENSOR_MANAGER_H
 
-#include <map>
-
 #include <stdint.h>
 #include <sys/types.h>
 
 #include <binder/IBinder.h>
-#include <binder/IPCThreadState.h>
-#include <binder/IServiceManager.h>
 
 #include <utils/Errors.h>
 #include <utils/RefBase.h>
 #include <utils/Singleton.h>
 #include <utils/Vector.h>
-#include <utils/String8.h>
 
 #include <gui/SensorEventQueue.h>
 
@@ -45,69 +40,20 @@ namespace android {
 class ISensorServer;
 class Sensor;
 class SensorEventQueue;
+
 // ----------------------------------------------------------------------------
 
 class SensorManager :
-    public ASensorManager
+    public ASensorManager,
+    public Singleton<SensorManager>
 {
 public:
-    static SensorManager& getInstanceForPackage(const String16& packageName) {
-        Mutex::Autolock _l(sLock);
-
-        SensorManager* sensorManager;
-        std::map<String16, SensorManager*>::iterator iterator =
-                sPackageInstances.find(packageName);
-
-        if (iterator != sPackageInstances.end()) {
-            sensorManager = iterator->second;
-        } else {
-            String16 opPackageName = packageName;
-
-            // It is possible that the calling code has no access to the package name.
-            // In this case we will get the packages for the calling UID and pick the
-            // first one for attributing the app op. This will work correctly for
-            // runtime permissions as for legacy apps we will toggle the app op for
-            // all packages in the UID. The caveat is that the operation may be attributed
-            // to the wrong package and stats based on app ops may be slightly off.
-            if (opPackageName.size() <= 0) {
-                sp<IBinder> binder = defaultServiceManager()->getService(String16("permission"));
-                if (binder != 0) {
-                    const uid_t uid = IPCThreadState::self()->getCallingUid();
-                    Vector<String16> packages;
-                    interface_cast<IPermissionController>(binder)->getPackagesForUid(uid, packages);
-                    if (!packages.isEmpty()) {
-                        opPackageName = packages[0];
-                    } else {
-                        ALOGE("No packages for calling UID");
-                    }
-                } else {
-                    ALOGE("Cannot get permission service");
-                }
-            }
-
-            sensorManager = new SensorManager(opPackageName);
-
-            // If we had no package name, we looked it up from the UID and the sensor
-            // manager instance we created should also be mapped to the empty package
-            // name, to avoid looking up the packages for a UID and get the same result.
-            if (packageName.size() <= 0) {
-                sPackageInstances.insert(std::make_pair(String16(), sensorManager));
-            }
-
-            // Stash the per package sensor manager.
-            sPackageInstances.insert(std::make_pair(opPackageName, sensorManager));
-        }
-
-        return *sensorManager;
-    }
-
-    SensorManager(const String16& opPackageName);
+    SensorManager();
     ~SensorManager();
 
     ssize_t getSensorList(Sensor const* const** list) const;
     Sensor const* getDefaultSensor(int type);
-    sp<SensorEventQueue> createEventQueue(String8 packageName = String8(""), int mode = 0);
-    bool isDataInjectionEnabled();
+    sp<SensorEventQueue> createEventQueue();
 
 private:
     // DeathRecipient interface
@@ -116,15 +62,11 @@ private:
     status_t assertStateLocked() const;
 
 private:
-    static Mutex sLock;
-    static std::map<String16, SensorManager*> sPackageInstances;
-
     mutable Mutex mLock;
     mutable sp<ISensorServer> mSensorServer;
     mutable Sensor const** mSensorList;
     mutable Vector<Sensor> mSensors;
     mutable sp<IBinder::DeathRecipient> mDeathObserver;
-    const String16 mOpPackageName;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/include/gui/Surface.h b/include/gui/Surface.h
index 72f1067..f2cf018 100644
--- a/include/gui/Surface.h
+++ b/include/gui/Surface.h
@@ -101,14 +101,6 @@ public:
      */
     void allocateBuffers();
 
-    /* Sets the generation number on the IGraphicBufferProducer and updates the
-     * generation number on any buffers attached to the Surface after this call.
-     * See IGBP::setGenerationNumber for more information. */
-    status_t setGenerationNumber(uint32_t generationNumber);
-
-    // See IGraphicBufferProducer::getConsumerName
-    String8 getConsumerName() const;
-
 protected:
     virtual ~Surface();
 
@@ -154,8 +146,6 @@ private:
     int dispatchLock(va_list args);
     int dispatchUnlockAndPost(va_list args);
     int dispatchSetSidebandStream(va_list args);
-    int dispatchSetBuffersDataSpace(va_list args);
-    int dispatchSetSurfaceDamage(va_list args);
 
 protected:
     virtual int dequeueBuffer(ANativeWindowBuffer** buffer, int* fenceFd);
@@ -170,27 +160,20 @@ protected:
     virtual int connect(int api);
     virtual int disconnect(int api);
     virtual int setBufferCount(int bufferCount);
-    virtual int setBuffersDimensions(uint32_t width, uint32_t height);
-    virtual int setBuffersUserDimensions(uint32_t width, uint32_t height);
-    virtual int setBuffersFormat(PixelFormat format);
+    virtual int setBuffersDimensions(int w, int h);
+    virtual int setBuffersUserDimensions(int w, int h);
+    virtual int setBuffersFormat(int format);
     virtual int setScalingMode(int mode);
-    virtual int setBuffersTransform(uint32_t transform);
-    virtual int setBuffersStickyTransform(uint32_t transform);
+    virtual int setBuffersTransform(int transform);
+    virtual int setBuffersStickyTransform(int transform);
     virtual int setBuffersTimestamp(int64_t timestamp);
-    virtual int setBuffersDataSpace(android_dataspace dataSpace);
     virtual int setCrop(Rect const* rect);
     virtual int setUsage(uint32_t reqUsage);
-    virtual void setSurfaceDamage(android_native_rect_t* rects, size_t numRects);
 
 public:
     virtual int lock(ANativeWindow_Buffer* outBuffer, ARect* inOutDirtyBounds);
     virtual int unlockAndPost();
 
-    virtual int connect(int api, const sp<IProducerListener>& listener);
-    virtual int detachNextBuffer(sp<GraphicBuffer>* outBuffer,
-            sp<Fence>* outFence);
-    virtual int attachBuffer(ANativeWindowBuffer*);
-
 protected:
     enum { NUM_BUFFER_SLOTS = BufferQueue::NUM_BUFFER_SLOTS };
     enum { DEFAULT_FORMAT = PIXEL_FORMAT_RGBA_8888 };
@@ -228,7 +211,7 @@ private:
 
     // mReqFormat is the buffer pixel format that will be requested at the next
     // deuque operation. It is initialized to PIXEL_FORMAT_RGBA_8888.
-    PixelFormat mReqFormat;
+    uint32_t mReqFormat;
 
     // mReqUsage is the set of buffer usage flags that will be requested
     // at the next deuque operation. It is initialized to 0.
@@ -239,11 +222,6 @@ private:
     // a timestamp is auto-generated when queueBuffer is called.
     int64_t mTimestamp;
 
-    // mDataSpace is the buffer dataSpace that will be used for the next buffer
-    // queue operation. It defaults to HAL_DATASPACE_UNKNOWN, which
-    // means that the buffer contains some type of color data.
-    android_dataspace mDataSpace;
-
     // mCrop is the crop rectangle that will be used for the next buffer
     // that gets queued. It is set by calling setCrop.
     Rect mCrop;
@@ -262,23 +240,23 @@ private:
     // from being set by the compositor.
     uint32_t mStickyTransform;
 
-    // mDefaultWidth is default width of the buffers, regardless of the
-    // native_window_set_buffers_dimensions call.
-    uint32_t mDefaultWidth;
+     // mDefaultWidth is default width of the buffers, regardless of the
+     // native_window_set_buffers_dimensions call.
+     uint32_t mDefaultWidth;
 
-    // mDefaultHeight is default height of the buffers, regardless of the
-    // native_window_set_buffers_dimensions call.
-    uint32_t mDefaultHeight;
+     // mDefaultHeight is default height of the buffers, regardless of the
+     // native_window_set_buffers_dimensions call.
+     uint32_t mDefaultHeight;
 
-    // mUserWidth, if non-zero, is an application-specified override
-    // of mDefaultWidth.  This is lower priority than the width set by
-    // native_window_set_buffers_dimensions.
-    uint32_t mUserWidth;
+     // mUserWidth, if non-zero, is an application-specified override
+     // of mDefaultWidth.  This is lower priority than the width set by
+     // native_window_set_buffers_dimensions.
+     uint32_t mUserWidth;
 
-    // mUserHeight, if non-zero, is an application-specified override
-    // of mDefaultHeight.  This is lower priority than the height set
-    // by native_window_set_buffers_dimensions.
-    uint32_t mUserHeight;
+     // mUserHeight, if non-zero, is an application-specified override
+     // of mDefaultHeight.  This is lower priority than the height set
+     // by native_window_set_buffers_dimensions.
+     uint32_t mUserHeight;
 
     // mTransformHint is the transform probably applied to buffers of this
     // window. this is only a hint, actual transform may differ.
@@ -306,17 +284,8 @@ private:
     sp<GraphicBuffer>           mPostedBuffer;
     bool                        mConnectedToCpu;
 
-    // When a CPU producer is attached, this reflects the region that the
-    // producer wished to update as well as whether the Surface was able to copy
-    // the previous buffer back to allow a partial update.
-    //
-    // When a non-CPU producer is attached, this reflects the surface damage
-    // (the change since the previous frame) passed in by the producer.
+    // must be accessed from lock/unlock thread only
     Region mDirtyRegion;
-
-    // Stores the current generation number. See setGenerationNumber and
-    // IGraphicBufferProducer::setGenerationNumber for more information.
-    uint32_t mGenerationNumber;
 };
 
 }; // namespace android
diff --git a/include/gui/SurfaceComposerClient.h b/include/gui/SurfaceComposerClient.h
index 37d953e..4cbfc09 100644
--- a/include/gui/SurfaceComposerClient.h
+++ b/include/gui/SurfaceComposerClient.h
@@ -127,7 +127,7 @@ public:
     status_t    show(const sp<IBinder>& id);
     status_t    setFlags(const sp<IBinder>& id, uint32_t flags, uint32_t mask);
     status_t    setTransparentRegionHint(const sp<IBinder>& id, const Region& transparent);
-    status_t    setLayer(const sp<IBinder>& id, uint32_t layer);
+    status_t    setLayer(const sp<IBinder>& id, int32_t layer);
     status_t    setAlpha(const sp<IBinder>& id, float alpha=1.0f);
     status_t    setMatrix(const sp<IBinder>& id, float dsdx, float dtdx, float dsdy, float dtdy);
     status_t    setPosition(const sp<IBinder>& id, float x, float y);
diff --git a/include/gui/SurfaceControl.h b/include/gui/SurfaceControl.h
index 9f62f7c..f0b01e2 100644
--- a/include/gui/SurfaceControl.h
+++ b/include/gui/SurfaceControl.h
@@ -57,9 +57,12 @@ public:
     // release surface data from java
     void        clear();
 
-    status_t    setLayerStack(uint32_t layerStack);
-    status_t    setLayer(uint32_t layer);
+    status_t    setLayerStack(int32_t layerStack);
+    status_t    setLayer(int32_t layer);
     status_t    setPosition(float x, float y);
+#ifdef USES_LEGACY_SET_POSITION
+    status_t    setPosition(int32_t x, int32_t y);
+#endif
     status_t    setSize(uint32_t w, uint32_t h);
     status_t    hide();
     status_t    show();
diff --git a/include/ui/DisplayInfo.h b/include/ui/DisplayInfo.h
index 799944f..5b5781e 100644
--- a/include/ui/DisplayInfo.h
+++ b/include/ui/DisplayInfo.h
@@ -36,6 +36,10 @@ struct DisplayInfo {
     bool secure;
     nsecs_t appVsyncOffset;
     nsecs_t presentationDeadline;
+#ifdef HAVE_PIXEL_FORMAT_INFO
+    // needed only by old blobs
+    PixelFormatInfo pixelFormatInfo;
+#endif
 };
 
 /* Display orientations as defined in Surface.java and ISurfaceComposer.h. */
diff --git a/include/ui/Fence.h b/include/ui/Fence.h
index b431bd5..20466b6 100644
--- a/include/ui/Fence.h
+++ b/include/ui/Fence.h
@@ -65,7 +65,7 @@ public:
     // before the fence signals then -ETIME is returned.  A timeout of
     // TIMEOUT_NEVER may be used to indicate that the call should wait
     // indefinitely for the fence to signal.
-    status_t wait(int timeout);
+    status_t wait(unsigned int timeout);
 
     // waitForever is a convenience function for waiting forever for a fence to
     // signal (just like wait(TIMEOUT_NEVER)), but issuing an error to the
diff --git a/include/ui/FramebufferNativeWindow.h b/include/ui/FramebufferNativeWindow.h
index 6b66d5f..5cd8101 100644
--- a/include/ui/FramebufferNativeWindow.h
+++ b/include/ui/FramebufferNativeWindow.h
@@ -14,13 +14,11 @@
  * limitations under the License.
  */
 
-#ifndef INCLUDED_FROM_FRAMEBUFFER_NATIVE_WINDOW_CPP
-#warning "FramebufferNativeWindow is deprecated"
-#endif
-
 #ifndef ANDROID_FRAMEBUFFER_NATIVE_WINDOW_H
 #define ANDROID_FRAMEBUFFER_NATIVE_WINDOW_H
 
+#warning "FramebufferNativeWindow is deprecated"
+
 #include <stdint.h>
 #include <sys/types.h>
 
diff --git a/include/ui/GraphicBuffer.h b/include/ui/GraphicBuffer.h
index 3da720f..3a5b10d 100644
--- a/include/ui/GraphicBuffer.h
+++ b/include/ui/GraphicBuffer.h
@@ -71,14 +71,18 @@ public:
 
     GraphicBuffer();
 
+#ifdef QCOM_BSP_LEGACY
+    // creates buffer of bufferSize
+    GraphicBuffer(uint32_t w, uint32_t h,
+                  PixelFormat format, uint32_t usage, uint32_t bufferSize);
+#endif
+
     // creates w * h buffer
-    GraphicBuffer(uint32_t inWidth, uint32_t inHeight, PixelFormat inFormat,
-            uint32_t inUsage);
+    GraphicBuffer(uint32_t w, uint32_t h, PixelFormat format, uint32_t usage);
 
     // create a buffer from an existing handle
-    GraphicBuffer(uint32_t inWidth, uint32_t inHeight, PixelFormat inFormat,
-            uint32_t inUsage, uint32_t inStride, native_handle_t* inHandle,
-            bool keepOwnership);
+    GraphicBuffer(uint32_t w, uint32_t h, PixelFormat format, uint32_t usage,
+            uint32_t stride, native_handle_t* handle, bool keepOwnership);
 
     // create a buffer from an existing ANativeWindowBuffer
     GraphicBuffer(ANativeWindowBuffer* buffer, bool keepOwnership);
@@ -86,39 +90,26 @@ public:
     // return status
     status_t initCheck() const;
 
-    uint32_t getWidth() const           { return static_cast<uint32_t>(width); }
-    uint32_t getHeight() const          { return static_cast<uint32_t>(height); }
-    uint32_t getStride() const          { return static_cast<uint32_t>(stride); }
-    uint32_t getUsage() const           { return static_cast<uint32_t>(usage); }
+    uint32_t getWidth() const           { return width; }
+    uint32_t getHeight() const          { return height; }
+    uint32_t getStride() const          { return stride; }
+    uint32_t getUsage() const           { return usage; }
     PixelFormat getPixelFormat() const  { return format; }
     Rect getBounds() const              { return Rect(width, height); }
     uint64_t getId() const              { return mId; }
 
-    uint32_t getGenerationNumber() const { return mGenerationNumber; }
-    void setGenerationNumber(uint32_t generation) {
-        mGenerationNumber = generation;
-    }
-
-    status_t reallocate(uint32_t inWidth, uint32_t inHeight,
-            PixelFormat inFormat, uint32_t inUsage);
+    status_t reallocate(uint32_t w, uint32_t h, PixelFormat f, uint32_t usage);
 
-    bool needsReallocation(uint32_t inWidth, uint32_t inHeight,
-            PixelFormat inFormat, uint32_t inUsage);
-
-    status_t lock(uint32_t inUsage, void** vaddr);
-    status_t lock(uint32_t inUsage, const Rect& rect, void** vaddr);
+    status_t lock(uint32_t usage, void** vaddr);
+    status_t lock(uint32_t usage, const Rect& rect, void** vaddr);
     // For HAL_PIXEL_FORMAT_YCbCr_420_888
-    status_t lockYCbCr(uint32_t inUsage, android_ycbcr *ycbcr);
-    status_t lockYCbCr(uint32_t inUsage, const Rect& rect,
-            android_ycbcr *ycbcr);
+    status_t lockYCbCr(uint32_t usage, android_ycbcr *ycbcr);
+    status_t lockYCbCr(uint32_t usage, const Rect& rect, android_ycbcr *ycbcr);
     status_t unlock();
-    status_t lockAsync(uint32_t inUsage, void** vaddr, int fenceFd);
-    status_t lockAsync(uint32_t inUsage, const Rect& rect, void** vaddr,
-            int fenceFd);
-    status_t lockAsyncYCbCr(uint32_t inUsage, android_ycbcr *ycbcr,
-            int fenceFd);
-    status_t lockAsyncYCbCr(uint32_t inUsage, const Rect& rect,
-            android_ycbcr *ycbcr, int fenceFd);
+    status_t lockAsync(uint32_t usage, void** vaddr, int fenceFd);
+    status_t lockAsync(uint32_t usage, const Rect& rect, void** vaddr, int fenceFd);
+    status_t lockAsyncYCbCr(uint32_t usage, android_ycbcr *ycbcr, int fenceFd);
+    status_t lockAsyncYCbCr(uint32_t usage, const Rect& rect, android_ycbcr *ycbcr, int fenceFd);
     status_t unlockAsync(int *fenceFd);
 
     ANativeWindowBuffer* getNativeBuffer() const;
@@ -158,8 +149,12 @@ private:
     GraphicBuffer& operator = (const GraphicBuffer& rhs);
     const GraphicBuffer& operator = (const GraphicBuffer& rhs) const;
 
-    status_t initSize(uint32_t inWidth, uint32_t inHeight, PixelFormat inFormat,
-            uint32_t inUsage);
+    status_t initSize(uint32_t w, uint32_t h, PixelFormat format,
+            uint32_t usage);
+#ifdef QCOM_BSP_LEGACY
+    status_t initSize(uint32_t w, uint32_t h, PixelFormat format,
+            uint32_t usage, uint32_t bufferSize);
+#endif
 
     void free_handle();
 
@@ -171,11 +166,6 @@ private:
     sp<ANativeWindowBuffer> mWrappedBuffer;
 
     uint64_t mId;
-
-    // Stores the generation number of this buffer. If this number does not
-    // match the BufferQueue's internal generation number (set through
-    // IGBP::setGenerationNumber), attempts to attach the buffer will fail.
-    uint32_t mGenerationNumber;
 };
 
 }; // namespace android
diff --git a/include/ui/GraphicBufferAllocator.h b/include/ui/GraphicBufferAllocator.h
index 5443f09..a6e3412 100644
--- a/include/ui/GraphicBufferAllocator.h
+++ b/include/ui/GraphicBufferAllocator.h
@@ -1,17 +1,17 @@
-/*
+/* 
 **
 ** Copyright 2009, The Android Open Source Project
 **
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
+** Licensed under the Apache License, Version 2.0 (the "License"); 
+** you may not use this file except in compliance with the License. 
+** You may obtain a copy of the License at 
 **
-**     http://www.apache.org/licenses/LICENSE-2.0
+**     http://www.apache.org/licenses/LICENSE-2.0 
 **
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
+** Unless required by applicable law or agreed to in writing, software 
+** distributed under the License is distributed on an "AS IS" BASIS, 
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
+** See the License for the specific language governing permissions and 
 ** limitations under the License.
 */
 
@@ -45,14 +45,14 @@ public:
         USAGE_SW_READ_RARELY    = GRALLOC_USAGE_SW_READ_RARELY,
         USAGE_SW_READ_OFTEN     = GRALLOC_USAGE_SW_READ_OFTEN,
         USAGE_SW_READ_MASK      = GRALLOC_USAGE_SW_READ_MASK,
-
+        
         USAGE_SW_WRITE_NEVER    = GRALLOC_USAGE_SW_WRITE_NEVER,
         USAGE_SW_WRITE_RARELY   = GRALLOC_USAGE_SW_WRITE_RARELY,
         USAGE_SW_WRITE_OFTEN    = GRALLOC_USAGE_SW_WRITE_OFTEN,
         USAGE_SW_WRITE_MASK     = GRALLOC_USAGE_SW_WRITE_MASK,
-
+        
         USAGE_SOFTWARE_MASK     = USAGE_SW_READ_MASK|USAGE_SW_WRITE_MASK,
-
+        
         USAGE_HW_TEXTURE        = GRALLOC_USAGE_HW_TEXTURE,
         USAGE_HW_RENDER         = GRALLOC_USAGE_HW_RENDER,
         USAGE_HW_2D             = GRALLOC_USAGE_HW_2D,
@@ -60,9 +60,15 @@ public:
     };
 
     static inline GraphicBufferAllocator& get() { return getInstance(); }
+    
+
+    status_t alloc(uint32_t w, uint32_t h, PixelFormat format, int usage,
+            buffer_handle_t* handle, int32_t* stride);
 
-    status_t alloc(uint32_t w, uint32_t h, PixelFormat format, uint32_t usage,
-            buffer_handle_t* handle, uint32_t* stride);
+#ifdef QCOM_BSP_LEGACY
+    status_t alloc(uint32_t w, uint32_t h, PixelFormat format, int usage,
+            buffer_handle_t* handle, int32_t* stride, uint32_t bufferSize);
+#endif
 
     status_t free(buffer_handle_t handle);
 
@@ -71,21 +77,21 @@ public:
 
 private:
     struct alloc_rec_t {
-        uint32_t width;
-        uint32_t height;
-        uint32_t stride;
+        uint32_t w;
+        uint32_t h;
+        uint32_t s;
         PixelFormat format;
         uint32_t usage;
         size_t size;
     };
-
+    
     static Mutex sLock;
     static KeyedVector<buffer_handle_t, alloc_rec_t> sAllocList;
-
+    
     friend class Singleton<GraphicBufferAllocator>;
     GraphicBufferAllocator();
     ~GraphicBufferAllocator();
-
+    
     alloc_device_t  *mAllocDev;
 };
 
diff --git a/include/ui/GraphicBufferMapper.h b/include/ui/GraphicBufferMapper.h
index 6099548..0ffc582 100644
--- a/include/ui/GraphicBufferMapper.h
+++ b/include/ui/GraphicBufferMapper.h
@@ -41,23 +41,26 @@ public:
     status_t registerBuffer(buffer_handle_t handle);
 
     status_t unregisterBuffer(buffer_handle_t handle);
-
+    
     status_t lock(buffer_handle_t handle,
-            uint32_t usage, const Rect& bounds, void** vaddr);
+            int usage, const Rect& bounds, void** vaddr);
 
     status_t lockYCbCr(buffer_handle_t handle,
-            uint32_t usage, const Rect& bounds, android_ycbcr *ycbcr);
+            int usage, const Rect& bounds, android_ycbcr *ycbcr);
 
     status_t unlock(buffer_handle_t handle);
 
     status_t lockAsync(buffer_handle_t handle,
-            uint32_t usage, const Rect& bounds, void** vaddr, int fenceFd);
+            int usage, const Rect& bounds, void** vaddr, int fenceFd);
 
     status_t lockAsyncYCbCr(buffer_handle_t handle,
-            uint32_t usage, const Rect& bounds, android_ycbcr *ycbcr,
-            int fenceFd);
+            int usage, const Rect& bounds, android_ycbcr *ycbcr, int fenceFd);
 
     status_t unlockAsync(buffer_handle_t handle, int *fenceFd);
+    
+#ifdef EXYNOS4_ENHANCEMENTS
+    status_t getphys(buffer_handle_t handle, void** paddr);
+#endif
 
     // dumps information about the mapping of this handle
     void dump(buffer_handle_t handle);
diff --git a/include/ui/PixelFormat.h b/include/ui/PixelFormat.h
index f26fecb..ed7c1d8 100644
--- a/include/ui/PixelFormat.h
+++ b/include/ui/PixelFormat.h
@@ -25,6 +25,9 @@
 #ifndef UI_PIXELFORMAT_H
 #define UI_PIXELFORMAT_H
 
+#include <stdint.h>
+#include <sys/types.h>
+#include <utils/Errors.h>
 #include <hardware/hardware.h>
 
 namespace android {
@@ -60,12 +63,67 @@ enum {
     PIXEL_FORMAT_BGRA_8888   = HAL_PIXEL_FORMAT_BGRA_8888,   // 4x8-bit BGRA
     PIXEL_FORMAT_RGBA_5551   = 6,                            // 16-bit ARGB
     PIXEL_FORMAT_RGBA_4444   = 7,                            // 16-bit ARGB
+    PIXEL_FORMAT_sRGB_A_8888 = HAL_PIXEL_FORMAT_sRGB_A_8888, // 4x8-bit sRGB + A
+    PIXEL_FORMAT_sRGB_X_8888 = HAL_PIXEL_FORMAT_sRGB_X_8888, // 4x8-bit sRGB, no A
 };
 
 typedef int32_t PixelFormat;
 
-uint32_t bytesPerPixel(PixelFormat format);
-uint32_t bitsPerPixel(PixelFormat format);
+#ifdef HAVE_PIXEL_FORMAT_INFO
+struct PixelFormatInfo {
+    enum {
+        INDEX_ALPHA   = 0,
+        INDEX_RED     = 1,
+        INDEX_GREEN   = 2,
+        INDEX_BLUE    = 3
+    };
+
+    enum { // components
+        ALPHA   = 1,
+        RGB     = 2,
+        RGBA    = 3,
+        L       = 4,
+        LA      = 5,
+        OTHER   = 0xFF
+    };
+
+    struct szinfo {
+        uint8_t h;
+        uint8_t l;
+    };
+
+    inline PixelFormatInfo() : version(sizeof(PixelFormatInfo)) { }
+    size_t getScanlineSize(unsigned int width) const;
+    size_t getSize(size_t ci) const {
+        return (ci <= 3) ? (cinfo[ci].h - cinfo[ci].l) : 0;
+    }
+    size_t      version;
+    PixelFormat format;
+    size_t      bytesPerPixel;
+    size_t      bitsPerPixel;
+    union {
+        szinfo      cinfo[4];
+        struct {
+            uint8_t     h_alpha;
+            uint8_t     l_alpha;
+            uint8_t     h_red;
+            uint8_t     l_red;
+            uint8_t     h_green;
+            uint8_t     l_green;
+            uint8_t     h_blue;
+            uint8_t     l_blue;
+        };
+    };
+    uint8_t     components;
+    uint8_t     reserved0[3];
+    uint32_t    reserved1;
+};
+
+status_t getPixelFormatInfo(PixelFormat format, PixelFormatInfo* info);
+#endif
+
+ssize_t bytesPerPixel(PixelFormat format);
+ssize_t bitsPerPixel(PixelFormat format);
 
 }; // namespace android
 
diff --git a/include/ui/Rect.h b/include/ui/Rect.h
index 3886f93..31e28d2 100644
--- a/include/ui/Rect.h
+++ b/include/ui/Rect.h
@@ -18,7 +18,6 @@
 #define ANDROID_UI_RECT
 
 #include <utils/Flattenable.h>
-#include <utils/Log.h>
 #include <utils/TypeHelpers.h>
 #include <ui/Point.h>
 
@@ -31,8 +30,6 @@ class Rect : public ARect, public LightFlattenablePod<Rect>
 public:
     typedef ARect::value_type value_type;
 
-    static const Rect INVALID_RECT;
-
     // we don't provide copy-ctor and operator= on purpose
     // because we want the compiler generated versions
 
@@ -46,22 +43,6 @@ public:
         bottom = h;
     }
 
-    inline Rect(uint32_t w, uint32_t h) {
-        if (w > INT32_MAX) {
-            ALOG(LOG_WARN, "Rect",
-                    "Width %u too large for Rect class, clamping", w);
-            w = INT32_MAX;
-        }
-        if (h > INT32_MAX) {
-            ALOG(LOG_WARN, "Rect",
-                    "Height %u too large for Rect class, clamping", h);
-            h = INT32_MAX;
-        }
-        left = top = 0;
-        right = w;
-        bottom = h;
-    }
-
     inline Rect(int32_t l, int32_t t, int32_t r, int32_t b) {
         left = l;
         top = t;
diff --git a/include/ui/Region.h b/include/ui/Region.h
index 2a14918..0d1c68c 100644
--- a/include/ui/Region.h
+++ b/include/ui/Region.h
@@ -35,8 +35,6 @@ class String8;
 class Region : public LightFlattenable<Region>
 {
 public:
-    static const Region INVALID_REGION;
-
                         Region();
                         Region(const Region& rhs);
     explicit            Region(const Rect& rhs);
@@ -57,12 +55,11 @@ public:
 
             // the region becomes its bounds
             Region&     makeBoundsSelf();
-
+    
             void        clear();
             void        set(const Rect& r);
-            void        set(int32_t w, int32_t h);
             void        set(uint32_t w, uint32_t h);
-
+        
             Region&     orSelf(const Rect& rhs);
             Region&     xorSelf(const Rect& rhs);
             Region&     andSelf(const Rect& rhs);
@@ -113,14 +110,14 @@ public:
     inline  Region&     operator -= (const Region& rhs);
     inline  Region&     operator += (const Point& pt);
 
-
+    
     // returns true if the regions share the same underlying storage
     bool isTriviallyEqual(const Region& region) const;
 
 
     /* various ways to access the rectangle list */
 
-
+    
     // STL-like iterators
     typedef Rect const* const_iterator;
     const_iterator begin() const;
@@ -136,7 +133,7 @@ public:
     SharedBuffer const* getSharedBuffer(size_t* count) const;
 
     /* no user serviceable parts here... */
-
+            
             // add a rectangle to the internal list. This rectangle must
             // be sorted in Y and X and must not make the region invalid.
             void        addRectUnchecked(int l, int t, int r, int b);
@@ -152,7 +149,7 @@ public:
 private:
     class rasterizer;
     friend class rasterizer;
-
+    
     Region& operationSelf(const Rect& r, int op);
     Region& operationSelf(const Region& r, int op);
     Region& operationSelf(const Region& r, int dx, int dy, int op);
@@ -175,7 +172,7 @@ private:
 
     static bool validate(const Region& reg,
             const char* name, bool silent = false);
-
+    
     // mStorage is a (manually) sorted array of Rects describing the region
     // with an extra Rect as the last element which is set to the
     // bounds of the region. However, if the region is
diff --git a/libs/gui/Android.mk b/libs/gui/Android.mk
index 8a965dd..e5a5eb3 100644
--- a/libs/gui/Android.mk
+++ b/libs/gui/Android.mk
@@ -1,42 +1,7 @@
-# Copyright 2010 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-LOCAL_PATH := $(call my-dir)
+LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
-LOCAL_CLANG := true
-LOCAL_CPPFLAGS := -std=c++1y -Weverything -Werror
-
-# The static constructors and destructors in this library have not been noted to
-# introduce significant overheads
-LOCAL_CPPFLAGS += -Wno-exit-time-destructors
-LOCAL_CPPFLAGS += -Wno-global-constructors
-
-# We only care about compiling as C++14
-LOCAL_CPPFLAGS += -Wno-c++98-compat-pedantic
-
-# We don't need to enumerate every case in a switch as long as a default case
-# is present
-LOCAL_CPPFLAGS += -Wno-switch-enum
-
-# Allow calling variadic macros without a __VA_ARGS__ list
-LOCAL_CPPFLAGS += -Wno-gnu-zero-variadic-macro-arguments
-
-# Don't warn about struct padding
-LOCAL_CPPFLAGS += -Wno-padded
-
-LOCAL_SRC_FILES := \
+LOCAL_SRC_FILES:= \
 	IGraphicBufferConsumer.cpp \
 	IConsumerListener.cpp \
 	BitTube.cpp \
@@ -82,7 +47,7 @@ LOCAL_SHARED_LIBRARIES := \
 	liblog
 
 
-LOCAL_MODULE := libgui
+LOCAL_MODULE:= libgui
 
 ifeq ($(TARGET_BOARD_PLATFORM), tegra)
 	LOCAL_CFLAGS += -DDONT_USE_FENCE_SYNC
@@ -90,6 +55,9 @@ endif
 ifeq ($(TARGET_BOARD_PLATFORM), tegra3)
 	LOCAL_CFLAGS += -DDONT_USE_FENCE_SYNC
 endif
+ifeq ($(BOARD_USES_LEGACY_SET_POSITION),true)
+	LOCAL_CFLAGS += -DUSES_LEGACY_SET_POSITION
+endif
 
 include $(BUILD_SHARED_LIBRARY)
 
diff --git a/libs/gui/BitTube.cpp b/libs/gui/BitTube.cpp
index b653c5b..3ed1f37 100644
--- a/libs/gui/BitTube.cpp
+++ b/libs/gui/BitTube.cpp
@@ -149,12 +149,12 @@ ssize_t BitTube::sendObjects(const sp<BitTube>& tube,
     ssize_t size = tube->write(vaddr, count*objSize);
 
     // should never happen because of SOCK_SEQPACKET
-    LOG_ALWAYS_FATAL_IF((size >= 0) && (size % static_cast<ssize_t>(objSize)),
+    LOG_ALWAYS_FATAL_IF((size >= 0) && (size % objSize),
             "BitTube::sendObjects(count=%zu, size=%zu), res=%zd (partial events were sent!)",
             count, objSize, size);
 
     //ALOGE_IF(size<0, "error %d sending %d events", size, count);
-    return size < 0 ? size : size / static_cast<ssize_t>(objSize);
+    return size < 0 ? size : size / objSize;
 }
 
 ssize_t BitTube::recvObjects(const sp<BitTube>& tube,
@@ -164,12 +164,12 @@ ssize_t BitTube::recvObjects(const sp<BitTube>& tube,
     ssize_t size = tube->read(vaddr, count*objSize);
 
     // should never happen because of SOCK_SEQPACKET
-    LOG_ALWAYS_FATAL_IF((size >= 0) && (size % static_cast<ssize_t>(objSize)),
+    LOG_ALWAYS_FATAL_IF((size >= 0) && (size % objSize),
             "BitTube::recvObjects(count=%zu, size=%zu), res=%zd (partial events were received!)",
             count, objSize, size);
 
     //ALOGE_IF(size<0, "error %d receiving %d events", size, count);
-    return size < 0 ? size : size / static_cast<ssize_t>(objSize);
+    return size < 0 ? size : size / objSize;
 }
 
 // ----------------------------------------------------------------------------
diff --git a/libs/gui/BufferItem.cpp b/libs/gui/BufferItem.cpp
index 8f64ae0..e6fc791 100644
--- a/libs/gui/BufferItem.cpp
+++ b/libs/gui/BufferItem.cpp
@@ -28,7 +28,6 @@ BufferItem::BufferItem() :
     mScalingMode(NATIVE_WINDOW_SCALING_MODE_FREEZE),
     mTimestamp(0),
     mIsAutoTimestamp(false),
-    mDataSpace(HAL_DATASPACE_UNKNOWN),
     mFrameNumber(0),
     mSlot(INVALID_BUFFER_SLOT),
     mIsDroppable(false),
@@ -39,67 +38,66 @@ BufferItem::BufferItem() :
 
 BufferItem::~BufferItem() {}
 
-template <typename T>
-static void addAligned(size_t& size, T /* value */) {
-    size = FlattenableUtils::align<sizeof(T)>(size);
-    size += sizeof(T);
+BufferItem::operator IGraphicBufferConsumer::BufferItem() const {
+    IGraphicBufferConsumer::BufferItem bufferItem;
+    bufferItem.mGraphicBuffer = mGraphicBuffer;
+    bufferItem.mFence = mFence;
+    bufferItem.mCrop = mCrop;
+    bufferItem.mTransform = mTransform;
+    bufferItem.mScalingMode = mScalingMode;
+    bufferItem.mTimestamp = mTimestamp;
+    bufferItem.mIsAutoTimestamp = mIsAutoTimestamp;
+    bufferItem.mFrameNumber = mFrameNumber;
+    bufferItem.mBuf = mSlot;
+    bufferItem.mIsDroppable = mIsDroppable;
+    bufferItem.mAcquireCalled = mAcquireCalled;
+    bufferItem.mTransformToDisplayInverse = mTransformToDisplayInverse;
+    return bufferItem;
 }
 
 size_t BufferItem::getPodSize() const {
-    size_t size = 0;
-    addAligned(size, mCrop);
-    addAligned(size, mTransform);
-    addAligned(size, mScalingMode);
-    addAligned(size, mTimestampLo);
-    addAligned(size, mTimestampHi);
-    addAligned(size, mIsAutoTimestamp);
-    addAligned(size, mDataSpace);
-    addAligned(size, mFrameNumberLo);
-    addAligned(size, mFrameNumberHi);
-    addAligned(size, mSlot);
-    addAligned(size, mIsDroppable);
-    addAligned(size, mAcquireCalled);
-    addAligned(size, mTransformToDisplayInverse);
-    return size;
+    size_t c =  sizeof(mCrop) +
+            sizeof(mTransform) +
+            sizeof(mScalingMode) +
+            sizeof(mTimestamp) +
+            sizeof(mIsAutoTimestamp) +
+            sizeof(mFrameNumber) +
+            sizeof(mSlot) +
+            sizeof(mIsDroppable) +
+            sizeof(mAcquireCalled) +
+            sizeof(mTransformToDisplayInverse);
+    return c;
 }
 
 size_t BufferItem::getFlattenedSize() const {
-    size_t size = sizeof(uint32_t); // Flags
+    size_t c = 0;
     if (mGraphicBuffer != 0) {
-        size += mGraphicBuffer->getFlattenedSize();
-        FlattenableUtils::align<4>(size);
+        c += mGraphicBuffer->getFlattenedSize();
+        FlattenableUtils::align<4>(c);
     }
     if (mFence != 0) {
-        size += mFence->getFlattenedSize();
-        FlattenableUtils::align<4>(size);
+        c += mFence->getFlattenedSize();
+        FlattenableUtils::align<4>(c);
     }
-    size += mSurfaceDamage.getFlattenedSize();
-    size = FlattenableUtils::align<8>(size);
-    return size + getPodSize();
+    return sizeof(int32_t) + c + getPodSize();
 }
 
 size_t BufferItem::getFdCount() const {
-    size_t count = 0;
+    size_t c = 0;
     if (mGraphicBuffer != 0) {
-        count += mGraphicBuffer->getFdCount();
+        c += mGraphicBuffer->getFdCount();
     }
     if (mFence != 0) {
-        count += mFence->getFdCount();
+        c += mFence->getFdCount();
     }
-    return count;
-}
-
-template <typename T>
-static void writeAligned(void*& buffer, size_t& size, T value) {
-    size -= FlattenableUtils::align<alignof(T)>(buffer);
-    FlattenableUtils::write(buffer, size, value);
+    return c;
 }
 
 status_t BufferItem::flatten(
         void*& buffer, size_t& size, int*& fds, size_t& count) const {
 
     // make sure we have enough space
-    if (size < BufferItem::getFlattenedSize()) {
+    if (count < BufferItem::getFlattenedSize()) {
         return NO_MEMORY;
     }
 
@@ -123,44 +121,30 @@ status_t BufferItem::flatten(
         flags |= 2;
     }
 
-    status_t err = mSurfaceDamage.flatten(buffer, size);
-    if (err) return err;
-    FlattenableUtils::advance(buffer, size, mSurfaceDamage.getFlattenedSize());
-
-    // Check we still have enough space
+    // check we have enough space (in case flattening the fence/graphicbuffer lied to us)
     if (size < getPodSize()) {
         return NO_MEMORY;
     }
 
-    writeAligned(buffer, size, mCrop);
-    writeAligned(buffer, size, mTransform);
-    writeAligned(buffer, size, mScalingMode);
-    writeAligned(buffer, size, mTimestampLo);
-    writeAligned(buffer, size, mTimestampHi);
-    writeAligned(buffer, size, mIsAutoTimestamp);
-    writeAligned(buffer, size, mDataSpace);
-    writeAligned(buffer, size, mFrameNumberLo);
-    writeAligned(buffer, size, mFrameNumberHi);
-    writeAligned(buffer, size, mSlot);
-    writeAligned(buffer, size, mIsDroppable);
-    writeAligned(buffer, size, mAcquireCalled);
-    writeAligned(buffer, size, mTransformToDisplayInverse);
+    FlattenableUtils::write(buffer, size, mCrop);
+    FlattenableUtils::write(buffer, size, mTransform);
+    FlattenableUtils::write(buffer, size, mScalingMode);
+    FlattenableUtils::write(buffer, size, mTimestamp);
+    FlattenableUtils::write(buffer, size, mIsAutoTimestamp);
+    FlattenableUtils::write(buffer, size, mFrameNumber);
+    FlattenableUtils::write(buffer, size, mSlot);
+    FlattenableUtils::write(buffer, size, mIsDroppable);
+    FlattenableUtils::write(buffer, size, mAcquireCalled);
+    FlattenableUtils::write(buffer, size, mTransformToDisplayInverse);
 
     return NO_ERROR;
 }
 
-template <typename T>
-static void readAligned(const void*& buffer, size_t& size, T& value) {
-    size -= FlattenableUtils::align<alignof(T)>(buffer);
-    FlattenableUtils::read(buffer, size, value);
-}
-
 status_t BufferItem::unflatten(
         void const*& buffer, size_t& size, int const*& fds, size_t& count) {
 
-    if (size < sizeof(uint32_t)) {
+    if (size < sizeof(uint32_t))
         return NO_MEMORY;
-    }
 
     uint32_t flags = 0;
     FlattenableUtils::read(buffer, size, flags);
@@ -179,28 +163,21 @@ status_t BufferItem::unflatten(
         size -= FlattenableUtils::align<4>(buffer);
     }
 
-    status_t err = mSurfaceDamage.unflatten(buffer, size);
-    if (err) return err;
-    FlattenableUtils::advance(buffer, size, mSurfaceDamage.getFlattenedSize());
-
-    // Check we still have enough space
+    // check we have enough space
     if (size < getPodSize()) {
         return NO_MEMORY;
     }
 
-    readAligned(buffer, size, mCrop);
-    readAligned(buffer, size, mTransform);
-    readAligned(buffer, size, mScalingMode);
-    readAligned(buffer, size, mTimestampLo);
-    readAligned(buffer, size, mTimestampHi);
-    readAligned(buffer, size, mIsAutoTimestamp);
-    readAligned(buffer, size, mDataSpace);
-    readAligned(buffer, size, mFrameNumberLo);
-    readAligned(buffer, size, mFrameNumberHi);
-    readAligned(buffer, size, mSlot);
-    readAligned(buffer, size, mIsDroppable);
-    readAligned(buffer, size, mAcquireCalled);
-    readAligned(buffer, size, mTransformToDisplayInverse);
+    FlattenableUtils::read(buffer, size, mCrop);
+    FlattenableUtils::read(buffer, size, mTransform);
+    FlattenableUtils::read(buffer, size, mScalingMode);
+    FlattenableUtils::read(buffer, size, mTimestamp);
+    FlattenableUtils::read(buffer, size, mIsAutoTimestamp);
+    FlattenableUtils::read(buffer, size, mFrameNumber);
+    FlattenableUtils::read(buffer, size, mSlot);
+    FlattenableUtils::read(buffer, size, mIsDroppable);
+    FlattenableUtils::read(buffer, size, mAcquireCalled);
+    FlattenableUtils::read(buffer, size, mTransformToDisplayInverse);
 
     return NO_ERROR;
 }
diff --git a/libs/gui/BufferItemConsumer.cpp b/libs/gui/BufferItemConsumer.cpp
index 578b8d9..fe50c55 100644
--- a/libs/gui/BufferItemConsumer.cpp
+++ b/libs/gui/BufferItemConsumer.cpp
@@ -16,17 +16,16 @@
 
 //#define LOG_NDEBUG 0
 #define LOG_TAG "BufferItemConsumer"
-//#define ATRACE_TAG ATRACE_TAG_GRAPHICS
+#define ATRACE_TAG ATRACE_TAG_GRAPHICS
 #include <utils/Log.h>
 
-#include <gui/BufferItem.h>
 #include <gui/BufferItemConsumer.h>
 
-//#define BI_LOGV(x, ...) ALOGV("[%s] " x, mName.string(), ##__VA_ARGS__)
-//#define BI_LOGD(x, ...) ALOGD("[%s] " x, mName.string(), ##__VA_ARGS__)
-//#define BI_LOGI(x, ...) ALOGI("[%s] " x, mName.string(), ##__VA_ARGS__)
-//#define BI_LOGW(x, ...) ALOGW("[%s] " x, mName.string(), ##__VA_ARGS__)
-#define BI_LOGE(x, ...) ALOGE("[%s] " x, mName.string(), ##__VA_ARGS__)
+#define BI_LOGV(x, ...) ALOGV("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define BI_LOGD(x, ...) ALOGD("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define BI_LOGI(x, ...) ALOGI("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define BI_LOGW(x, ...) ALOGW("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define BI_LOGE(x, ...) ALOGE("[%s] "x, mName.string(), ##__VA_ARGS__)
 
 namespace android {
 
@@ -45,7 +44,8 @@ BufferItemConsumer::BufferItemConsumer(
     }
 }
 
-BufferItemConsumer::~BufferItemConsumer() {}
+BufferItemConsumer::~BufferItemConsumer() {
+}
 
 void BufferItemConsumer::setName(const String8& name) {
     Mutex::Autolock _l(mMutex);
@@ -100,4 +100,14 @@ status_t BufferItemConsumer::releaseBuffer(const BufferItem &item,
     return err;
 }
 
+status_t BufferItemConsumer::setDefaultBufferSize(uint32_t w, uint32_t h) {
+    Mutex::Autolock _l(mMutex);
+    return mConsumer->setDefaultBufferSize(w, h);
+}
+
+status_t BufferItemConsumer::setDefaultBufferFormat(uint32_t defaultFormat) {
+    Mutex::Autolock _l(mMutex);
+    return mConsumer->setDefaultBufferFormat(defaultFormat);
+}
+
 } // namespace android
diff --git a/libs/gui/BufferQueue.cpp b/libs/gui/BufferQueue.cpp
index ccbb5a2..61fd8c4 100644
--- a/libs/gui/BufferQueue.cpp
+++ b/libs/gui/BufferQueue.cpp
@@ -32,21 +32,13 @@ BufferQueue::ProxyConsumerListener::ProxyConsumerListener(
 BufferQueue::ProxyConsumerListener::~ProxyConsumerListener() {}
 
 void BufferQueue::ProxyConsumerListener::onFrameAvailable(
-        const BufferItem& item) {
+        const android::BufferItem& item) {
     sp<ConsumerListener> listener(mConsumerListener.promote());
     if (listener != NULL) {
         listener->onFrameAvailable(item);
     }
 }
 
-void BufferQueue::ProxyConsumerListener::onFrameReplaced(
-        const BufferItem& item) {
-    sp<ConsumerListener> listener(mConsumerListener.promote());
-    if (listener != NULL) {
-        listener->onFrameReplaced(item);
-    }
-}
-
 void BufferQueue::ProxyConsumerListener::onBuffersReleased() {
     sp<ConsumerListener> listener(mConsumerListener.promote());
     if (listener != NULL) {
diff --git a/libs/gui/BufferQueueConsumer.cpp b/libs/gui/BufferQueueConsumer.cpp
index bb3e1b0..36e3c06 100644
--- a/libs/gui/BufferQueueConsumer.cpp
+++ b/libs/gui/BufferQueueConsumer.cpp
@@ -36,170 +36,142 @@ BufferQueueConsumer::BufferQueueConsumer(const sp<BufferQueueCore>& core) :
 BufferQueueConsumer::~BufferQueueConsumer() {}
 
 status_t BufferQueueConsumer::acquireBuffer(BufferItem* outBuffer,
-        nsecs_t expectedPresent, uint64_t maxFrameNumber) {
+        nsecs_t expectedPresent) {
     ATRACE_CALL();
+    Mutex::Autolock lock(mCore->mMutex);
 
-    int numDroppedBuffers = 0;
-    sp<IProducerListener> listener;
-    {
-        Mutex::Autolock lock(mCore->mMutex);
-
-        // Check that the consumer doesn't currently have the maximum number of
-        // buffers acquired. We allow the max buffer count to be exceeded by one
-        // buffer so that the consumer can successfully set up the newly acquired
-        // buffer before releasing the old one.
-        int numAcquiredBuffers = 0;
-        for (int s = 0; s < BufferQueueDefs::NUM_BUFFER_SLOTS; ++s) {
-            if (mSlots[s].mBufferState == BufferSlot::ACQUIRED) {
-                ++numAcquiredBuffers;
-            }
-        }
-        if (numAcquiredBuffers >= mCore->mMaxAcquiredBufferCount + 1) {
-            BQ_LOGE("acquireBuffer: max acquired buffer count reached: %d (max %d)",
-                    numAcquiredBuffers, mCore->mMaxAcquiredBufferCount);
-            return INVALID_OPERATION;
-        }
-
-        // Check if the queue is empty.
-        // In asynchronous mode the list is guaranteed to be one buffer deep,
-        // while in synchronous mode we use the oldest buffer.
-        if (mCore->mQueue.empty()) {
-            return NO_BUFFER_AVAILABLE;
+    // Check that the consumer doesn't currently have the maximum number of
+    // buffers acquired. We allow the max buffer count to be exceeded by one
+    // buffer so that the consumer can successfully set up the newly acquired
+    // buffer before releasing the old one.
+    int numAcquiredBuffers = 0;
+    for (int s = 0; s < BufferQueueDefs::NUM_BUFFER_SLOTS; ++s) {
+        if (mSlots[s].mBufferState == BufferSlot::ACQUIRED) {
+            ++numAcquiredBuffers;
         }
+    }
+    if (numAcquiredBuffers >= mCore->mMaxAcquiredBufferCount + 1) {
+        BQ_LOGE("acquireBuffer: max acquired buffer count reached: %d (max %d)",
+                numAcquiredBuffers, mCore->mMaxAcquiredBufferCount);
+        return INVALID_OPERATION;
+    }
 
-        BufferQueueCore::Fifo::iterator front(mCore->mQueue.begin());
-
-        // If expectedPresent is specified, we may not want to return a buffer yet.
-        // If it's specified and there's more than one buffer queued, we may want
-        // to drop a buffer.
-        if (expectedPresent != 0) {
-            const int MAX_REASONABLE_NSEC = 1000000000ULL; // 1 second
+    // Check if the queue is empty.
+    // In asynchronous mode the list is guaranteed to be one buffer deep,
+    // while in synchronous mode we use the oldest buffer.
+    if (mCore->mQueue.empty()) {
+        return NO_BUFFER_AVAILABLE;
+    }
 
-            // The 'expectedPresent' argument indicates when the buffer is expected
-            // to be presented on-screen. If the buffer's desired present time is
-            // earlier (less) than expectedPresent -- meaning it will be displayed
-            // on time or possibly late if we show it as soon as possible -- we
-            // acquire and return it. If we don't want to display it until after the
-            // expectedPresent time, we return PRESENT_LATER without acquiring it.
-            //
-            // To be safe, we don't defer acquisition if expectedPresent is more
-            // than one second in the future beyond the desired present time
-            // (i.e., we'd be holding the buffer for a long time).
+    BufferQueueCore::Fifo::iterator front(mCore->mQueue.begin());
+
+    // If expectedPresent is specified, we may not want to return a buffer yet.
+    // If it's specified and there's more than one buffer queued, we may want
+    // to drop a buffer.
+    if (expectedPresent != 0) {
+        const int MAX_REASONABLE_NSEC = 1000000000ULL; // 1 second
+
+        // The 'expectedPresent' argument indicates when the buffer is expected
+        // to be presented on-screen. If the buffer's desired present time is
+        // earlier (less) than expectedPresent -- meaning it will be displayed
+        // on time or possibly late if we show it as soon as possible -- we
+        // acquire and return it. If we don't want to display it until after the
+        // expectedPresent time, we return PRESENT_LATER without acquiring it.
+        //
+        // To be safe, we don't defer acquisition if expectedPresent is more
+        // than one second in the future beyond the desired present time
+        // (i.e., we'd be holding the buffer for a long time).
+        //
+        // NOTE: Code assumes monotonic time values from the system clock
+        // are positive.
+
+        // Start by checking to see if we can drop frames. We skip this check if
+        // the timestamps are being auto-generated by Surface. If the app isn't
+        // generating timestamps explicitly, it probably doesn't want frames to
+        // be discarded based on them.
+        while (mCore->mQueue.size() > 1 && !mCore->mQueue[0].mIsAutoTimestamp) {
+            // If entry[1] is timely, drop entry[0] (and repeat). We apply an
+            // additional criterion here: we only drop the earlier buffer if our
+            // desiredPresent falls within +/- 1 second of the expected present.
+            // Otherwise, bogus desiredPresent times (e.g., 0 or a small
+            // relative timestamp), which normally mean "ignore the timestamp
+            // and acquire immediately", would cause us to drop frames.
             //
-            // NOTE: Code assumes monotonic time values from the system clock
-            // are positive.
-
-            // Start by checking to see if we can drop frames. We skip this check if
-            // the timestamps are being auto-generated by Surface. If the app isn't
-            // generating timestamps explicitly, it probably doesn't want frames to
-            // be discarded based on them.
-            while (mCore->mQueue.size() > 1 && !mCore->mQueue[0].mIsAutoTimestamp) {
-                const BufferItem& bufferItem(mCore->mQueue[1]);
-
-                // If dropping entry[0] would leave us with a buffer that the
-                // consumer is not yet ready for, don't drop it.
-                if (maxFrameNumber && bufferItem.mFrameNumber > maxFrameNumber) {
-                    break;
-                }
-
-                // If entry[1] is timely, drop entry[0] (and repeat). We apply an
-                // additional criterion here: we only drop the earlier buffer if our
-                // desiredPresent falls within +/- 1 second of the expected present.
-                // Otherwise, bogus desiredPresent times (e.g., 0 or a small
-                // relative timestamp), which normally mean "ignore the timestamp
-                // and acquire immediately", would cause us to drop frames.
-                //
-                // We may want to add an additional criterion: don't drop the
-                // earlier buffer if entry[1]'s fence hasn't signaled yet.
-                nsecs_t desiredPresent = bufferItem.mTimestamp;
-                if (desiredPresent < expectedPresent - MAX_REASONABLE_NSEC ||
-                        desiredPresent > expectedPresent) {
-                    // This buffer is set to display in the near future, or
-                    // desiredPresent is garbage. Either way we don't want to drop
-                    // the previous buffer just to get this on the screen sooner.
-                    BQ_LOGV("acquireBuffer: nodrop desire=%" PRId64 " expect=%"
-                            PRId64 " (%" PRId64 ") now=%" PRId64,
-                            desiredPresent, expectedPresent,
-                            desiredPresent - expectedPresent,
-                            systemTime(CLOCK_MONOTONIC));
-                    break;
-                }
-
-                BQ_LOGV("acquireBuffer: drop desire=%" PRId64 " expect=%" PRId64
-                        " size=%zu",
-                        desiredPresent, expectedPresent, mCore->mQueue.size());
-                if (mCore->stillTracking(front)) {
-                    // Front buffer is still in mSlots, so mark the slot as free
-                    mSlots[front->mSlot].mBufferState = BufferSlot::FREE;
-                    mCore->mFreeBuffers.push_back(front->mSlot);
-                    listener = mCore->mConnectedProducerListener;
-                    ++numDroppedBuffers;
-                }
-                mCore->mQueue.erase(front);
-                front = mCore->mQueue.begin();
-            }
-
-            // See if the front buffer is ready to be acquired
-            nsecs_t desiredPresent = front->mTimestamp;
-            bool bufferIsDue = desiredPresent <= expectedPresent ||
-                    desiredPresent > expectedPresent + MAX_REASONABLE_NSEC;
-            bool consumerIsReady = maxFrameNumber > 0 ?
-                    front->mFrameNumber <= maxFrameNumber : true;
-            if (!bufferIsDue || !consumerIsReady) {
-                BQ_LOGV("acquireBuffer: defer desire=%" PRId64 " expect=%" PRId64
-                        " (%" PRId64 ") now=%" PRId64 " frame=%" PRIu64
-                        " consumer=%" PRIu64,
+            // We may want to add an additional criterion: don't drop the
+            // earlier buffer if entry[1]'s fence hasn't signaled yet.
+            const BufferItem& bufferItem(mCore->mQueue[1]);
+            nsecs_t desiredPresent = bufferItem.mTimestamp;
+            if (desiredPresent < expectedPresent - MAX_REASONABLE_NSEC ||
+                    desiredPresent > expectedPresent) {
+                // This buffer is set to display in the near future, or
+                // desiredPresent is garbage. Either way we don't want to drop
+                // the previous buffer just to get this on the screen sooner.
+                BQ_LOGV("acquireBuffer: nodrop desire=%" PRId64 " expect=%"
+                        PRId64 " (%" PRId64 ") now=%" PRId64,
                         desiredPresent, expectedPresent,
                         desiredPresent - expectedPresent,
-                        systemTime(CLOCK_MONOTONIC),
-                        front->mFrameNumber, maxFrameNumber);
-                return PRESENT_LATER;
+                        systemTime(CLOCK_MONOTONIC));
+                break;
+            }
+
+            BQ_LOGV("acquireBuffer: drop desire=%" PRId64 " expect=%" PRId64
+                    " size=%zu",
+                    desiredPresent, expectedPresent, mCore->mQueue.size());
+            if (mCore->stillTracking(front)) {
+                // Front buffer is still in mSlots, so mark the slot as free
+                mSlots[front->mSlot].mBufferState = BufferSlot::FREE;
             }
+            mCore->mQueue.erase(front);
+            front = mCore->mQueue.begin();
+        }
 
-            BQ_LOGV("acquireBuffer: accept desire=%" PRId64 " expect=%" PRId64 " "
-                    "(%" PRId64 ") now=%" PRId64, desiredPresent, expectedPresent,
+        // See if the front buffer is due
+        nsecs_t desiredPresent = front->mTimestamp;
+        if (desiredPresent > expectedPresent &&
+                desiredPresent < expectedPresent + MAX_REASONABLE_NSEC) {
+            BQ_LOGV("acquireBuffer: defer desire=%" PRId64 " expect=%" PRId64
+                    " (%" PRId64 ") now=%" PRId64,
+                    desiredPresent, expectedPresent,
                     desiredPresent - expectedPresent,
                     systemTime(CLOCK_MONOTONIC));
+            return PRESENT_LATER;
         }
 
-        int slot = front->mSlot;
-        *outBuffer = *front;
-        ATRACE_BUFFER_INDEX(slot);
-
-        BQ_LOGV("acquireBuffer: acquiring { slot=%d/%" PRIu64 " buffer=%p }",
-                slot, front->mFrameNumber, front->mGraphicBuffer->handle);
-        // If the front buffer is still being tracked, update its slot state
-        if (mCore->stillTracking(front)) {
-            mSlots[slot].mAcquireCalled = true;
-            mSlots[slot].mNeedsCleanupOnRelease = false;
-            mSlots[slot].mBufferState = BufferSlot::ACQUIRED;
-            mSlots[slot].mFence = Fence::NO_FENCE;
-        }
+        BQ_LOGV("acquireBuffer: accept desire=%" PRId64 " expect=%" PRId64 " "
+                "(%" PRId64 ") now=%" PRId64, desiredPresent, expectedPresent,
+                desiredPresent - expectedPresent,
+                systemTime(CLOCK_MONOTONIC));
+    }
 
-        // If the buffer has previously been acquired by the consumer, set
-        // mGraphicBuffer to NULL to avoid unnecessarily remapping this buffer
-        // on the consumer side
-        if (outBuffer->mAcquireCalled) {
-            outBuffer->mGraphicBuffer = NULL;
-        }
+    int slot = front->mSlot;
+    *outBuffer = *front;
+    ATRACE_BUFFER_INDEX(slot);
 
-        mCore->mQueue.erase(front);
+    BQ_LOGV("acquireBuffer: acquiring { slot=%d/%" PRIu64 " buffer=%p }",
+            slot, front->mFrameNumber, front->mGraphicBuffer->handle);
+    // If the front buffer is still being tracked, update its slot state
+    if (mCore->stillTracking(front)) {
+        mSlots[slot].mAcquireCalled = true;
+        mSlots[slot].mNeedsCleanupOnRelease = false;
+        mSlots[slot].mBufferState = BufferSlot::ACQUIRED;
+        mSlots[slot].mFence = Fence::NO_FENCE;
+    }
 
-        // We might have freed a slot while dropping old buffers, or the producer
-        // may be blocked waiting for the number of buffers in the queue to
-        // decrease.
-        mCore->mDequeueCondition.broadcast();
+    // If the buffer has previously been acquired by the consumer, set
+    // mGraphicBuffer to NULL to avoid unnecessarily remapping this buffer
+    // on the consumer side
+    if (outBuffer->mAcquireCalled) {
+        outBuffer->mGraphicBuffer = NULL;
+    }
 
-        ATRACE_INT(mCore->mConsumerName.string(), mCore->mQueue.size());
+    mCore->mQueue.erase(front);
 
-        mCore->validateConsistencyLocked();
-    }
+    // We might have freed a slot while dropping old buffers, or the producer
+    // may be blocked waiting for the number of buffers in the queue to
+    // decrease.
+    mCore->mDequeueCondition.broadcast();
 
-    if (listener != NULL) {
-        for (int i = 0; i < numDroppedBuffers; ++i) {
-            listener->onBufferReleased();
-        }
-    }
+    ATRACE_INT(mCore->mConsumerName.string(), mCore->mQueue.size());
 
     return NO_ERROR;
 }
@@ -227,7 +199,6 @@ status_t BufferQueueConsumer::detachBuffer(int slot) {
 
     mCore->freeBufferLocked(slot);
     mCore->mDequeueCondition.broadcast();
-    mCore->validateConsistencyLocked();
 
     return NO_ERROR;
 }
@@ -246,11 +217,18 @@ status_t BufferQueueConsumer::attachBuffer(int* outSlot,
 
     Mutex::Autolock lock(mCore->mMutex);
 
-    // Make sure we don't have too many acquired buffers
+    // Make sure we don't have too many acquired buffers and find a free slot
+    // to put the buffer into (the oldest if there are multiple).
     int numAcquiredBuffers = 0;
+    int found = BufferQueueCore::INVALID_BUFFER_SLOT;
     for (int s = 0; s < BufferQueueDefs::NUM_BUFFER_SLOTS; ++s) {
         if (mSlots[s].mBufferState == BufferSlot::ACQUIRED) {
             ++numAcquiredBuffers;
+        } else if (mSlots[s].mBufferState == BufferSlot::FREE) {
+            if (found == BufferQueueCore::INVALID_BUFFER_SLOT ||
+                    mSlots[s].mFrameNumber < mSlots[found].mFrameNumber) {
+                found = s;
+            }
         }
     }
 
@@ -260,24 +238,6 @@ status_t BufferQueueConsumer::attachBuffer(int* outSlot,
                 mCore->mMaxAcquiredBufferCount);
         return INVALID_OPERATION;
     }
-
-    if (buffer->getGenerationNumber() != mCore->mGenerationNumber) {
-        BQ_LOGE("attachBuffer: generation number mismatch [buffer %u] "
-                "[queue %u]", buffer->getGenerationNumber(),
-                mCore->mGenerationNumber);
-        return BAD_VALUE;
-    }
-
-    // Find a free slot to put the buffer into
-    int found = BufferQueueCore::INVALID_BUFFER_SLOT;
-    if (!mCore->mFreeSlots.empty()) {
-        auto slot = mCore->mFreeSlots.begin();
-        found = *slot;
-        mCore->mFreeSlots.erase(slot);
-    } else if (!mCore->mFreeBuffers.empty()) {
-        found = mCore->mFreeBuffers.front();
-        mCore->mFreeBuffers.remove(found);
-    }
     if (found == BufferQueueCore::INVALID_BUFFER_SLOT) {
         BQ_LOGE("attachBuffer(P): could not find free buffer slot");
         return NO_MEMORY;
@@ -311,8 +271,6 @@ status_t BufferQueueConsumer::attachBuffer(int* outSlot,
     // for attached buffers.
     mSlots[*outSlot].mAcquireCalled = false;
 
-    mCore->validateConsistencyLocked();
-
     return NO_ERROR;
 }
 
@@ -324,8 +282,6 @@ status_t BufferQueueConsumer::releaseBuffer(int slot, uint64_t frameNumber,
 
     if (slot < 0 || slot >= BufferQueueDefs::NUM_BUFFER_SLOTS ||
             releaseFence == NULL) {
-        BQ_LOGE("releaseBuffer: slot %d out of range or fence %p NULL", slot,
-                releaseFence.get());
         return BAD_VALUE;
     }
 
@@ -355,7 +311,6 @@ status_t BufferQueueConsumer::releaseBuffer(int slot, uint64_t frameNumber,
             mSlots[slot].mEglFence = eglFence;
             mSlots[slot].mFence = releaseFence;
             mSlots[slot].mBufferState = BufferSlot::FREE;
-            mCore->mFreeBuffers.push_back(slot);
             listener = mCore->mConnectedProducerListener;
             BQ_LOGV("releaseBuffer: releasing slot %d", slot);
         } else if (mSlots[slot].mNeedsCleanupOnRelease) {
@@ -364,13 +319,12 @@ status_t BufferQueueConsumer::releaseBuffer(int slot, uint64_t frameNumber,
             mSlots[slot].mNeedsCleanupOnRelease = false;
             return STALE_BUFFER_SLOT;
         } else {
-            BQ_LOGE("releaseBuffer: attempted to release buffer slot %d "
+            BQ_LOGV("releaseBuffer: attempted to release buffer slot %d "
                     "but its state was %d", slot, mSlots[slot].mBufferState);
             return BAD_VALUE;
         }
 
         mCore->mDequeueCondition.broadcast();
-        mCore->validateConsistencyLocked();
     } // Autolock scope
 
     // Call back without lock held
@@ -534,7 +488,7 @@ void BufferQueueConsumer::setConsumerName(const String8& name) {
     mConsumerName = name;
 }
 
-status_t BufferQueueConsumer::setDefaultBufferFormat(PixelFormat defaultFormat) {
+status_t BufferQueueConsumer::setDefaultBufferFormat(uint32_t defaultFormat) {
     ATRACE_CALL();
     BQ_LOGV("setDefaultBufferFormat: %u", defaultFormat);
     Mutex::Autolock lock(mCore->mMutex);
@@ -542,15 +496,6 @@ status_t BufferQueueConsumer::setDefaultBufferFormat(PixelFormat defaultFormat)
     return NO_ERROR;
 }
 
-status_t BufferQueueConsumer::setDefaultBufferDataSpace(
-        android_dataspace defaultDataSpace) {
-    ATRACE_CALL();
-    BQ_LOGV("setDefaultBufferDataSpace: %u", defaultDataSpace);
-    Mutex::Autolock lock(mCore->mMutex);
-    mCore->mDefaultBufferDataSpace = defaultDataSpace;
-    return NO_ERROR;
-}
-
 status_t BufferQueueConsumer::setConsumerUsageBits(uint32_t usage) {
     ATRACE_CALL();
     BQ_LOGV("setConsumerUsageBits: %#x", usage);
diff --git a/libs/gui/BufferQueueCore.cpp b/libs/gui/BufferQueueCore.cpp
index 851a396..ec1e631 100644
--- a/libs/gui/BufferQueueCore.cpp
+++ b/libs/gui/BufferQueueCore.cpp
@@ -53,8 +53,6 @@ BufferQueueCore::BufferQueueCore(const sp<IGraphicBufferAlloc>& allocator) :
     mConnectedProducerListener(),
     mSlots(),
     mQueue(),
-    mFreeSlots(),
-    mFreeBuffers(),
     mOverrideMaxBufferCount(0),
     mDequeueCondition(),
     mUseAsyncBuffer(true),
@@ -62,17 +60,13 @@ BufferQueueCore::BufferQueueCore(const sp<IGraphicBufferAlloc>& allocator) :
     mDefaultBufferFormat(PIXEL_FORMAT_RGBA_8888),
     mDefaultWidth(1),
     mDefaultHeight(1),
-    mDefaultBufferDataSpace(HAL_DATASPACE_UNKNOWN),
     mDefaultMaxBufferCount(2),
     mMaxAcquiredBufferCount(1),
     mBufferHasBeenQueued(false),
     mFrameCounter(0),
     mTransformHint(0),
     mIsAllocating(false),
-    mIsAllocatingCondition(),
-    mAllowAllocation(true),
-    mBufferAge(0),
-    mGenerationNumber(0)
+    mIsAllocatingCondition()
 {
     if (allocator == NULL) {
         sp<ISurfaceComposer> composer(ComposerService::getComposerService());
@@ -81,9 +75,6 @@ BufferQueueCore::BufferQueueCore(const sp<IGraphicBufferAlloc>& allocator) :
             BQ_LOGE("createGraphicBufferAlloc failed");
         }
     }
-    for (int slot = 0; slot < BufferQueueDefs::NUM_BUFFER_SLOTS; ++slot) {
-        mFreeSlots.insert(slot);
-    }
 }
 
 BufferQueueCore::~BufferQueueCore() {}
@@ -198,22 +189,13 @@ status_t BufferQueueCore::setDefaultMaxBufferCountLocked(int count) {
 
 void BufferQueueCore::freeBufferLocked(int slot) {
     BQ_LOGV("freeBufferLocked: slot %d", slot);
-    bool hadBuffer = mSlots[slot].mGraphicBuffer != NULL;
     mSlots[slot].mGraphicBuffer.clear();
     if (mSlots[slot].mBufferState == BufferSlot::ACQUIRED) {
         mSlots[slot].mNeedsCleanupOnRelease = true;
     }
-    if (mSlots[slot].mBufferState != BufferSlot::FREE) {
-        mFreeSlots.insert(slot);
-    } else if (hadBuffer) {
-        // If the slot was FREE, but we had a buffer, we need to move this slot
-        // from the free buffers list to the the free slots list
-        mFreeBuffers.remove(slot);
-        mFreeSlots.insert(slot);
-    }
     mSlots[slot].mBufferState = BufferSlot::FREE;
+    mSlots[slot].mFrameNumber = UINT32_MAX;
     mSlots[slot].mAcquireCalled = false;
-    mSlots[slot].mFrameNumber = 0;
 
     // Destroy fence as BufferQueue now takes ownership
     if (mSlots[slot].mEglFence != EGL_NO_SYNC_KHR) {
@@ -221,7 +203,6 @@ void BufferQueueCore::freeBufferLocked(int slot) {
         mSlots[slot].mEglFence = EGL_NO_SYNC_KHR;
     }
     mSlots[slot].mFence = Fence::NO_FENCE;
-    validateConsistencyLocked();
 }
 
 void BufferQueueCore::freeAllBuffersLocked() {
@@ -254,48 +235,4 @@ void BufferQueueCore::waitWhileAllocatingLocked() const {
     }
 }
 
-void BufferQueueCore::validateConsistencyLocked() const {
-    static const useconds_t PAUSE_TIME = 0;
-    for (int slot = 0; slot < BufferQueueDefs::NUM_BUFFER_SLOTS; ++slot) {
-        bool isInFreeSlots = mFreeSlots.count(slot) != 0;
-        bool isInFreeBuffers =
-                std::find(mFreeBuffers.cbegin(), mFreeBuffers.cend(), slot) !=
-                mFreeBuffers.cend();
-        if (mSlots[slot].mBufferState == BufferSlot::FREE) {
-            if (mSlots[slot].mGraphicBuffer == NULL) {
-                if (!isInFreeSlots) {
-                    BQ_LOGE("Slot %d is FREE but is not in mFreeSlots", slot);
-                    usleep(PAUSE_TIME);
-                }
-                if (isInFreeBuffers) {
-                    BQ_LOGE("Slot %d is in mFreeSlots "
-                            "but is also in mFreeBuffers", slot);
-                    usleep(PAUSE_TIME);
-                }
-            } else {
-                if (!isInFreeBuffers) {
-                    BQ_LOGE("Slot %d is FREE but is not in mFreeBuffers", slot);
-                    usleep(PAUSE_TIME);
-                }
-                if (isInFreeSlots) {
-                    BQ_LOGE("Slot %d is in mFreeBuffers "
-                            "but is also in mFreeSlots", slot);
-                    usleep(PAUSE_TIME);
-                }
-            }
-        } else {
-            if (isInFreeSlots) {
-                BQ_LOGE("Slot %d is in mFreeSlots but is not FREE (%d)",
-                        slot, mSlots[slot].mBufferState);
-                usleep(PAUSE_TIME);
-            }
-            if (isInFreeBuffers) {
-                BQ_LOGE("Slot %d is in mFreeBuffers but is not FREE (%d)",
-                        slot, mSlots[slot].mBufferState);
-                usleep(PAUSE_TIME);
-            }
-        }
-    }
-}
-
 } // namespace android
diff --git a/libs/gui/BufferQueueProducer.cpp b/libs/gui/BufferQueueProducer.cpp
index 87e5b4d..16b9747 100644
--- a/libs/gui/BufferQueueProducer.cpp
+++ b/libs/gui/BufferQueueProducer.cpp
@@ -161,6 +161,8 @@ status_t BufferQueueProducer::waitForFreeSlotThenRelock(const char* caller,
             }
         }
 
+        // Look for a free buffer to give to the client
+        *found = BufferQueueCore::INVALID_BUFFER_SLOT;
         int dequeuedCount = 0;
         int acquiredCount = 0;
         for (int s = 0; s < maxBufferCount; ++s) {
@@ -171,6 +173,15 @@ status_t BufferQueueProducer::waitForFreeSlotThenRelock(const char* caller,
                 case BufferSlot::ACQUIRED:
                     ++acquiredCount;
                     break;
+                case BufferSlot::FREE:
+                    // We return the oldest of the free buffers to avoid
+                    // stalling the producer if possible, since the consumer
+                    // may still have pending reads of in-flight buffers
+                    if (*found == BufferQueueCore::INVALID_BUFFER_SLOT ||
+                            mSlots[s].mFrameNumber < mSlots[*found].mFrameNumber) {
+                        *found = s;
+                    }
+                    break;
                 default:
                     break;
             }
@@ -203,8 +214,6 @@ status_t BufferQueueProducer::waitForFreeSlotThenRelock(const char* caller,
             }
         }
 
-        *found = BufferQueueCore::INVALID_BUFFER_SLOT;
-
         // If we disconnect and reconnect quickly, we can be in a state where
         // our slots are empty but we have many buffers in the queue. This can
         // cause us to run out of memory if we outrun the consumer. Wait here if
@@ -214,19 +223,6 @@ status_t BufferQueueProducer::waitForFreeSlotThenRelock(const char* caller,
         if (tooManyBuffers) {
             BQ_LOGV("%s: queue size is %zu, waiting", caller,
                     mCore->mQueue.size());
-        } else {
-            if (!mCore->mFreeBuffers.empty()) {
-                auto slot = mCore->mFreeBuffers.begin();
-                *found = *slot;
-                mCore->mFreeBuffers.erase(slot);
-            } else if (mCore->mAllowAllocation && !mCore->mFreeSlots.empty()) {
-                auto slot = mCore->mFreeSlots.begin();
-                // Only return free slots up to the max buffer count
-                if (*slot < maxBufferCount) {
-                    *found = *slot;
-                    mCore->mFreeSlots.erase(slot);
-                }
-            }
         }
 
         // If no buffer is found, or if the queue has too many buffers
@@ -254,7 +250,7 @@ status_t BufferQueueProducer::waitForFreeSlotThenRelock(const char* caller,
 
 status_t BufferQueueProducer::dequeueBuffer(int *outSlot,
         sp<android::Fence> *outFence, bool async,
-        uint32_t width, uint32_t height, PixelFormat format, uint32_t usage) {
+        uint32_t width, uint32_t height, uint32_t format, uint32_t usage) {
     ATRACE_CALL();
     { // Autolock scope
         Mutex::Autolock lock(mCore->mMutex);
@@ -285,39 +281,17 @@ status_t BufferQueueProducer::dequeueBuffer(int *outSlot,
         // Enable the usage bits the consumer requested
         usage |= mCore->mConsumerUsageBits;
 
-        const bool useDefaultSize = !width && !height;
-        if (useDefaultSize) {
-            width = mCore->mDefaultWidth;
-            height = mCore->mDefaultHeight;
+        int found;
+        status_t status = waitForFreeSlotThenRelock("dequeueBuffer", async,
+                &found, &returnFlags);
+        if (status != NO_ERROR) {
+            return status;
         }
 
-        int found = BufferItem::INVALID_BUFFER_SLOT;
-        while (found == BufferItem::INVALID_BUFFER_SLOT) {
-            status_t status = waitForFreeSlotThenRelock("dequeueBuffer", async,
-                    &found, &returnFlags);
-            if (status != NO_ERROR) {
-                return status;
-            }
-
-            // This should not happen
-            if (found == BufferQueueCore::INVALID_BUFFER_SLOT) {
-                BQ_LOGE("dequeueBuffer: no available buffer slots");
-                return -EBUSY;
-            }
-
-            const sp<GraphicBuffer>& buffer(mSlots[found].mGraphicBuffer);
-
-            // If we are not allowed to allocate new buffers,
-            // waitForFreeSlotThenRelock must have returned a slot containing a
-            // buffer. If this buffer would require reallocation to meet the
-            // requested attributes, we free it and attempt to get another one.
-            if (!mCore->mAllowAllocation) {
-                if (buffer->needsReallocation(width, height, format, usage)) {
-                    mCore->freeBufferLocked(found);
-                    found = BufferItem::INVALID_BUFFER_SLOT;
-                    continue;
-                }
-            }
+        // This should not happen
+        if (found == BufferQueueCore::INVALID_BUFFER_SLOT) {
+            BQ_LOGE("dequeueBuffer: no available buffer slots");
+            return -EBUSY;
         }
 
         *outSlot = found;
@@ -325,11 +299,20 @@ status_t BufferQueueProducer::dequeueBuffer(int *outSlot,
 
         attachedByConsumer = mSlots[found].mAttachedByConsumer;
 
+        const bool useDefaultSize = !width && !height;
+        if (useDefaultSize) {
+            width = mCore->mDefaultWidth;
+            height = mCore->mDefaultHeight;
+        }
+
         mSlots[found].mBufferState = BufferSlot::DEQUEUED;
 
         const sp<GraphicBuffer>& buffer(mSlots[found].mGraphicBuffer);
         if ((buffer == NULL) ||
-                buffer->needsReallocation(width, height, format, usage))
+                (static_cast<uint32_t>(buffer->width) != width) ||
+                (static_cast<uint32_t>(buffer->height) != height) ||
+                (static_cast<uint32_t>(buffer->format) != format) ||
+                ((static_cast<uint32_t>(buffer->usage) & usage) != usage))
         {
             mSlots[found].mAcquireCalled = false;
             mSlots[found].mGraphicBuffer = NULL;
@@ -337,19 +320,10 @@ status_t BufferQueueProducer::dequeueBuffer(int *outSlot,
             mSlots[found].mEglDisplay = EGL_NO_DISPLAY;
             mSlots[found].mEglFence = EGL_NO_SYNC_KHR;
             mSlots[found].mFence = Fence::NO_FENCE;
-            mCore->mBufferAge = 0;
 
             returnFlags |= BUFFER_NEEDS_REALLOCATION;
-        } else {
-            // We add 1 because that will be the frame number when this buffer
-            // is queued
-            mCore->mBufferAge =
-                    mCore->mFrameCounter + 1 - mSlots[found].mFrameNumber;
         }
 
-        BQ_LOGV("dequeueBuffer: setting buffer age to %" PRIu64,
-                mCore->mBufferAge);
-
         if (CC_UNLIKELY(mSlots[found].mFence == NULL)) {
             BQ_LOGE("dequeueBuffer: about to return a NULL fence - "
                     "slot=%d w=%d h=%d format=%u",
@@ -361,15 +335,13 @@ status_t BufferQueueProducer::dequeueBuffer(int *outSlot,
         *outFence = mSlots[found].mFence;
         mSlots[found].mEglFence = EGL_NO_SYNC_KHR;
         mSlots[found].mFence = Fence::NO_FENCE;
-
-        mCore->validateConsistencyLocked();
     } // Autolock scope
 
     if (returnFlags & BUFFER_NEEDS_REALLOCATION) {
         status_t error;
         BQ_LOGV("dequeueBuffer: allocating a new buffer for slot %d", *outSlot);
         sp<GraphicBuffer> graphicBuffer(mCore->mAllocator->createGraphicBuffer(
-                width, height, format, usage, &error));
+                    width, height, format, usage, &error));
         if (graphicBuffer == NULL) {
             BQ_LOGE("dequeueBuffer: createGraphicBuffer failed");
             return error;
@@ -383,7 +355,7 @@ status_t BufferQueueProducer::dequeueBuffer(int *outSlot,
                 return NO_INIT;
             }
 
-            graphicBuffer->setGenerationNumber(mCore->mGenerationNumber);
+            mSlots[*outSlot].mFrameNumber = UINT32_MAX;
             mSlots[*outSlot].mGraphicBuffer = graphicBuffer;
         } // Autolock scope
     }
@@ -442,7 +414,6 @@ status_t BufferQueueProducer::detachBuffer(int slot) {
 
     mCore->freeBufferLocked(slot);
     mCore->mDequeueCondition.broadcast();
-    mCore->validateConsistencyLocked();
 
     return NO_ERROR;
 }
@@ -467,19 +438,27 @@ status_t BufferQueueProducer::detachNextBuffer(sp<GraphicBuffer>* outBuffer,
         return NO_INIT;
     }
 
-    if (mCore->mFreeBuffers.empty()) {
-        return NO_MEMORY;
+    // Find the oldest valid slot
+    int found = BufferQueueCore::INVALID_BUFFER_SLOT;
+    for (int s = 0; s < BufferQueueDefs::NUM_BUFFER_SLOTS; ++s) {
+        if (mSlots[s].mBufferState == BufferSlot::FREE &&
+                mSlots[s].mGraphicBuffer != NULL) {
+            if (found == BufferQueueCore::INVALID_BUFFER_SLOT ||
+                    mSlots[s].mFrameNumber < mSlots[found].mFrameNumber) {
+                found = s;
+            }
+        }
     }
 
-    int found = mCore->mFreeBuffers.front();
-    mCore->mFreeBuffers.remove(found);
+    if (found == BufferQueueCore::INVALID_BUFFER_SLOT) {
+        return NO_MEMORY;
+    }
 
     BQ_LOGV("detachNextBuffer detached slot %d", found);
 
     *outBuffer = mSlots[found].mGraphicBuffer;
     *outFence = mSlots[found].mFence;
     mCore->freeBufferLocked(found);
-    mCore->validateConsistencyLocked();
 
     return NO_ERROR;
 }
@@ -499,13 +478,6 @@ status_t BufferQueueProducer::attachBuffer(int* outSlot,
     Mutex::Autolock lock(mCore->mMutex);
     mCore->waitWhileAllocatingLocked();
 
-    if (buffer->getGenerationNumber() != mCore->mGenerationNumber) {
-        BQ_LOGE("attachBuffer: generation number mismatch [buffer %u] "
-                "[queue %u]", buffer->getGenerationNumber(),
-                mCore->mGenerationNumber);
-        return BAD_VALUE;
-    }
-
     status_t returnFlags = NO_ERROR;
     int found;
     // TODO: Should we provide an async flag to attachBuffer? It seems
@@ -534,8 +506,6 @@ status_t BufferQueueProducer::attachBuffer(int* outSlot,
     mSlots[*outSlot].mFence = Fence::NO_FENCE;
     mSlots[*outSlot].mRequestBufferCalled = true;
 
-    mCore->validateConsistencyLocked();
-
     return returnFlags;
 }
 
@@ -546,16 +516,14 @@ status_t BufferQueueProducer::queueBuffer(int slot,
 
     int64_t timestamp;
     bool isAutoTimestamp;
-    android_dataspace dataSpace;
     Rect crop;
     int scalingMode;
     uint32_t transform;
     uint32_t stickyTransform;
     bool async;
     sp<Fence> fence;
-    input.deflate(&timestamp, &isAutoTimestamp, &dataSpace, &crop, &scalingMode,
-            &transform, &async, &fence, &stickyTransform);
-    Region surfaceDamage = input.getSurfaceDamage();
+    input.deflate(&timestamp, &isAutoTimestamp, &crop, &scalingMode, &transform,
+            &async, &fence, &stickyTransform);
 
     if (fence == NULL) {
         BQ_LOGE("queueBuffer: fence is NULL");
@@ -611,11 +579,11 @@ status_t BufferQueueProducer::queueBuffer(int slot,
             return BAD_VALUE;
         }
 
-        BQ_LOGV("queueBuffer: slot=%d/%" PRIu64 " time=%" PRIu64 " dataSpace=%d"
+        BQ_LOGV("queueBuffer: slot=%d/%" PRIu64 " time=%" PRIu64
                 " crop=[%d,%d,%d,%d] transform=%#x scale=%s",
-                slot, mCore->mFrameCounter + 1, timestamp, dataSpace,
-                crop.left, crop.top, crop.right, crop.bottom, transform,
-                BufferItem::scalingModeName(static_cast<uint32_t>(scalingMode)));
+                slot, mCore->mFrameCounter + 1, timestamp,
+                crop.left, crop.top, crop.right, crop.bottom,
+                transform, BufferItem::scalingModeName(scalingMode));
 
         const sp<GraphicBuffer>& graphicBuffer(mSlots[slot].mGraphicBuffer);
         Rect bufferRect(graphicBuffer->getWidth(), graphicBuffer->getHeight());
@@ -627,11 +595,6 @@ status_t BufferQueueProducer::queueBuffer(int slot,
             return BAD_VALUE;
         }
 
-        // Override UNKNOWN dataspace with consumer default
-        if (dataSpace == HAL_DATASPACE_UNKNOWN) {
-            dataSpace = mCore->mDefaultBufferDataSpace;
-        }
-
         mSlots[slot].mFence = fence;
         mSlots[slot].mBufferState = BufferSlot::QUEUED;
         ++mCore->mFrameCounter;
@@ -640,19 +603,16 @@ status_t BufferQueueProducer::queueBuffer(int slot,
         item.mAcquireCalled = mSlots[slot].mAcquireCalled;
         item.mGraphicBuffer = mSlots[slot].mGraphicBuffer;
         item.mCrop = crop;
-        item.mTransform = transform &
-                ~static_cast<uint32_t>(NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);
+        item.mTransform = transform & ~NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY;
         item.mTransformToDisplayInverse =
-                (transform & NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY) != 0;
-        item.mScalingMode = static_cast<uint32_t>(scalingMode);
+                bool(transform & NATIVE_WINDOW_TRANSFORM_INVERSE_DISPLAY);
+        item.mScalingMode = scalingMode;
         item.mTimestamp = timestamp;
         item.mIsAutoTimestamp = isAutoTimestamp;
-        item.mDataSpace = dataSpace;
         item.mFrameNumber = mCore->mFrameCounter;
         item.mSlot = slot;
         item.mFence = fence;
         item.mIsDroppable = mCore->mDequeueBufferCannotBlock || async;
-        item.mSurfaceDamage = surfaceDamage;
 
         mStickyTransform = stickyTransform;
 
@@ -670,7 +630,9 @@ status_t BufferQueueProducer::queueBuffer(int slot,
                 // mark it as freed
                 if (mCore->stillTracking(front)) {
                     mSlots[front->mSlot].mBufferState = BufferSlot::FREE;
-                    mCore->mFreeBuffers.push_front(front->mSlot);
+                    // Reset the frame number of the freed buffer so that it is
+                    // the first in line to be dequeued again
+                    mSlots[front->mSlot].mFrameNumber = 0;
                 }
                 // Overwrite the droppable buffer with the incoming one
                 *front = item;
@@ -685,15 +647,12 @@ status_t BufferQueueProducer::queueBuffer(int slot,
         mCore->mDequeueCondition.broadcast();
 
         output->inflate(mCore->mDefaultWidth, mCore->mDefaultHeight,
-                mCore->mTransformHint,
-                static_cast<uint32_t>(mCore->mQueue.size()));
+                mCore->mTransformHint, mCore->mQueue.size());
 
         ATRACE_INT(mCore->mConsumerName.string(), mCore->mQueue.size());
 
         // Take a ticket for the callback functions
         callbackTicket = mNextCallbackTicket++;
-
-        mCore->validateConsistencyLocked();
     } // Autolock scope
 
     // Wait without lock held
@@ -754,11 +713,10 @@ void BufferQueueProducer::cancelBuffer(int slot, const sp<Fence>& fence) {
         return;
     }
 
-    mCore->mFreeBuffers.push_front(slot);
     mSlots[slot].mBufferState = BufferSlot::FREE;
+    mSlots[slot].mFrameNumber = 0;
     mSlots[slot].mFence = fence;
     mCore->mDequeueCondition.broadcast();
-    mCore->validateConsistencyLocked();
 }
 
 int BufferQueueProducer::query(int what, int *outValue) {
@@ -778,35 +736,25 @@ int BufferQueueProducer::query(int what, int *outValue) {
     int value;
     switch (what) {
         case NATIVE_WINDOW_WIDTH:
-            value = static_cast<int32_t>(mCore->mDefaultWidth);
+            value = mCore->mDefaultWidth;
             break;
         case NATIVE_WINDOW_HEIGHT:
-            value = static_cast<int32_t>(mCore->mDefaultHeight);
+            value = mCore->mDefaultHeight;
             break;
         case NATIVE_WINDOW_FORMAT:
-            value = static_cast<int32_t>(mCore->mDefaultBufferFormat);
+            value = mCore->mDefaultBufferFormat;
             break;
         case NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS:
             value = mCore->getMinUndequeuedBufferCountLocked(false);
             break;
         case NATIVE_WINDOW_STICKY_TRANSFORM:
-            value = static_cast<int32_t>(mStickyTransform);
+            value = static_cast<int>(mStickyTransform);
             break;
         case NATIVE_WINDOW_CONSUMER_RUNNING_BEHIND:
             value = (mCore->mQueue.size() > 1);
             break;
         case NATIVE_WINDOW_CONSUMER_USAGE_BITS:
-            value = static_cast<int32_t>(mCore->mConsumerUsageBits);
-            break;
-        case NATIVE_WINDOW_DEFAULT_DATASPACE:
-            value = static_cast<int32_t>(mCore->mDefaultBufferDataSpace);
-            break;
-        case NATIVE_WINDOW_BUFFER_AGE:
-            if (mCore->mBufferAge > INT32_MAX) {
-                value = 0;
-            } else {
-                value = static_cast<int32_t>(mCore->mBufferAge);
-            }
+            value = mCore->mConsumerUsageBits;
             break;
         default:
             return BAD_VALUE;
@@ -854,14 +802,13 @@ status_t BufferQueueProducer::connect(const sp<IProducerListener>& listener,
         case NATIVE_WINDOW_API_CAMERA:
             mCore->mConnectedApi = api;
             output->inflate(mCore->mDefaultWidth, mCore->mDefaultHeight,
-                    mCore->mTransformHint,
-                    static_cast<uint32_t>(mCore->mQueue.size()));
+                    mCore->mTransformHint, mCore->mQueue.size());
 
             // Set up a death notification so that we can disconnect
             // automatically if the remote producer dies
             if (listener != NULL &&
-                    IInterface::asBinder(listener)->remoteBinder() != NULL) {
-                status = IInterface::asBinder(listener)->linkToDeath(
+                    listener->asBinder()->remoteBinder() != NULL) {
+                status = listener->asBinder()->linkToDeath(
                         static_cast<IBinder::DeathRecipient*>(this));
                 if (status != NO_ERROR) {
                     BQ_LOGE("connect(P): linkToDeath failed: %s (%d)",
@@ -879,7 +826,6 @@ status_t BufferQueueProducer::connect(const sp<IProducerListener>& listener,
     mCore->mBufferHasBeenQueued = false;
     mCore->mDequeueBufferCannotBlock =
             mCore->mConsumerControlledByApp && producerControlledByApp;
-    mCore->mAllowAllocation = true;
 
     return status;
 }
@@ -911,7 +857,7 @@ status_t BufferQueueProducer::disconnect(int api) {
                     // Remove our death notification callback if we have one
                     if (mCore->mConnectedProducerListener != NULL) {
                         sp<IBinder> token =
-                                IInterface::asBinder(mCore->mConnectedProducerListener);
+                                mCore->mConnectedProducerListener->asBinder();
                         // This can fail if we're here because of the death
                         // notification, but we just ignore it
                         token->unlinkToDeath(
@@ -922,8 +868,8 @@ status_t BufferQueueProducer::disconnect(int api) {
                     mCore->mSidebandStream.clear();
                     mCore->mDequeueCondition.broadcast();
                     listener = mCore->mConsumerListener;
-                } else if (mCore->mConnectedApi != BufferQueueCore::NO_CONNECTED_API) {
-                    BQ_LOGE("disconnect(P): still connected to another API "
+                } else {
+                    BQ_LOGE("disconnect(P): connected to another API "
                             "(cur=%d req=%d)", mCore->mConnectedApi, api);
                     status = BAD_VALUE;
                 }
@@ -958,25 +904,19 @@ status_t BufferQueueProducer::setSidebandStream(const sp<NativeHandle>& stream)
 }
 
 void BufferQueueProducer::allocateBuffers(bool async, uint32_t width,
-        uint32_t height, PixelFormat format, uint32_t usage) {
+        uint32_t height, uint32_t format, uint32_t usage) {
     ATRACE_CALL();
     while (true) {
         Vector<int> freeSlots;
         size_t newBufferCount = 0;
         uint32_t allocWidth = 0;
         uint32_t allocHeight = 0;
-        PixelFormat allocFormat = PIXEL_FORMAT_UNKNOWN;
+        uint32_t allocFormat = 0;
         uint32_t allocUsage = 0;
         { // Autolock scope
             Mutex::Autolock lock(mCore->mMutex);
             mCore->waitWhileAllocatingLocked();
 
-            if (!mCore->mAllowAllocation) {
-                BQ_LOGE("allocateBuffers: allocation is not allowed for this "
-                        "BufferQueue");
-                return;
-            }
-
             int currentBufferCount = 0;
             for (int slot = 0; slot < BufferQueueDefs::NUM_BUFFER_SLOTS; ++slot) {
                 if (mSlots[slot].mGraphicBuffer != NULL) {
@@ -997,8 +937,7 @@ void BufferQueueProducer::allocateBuffers(bool async, uint32_t width,
                     currentBufferCount, maxBufferCount);
             if (maxBufferCount <= currentBufferCount)
                 return;
-            newBufferCount =
-                    static_cast<size_t>(maxBufferCount - currentBufferCount);
+            newBufferCount = maxBufferCount - currentBufferCount;
             if (freeSlots.size() < newBufferCount) {
                 BQ_LOGE("allocateBuffers: ran out of free slots");
                 return;
@@ -1011,7 +950,7 @@ void BufferQueueProducer::allocateBuffers(bool async, uint32_t width,
             mCore->mIsAllocating = true;
         } // Autolock scope
 
-        Vector<sp<GraphicBuffer>> buffers;
+        Vector<sp<GraphicBuffer> > buffers;
         for (size_t i = 0; i <  newBufferCount; ++i) {
             status_t result = NO_ERROR;
             sp<GraphicBuffer> graphicBuffer(mCore->mAllocator->createGraphicBuffer(
@@ -1031,8 +970,7 @@ void BufferQueueProducer::allocateBuffers(bool async, uint32_t width,
             Mutex::Autolock lock(mCore->mMutex);
             uint32_t checkWidth = width > 0 ? width : mCore->mDefaultWidth;
             uint32_t checkHeight = height > 0 ? height : mCore->mDefaultHeight;
-            PixelFormat checkFormat = format != 0 ?
-                    format : mCore->mDefaultBufferFormat;
+            uint32_t checkFormat = format != 0 ? format : mCore->mDefaultBufferFormat;
             uint32_t checkUsage = usage | mCore->mConsumerUsageBits;
             if (checkWidth != allocWidth || checkHeight != allocHeight ||
                 checkFormat != allocFormat || checkUsage != allocUsage) {
@@ -1054,47 +992,17 @@ void BufferQueueProducer::allocateBuffers(bool async, uint32_t width,
                 }
                 mCore->freeBufferLocked(slot); // Clean up the slot first
                 mSlots[slot].mGraphicBuffer = buffers[i];
+                mSlots[slot].mFrameNumber = 0;
                 mSlots[slot].mFence = Fence::NO_FENCE;
-
-                // freeBufferLocked puts this slot on the free slots list. Since
-                // we then attached a buffer, move the slot to free buffer list.
-                mCore->mFreeSlots.erase(slot);
-                mCore->mFreeBuffers.push_front(slot);
-
                 BQ_LOGV("allocateBuffers: allocated a new buffer in slot %d", slot);
             }
 
             mCore->mIsAllocating = false;
             mCore->mIsAllocatingCondition.broadcast();
-            mCore->validateConsistencyLocked();
         } // Autolock scope
     }
 }
 
-status_t BufferQueueProducer::allowAllocation(bool allow) {
-    ATRACE_CALL();
-    BQ_LOGV("allowAllocation: %s", allow ? "true" : "false");
-
-    Mutex::Autolock lock(mCore->mMutex);
-    mCore->mAllowAllocation = allow;
-    return NO_ERROR;
-}
-
-status_t BufferQueueProducer::setGenerationNumber(uint32_t generationNumber) {
-    ATRACE_CALL();
-    BQ_LOGV("setGenerationNumber: %u", generationNumber);
-
-    Mutex::Autolock lock(mCore->mMutex);
-    mCore->mGenerationNumber = generationNumber;
-    return NO_ERROR;
-}
-
-String8 BufferQueueProducer::getConsumerName() const {
-    ATRACE_CALL();
-    BQ_LOGV("getConsumerName: %s", mConsumerName.string());
-    return mConsumerName;
-}
-
 void BufferQueueProducer::binderDied(const wp<android::IBinder>& /* who */) {
     // If we're here, it means that a producer we were connected to died.
     // We're guaranteed that we are still connected to it because we remove
diff --git a/libs/gui/BufferSlot.cpp b/libs/gui/BufferSlot.cpp
index 01595de..b8877fe 100644
--- a/libs/gui/BufferSlot.cpp
+++ b/libs/gui/BufferSlot.cpp
@@ -24,8 +24,8 @@ const char* BufferSlot::bufferStateName(BufferState state) {
         case BufferSlot::QUEUED: return "QUEUED";
         case BufferSlot::FREE: return "FREE";
         case BufferSlot::ACQUIRED: return "ACQUIRED";
+        default: return "Unknown";
     }
-    return "Unknown";
 }
 
 } // namespace android
diff --git a/libs/gui/ConsumerBase.cpp b/libs/gui/ConsumerBase.cpp
index 04ab06b..210e98e 100644
--- a/libs/gui/ConsumerBase.cpp
+++ b/libs/gui/ConsumerBase.cpp
@@ -27,7 +27,6 @@
 
 #include <hardware/hardware.h>
 
-#include <gui/BufferItem.h>
 #include <gui/IGraphicBufferAlloc.h>
 #include <gui/ISurfaceComposer.h>
 #include <gui/SurfaceComposerClient.h>
@@ -40,11 +39,11 @@
 #include <utils/Trace.h>
 
 // Macros for including the ConsumerBase name in log messages
-#define CB_LOGV(x, ...) ALOGV("[%s] " x, mName.string(), ##__VA_ARGS__)
-//#define CB_LOGD(x, ...) ALOGD("[%s] " x, mName.string(), ##__VA_ARGS__)
-//#define CB_LOGI(x, ...) ALOGI("[%s] " x, mName.string(), ##__VA_ARGS__)
-//#define CB_LOGW(x, ...) ALOGW("[%s] " x, mName.string(), ##__VA_ARGS__)
-#define CB_LOGE(x, ...) ALOGE("[%s] " x, mName.string(), ##__VA_ARGS__)
+#define CB_LOGV(x, ...) ALOGV("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define CB_LOGD(x, ...) ALOGD("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define CB_LOGI(x, ...) ALOGI("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define CB_LOGW(x, ...) ALOGW("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define CB_LOGE(x, ...) ALOGE("[%s] "x, mName.string(), ##__VA_ARGS__)
 
 namespace android {
 
@@ -114,21 +113,6 @@ void ConsumerBase::onFrameAvailable(const BufferItem& item) {
     }
 }
 
-void ConsumerBase::onFrameReplaced(const BufferItem &item) {
-    CB_LOGV("onFrameReplaced");
-
-    sp<FrameAvailableListener> listener;
-    {
-        Mutex::Autolock lock(mMutex);
-        listener = mFrameAvailableListener.promote();
-    }
-
-    if (listener != NULL) {
-        CB_LOGV("actually calling onFrameReplaced");
-        listener->onFrameReplaced(item);
-    }
-}
-
 void ConsumerBase::onBuffersReleased() {
     Mutex::Autolock lock(mMutex);
 
@@ -171,11 +155,6 @@ void ConsumerBase::abandonLocked() {
     mConsumer.clear();
 }
 
-bool ConsumerBase::isAbandoned() {
-    Mutex::Autolock _l(mMutex);
-    return mAbandoned;
-}
-
 void ConsumerBase::setFrameAvailableListener(
         const wp<FrameAvailableListener>& listener) {
     CB_LOGV("setFrameAvailableListener");
@@ -183,37 +162,6 @@ void ConsumerBase::setFrameAvailableListener(
     mFrameAvailableListener = listener;
 }
 
-status_t ConsumerBase::detachBuffer(int slot) {
-    CB_LOGV("detachBuffer");
-    Mutex::Autolock lock(mMutex);
-
-    status_t result = mConsumer->detachBuffer(slot);
-    if (result != NO_ERROR) {
-        CB_LOGE("Failed to detach buffer: %d", result);
-        return result;
-    }
-
-    freeBufferLocked(slot);
-
-    return result;
-}
-
-status_t ConsumerBase::setDefaultBufferSize(uint32_t width, uint32_t height) {
-    Mutex::Autolock _l(mMutex);
-    return mConsumer->setDefaultBufferSize(width, height);
-}
-
-status_t ConsumerBase::setDefaultBufferFormat(PixelFormat defaultFormat) {
-    Mutex::Autolock _l(mMutex);
-    return mConsumer->setDefaultBufferFormat(defaultFormat);
-}
-
-status_t ConsumerBase::setDefaultBufferDataSpace(
-        android_dataspace defaultDataSpace) {
-    Mutex::Autolock _l(mMutex);
-    return mConsumer->setDefaultBufferDataSpace(defaultDataSpace);
-}
-
 void ConsumerBase::dump(String8& result) const {
     dump(result, "");
 }
@@ -231,9 +179,9 @@ void ConsumerBase::dumpLocked(String8& result, const char* prefix) const {
     }
 }
 
-status_t ConsumerBase::acquireBufferLocked(BufferItem *item,
-        nsecs_t presentWhen, uint64_t maxFrameNumber) {
-    status_t err = mConsumer->acquireBuffer(item, presentWhen, maxFrameNumber);
+status_t ConsumerBase::acquireBufferLocked(BufferQueue::BufferItem *item,
+        nsecs_t presentWhen) {
+    status_t err = mConsumer->acquireBuffer(item, presentWhen);
     if (err != NO_ERROR) {
         return err;
     }
diff --git a/libs/gui/CpuConsumer.cpp b/libs/gui/CpuConsumer.cpp
index e29b740..c541ff4 100644
--- a/libs/gui/CpuConsumer.cpp
+++ b/libs/gui/CpuConsumer.cpp
@@ -16,23 +16,22 @@
 
 //#define LOG_NDEBUG 0
 #define LOG_TAG "CpuConsumer"
-//#define ATRACE_TAG ATRACE_TAG_GRAPHICS
+#define ATRACE_TAG ATRACE_TAG_GRAPHICS
 
 #include <cutils/compiler.h>
 #include <utils/Log.h>
-#include <gui/BufferItem.h>
 #include <gui/CpuConsumer.h>
 
-#define CC_LOGV(x, ...) ALOGV("[%s] " x, mName.string(), ##__VA_ARGS__)
-//#define CC_LOGD(x, ...) ALOGD("[%s] " x, mName.string(), ##__VA_ARGS__)
-//#define CC_LOGI(x, ...) ALOGI("[%s] " x, mName.string(), ##__VA_ARGS__)
-#define CC_LOGW(x, ...) ALOGW("[%s] " x, mName.string(), ##__VA_ARGS__)
-#define CC_LOGE(x, ...) ALOGE("[%s] " x, mName.string(), ##__VA_ARGS__)
+#define CC_LOGV(x, ...) ALOGV("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define CC_LOGD(x, ...) ALOGD("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define CC_LOGI(x, ...) ALOGI("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define CC_LOGW(x, ...) ALOGW("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define CC_LOGE(x, ...) ALOGE("[%s] "x, mName.string(), ##__VA_ARGS__)
 
 namespace android {
 
 CpuConsumer::CpuConsumer(const sp<IGraphicBufferConsumer>& bq,
-        size_t maxLockedBuffers, bool controlledByApp) :
+        uint32_t maxLockedBuffers, bool controlledByApp) :
     ConsumerBase(bq, controlledByApp),
     mMaxLockedBuffers(maxLockedBuffers),
     mCurrentLockedBuffers(0)
@@ -41,7 +40,7 @@ CpuConsumer::CpuConsumer(const sp<IGraphicBufferConsumer>& bq,
     mAcquiredBuffers.insertAt(0, maxLockedBuffers);
 
     mConsumer->setConsumerUsageBits(GRALLOC_USAGE_SW_READ_OFTEN);
-    mConsumer->setMaxAcquiredBufferCount(static_cast<int32_t>(maxLockedBuffers));
+    mConsumer->setMaxAcquiredBufferCount(maxLockedBuffers);
 }
 
 CpuConsumer::~CpuConsumer() {
@@ -56,16 +55,30 @@ void CpuConsumer::setName(const String8& name) {
     mConsumer->setConsumerName(name);
 }
 
+status_t CpuConsumer::setDefaultBufferSize(uint32_t width, uint32_t height)
+{
+    Mutex::Autolock _l(mMutex);
+    return mConsumer->setDefaultBufferSize(width, height);
+}
+
+status_t CpuConsumer::setDefaultBufferFormat(uint32_t defaultFormat)
+{
+    Mutex::Autolock _l(mMutex);
+    return mConsumer->setDefaultBufferFormat(defaultFormat);
+}
+
 static bool isPossiblyYUV(PixelFormat format) {
-    switch (static_cast<int>(format)) {
+    switch ((int)format) {
         case HAL_PIXEL_FORMAT_RGBA_8888:
         case HAL_PIXEL_FORMAT_RGBX_8888:
         case HAL_PIXEL_FORMAT_RGB_888:
         case HAL_PIXEL_FORMAT_RGB_565:
         case HAL_PIXEL_FORMAT_BGRA_8888:
+        case HAL_PIXEL_FORMAT_sRGB_A_8888:
+        case HAL_PIXEL_FORMAT_sRGB_X_8888:
         case HAL_PIXEL_FORMAT_Y8:
         case HAL_PIXEL_FORMAT_Y16:
-        case HAL_PIXEL_FORMAT_RAW16:
+        case HAL_PIXEL_FORMAT_RAW16: // same as HAL_PIXEL_FORMAT_RAW_SENSOR
         case HAL_PIXEL_FORMAT_RAW10:
         case HAL_PIXEL_FORMAT_RAW_OPAQUE:
         case HAL_PIXEL_FORMAT_BLOB:
@@ -87,12 +100,12 @@ status_t CpuConsumer::lockNextBuffer(LockedBuffer *nativeBuffer) {
 
     if (!nativeBuffer) return BAD_VALUE;
     if (mCurrentLockedBuffers == mMaxLockedBuffers) {
-        CC_LOGW("Max buffers have been locked (%zd), cannot lock anymore.",
+        CC_LOGW("Max buffers have been locked (%d), cannot lock anymore.",
                 mMaxLockedBuffers);
         return NOT_ENOUGH_DATA;
     }
 
-    BufferItem b;
+    BufferQueue::BufferItem b;
 
     Mutex::Autolock _l(mMutex);
 
@@ -160,7 +173,7 @@ status_t CpuConsumer::lockNextBuffer(LockedBuffer *nativeBuffer) {
     }
 
     size_t lockedIdx = 0;
-    for (; lockedIdx < static_cast<size_t>(mMaxLockedBuffers); lockedIdx++) {
+    for (; lockedIdx < mMaxLockedBuffers; lockedIdx++) {
         if (mAcquiredBuffers[lockedIdx].mSlot ==
                 BufferQueue::INVALID_BUFFER_SLOT) {
             break;
@@ -180,20 +193,19 @@ status_t CpuConsumer::lockNextBuffer(LockedBuffer *nativeBuffer) {
     nativeBuffer->format = format;
     nativeBuffer->flexFormat = flexFormat;
     nativeBuffer->stride = (ycbcr.y != NULL) ?
-            static_cast<uint32_t>(ycbcr.ystride) :
+            ycbcr.ystride :
             mSlots[buf].mGraphicBuffer->getStride();
 
     nativeBuffer->crop        = b.mCrop;
     nativeBuffer->transform   = b.mTransform;
     nativeBuffer->scalingMode = b.mScalingMode;
     nativeBuffer->timestamp   = b.mTimestamp;
-    nativeBuffer->dataSpace   = b.mDataSpace;
     nativeBuffer->frameNumber = b.mFrameNumber;
 
     nativeBuffer->dataCb       = reinterpret_cast<uint8_t*>(ycbcr.cb);
     nativeBuffer->dataCr       = reinterpret_cast<uint8_t*>(ycbcr.cr);
-    nativeBuffer->chromaStride = static_cast<uint32_t>(ycbcr.cstride);
-    nativeBuffer->chromaStep   = static_cast<uint32_t>(ycbcr.chroma_step);
+    nativeBuffer->chromaStride = ycbcr.cstride;
+    nativeBuffer->chromaStep   = ycbcr.chroma_step;
 
     mCurrentLockedBuffers++;
 
@@ -203,9 +215,10 @@ status_t CpuConsumer::lockNextBuffer(LockedBuffer *nativeBuffer) {
 status_t CpuConsumer::unlockBuffer(const LockedBuffer &nativeBuffer) {
     Mutex::Autolock _l(mMutex);
     size_t lockedIdx = 0;
+    status_t err;
 
     void *bufPtr = reinterpret_cast<void *>(nativeBuffer.data);
-    for (; lockedIdx < static_cast<size_t>(mMaxLockedBuffers); lockedIdx++) {
+    for (; lockedIdx < mMaxLockedBuffers; lockedIdx++) {
         if (bufPtr == mAcquiredBuffers[lockedIdx].mBufferPointer) break;
     }
     if (lockedIdx == mMaxLockedBuffers) {
@@ -216,13 +229,13 @@ status_t CpuConsumer::unlockBuffer(const LockedBuffer &nativeBuffer) {
     return releaseAcquiredBufferLocked(lockedIdx);
 }
 
-status_t CpuConsumer::releaseAcquiredBufferLocked(size_t lockedIdx) {
+status_t CpuConsumer::releaseAcquiredBufferLocked(int lockedIdx) {
     status_t err;
     int fd = -1;
 
     err = mAcquiredBuffers[lockedIdx].mGraphicBuffer->unlockAsync(&fd);
     if (err != OK) {
-        CC_LOGE("%s: Unable to unlock graphic buffer %zd", __FUNCTION__,
+        CC_LOGE("%s: Unable to unlock graphic buffer %d", __FUNCTION__,
                 lockedIdx);
         return err;
     }
diff --git a/libs/gui/GLConsumer.cpp b/libs/gui/GLConsumer.cpp
index 757e08a..318c087 100644
--- a/libs/gui/GLConsumer.cpp
+++ b/libs/gui/GLConsumer.cpp
@@ -29,7 +29,6 @@
 
 #include <hardware/hardware.h>
 
-#include <gui/BufferItem.h>
 #include <gui/GLConsumer.h>
 #include <gui/IGraphicBufferAlloc.h>
 #include <gui/ISurfaceComposer.h>
@@ -48,28 +47,18 @@ EGLAPI const char* eglQueryStringImplementationANDROID(EGLDisplay dpy, EGLint na
 namespace android {
 
 // Macros for including the GLConsumer name in log messages
-#define GLC_LOGV(x, ...) ALOGV("[%s] " x, mName.string(), ##__VA_ARGS__)
-#define GLC_LOGD(x, ...) ALOGD("[%s] " x, mName.string(), ##__VA_ARGS__)
-//#define GLC_LOGI(x, ...) ALOGI("[%s] " x, mName.string(), ##__VA_ARGS__)
-#define GLC_LOGW(x, ...) ALOGW("[%s] " x, mName.string(), ##__VA_ARGS__)
-#define GLC_LOGE(x, ...) ALOGE("[%s] " x, mName.string(), ##__VA_ARGS__)
+#define ST_LOGV(x, ...) ALOGV("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define ST_LOGD(x, ...) ALOGD("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define ST_LOGI(x, ...) ALOGI("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define ST_LOGW(x, ...) ALOGW("[%s] "x, mName.string(), ##__VA_ARGS__)
+#define ST_LOGE(x, ...) ALOGE("[%s] "x, mName.string(), ##__VA_ARGS__)
 
 static const struct {
-    uint32_t width, height;
+    size_t width, height;
     char const* bits;
 } kDebugData = { 15, 12,
-    "_______________"
-    "_______________"
-    "_____XX_XX_____"
-    "__X_X_____X_X__"
-    "__X_XXXXXXX_X__"
-    "__XXXXXXXXXXX__"
-    "___XX_XXX_XX___"
-    "____XXXXXXX____"
-    "_____X___X_____"
-    "____X_____X____"
-    "_______________"
-    "_______________"
+    "___________________________________XX_XX_______X_X_____X_X____X_XXXXXXX_X____XXXXXXXXXXX__"
+    "___XX_XXX_XX_______XXXXXXX_________X___X_________X_____X__________________________________"
 };
 
 // Transform matrices
@@ -146,7 +135,7 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex,
     mCurrentTexture(BufferQueue::INVALID_BUFFER_SLOT),
     mAttached(true)
 {
-    GLC_LOGV("GLConsumer");
+    ST_LOGV("GLConsumer");
 
     memcpy(mCurrentTransformMatrix, mtxIdentity,
             sizeof(mCurrentTransformMatrix));
@@ -165,7 +154,7 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t texTarget,
     mDefaultWidth(1),
     mDefaultHeight(1),
     mFilteringEnabled(true),
-    mTexName(0),
+    mTexName(-1),
     mUseFenceSync(useFenceSync),
     mTexTarget(texTarget),
     mEglDisplay(EGL_NO_DISPLAY),
@@ -173,7 +162,7 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t texTarget,
     mCurrentTexture(BufferQueue::INVALID_BUFFER_SLOT),
     mAttached(false)
 {
-    GLC_LOGV("GLConsumer");
+    ST_LOGV("GLConsumer");
 
     memcpy(mCurrentTransformMatrix, mtxIdentity,
             sizeof(mCurrentTransformMatrix));
@@ -197,11 +186,11 @@ status_t GLConsumer::setDefaultBufferSize(uint32_t w, uint32_t h)
 
 status_t GLConsumer::updateTexImage() {
     ATRACE_CALL();
-    GLC_LOGV("updateTexImage");
+    ST_LOGV("updateTexImage");
     Mutex::Autolock lock(mMutex);
 
     if (mAbandoned) {
-        GLC_LOGE("updateTexImage: GLConsumer is abandoned!");
+        ST_LOGE("updateTexImage: GLConsumer is abandoned!");
         return NO_INIT;
     }
 
@@ -211,7 +200,7 @@ status_t GLConsumer::updateTexImage() {
         return err;
     }
 
-    BufferItem item;
+    BufferQueue::BufferItem item;
 
     // Acquire the next buffer.
     // In asynchronous mode the list is guaranteed to be one buffer
@@ -220,11 +209,11 @@ status_t GLConsumer::updateTexImage() {
     if (err != NO_ERROR) {
         if (err == BufferQueue::NO_BUFFER_AVAILABLE) {
             // We always bind the texture even if we don't update its contents.
-            GLC_LOGV("updateTexImage: no buffers were available");
+            ST_LOGV("updateTexImage: no buffers were available");
             glBindTexture(mTexTarget, mTexName);
             err = NO_ERROR;
         } else {
-            GLC_LOGE("updateTexImage: acquire failed: %s (%d)",
+            ST_LOGE("updateTexImage: acquire failed: %s (%d)",
                 strerror(-err), err);
         }
         return err;
@@ -245,11 +234,11 @@ status_t GLConsumer::updateTexImage() {
 
 status_t GLConsumer::releaseTexImage() {
     ATRACE_CALL();
-    GLC_LOGV("releaseTexImage");
+    ST_LOGV("releaseTexImage");
     Mutex::Autolock lock(mMutex);
 
     if (mAbandoned) {
-        GLC_LOGE("releaseTexImage: GLConsumer is abandoned!");
+        ST_LOGE("releaseTexImage: GLConsumer is abandoned!");
         return NO_INIT;
     }
 
@@ -269,13 +258,13 @@ status_t GLConsumer::releaseTexImage() {
     int buf = mCurrentTexture;
     if (buf != BufferQueue::INVALID_BUFFER_SLOT) {
 
-        GLC_LOGV("releaseTexImage: (slot=%d, mAttached=%d)", buf, mAttached);
+        ST_LOGV("releaseTexImage: (slot=%d, mAttached=%d)", buf, mAttached);
 
         if (mAttached) {
             // Do whatever sync ops we need to do before releasing the slot.
             err = syncForReleaseLocked(mEglDisplay);
             if (err != NO_ERROR) {
-                GLC_LOGE("syncForReleaseLocked failed (slot=%d), err=%d", buf, err);
+                ST_LOGE("syncForReleaseLocked failed (slot=%d), err=%d", buf, err);
                 return err;
             }
         } else {
@@ -285,7 +274,7 @@ status_t GLConsumer::releaseTexImage() {
 
         err = releaseBufferLocked(buf, mSlots[buf].mGraphicBuffer, mEglDisplay, EGL_NO_SYNC_KHR);
         if (err < NO_ERROR) {
-            GLC_LOGE("releaseTexImage: failed to release buffer: %s (%d)",
+            ST_LOGE("releaseTexImage: failed to release buffer: %s (%d)",
                     strerror(-err), err);
             return err;
         }
@@ -304,9 +293,9 @@ status_t GLConsumer::releaseTexImage() {
 
         if (mAttached) {
             // This binds a dummy buffer (mReleasedTexImage).
-            status_t result = bindTextureImageLocked();
-            if (result != NO_ERROR) {
-                return result;
+            status_t err =  bindTextureImageLocked();
+            if (err != NO_ERROR) {
+                return err;
             }
         } else {
             // detached, don't touch the texture (and we may not even have an
@@ -327,15 +316,14 @@ sp<GraphicBuffer> GLConsumer::getDebugTexImageBuffer() {
                 GraphicBuffer::USAGE_SW_WRITE_RARELY);
         uint32_t* bits;
         buffer->lock(GraphicBuffer::USAGE_SW_WRITE_RARELY, reinterpret_cast<void**>(&bits));
-        uint32_t stride = buffer->getStride();
-        uint32_t height = buffer->getHeight();
-        memset(bits, 0, stride * height * 4);
-        for (uint32_t y = 0; y < kDebugData.height; y++) {
-            for (uint32_t x = 0; x < kDebugData.width; x++) {
-                bits[x] = (kDebugData.bits[y + kDebugData.width + x] == 'X') ?
-                    0xFF000000 : 0xFFFFFFFF;
+        size_t w = buffer->getStride();
+        size_t h = buffer->getHeight();
+        memset(bits, 0, w*h*4);
+        for (size_t y=0 ; y<kDebugData.height ; y++) {
+            for (size_t x=0 ; x<kDebugData.width ; x++) {
+                bits[x] = (kDebugData.bits[y*kDebugData.width+x] == 'X') ? 0xFF000000 : 0xFFFFFFFF;
             }
-            bits += stride;
+            bits += w;
         }
         buffer->unlock();
         sReleasedTexImageBuffer = buffer;
@@ -343,10 +331,9 @@ sp<GraphicBuffer> GLConsumer::getDebugTexImageBuffer() {
     return sReleasedTexImageBuffer;
 }
 
-status_t GLConsumer::acquireBufferLocked(BufferItem *item,
-        nsecs_t presentWhen, uint64_t maxFrameNumber) {
-    status_t err = ConsumerBase::acquireBufferLocked(item, presentWhen,
-            maxFrameNumber);
+status_t GLConsumer::acquireBufferLocked(BufferQueue::BufferItem *item,
+        nsecs_t presentWhen) {
+    status_t err = ConsumerBase::acquireBufferLocked(item, presentWhen);
     if (err != NO_ERROR) {
         return err;
     }
@@ -375,14 +362,14 @@ status_t GLConsumer::releaseBufferLocked(int buf,
     return err;
 }
 
-status_t GLConsumer::updateAndReleaseLocked(const BufferItem& item)
+status_t GLConsumer::updateAndReleaseLocked(const BufferQueue::BufferItem& item)
 {
     status_t err = NO_ERROR;
 
     int buf = item.mBuf;
 
     if (!mAttached) {
-        GLC_LOGE("updateAndRelease: GLConsumer is not attached to an OpenGL "
+        ST_LOGE("updateAndRelease: GLConsumer is not attached to an OpenGL "
                 "ES context");
         releaseBufferLocked(buf, mSlots[buf].mGraphicBuffer,
                 mEglDisplay, EGL_NO_SYNC_KHR);
@@ -404,7 +391,7 @@ status_t GLConsumer::updateAndReleaseLocked(const BufferItem& item)
     // means the buffer was previously acquired).
     err = mEglSlots[buf].mEglImage->createIfNeeded(mEglDisplay, item.mCrop);
     if (err != NO_ERROR) {
-        GLC_LOGW("updateAndRelease: unable to createImage on display=%p slot=%d",
+        ST_LOGW("updateAndRelease: unable to createImage on display=%p slot=%d",
                 mEglDisplay, buf);
         releaseBufferLocked(buf, mSlots[buf].mGraphicBuffer,
                 mEglDisplay, EGL_NO_SYNC_KHR);
@@ -423,7 +410,7 @@ status_t GLConsumer::updateAndReleaseLocked(const BufferItem& item)
         return err;
     }
 
-    GLC_LOGV("updateAndRelease: (slot=%d buf=%p) -> (slot=%d buf=%p)",
+    ST_LOGV("updateAndRelease: (slot=%d buf=%p) -> (slot=%d buf=%p)",
             mCurrentTexture, mCurrentTextureImage != NULL ?
                     mCurrentTextureImage->graphicBufferHandle() : 0,
             buf, mSlots[buf].mGraphicBuffer->handle);
@@ -434,7 +421,7 @@ status_t GLConsumer::updateAndReleaseLocked(const BufferItem& item)
                 mCurrentTexture, mCurrentTextureImage->graphicBuffer(),
                 mEglDisplay, mEglSlots[mCurrentTexture].mEglFence);
         if (status < NO_ERROR) {
-            GLC_LOGE("updateAndRelease: failed to release buffer: %s (%d)",
+            ST_LOGE("updateAndRelease: failed to release buffer: %s (%d)",
                    strerror(-status), status);
             err = status;
             // keep going, with error raised [?]
@@ -462,22 +449,22 @@ status_t GLConsumer::bindTextureImageLocked() {
         return INVALID_OPERATION;
     }
 
-    GLenum error;
+    GLint error;
     while ((error = glGetError()) != GL_NO_ERROR) {
-        GLC_LOGW("bindTextureImage: clearing GL error: %#04x", error);
+        ST_LOGW("bindTextureImage: clearing GL error: %#04x", error);
     }
 
     glBindTexture(mTexTarget, mTexName);
     if (mCurrentTexture == BufferQueue::INVALID_BUFFER_SLOT &&
             mCurrentTextureImage == NULL) {
-        GLC_LOGE("bindTextureImage: no currently-bound texture");
+        ST_LOGE("bindTextureImage: no currently-bound texture");
         return NO_INIT;
     }
 
     status_t err = mCurrentTextureImage->createIfNeeded(mEglDisplay,
                                                         mCurrentCrop);
     if (err != NO_ERROR) {
-        GLC_LOGW("bindTextureImage: can't create image on display=%p slot=%d",
+        ST_LOGW("bindTextureImage: can't create image on display=%p slot=%d",
                 mEglDisplay, mCurrentTexture);
         return UNKNOWN_ERROR;
     }
@@ -489,17 +476,17 @@ status_t GLConsumer::bindTextureImageLocked() {
     // forcing the creation of a new image.
     if ((error = glGetError()) != GL_NO_ERROR) {
         glBindTexture(mTexTarget, mTexName);
-        status_t result = mCurrentTextureImage->createIfNeeded(mEglDisplay,
-                                                               mCurrentCrop,
-                                                               true);
-        if (result != NO_ERROR) {
-            GLC_LOGW("bindTextureImage: can't create image on display=%p slot=%d",
+        status_t err = mCurrentTextureImage->createIfNeeded(mEglDisplay,
+                                                            mCurrentCrop,
+                                                            true);
+        if (err != NO_ERROR) {
+            ST_LOGW("bindTextureImage: can't create image on display=%p slot=%d",
                     mEglDisplay, mCurrentTexture);
             return UNKNOWN_ERROR;
         }
         mCurrentTextureImage->bindToTextureTarget(mTexTarget);
         if ((error = glGetError()) != GL_NO_ERROR) {
-            GLC_LOGE("bindTextureImage: error binding external image: %#04x", error);
+            ST_LOGE("bindTextureImage: error binding external image: %#04x", error);
             return UNKNOWN_ERROR;
         }
     }
@@ -524,12 +511,12 @@ status_t GLConsumer::checkAndUpdateEglStateLocked(bool contextCheck) {
     }
 
     if (mEglDisplay != dpy || dpy == EGL_NO_DISPLAY) {
-        GLC_LOGE("checkAndUpdateEglState: invalid current EGLDisplay");
+        ST_LOGE("checkAndUpdateEglState: invalid current EGLDisplay");
         return INVALID_OPERATION;
     }
 
     if (mEglContext != ctx || ctx == EGL_NO_CONTEXT) {
-        GLC_LOGE("checkAndUpdateEglState: invalid current EGLContext");
+        ST_LOGE("checkAndUpdateEglState: invalid current EGLContext");
         return INVALID_OPERATION;
     }
 
@@ -544,7 +531,7 @@ void GLConsumer::setReleaseFence(const sp<Fence>& fence) {
         status_t err = addReleaseFence(mCurrentTexture,
                 mCurrentTextureImage->graphicBuffer(), fence);
         if (err != OK) {
-            GLC_LOGE("setReleaseFence: failed to add the fence: %s (%d)",
+            ST_LOGE("setReleaseFence: failed to add the fence: %s (%d)",
                     strerror(-err), err);
         }
     }
@@ -552,16 +539,16 @@ void GLConsumer::setReleaseFence(const sp<Fence>& fence) {
 
 status_t GLConsumer::detachFromContext() {
     ATRACE_CALL();
-    GLC_LOGV("detachFromContext");
+    ST_LOGV("detachFromContext");
     Mutex::Autolock lock(mMutex);
 
     if (mAbandoned) {
-        GLC_LOGE("detachFromContext: abandoned GLConsumer");
+        ST_LOGE("detachFromContext: abandoned GLConsumer");
         return NO_INIT;
     }
 
     if (!mAttached) {
-        GLC_LOGE("detachFromContext: GLConsumer is not attached to a "
+        ST_LOGE("detachFromContext: GLConsumer is not attached to a "
                 "context");
         return INVALID_OPERATION;
     }
@@ -570,12 +557,12 @@ status_t GLConsumer::detachFromContext() {
     EGLContext ctx = eglGetCurrentContext();
 
     if (mEglDisplay != dpy && mEglDisplay != EGL_NO_DISPLAY) {
-        GLC_LOGE("detachFromContext: invalid current EGLDisplay");
+        ST_LOGE("detachFromContext: invalid current EGLDisplay");
         return INVALID_OPERATION;
     }
 
     if (mEglContext != ctx && mEglContext != EGL_NO_CONTEXT) {
-        GLC_LOGE("detachFromContext: invalid current EGLContext");
+        ST_LOGE("detachFromContext: invalid current EGLContext");
         return INVALID_OPERATION;
     }
 
@@ -597,16 +584,16 @@ status_t GLConsumer::detachFromContext() {
 
 status_t GLConsumer::attachToContext(uint32_t tex) {
     ATRACE_CALL();
-    GLC_LOGV("attachToContext");
+    ST_LOGV("attachToContext");
     Mutex::Autolock lock(mMutex);
 
     if (mAbandoned) {
-        GLC_LOGE("attachToContext: abandoned GLConsumer");
+        ST_LOGE("attachToContext: abandoned GLConsumer");
         return NO_INIT;
     }
 
     if (mAttached) {
-        GLC_LOGE("attachToContext: GLConsumer is already attached to a "
+        ST_LOGE("attachToContext: GLConsumer is already attached to a "
                 "context");
         return INVALID_OPERATION;
     }
@@ -615,12 +602,12 @@ status_t GLConsumer::attachToContext(uint32_t tex) {
     EGLContext ctx = eglGetCurrentContext();
 
     if (dpy == EGL_NO_DISPLAY) {
-        GLC_LOGE("attachToContext: invalid current EGLDisplay");
+        ST_LOGE("attachToContext: invalid current EGLDisplay");
         return INVALID_OPERATION;
     }
 
     if (ctx == EGL_NO_CONTEXT) {
-        GLC_LOGE("attachToContext: invalid current EGLContext");
+        ST_LOGE("attachToContext: invalid current EGLContext");
         return INVALID_OPERATION;
     }
 
@@ -649,14 +636,14 @@ status_t GLConsumer::attachToContext(uint32_t tex) {
 
 
 status_t GLConsumer::syncForReleaseLocked(EGLDisplay dpy) {
-    GLC_LOGV("syncForReleaseLocked");
+    ST_LOGV("syncForReleaseLocked");
 
     if (mCurrentTexture != BufferQueue::INVALID_BUFFER_SLOT) {
         if (SyncFeatures::getInstance().useNativeFenceSync()) {
             EGLSyncKHR sync = eglCreateSyncKHR(dpy,
                     EGL_SYNC_NATIVE_FENCE_ANDROID, NULL);
             if (sync == EGL_NO_SYNC_KHR) {
-                GLC_LOGE("syncForReleaseLocked: error creating EGL fence: %#x",
+                ST_LOGE("syncForReleaseLocked: error creating EGL fence: %#x",
                         eglGetError());
                 return UNKNOWN_ERROR;
             }
@@ -664,7 +651,7 @@ status_t GLConsumer::syncForReleaseLocked(EGLDisplay dpy) {
             int fenceFd = eglDupNativeFenceFDANDROID(dpy, sync);
             eglDestroySyncKHR(dpy, sync);
             if (fenceFd == EGL_NO_NATIVE_FENCE_FD_ANDROID) {
-                GLC_LOGE("syncForReleaseLocked: error dup'ing native fence "
+                ST_LOGE("syncForReleaseLocked: error dup'ing native fence "
                         "fd: %#x", eglGetError());
                 return UNKNOWN_ERROR;
             }
@@ -672,7 +659,7 @@ status_t GLConsumer::syncForReleaseLocked(EGLDisplay dpy) {
             status_t err = addReleaseFenceLocked(mCurrentTexture,
                     mCurrentTextureImage->graphicBuffer(), fence);
             if (err != OK) {
-                GLC_LOGE("syncForReleaseLocked: error adding release fence: "
+                ST_LOGE("syncForReleaseLocked: error adding release fence: "
                         "%s (%d)", strerror(-err), err);
                 return err;
             }
@@ -685,11 +672,11 @@ status_t GLConsumer::syncForReleaseLocked(EGLDisplay dpy) {
                 // before the producer accesses it.
                 EGLint result = eglClientWaitSyncKHR(dpy, fence, 0, 1000000000);
                 if (result == EGL_FALSE) {
-                    GLC_LOGE("syncForReleaseLocked: error waiting for previous "
+                    ST_LOGE("syncForReleaseLocked: error waiting for previous "
                             "fence: %#x", eglGetError());
                     return UNKNOWN_ERROR;
                 } else if (result == EGL_TIMEOUT_EXPIRED_KHR) {
-                    GLC_LOGE("syncForReleaseLocked: timeout waiting for previous "
+                    ST_LOGE("syncForReleaseLocked: timeout waiting for previous "
                             "fence");
                     return TIMED_OUT;
                 }
@@ -700,7 +687,7 @@ status_t GLConsumer::syncForReleaseLocked(EGLDisplay dpy) {
             // OpenGL ES context.
             fence = eglCreateSyncKHR(dpy, EGL_SYNC_FENCE_KHR, NULL);
             if (fence == EGL_NO_SYNC_KHR) {
-                GLC_LOGE("syncForReleaseLocked: error creating fence: %#x",
+                ST_LOGE("syncForReleaseLocked: error creating fence: %#x",
                         eglGetError());
                 return UNKNOWN_ERROR;
             }
@@ -712,7 +699,7 @@ status_t GLConsumer::syncForReleaseLocked(EGLDisplay dpy) {
     return OK;
 }
 
-bool GLConsumer::isExternalFormat(PixelFormat format)
+bool GLConsumer::isExternalFormat(uint32_t format)
 {
     switch (format) {
     // supported YUV formats
@@ -743,14 +730,14 @@ void GLConsumer::getTransformMatrix(float mtx[16]) {
 void GLConsumer::setFilteringEnabled(bool enabled) {
     Mutex::Autolock lock(mMutex);
     if (mAbandoned) {
-        GLC_LOGE("setFilteringEnabled: GLConsumer is abandoned!");
+        ST_LOGE("setFilteringEnabled: GLConsumer is abandoned!");
         return;
     }
     bool needsRecompute = mFilteringEnabled != enabled;
     mFilteringEnabled = enabled;
 
     if (needsRecompute && mCurrentTextureImage==NULL) {
-        GLC_LOGD("setFilteringEnabled called with mCurrentTextureImage == NULL");
+        ST_LOGD("setFilteringEnabled called with mCurrentTextureImage == NULL");
     }
 
     if (needsRecompute && mCurrentTextureImage != NULL) {
@@ -759,7 +746,7 @@ void GLConsumer::setFilteringEnabled(bool enabled) {
 }
 
 void GLConsumer::computeCurrentTransformMatrixLocked() {
-    GLC_LOGV("computeCurrentTransformMatrixLocked");
+    ST_LOGV("computeCurrentTransformMatrixLocked");
 
     float xform[16];
     for (int i = 0; i < 16; i++) {
@@ -791,7 +778,7 @@ void GLConsumer::computeCurrentTransformMatrixLocked() {
             NULL : mCurrentTextureImage->graphicBuffer();
 
     if (buf == NULL) {
-        GLC_LOGD("computeCurrentTransformMatrixLocked: mCurrentTextureImage is NULL");
+        ST_LOGD("computeCurrentTransformMatrixLocked: mCurrentTextureImage is NULL");
     }
 
     float mtxBeforeFlipV[16];
@@ -863,13 +850,13 @@ void GLConsumer::computeCurrentTransformMatrixLocked() {
 }
 
 nsecs_t GLConsumer::getTimestamp() {
-    GLC_LOGV("getTimestamp");
+    ST_LOGV("getTimestamp");
     Mutex::Autolock lock(mMutex);
     return mCurrentTimestamp;
 }
 
-uint64_t GLConsumer::getFrameNumber() {
-    GLC_LOGV("getFrameNumber");
+nsecs_t GLConsumer::getFrameNumber() {
+    ST_LOGV("getFrameNumber");
     Mutex::Autolock lock(mMutex);
     return mCurrentFrameNumber;
 }
@@ -885,37 +872,30 @@ Rect GLConsumer::getCurrentCrop() const {
 
     Rect outCrop = mCurrentCrop;
     if (mCurrentScalingMode == NATIVE_WINDOW_SCALING_MODE_SCALE_CROP) {
-        uint32_t newWidth = static_cast<uint32_t>(mCurrentCrop.width());
-        uint32_t newHeight = static_cast<uint32_t>(mCurrentCrop.height());
+        int32_t newWidth = mCurrentCrop.width();
+        int32_t newHeight = mCurrentCrop.height();
 
         if (newWidth * mDefaultHeight > newHeight * mDefaultWidth) {
             newWidth = newHeight * mDefaultWidth / mDefaultHeight;
-            GLC_LOGV("too wide: newWidth = %d", newWidth);
+            ST_LOGV("too wide: newWidth = %d", newWidth);
         } else if (newWidth * mDefaultHeight < newHeight * mDefaultWidth) {
             newHeight = newWidth * mDefaultHeight / mDefaultWidth;
-            GLC_LOGV("too tall: newHeight = %d", newHeight);
+            ST_LOGV("too tall: newHeight = %d", newHeight);
         }
 
-        uint32_t currentWidth = static_cast<uint32_t>(mCurrentCrop.width());
-        uint32_t currentHeight = static_cast<uint32_t>(mCurrentCrop.height());
-
         // The crop is too wide
-        if (newWidth < currentWidth) {
-            uint32_t dw = currentWidth - newWidth;
-            auto halfdw = dw / 2;
-            outCrop.left += halfdw;
-            // Not halfdw because it would subtract 1 too few when dw is odd
-            outCrop.right -= (dw - halfdw);
+        if (newWidth < mCurrentCrop.width()) {
+            int32_t dw = (newWidth - mCurrentCrop.width())/2;
+            outCrop.left -=dw;
+            outCrop.right += dw;
         // The crop is too tall
-        } else if (newHeight < currentHeight) {
-            uint32_t dh = currentHeight - newHeight;
-            auto halfdh = dh / 2;
-            outCrop.top += halfdh;
-            // Not halfdh because it would subtract 1 too few when dh is odd
-            outCrop.bottom -= (dh - halfdh);
+        } else if (newHeight < mCurrentCrop.height()) {
+            int32_t dh = (newHeight - mCurrentCrop.height())/2;
+            outCrop.top -= dh;
+            outCrop.bottom += dh;
         }
 
-        GLC_LOGV("getCurrentCrop final crop [%d,%d,%d,%d]",
+        ST_LOGV("getCurrentCrop final crop [%d,%d,%d,%d]",
             outCrop.left, outCrop.top,
             outCrop.right,outCrop.bottom);
     }
@@ -949,12 +929,12 @@ status_t GLConsumer::doGLFenceWaitLocked() const {
     EGLContext ctx = eglGetCurrentContext();
 
     if (mEglDisplay != dpy || mEglDisplay == EGL_NO_DISPLAY) {
-        GLC_LOGE("doGLFenceWait: invalid current EGLDisplay");
+        ST_LOGE("doGLFenceWait: invalid current EGLDisplay");
         return INVALID_OPERATION;
     }
 
     if (mEglContext != ctx || mEglContext == EGL_NO_CONTEXT) {
-        GLC_LOGE("doGLFenceWait: invalid current EGLContext");
+        ST_LOGE("doGLFenceWait: invalid current EGLContext");
         return INVALID_OPERATION;
     }
 
@@ -963,7 +943,7 @@ status_t GLConsumer::doGLFenceWaitLocked() const {
             // Create an EGLSyncKHR from the current fence.
             int fenceFd = mCurrentFence->dup();
             if (fenceFd == -1) {
-                GLC_LOGE("doGLFenceWait: error dup'ing fence fd: %d", errno);
+                ST_LOGE("doGLFenceWait: error dup'ing fence fd: %d", errno);
                 return -errno;
             }
             EGLint attribs[] = {
@@ -974,7 +954,7 @@ status_t GLConsumer::doGLFenceWaitLocked() const {
                     EGL_SYNC_NATIVE_FENCE_ANDROID, attribs);
             if (sync == EGL_NO_SYNC_KHR) {
                 close(fenceFd);
-                GLC_LOGE("doGLFenceWait: error creating EGL fence: %#x",
+                ST_LOGE("doGLFenceWait: error creating EGL fence: %#x",
                         eglGetError());
                 return UNKNOWN_ERROR;
             }
@@ -986,7 +966,7 @@ status_t GLConsumer::doGLFenceWaitLocked() const {
             EGLint eglErr = eglGetError();
             eglDestroySyncKHR(dpy, sync);
             if (eglErr != EGL_SUCCESS) {
-                GLC_LOGE("doGLFenceWait: error waiting for EGL fence: %#x",
+                ST_LOGE("doGLFenceWait: error waiting for EGL fence: %#x",
                         eglErr);
                 return UNKNOWN_ERROR;
             }
@@ -994,7 +974,7 @@ status_t GLConsumer::doGLFenceWaitLocked() const {
             status_t err = mCurrentFence->waitForever(
                     "GLConsumer::doGLFenceWaitLocked");
             if (err != NO_ERROR) {
-                GLC_LOGE("doGLFenceWait: error waiting for fence: %d", err);
+                ST_LOGE("doGLFenceWait: error waiting for fence: %d", err);
                 return err;
             }
         }
@@ -1004,7 +984,7 @@ status_t GLConsumer::doGLFenceWaitLocked() const {
 }
 
 void GLConsumer::freeBufferLocked(int slotIndex) {
-    GLC_LOGV("freeBufferLocked: slotIndex=%d", slotIndex);
+    ST_LOGV("freeBufferLocked: slotIndex=%d", slotIndex);
     if (slotIndex == mCurrentTexture) {
         mCurrentTexture = BufferQueue::INVALID_BUFFER_SLOT;
     }
@@ -1013,7 +993,7 @@ void GLConsumer::freeBufferLocked(int slotIndex) {
 }
 
 void GLConsumer::abandonLocked() {
-    GLC_LOGV("abandonLocked");
+    ST_LOGV("abandonLocked");
     mCurrentTextureImage.clear();
     ConsumerBase::abandonLocked();
 }
@@ -1024,17 +1004,11 @@ void GLConsumer::setName(const String8& name) {
     mConsumer->setConsumerName(name);
 }
 
-status_t GLConsumer::setDefaultBufferFormat(PixelFormat defaultFormat) {
+status_t GLConsumer::setDefaultBufferFormat(uint32_t defaultFormat) {
     Mutex::Autolock lock(mMutex);
     return mConsumer->setDefaultBufferFormat(defaultFormat);
 }
 
-status_t GLConsumer::setDefaultBufferDataSpace(
-        android_dataspace defaultDataSpace) {
-    Mutex::Autolock lock(mMutex);
-    return mConsumer->setDefaultBufferDataSpace(defaultDataSpace);
-}
-
 status_t GLConsumer::setConsumerUsageBits(uint32_t usage) {
     Mutex::Autolock lock(mMutex);
     usage |= DEFAULT_USAGE_FLAGS;
@@ -1133,14 +1107,12 @@ status_t GLConsumer::EglImage::createIfNeeded(EGLDisplay eglDisplay,
 }
 
 void GLConsumer::EglImage::bindToTextureTarget(uint32_t texTarget) {
-    glEGLImageTargetTexture2DOES(texTarget,
-            static_cast<GLeglImageOES>(mEglImage));
+    glEGLImageTargetTexture2DOES(texTarget, (GLeglImageOES)mEglImage);
 }
 
 EGLImageKHR GLConsumer::EglImage::createImage(EGLDisplay dpy,
         const sp<GraphicBuffer>& graphicBuffer, const Rect& crop) {
-    EGLClientBuffer cbuf =
-            static_cast<EGLClientBuffer>(graphicBuffer->getNativeBuffer());
+    EGLClientBuffer cbuf = (EGLClientBuffer)graphicBuffer->getNativeBuffer();
     EGLint attrs[] = {
         EGL_IMAGE_PRESERVED_KHR,        EGL_TRUE,
         EGL_IMAGE_CROP_LEFT_ANDROID,    crop.left,
diff --git a/libs/gui/GraphicBufferAlloc.cpp b/libs/gui/GraphicBufferAlloc.cpp
index 9643402..b360e81 100644
--- a/libs/gui/GraphicBufferAlloc.cpp
+++ b/libs/gui/GraphicBufferAlloc.cpp
@@ -31,10 +31,9 @@ GraphicBufferAlloc::GraphicBufferAlloc() {
 GraphicBufferAlloc::~GraphicBufferAlloc() {
 }
 
-sp<GraphicBuffer> GraphicBufferAlloc::createGraphicBuffer(uint32_t width,
-        uint32_t height, PixelFormat format, uint32_t usage, status_t* error) {
-    sp<GraphicBuffer> graphicBuffer(
-            new GraphicBuffer(width, height, format, usage));
+sp<GraphicBuffer> GraphicBufferAlloc::createGraphicBuffer(uint32_t w, uint32_t h,
+        PixelFormat format, uint32_t usage, status_t* error) {
+    sp<GraphicBuffer> graphicBuffer(new GraphicBuffer(w, h, format, usage));
     status_t err = graphicBuffer->initCheck();
     *error = err;
     if (err != 0 || graphicBuffer->handle == 0) {
@@ -43,7 +42,7 @@ sp<GraphicBuffer> GraphicBufferAlloc::createGraphicBuffer(uint32_t width,
         }
         ALOGE("GraphicBufferAlloc::createGraphicBuffer(w=%d, h=%d) "
              "failed (%s), handle=%p",
-                width, height, strerror(-err), graphicBuffer->handle);
+                w, h, strerror(-err), graphicBuffer->handle);
         return 0;
     }
     return graphicBuffer;
diff --git a/libs/gui/IConsumerListener.cpp b/libs/gui/IConsumerListener.cpp
index cab7dc3..409dfe4 100644
--- a/libs/gui/IConsumerListener.cpp
+++ b/libs/gui/IConsumerListener.cpp
@@ -40,8 +40,6 @@ public:
         : BpInterface<IConsumerListener>(impl) {
     }
 
-    virtual ~BpConsumerListener();
-
     virtual void onFrameAvailable(const BufferItem& item) {
         Parcel data, reply;
         data.writeInterfaceToken(IConsumerListener::getInterfaceDescriptor());
@@ -62,10 +60,6 @@ public:
     }
 };
 
-// Out-of-line virtual method definition to trigger vtable emission in this
-// translation unit (see clang warning -Wweak-vtables)
-BpConsumerListener::~BpConsumerListener() {}
-
 IMPLEMENT_META_INTERFACE(ConsumerListener, "android.gui.IConsumerListener");
 
 // ----------------------------------------------------------------------
diff --git a/libs/gui/IDisplayEventConnection.cpp b/libs/gui/IDisplayEventConnection.cpp
index 9890f44..887d176 100644
--- a/libs/gui/IDisplayEventConnection.cpp
+++ b/libs/gui/IDisplayEventConnection.cpp
@@ -44,8 +44,6 @@ public:
     {
     }
 
-    virtual ~BpDisplayEventConnection();
-
     virtual sp<BitTube> getDataChannel() const
     {
         Parcel data, reply;
@@ -57,7 +55,7 @@ public:
     virtual void setVsyncRate(uint32_t count) {
         Parcel data, reply;
         data.writeInterfaceToken(IDisplayEventConnection::getInterfaceDescriptor());
-        data.writeUint32(count);
+        data.writeInt32(count);
         remote()->transact(SET_VSYNC_RATE, data, &reply);
     }
 
@@ -68,10 +66,6 @@ public:
     }
 };
 
-// Out-of-line virtual method definition to trigger vtable emission in this
-// translation unit (see clang warning -Wweak-vtables)
-BpDisplayEventConnection::~BpDisplayEventConnection() {}
-
 IMPLEMENT_META_INTERFACE(DisplayEventConnection, "android.gui.DisplayEventConnection");
 
 // ----------------------------------------------------------------------------
@@ -85,17 +79,17 @@ status_t BnDisplayEventConnection::onTransact(
             sp<BitTube> channel(getDataChannel());
             channel->writeToParcel(reply);
             return NO_ERROR;
-        }
+        } break;
         case SET_VSYNC_RATE: {
             CHECK_INTERFACE(IDisplayEventConnection, data, reply);
-            setVsyncRate(data.readUint32());
+            setVsyncRate(data.readInt32());
             return NO_ERROR;
-        }
+        } break;
         case REQUEST_NEXT_VSYNC: {
             CHECK_INTERFACE(IDisplayEventConnection, data, reply);
             requestNextVsync();
             return NO_ERROR;
-        }
+        } break;
     }
     return BBinder::onTransact(code, data, reply, flags);
 }
diff --git a/libs/gui/IGraphicBufferAlloc.cpp b/libs/gui/IGraphicBufferAlloc.cpp
index 3009989..139f219 100644
--- a/libs/gui/IGraphicBufferAlloc.cpp
+++ b/libs/gui/IGraphicBufferAlloc.cpp
@@ -42,26 +42,20 @@ public:
     {
     }
 
-    virtual ~BpGraphicBufferAlloc();
-
-    virtual sp<GraphicBuffer> createGraphicBuffer(uint32_t width,
-            uint32_t height, PixelFormat format, uint32_t usage,
-            status_t* error) {
+    virtual sp<GraphicBuffer> createGraphicBuffer(uint32_t w, uint32_t h,
+            PixelFormat format, uint32_t usage, status_t* error) {
         Parcel data, reply;
         data.writeInterfaceToken(IGraphicBufferAlloc::getInterfaceDescriptor());
-        data.writeUint32(width);
-        data.writeUint32(height);
-        data.writeInt32(static_cast<int32_t>(format));
-        data.writeUint32(usage);
+        data.writeInt32(w);
+        data.writeInt32(h);
+        data.writeInt32(format);
+        data.writeInt32(usage);
         remote()->transact(CREATE_GRAPHIC_BUFFER, data, &reply);
         sp<GraphicBuffer> graphicBuffer;
         status_t result = reply.readInt32();
         if (result == NO_ERROR) {
             graphicBuffer = new GraphicBuffer();
             result = reply.read(*graphicBuffer);
-            if (result != NO_ERROR) {
-                graphicBuffer.clear();
-            }
             // reply.readStrongBinder();
             // here we don't even have to read the BufferReference from
             // the parcel, it'll die with the parcel.
@@ -71,10 +65,6 @@ public:
     }
 };
 
-// Out-of-line virtual method definition to trigger vtable emission in this
-// translation unit (see clang warning -Wweak-vtables)
-BpGraphicBufferAlloc::~BpGraphicBufferAlloc() {}
-
 IMPLEMENT_META_INTERFACE(GraphicBufferAlloc, "android.ui.IGraphicBufferAlloc");
 
 // ----------------------------------------------------------------------
@@ -84,26 +74,27 @@ status_t BnGraphicBufferAlloc::onTransact(
 {
     // codes that don't require permission check
 
-    // BufferReference just keeps a strong reference to a GraphicBuffer until it
-    // is destroyed (that is, until no local or remote process have a reference
-    // to it).
+    /* BufferReference just keeps a strong reference to a
+     * GraphicBuffer until it is destroyed (that is, until
+     * no local or remote process have a reference to it).
+     */
     class BufferReference : public BBinder {
-        sp<GraphicBuffer> mBuffer;
+        sp<GraphicBuffer> buffer;
     public:
-        BufferReference(const sp<GraphicBuffer>& buffer) : mBuffer(buffer) {}
+        BufferReference(const sp<GraphicBuffer>& buffer) : buffer(buffer) { }
     };
 
 
-    switch (code) {
+    switch(code) {
         case CREATE_GRAPHIC_BUFFER: {
             CHECK_INTERFACE(IGraphicBufferAlloc, data, reply);
-            uint32_t width = data.readUint32();
-            uint32_t height = data.readUint32();
-            PixelFormat format = static_cast<PixelFormat>(data.readInt32());
-            uint32_t usage = data.readUint32();
+            uint32_t w = data.readInt32();
+            uint32_t h = data.readInt32();
+            PixelFormat format = data.readInt32();
+            uint32_t usage = data.readInt32();
             status_t error;
             sp<GraphicBuffer> result =
-                    createGraphicBuffer(width, height, format, usage, &error);
+                    createGraphicBuffer(w, h, format, usage, &error);
             reply->writeInt32(error);
             if (result != 0) {
                 reply->write(*result);
@@ -116,7 +107,7 @@ status_t BnGraphicBufferAlloc::onTransact(
                 reply->writeStrongBinder( new BufferReference(result) );
             }
             return NO_ERROR;
-        }
+        } break;
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
diff --git a/libs/gui/IGraphicBufferConsumer.cpp b/libs/gui/IGraphicBufferConsumer.cpp
index b86f4c5..f6d087d 100644
--- a/libs/gui/IGraphicBufferConsumer.cpp
+++ b/libs/gui/IGraphicBufferConsumer.cpp
@@ -23,7 +23,6 @@
 #include <binder/Parcel.h>
 #include <binder/IInterface.h>
 
-#include <gui/BufferItem.h>
 #include <gui/IConsumerListener.h>
 #include <gui/IGraphicBufferConsumer.h>
 
@@ -33,6 +32,159 @@
 #include <system/window.h>
 
 namespace android {
+// ---------------------------------------------------------------------------
+
+IGraphicBufferConsumer::BufferItem::BufferItem() :
+    mTransform(0),
+    mScalingMode(NATIVE_WINDOW_SCALING_MODE_FREEZE),
+    mTimestamp(0),
+    mIsAutoTimestamp(false),
+    mFrameNumber(0),
+    mBuf(INVALID_BUFFER_SLOT),
+    mIsDroppable(false),
+    mAcquireCalled(false),
+    mTransformToDisplayInverse(false) {
+    mCrop.makeInvalid();
+}
+
+size_t IGraphicBufferConsumer::BufferItem::getPodSize() const {
+    size_t c =  sizeof(mCrop) +
+            sizeof(mTransform) +
+            sizeof(mScalingMode) +
+            sizeof(mTimestamp) +
+            sizeof(mIsAutoTimestamp) +
+            sizeof(mFrameNumber) +
+            sizeof(mBuf) +
+            sizeof(mIsDroppable) +
+            sizeof(mAcquireCalled) +
+            sizeof(mTransformToDisplayInverse);
+    return c;
+}
+
+size_t IGraphicBufferConsumer::BufferItem::getFlattenedSize() const {
+    size_t c = 0;
+    if (mGraphicBuffer != 0) {
+        c += mGraphicBuffer->getFlattenedSize();
+        c = FlattenableUtils::align<4>(c);
+    }
+    if (mFence != 0) {
+        c += mFence->getFlattenedSize();
+        c = FlattenableUtils::align<4>(c);
+    }
+    return sizeof(int32_t) + c + getPodSize();
+}
+
+size_t IGraphicBufferConsumer::BufferItem::getFdCount() const {
+    size_t c = 0;
+    if (mGraphicBuffer != 0) {
+        c += mGraphicBuffer->getFdCount();
+    }
+    if (mFence != 0) {
+        c += mFence->getFdCount();
+    }
+    return c;
+}
+
+static void writeBoolAsInt(void*& buffer, size_t& size, bool b) {
+    FlattenableUtils::write(buffer, size, static_cast<int32_t>(b));
+}
+
+static bool readBoolFromInt(void const*& buffer, size_t& size) {
+    int32_t i;
+    FlattenableUtils::read(buffer, size, i);
+    return static_cast<bool>(i);
+}
+
+status_t IGraphicBufferConsumer::BufferItem::flatten(
+        void*& buffer, size_t& size, int*& fds, size_t& count) const {
+
+    // make sure we have enough space
+    if (size < BufferItem::getFlattenedSize()) {
+        return NO_MEMORY;
+    }
+
+    // content flags are stored first
+    uint32_t& flags = *static_cast<uint32_t*>(buffer);
+
+    // advance the pointer
+    FlattenableUtils::advance(buffer, size, sizeof(uint32_t));
+
+    flags = 0;
+    if (mGraphicBuffer != 0) {
+        status_t err = mGraphicBuffer->flatten(buffer, size, fds, count);
+        if (err) return err;
+        size -= FlattenableUtils::align<4>(buffer);
+        flags |= 1;
+    }
+    if (mFence != 0) {
+        status_t err = mFence->flatten(buffer, size, fds, count);
+        if (err) return err;
+        size -= FlattenableUtils::align<4>(buffer);
+        flags |= 2;
+    }
+
+    // check we have enough space (in case flattening the fence/graphicbuffer lied to us)
+    if (size < getPodSize()) {
+        return NO_MEMORY;
+    }
+
+    FlattenableUtils::write(buffer, size, mCrop);
+    FlattenableUtils::write(buffer, size, mTransform);
+    FlattenableUtils::write(buffer, size, mScalingMode);
+    FlattenableUtils::write(buffer, size, mTimestamp);
+    writeBoolAsInt(buffer, size, mIsAutoTimestamp);
+    FlattenableUtils::write(buffer, size, mFrameNumber);
+    FlattenableUtils::write(buffer, size, mBuf);
+    writeBoolAsInt(buffer, size, mIsDroppable);
+    writeBoolAsInt(buffer, size, mAcquireCalled);
+    writeBoolAsInt(buffer, size, mTransformToDisplayInverse);
+
+    return NO_ERROR;
+}
+
+status_t IGraphicBufferConsumer::BufferItem::unflatten(
+        void const*& buffer, size_t& size, int const*& fds, size_t& count) {
+
+    if (size < sizeof(uint32_t))
+        return NO_MEMORY;
+
+    uint32_t flags = 0;
+    FlattenableUtils::read(buffer, size, flags);
+
+    if (flags & 1) {
+        mGraphicBuffer = new GraphicBuffer();
+        status_t err = mGraphicBuffer->unflatten(buffer, size, fds, count);
+        if (err) return err;
+        size -= FlattenableUtils::align<4>(buffer);
+    }
+
+    if (flags & 2) {
+        mFence = new Fence();
+        status_t err = mFence->unflatten(buffer, size, fds, count);
+        if (err) return err;
+        size -= FlattenableUtils::align<4>(buffer);
+    }
+
+    // check we have enough space
+    if (size < getPodSize()) {
+        return NO_MEMORY;
+    }
+
+    FlattenableUtils::read(buffer, size, mCrop);
+    FlattenableUtils::read(buffer, size, mTransform);
+    FlattenableUtils::read(buffer, size, mScalingMode);
+    FlattenableUtils::read(buffer, size, mTimestamp);
+    mIsAutoTimestamp = readBoolFromInt(buffer, size);
+    FlattenableUtils::read(buffer, size, mFrameNumber);
+    FlattenableUtils::read(buffer, size, mBuf);
+    mIsDroppable = readBoolFromInt(buffer, size);
+    mAcquireCalled = readBoolFromInt(buffer, size);
+    mTransformToDisplayInverse = readBoolFromInt(buffer, size);
+
+    return NO_ERROR;
+}
+
+// ---------------------------------------------------------------------------
 
 enum {
     ACQUIRE_BUFFER = IBinder::FIRST_CALL_TRANSACTION,
@@ -48,7 +200,6 @@ enum {
     SET_MAX_ACQUIRED_BUFFER_COUNT,
     SET_CONSUMER_NAME,
     SET_DEFAULT_BUFFER_FORMAT,
-    SET_DEFAULT_BUFFER_DATA_SPACE,
     SET_CONSUMER_USAGE_BITS,
     SET_TRANSFORM_HINT,
     GET_SIDEBAND_STREAM,
@@ -64,14 +215,10 @@ public:
     {
     }
 
-    virtual ~BpGraphicBufferConsumer();
-
-    virtual status_t acquireBuffer(BufferItem *buffer, nsecs_t presentWhen,
-            uint64_t maxFrameNumber) {
+    virtual status_t acquireBuffer(BufferItem *buffer, nsecs_t presentWhen) {
         Parcel data, reply;
         data.writeInterfaceToken(IGraphicBufferConsumer::getInterfaceDescriptor());
         data.writeInt64(presentWhen);
-        data.writeUint64(maxFrameNumber);
         status_t result = remote()->transact(ACQUIRE_BUFFER, data, &reply);
         if (result != NO_ERROR) {
             return result;
@@ -114,7 +261,7 @@ public:
         Parcel data, reply;
         data.writeInterfaceToken(IGraphicBufferConsumer::getInterfaceDescriptor());
         data.writeInt32(buf);
-        data.writeInt64(static_cast<int64_t>(frameNumber));
+        data.writeInt64(frameNumber);
         data.write(*releaseFence);
         status_t result = remote()->transact(RELEASE_BUFFER, data, &reply);
         if (result != NO_ERROR) {
@@ -126,7 +273,7 @@ public:
     virtual status_t consumerConnect(const sp<IConsumerListener>& consumer, bool controlledByApp) {
         Parcel data, reply;
         data.writeInterfaceToken(IGraphicBufferConsumer::getInterfaceDescriptor());
-        data.writeStrongBinder(IInterface::asBinder(consumer));
+        data.writeStrongBinder(consumer->asBinder());
         data.writeInt32(controlledByApp);
         status_t result = remote()->transact(CONSUMER_CONNECT, data, &reply);
         if (result != NO_ERROR) {
@@ -156,15 +303,15 @@ public:
         if (result != NO_ERROR) {
             return result;
         }
-        *slotMask = static_cast<uint64_t>(reply.readInt64());
+        *slotMask = reply.readInt64();
         return reply.readInt32();
     }
 
-    virtual status_t setDefaultBufferSize(uint32_t width, uint32_t height) {
+    virtual status_t setDefaultBufferSize(uint32_t w, uint32_t h) {
         Parcel data, reply;
         data.writeInterfaceToken(IGraphicBufferConsumer::getInterfaceDescriptor());
-        data.writeUint32(width);
-        data.writeUint32(height);
+        data.writeInt32(w);
+        data.writeInt32(h);
         status_t result = remote()->transact(SET_DEFAULT_BUFFER_SIZE, data, &reply);
         if (result != NO_ERROR) {
             return result;
@@ -211,10 +358,10 @@ public:
         remote()->transact(SET_CONSUMER_NAME, data, &reply);
     }
 
-    virtual status_t setDefaultBufferFormat(PixelFormat defaultFormat) {
+    virtual status_t setDefaultBufferFormat(uint32_t defaultFormat) {
         Parcel data, reply;
         data.writeInterfaceToken(IGraphicBufferConsumer::getInterfaceDescriptor());
-        data.writeInt32(static_cast<int32_t>(defaultFormat));
+        data.writeInt32(defaultFormat);
         status_t result = remote()->transact(SET_DEFAULT_BUFFER_FORMAT, data, &reply);
         if (result != NO_ERROR) {
             return result;
@@ -222,23 +369,10 @@ public:
         return reply.readInt32();
     }
 
-    virtual status_t setDefaultBufferDataSpace(
-            android_dataspace defaultDataSpace) {
-        Parcel data, reply;
-        data.writeInterfaceToken(IGraphicBufferConsumer::getInterfaceDescriptor());
-        data.writeInt32(static_cast<int32_t>(defaultDataSpace));
-        status_t result = remote()->transact(SET_DEFAULT_BUFFER_DATA_SPACE,
-                data, &reply);
-        if (result != NO_ERROR) {
-            return result;
-        }
-        return reply.readInt32();
-    }
-
     virtual status_t setConsumerUsageBits(uint32_t usage) {
         Parcel data, reply;
         data.writeInterfaceToken(IGraphicBufferConsumer::getInterfaceDescriptor());
-        data.writeUint32(usage);
+        data.writeInt32(usage);
         status_t result = remote()->transact(SET_CONSUMER_USAGE_BITS, data, &reply);
         if (result != NO_ERROR) {
             return result;
@@ -249,7 +383,7 @@ public:
     virtual status_t setTransformHint(uint32_t hint) {
         Parcel data, reply;
         data.writeInterfaceToken(IGraphicBufferConsumer::getInterfaceDescriptor());
-        data.writeUint32(hint);
+        data.writeInt32(hint);
         status_t result = remote()->transact(SET_TRANSFORM_HINT, data, &reply);
         if (result != NO_ERROR) {
             return result;
@@ -281,10 +415,6 @@ public:
     }
 };
 
-// Out-of-line virtual method definition to trigger vtable emission in this
-// translation unit (see clang warning -Wweak-vtables)
-BpGraphicBufferConsumer::~BpGraphicBufferConsumer() {}
-
 IMPLEMENT_META_INTERFACE(GraphicBufferConsumer, "android.gui.IGraphicBufferConsumer");
 
 // ----------------------------------------------------------------------
@@ -297,20 +427,19 @@ status_t BnGraphicBufferConsumer::onTransact(
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             BufferItem item;
             int64_t presentWhen = data.readInt64();
-            uint64_t maxFrameNumber = data.readUint64();
-            status_t result = acquireBuffer(&item, presentWhen, maxFrameNumber);
+            status_t result = acquireBuffer(&item, presentWhen);
             status_t err = reply->write(item);
             if (err) return err;
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case DETACH_BUFFER: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             int slot = data.readInt32();
             int result = detachBuffer(slot);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case ATTACH_BUFFER: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             sp<GraphicBuffer> buffer = new GraphicBuffer();
@@ -320,11 +449,11 @@ status_t BnGraphicBufferConsumer::onTransact(
             reply->writeInt32(slot);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case RELEASE_BUFFER: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             int buf = data.readInt32();
-            uint64_t frameNumber = static_cast<uint64_t>(data.readInt64());
+            uint64_t frameNumber = data.readInt64();
             sp<Fence> releaseFence = new Fence();
             status_t err = data.read(*releaseFence);
             if (err) return err;
@@ -332,7 +461,7 @@ status_t BnGraphicBufferConsumer::onTransact(
                     EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, releaseFence);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case CONSUMER_CONNECT: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             sp<IConsumerListener> consumer = IConsumerListener::asInterface( data.readStrongBinder() );
@@ -340,92 +469,75 @@ status_t BnGraphicBufferConsumer::onTransact(
             status_t result = consumerConnect(consumer, controlledByApp);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case CONSUMER_DISCONNECT: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             status_t result = consumerDisconnect();
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case GET_RELEASED_BUFFERS: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             uint64_t slotMask;
             status_t result = getReleasedBuffers(&slotMask);
-            reply->writeInt64(static_cast<int64_t>(slotMask));
+            reply->writeInt64(slotMask);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case SET_DEFAULT_BUFFER_SIZE: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
-            uint32_t width = data.readUint32();
-            uint32_t height = data.readUint32();
-            status_t result = setDefaultBufferSize(width, height);
+            uint32_t w = data.readInt32();
+            uint32_t h = data.readInt32();
+            status_t result = setDefaultBufferSize(w, h);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case SET_DEFAULT_MAX_BUFFER_COUNT: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
-            int bufferCount = data.readInt32();
+            uint32_t bufferCount = data.readInt32();
             status_t result = setDefaultMaxBufferCount(bufferCount);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case DISABLE_ASYNC_BUFFER: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             status_t result = disableAsyncBuffer();
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case SET_MAX_ACQUIRED_BUFFER_COUNT: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
-            int maxAcquiredBuffers = data.readInt32();
+            uint32_t maxAcquiredBuffers = data.readInt32();
             status_t result = setMaxAcquiredBufferCount(maxAcquiredBuffers);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case SET_CONSUMER_NAME: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             setConsumerName( data.readString8() );
             return NO_ERROR;
-        }
+        } break;
         case SET_DEFAULT_BUFFER_FORMAT: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
-            PixelFormat defaultFormat = static_cast<PixelFormat>(data.readInt32());
+            uint32_t defaultFormat = data.readInt32();
             status_t result = setDefaultBufferFormat(defaultFormat);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
-        case SET_DEFAULT_BUFFER_DATA_SPACE: {
-            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
-            android_dataspace defaultDataSpace =
-                    static_cast<android_dataspace>(data.readInt32());
-            status_t result = setDefaultBufferDataSpace(defaultDataSpace);
-            reply->writeInt32(result);
-            return NO_ERROR;
-        }
+        } break;
         case SET_CONSUMER_USAGE_BITS: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
-            uint32_t usage = data.readUint32();
+            uint32_t usage = data.readInt32();
             status_t result = setConsumerUsageBits(usage);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case SET_TRANSFORM_HINT: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
-            uint32_t hint = data.readUint32();
+            uint32_t hint = data.readInt32();
             status_t result = setTransformHint(hint);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
-        case GET_SIDEBAND_STREAM: {
-            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
-            sp<NativeHandle> stream = getSidebandStream();
-            reply->writeInt32(static_cast<int32_t>(stream != NULL));
-            if (stream != NULL) {
-                reply->writeNativeHandle(stream->handle());
-            }
-            return NO_ERROR;
-        }
+        } break;
         case DUMP: {
             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);
             String8 result = data.readString8();
diff --git a/libs/gui/IGraphicBufferProducer.cpp b/libs/gui/IGraphicBufferProducer.cpp
index d7a7885..1e28f9b 100644
--- a/libs/gui/IGraphicBufferProducer.cpp
+++ b/libs/gui/IGraphicBufferProducer.cpp
@@ -46,9 +46,6 @@ enum {
     DISCONNECT,
     SET_SIDEBAND_STREAM,
     ALLOCATE_BUFFERS,
-    ALLOW_ALLOCATION,
-    SET_GENERATION_NUMBER,
-    GET_CONSUMER_NAME,
 };
 
 class BpGraphicBufferProducer : public BpInterface<IGraphicBufferProducer>
@@ -59,8 +56,6 @@ public:
     {
     }
 
-    virtual ~BpGraphicBufferProducer();
-
     virtual status_t requestBuffer(int bufferIdx, sp<GraphicBuffer>* buf) {
         Parcel data, reply;
         data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
@@ -96,15 +91,14 @@ public:
     }
 
     virtual status_t dequeueBuffer(int *buf, sp<Fence>* fence, bool async,
-            uint32_t width, uint32_t height, PixelFormat format,
-            uint32_t usage) {
+            uint32_t w, uint32_t h, uint32_t format, uint32_t usage) {
         Parcel data, reply;
         data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
-        data.writeInt32(static_cast<int32_t>(async));
-        data.writeUint32(width);
-        data.writeUint32(height);
-        data.writeInt32(static_cast<int32_t>(format));
-        data.writeUint32(usage);
+        data.writeInt32(async);
+        data.writeInt32(w);
+        data.writeInt32(h);
+        data.writeInt32(format);
+        data.writeInt32(usage);
         status_t result = remote()->transact(DEQUEUE_BUFFER, data, &reply);
         if (result != NO_ERROR) {
             return result;
@@ -217,7 +211,7 @@ public:
         data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
         if (listener != NULL) {
             data.writeInt32(1);
-            data.writeStrongBinder(IInterface::asBinder(listener));
+            data.writeStrongBinder(listener->asBinder());
         } else {
             data.writeInt32(0);
         }
@@ -261,59 +255,21 @@ public:
     }
 
     virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
-            PixelFormat format, uint32_t usage) {
+            uint32_t format, uint32_t usage) {
         Parcel data, reply;
         data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
         data.writeInt32(static_cast<int32_t>(async));
-        data.writeUint32(width);
-        data.writeUint32(height);
+        data.writeInt32(static_cast<int32_t>(width));
+        data.writeInt32(static_cast<int32_t>(height));
         data.writeInt32(static_cast<int32_t>(format));
-        data.writeUint32(usage);
+        data.writeInt32(static_cast<int32_t>(usage));
         status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
         if (result != NO_ERROR) {
             ALOGE("allocateBuffers failed to transact: %d", result);
         }
     }
-
-    virtual status_t allowAllocation(bool allow) {
-        Parcel data, reply;
-        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
-        data.writeInt32(static_cast<int32_t>(allow));
-        status_t result = remote()->transact(ALLOW_ALLOCATION, data, &reply);
-        if (result != NO_ERROR) {
-            return result;
-        }
-        result = reply.readInt32();
-        return result;
-    }
-
-    virtual status_t setGenerationNumber(uint32_t generationNumber) {
-        Parcel data, reply;
-        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
-        data.writeUint32(generationNumber);
-        status_t result = remote()->transact(SET_GENERATION_NUMBER, data, &reply);
-        if (result == NO_ERROR) {
-            result = reply.readInt32();
-        }
-        return result;
-    }
-
-    virtual String8 getConsumerName() const {
-        Parcel data, reply;
-        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
-        status_t result = remote()->transact(GET_CONSUMER_NAME, data, &reply);
-        if (result != NO_ERROR) {
-            ALOGE("getConsumerName failed to transact: %d", result);
-            return String8("TransactFailed");
-        }
-        return reply.readString8();
-    }
 };
 
-// Out-of-line virtual method definition to trigger vtable emission in this
-// translation unit (see clang warning -Wweak-vtables)
-BpGraphicBufferProducer::~BpGraphicBufferProducer() {}
-
 IMPLEMENT_META_INTERFACE(GraphicBufferProducer, "android.gui.IGraphicBufferProducer");
 
 // ----------------------------------------------------------------------
@@ -333,25 +289,24 @@ status_t BnGraphicBufferProducer::onTransact(
             }
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case SET_BUFFER_COUNT: {
             CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
             int bufferCount = data.readInt32();
             int result = setBufferCount(bufferCount);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case DEQUEUE_BUFFER: {
             CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
-            bool async = static_cast<bool>(data.readInt32());
-            uint32_t width = data.readUint32();
-            uint32_t height = data.readUint32();
-            PixelFormat format = static_cast<PixelFormat>(data.readInt32());
-            uint32_t usage = data.readUint32();
+            bool async      = data.readInt32();
+            uint32_t w      = data.readInt32();
+            uint32_t h      = data.readInt32();
+            uint32_t format = data.readInt32();
+            uint32_t usage  = data.readInt32();
             int buf;
             sp<Fence> fence;
-            int result = dequeueBuffer(&buf, &fence, async, width, height,
-                    format, usage);
+            int result = dequeueBuffer(&buf, &fence, async, w, h, format, usage);
             reply->writeInt32(buf);
             reply->writeInt32(fence != NULL);
             if (fence != NULL) {
@@ -359,14 +314,14 @@ status_t BnGraphicBufferProducer::onTransact(
             }
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case DETACH_BUFFER: {
             CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
             int slot = data.readInt32();
             int result = detachBuffer(slot);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case DETACH_NEXT_BUFFER: {
             CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
             sp<GraphicBuffer> buffer;
@@ -384,7 +339,7 @@ status_t BnGraphicBufferProducer::onTransact(
                 }
             }
             return NO_ERROR;
-        }
+        } break;
         case ATTACH_BUFFER: {
             CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
             sp<GraphicBuffer> buffer = new GraphicBuffer();
@@ -394,7 +349,7 @@ status_t BnGraphicBufferProducer::onTransact(
             reply->writeInt32(slot);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case QUEUE_BUFFER: {
             CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
             int buf = data.readInt32();
@@ -405,7 +360,7 @@ status_t BnGraphicBufferProducer::onTransact(
             status_t result = queueBuffer(buf, input, output);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case CANCEL_BUFFER: {
             CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
             int buf = data.readInt32();
@@ -413,7 +368,7 @@ status_t BnGraphicBufferProducer::onTransact(
             data.read(*fence.get());
             cancelBuffer(buf, fence);
             return NO_ERROR;
-        }
+        } break;
         case QUERY: {
             CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
             int value;
@@ -422,7 +377,7 @@ status_t BnGraphicBufferProducer::onTransact(
             reply->writeInt32(value);
             reply->writeInt32(res);
             return NO_ERROR;
-        }
+        } break;
         case CONNECT: {
             CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
             sp<IProducerListener> listener;
@@ -437,14 +392,14 @@ status_t BnGraphicBufferProducer::onTransact(
             status_t res = connect(listener, api, producerControlledByApp, output);
             reply->writeInt32(res);
             return NO_ERROR;
-        }
+        } break;
         case DISCONNECT: {
             CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
             int api = data.readInt32();
             status_t res = disconnect(api);
             reply->writeInt32(res);
             return NO_ERROR;
-        }
+        } break;
         case SET_SIDEBAND_STREAM: {
             CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
             sp<NativeHandle> stream;
@@ -454,36 +409,16 @@ status_t BnGraphicBufferProducer::onTransact(
             status_t result = setSidebandStream(stream);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
-        case ALLOCATE_BUFFERS: {
+        } break;
+        case ALLOCATE_BUFFERS:
             CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
             bool async = static_cast<bool>(data.readInt32());
-            uint32_t width = data.readUint32();
-            uint32_t height = data.readUint32();
-            PixelFormat format = static_cast<PixelFormat>(data.readInt32());
-            uint32_t usage = data.readUint32();
+            uint32_t width = static_cast<uint32_t>(data.readInt32());
+            uint32_t height = static_cast<uint32_t>(data.readInt32());
+            uint32_t format = static_cast<uint32_t>(data.readInt32());
+            uint32_t usage = static_cast<uint32_t>(data.readInt32());
             allocateBuffers(async, width, height, format, usage);
             return NO_ERROR;
-        }
-        case ALLOW_ALLOCATION: {
-            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
-            bool allow = static_cast<bool>(data.readInt32());
-            status_t result = allowAllocation(allow);
-            reply->writeInt32(result);
-            return NO_ERROR;
-        }
-        case SET_GENERATION_NUMBER: {
-            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
-            uint32_t generationNumber = data.readUint32();
-            status_t result = setGenerationNumber(generationNumber);
-            reply->writeInt32(result);
-            return NO_ERROR;
-        }
-        case GET_CONSUMER_NAME: {
-            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);
-            reply->writeString8(getConsumerName());
-            return NO_ERROR;
-        }
     }
     return BBinder::onTransact(code, data, reply, flags);
 }
@@ -497,14 +432,12 @@ IGraphicBufferProducer::QueueBufferInput::QueueBufferInput(const Parcel& parcel)
 size_t IGraphicBufferProducer::QueueBufferInput::getFlattenedSize() const {
     return sizeof(timestamp)
          + sizeof(isAutoTimestamp)
-         + sizeof(dataSpace)
          + sizeof(crop)
          + sizeof(scalingMode)
          + sizeof(transform)
          + sizeof(stickyTransform)
          + sizeof(async)
-         + fence->getFlattenedSize()
-         + surfaceDamage.getFlattenedSize();
+         + fence->getFlattenedSize();
 }
 
 size_t IGraphicBufferProducer::QueueBufferInput::getFdCount() const {
@@ -519,17 +452,12 @@ status_t IGraphicBufferProducer::QueueBufferInput::flatten(
     }
     FlattenableUtils::write(buffer, size, timestamp);
     FlattenableUtils::write(buffer, size, isAutoTimestamp);
-    FlattenableUtils::write(buffer, size, dataSpace);
     FlattenableUtils::write(buffer, size, crop);
     FlattenableUtils::write(buffer, size, scalingMode);
     FlattenableUtils::write(buffer, size, transform);
     FlattenableUtils::write(buffer, size, stickyTransform);
     FlattenableUtils::write(buffer, size, async);
-    status_t result = fence->flatten(buffer, size, fds, count);
-    if (result != NO_ERROR) {
-        return result;
-    }
-    return surfaceDamage.flatten(buffer, size);
+    return fence->flatten(buffer, size, fds, count);
 }
 
 status_t IGraphicBufferProducer::QueueBufferInput::unflatten(
@@ -538,7 +466,6 @@ status_t IGraphicBufferProducer::QueueBufferInput::unflatten(
     size_t minNeeded =
               sizeof(timestamp)
             + sizeof(isAutoTimestamp)
-            + sizeof(dataSpace)
             + sizeof(crop)
             + sizeof(scalingMode)
             + sizeof(transform)
@@ -551,7 +478,6 @@ status_t IGraphicBufferProducer::QueueBufferInput::unflatten(
 
     FlattenableUtils::read(buffer, size, timestamp);
     FlattenableUtils::read(buffer, size, isAutoTimestamp);
-    FlattenableUtils::read(buffer, size, dataSpace);
     FlattenableUtils::read(buffer, size, crop);
     FlattenableUtils::read(buffer, size, scalingMode);
     FlattenableUtils::read(buffer, size, transform);
@@ -559,11 +485,7 @@ status_t IGraphicBufferProducer::QueueBufferInput::unflatten(
     FlattenableUtils::read(buffer, size, async);
 
     fence = new Fence();
-    status_t result = fence->unflatten(buffer, size, fds, count);
-    if (result != NO_ERROR) {
-        return result;
-    }
-    return surfaceDamage.unflatten(buffer, size);
+    return fence->unflatten(buffer, size, fds, count);
 }
 
 }; // namespace android
diff --git a/libs/gui/IProducerListener.cpp b/libs/gui/IProducerListener.cpp
index 81adc95..efe4069 100644
--- a/libs/gui/IProducerListener.cpp
+++ b/libs/gui/IProducerListener.cpp
@@ -30,8 +30,6 @@ public:
     BpProducerListener(const sp<IBinder>& impl)
         : BpInterface<IProducerListener>(impl) {}
 
-    virtual ~BpProducerListener();
-
     virtual void onBufferReleased() {
         Parcel data, reply;
         data.writeInterfaceToken(IProducerListener::getInterfaceDescriptor());
@@ -39,10 +37,6 @@ public:
     }
 };
 
-// Out-of-line virtual method definition to trigger vtable emission in this
-// translation unit (see clang warning -Wweak-vtables)
-BpProducerListener::~BpProducerListener() {}
-
 IMPLEMENT_META_INTERFACE(ProducerListener, "android.gui.IProducerListener")
 
 status_t BnProducerListener::onTransact(uint32_t code, const Parcel& data,
diff --git a/libs/gui/ISensorEventConnection.cpp b/libs/gui/ISensorEventConnection.cpp
index dc7a35c..28fcb53 100644
--- a/libs/gui/ISensorEventConnection.cpp
+++ b/libs/gui/ISensorEventConnection.cpp
@@ -45,8 +45,6 @@ public:
     {
     }
 
-    virtual ~BpSensorEventConnection();
-
     virtual sp<BitTube> getSensorChannel() const
     {
         Parcel data, reply;
@@ -87,10 +85,6 @@ public:
     }
 };
 
-// Out-of-line virtual method definition to trigger vtable emission in this
-// translation unit (see clang warning -Wweak-vtables)
-BpSensorEventConnection::~BpSensorEventConnection() {}
-
 IMPLEMENT_META_INTERFACE(SensorEventConnection, "android.gui.SensorEventConnection");
 
 // ----------------------------------------------------------------------------
@@ -104,7 +98,7 @@ status_t BnSensorEventConnection::onTransact(
             sp<BitTube> channel(getSensorChannel());
             channel->writeToParcel(reply);
             return NO_ERROR;
-        }
+        } break;
         case ENABLE_DISABLE: {
             CHECK_INTERFACE(ISensorEventConnection, data, reply);
             int handle = data.readInt32();
@@ -116,21 +110,21 @@ status_t BnSensorEventConnection::onTransact(
                                             maxBatchReportLatencyNs, reservedFlags);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case SET_EVENT_RATE: {
             CHECK_INTERFACE(ISensorEventConnection, data, reply);
             int handle = data.readInt32();
-            nsecs_t ns = data.readInt64();
+            int ns = data.readInt64();
             status_t result = setEventRate(handle, ns);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case FLUSH_SENSOR: {
             CHECK_INTERFACE(ISensorEventConnection, data, reply);
             status_t result = flush();
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
     }
     return BBinder::onTransact(code, data, reply, flags);
 }
diff --git a/libs/gui/ISensorServer.cpp b/libs/gui/ISensorServer.cpp
index f581b5c..0b76f37 100644
--- a/libs/gui/ISensorServer.cpp
+++ b/libs/gui/ISensorServer.cpp
@@ -35,7 +35,6 @@ namespace android {
 enum {
     GET_SENSOR_LIST = IBinder::FIRST_CALL_TRANSACTION,
     CREATE_SENSOR_EVENT_CONNECTION,
-    ENABLE_DATA_INJECTION
 };
 
 class BpSensorServer : public BpInterface<ISensorServer>
@@ -46,17 +45,14 @@ public:
     {
     }
 
-    virtual ~BpSensorServer();
-
-    virtual Vector<Sensor> getSensorList(const String16& opPackageName)
+    virtual Vector<Sensor> getSensorList()
     {
         Parcel data, reply;
         data.writeInterfaceToken(ISensorServer::getInterfaceDescriptor());
-        data.writeString16(opPackageName);
         remote()->transact(GET_SENSOR_LIST, data, &reply);
         Sensor s;
         Vector<Sensor> v;
-        uint32_t n = reply.readUint32();
+        int32_t n = reply.readInt32();
         v.setCapacity(n);
         while (n--) {
             reply.read(s);
@@ -65,30 +61,15 @@ public:
         return v;
     }
 
-    virtual sp<ISensorEventConnection> createSensorEventConnection(const String8& packageName,
-             int mode, const String16& opPackageName)
+    virtual sp<ISensorEventConnection> createSensorEventConnection()
     {
         Parcel data, reply;
         data.writeInterfaceToken(ISensorServer::getInterfaceDescriptor());
-        data.writeString8(packageName);
-        data.writeInt32(mode);
-        data.writeString16(opPackageName);
         remote()->transact(CREATE_SENSOR_EVENT_CONNECTION, data, &reply);
         return interface_cast<ISensorEventConnection>(reply.readStrongBinder());
     }
-
-    virtual int isDataInjectionEnabled() {
-        Parcel data, reply;
-        data.writeInterfaceToken(ISensorServer::getInterfaceDescriptor());
-        remote()->transact(ENABLE_DATA_INJECTION, data, &reply);
-        return reply.readInt32();
-    }
 };
 
-// Out-of-line virtual method definition to trigger vtable emission in this
-// translation unit (see clang warning -Wweak-vtables)
-BpSensorServer::~BpSensorServer() {}
-
 IMPLEMENT_META_INTERFACE(SensorServer, "android.gui.SensorServer");
 
 // ----------------------------------------------------------------------
@@ -99,31 +80,20 @@ status_t BnSensorServer::onTransact(
     switch(code) {
         case GET_SENSOR_LIST: {
             CHECK_INTERFACE(ISensorServer, data, reply);
-            const String16& opPackageName = data.readString16();
-            Vector<Sensor> v(getSensorList(opPackageName));
+            Vector<Sensor> v(getSensorList());
             size_t n = v.size();
-            reply->writeUint32(static_cast<uint32_t>(n));
-            for (size_t i = 0; i < n; i++) {
+            reply->writeInt32(n);
+            for (size_t i=0 ; i<n ; i++) {
                 reply->write(v[i]);
             }
             return NO_ERROR;
-        }
+        } break;
         case CREATE_SENSOR_EVENT_CONNECTION: {
             CHECK_INTERFACE(ISensorServer, data, reply);
-            String8 packageName = data.readString8();
-            int32_t mode = data.readInt32();
-            const String16& opPackageName = data.readString16();
-            sp<ISensorEventConnection> connection(createSensorEventConnection(packageName, mode,
-                    opPackageName));
-            reply->writeStrongBinder(IInterface::asBinder(connection));
+            sp<ISensorEventConnection> connection(createSensorEventConnection());
+            reply->writeStrongBinder(connection->asBinder());
             return NO_ERROR;
-        }
-        case ENABLE_DATA_INJECTION: {
-            CHECK_INTERFACE(ISensorServer, data, reply);
-            int32_t ret = isDataInjectionEnabled();
-            reply->writeInt32(static_cast<int32_t>(ret));
-            return NO_ERROR;
-        }
+        } break;
     }
     return BBinder::onTransact(code, data, reply, flags);
 }
diff --git a/libs/gui/ISurfaceComposer.cpp b/libs/gui/ISurfaceComposer.cpp
index 78886d5..9313b9c 100644
--- a/libs/gui/ISurfaceComposer.cpp
+++ b/libs/gui/ISurfaceComposer.cpp
@@ -51,10 +51,9 @@ public:
     {
     }
 
-    virtual ~BpSurfaceComposer();
-
     virtual sp<ISurfaceComposerClient> createConnection()
     {
+        uint32_t n;
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
         remote()->transact(BnSurfaceComposer::CREATE_CONNECTION, data, &reply);
@@ -63,6 +62,7 @@ public:
 
     virtual sp<IGraphicBufferAlloc> createGraphicBufferAlloc()
     {
+        uint32_t n;
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
         remote()->transact(BnSurfaceComposer::CREATE_GRAPHIC_BUFFER_ALLOC, data, &reply);
@@ -76,18 +76,23 @@ public:
     {
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
-
-        data.writeUint32(static_cast<uint32_t>(state.size()));
-        for (const auto& s : state) {
-            s.write(data);
+        {
+            Vector<ComposerState>::const_iterator b(state.begin());
+            Vector<ComposerState>::const_iterator e(state.end());
+            data.writeInt32(state.size());
+            for ( ; b != e ; ++b ) {
+                b->write(data);
+            }
         }
-
-        data.writeUint32(static_cast<uint32_t>(displays.size()));
-        for (const auto& d : displays) {
-            d.write(data);
+        {
+            Vector<DisplayState>::const_iterator b(displays.begin());
+            Vector<DisplayState>::const_iterator e(displays.end());
+            data.writeInt32(displays.size());
+            for ( ; b != e ; ++b ) {
+                b->write(data);
+            }
         }
-
-        data.writeUint32(flags);
+        data.writeInt32(flags);
         remote()->transact(BnSurfaceComposer::SET_TRANSACTION_STATE, data, &reply);
     }
 
@@ -103,19 +108,21 @@ public:
             Rect sourceCrop, uint32_t reqWidth, uint32_t reqHeight,
             uint32_t minLayerZ, uint32_t maxLayerZ,
             bool useIdentityTransform,
-            ISurfaceComposer::Rotation rotation)
+            ISurfaceComposer::Rotation rotation,
+            bool isCpuConsumer)
     {
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceComposer::getInterfaceDescriptor());
         data.writeStrongBinder(display);
-        data.writeStrongBinder(IInterface::asBinder(producer));
+        data.writeStrongBinder(producer->asBinder());
         data.write(sourceCrop);
-        data.writeUint32(reqWidth);
-        data.writeUint32(reqHeight);
-        data.writeUint32(minLayerZ);
-        data.writeUint32(maxLayerZ);
+        data.writeInt32(reqWidth);
+        data.writeInt32(reqHeight);
+        data.writeInt32(minLayerZ);
+        data.writeInt32(maxLayerZ);
         data.writeInt32(static_cast<int32_t>(useIdentityTransform));
         data.writeInt32(static_cast<int32_t>(rotation));
+        data.writeInt32(isCpuConsumer);
         remote()->transact(BnSurfaceComposer::CAPTURE_SCREEN, data, &reply);
         return reply.readInt32();
     }
@@ -132,7 +139,7 @@ public:
                     "interface descriptor: %s (%d)", strerror(-err), -err);
             return false;
         }
-        err = data.writeStrongBinder(IInterface::asBinder(bufferProducer));
+        err = data.writeStrongBinder(bufferProducer->asBinder());
         if (err != NO_ERROR) {
             ALOGE("ISurfaceComposer::authenticateSurfaceTexture: error writing "
                     "strong binder to parcel: %s (%d)", strerror(-err), -err);
@@ -221,7 +228,7 @@ public:
         remote()->transact(BnSurfaceComposer::GET_DISPLAY_CONFIGS, data, &reply);
         status_t result = reply.readInt32();
         if (result == NO_ERROR) {
-            size_t numConfigs = reply.readUint32();
+            size_t numConfigs = static_cast<size_t>(reply.readInt32());
             configs->clear();
             configs->resize(numConfigs);
             for (size_t c = 0; c < numConfigs; ++c) {
@@ -284,10 +291,6 @@ public:
     }
 };
 
-// Out-of-line virtual method definition to trigger vtable emission in this
-// translation unit (see clang warning -Wweak-vtables)
-BpSurfaceComposer::~BpSurfaceComposer() {}
-
 IMPLEMENT_META_INTERFACE(SurfaceComposer, "android.ui.ISurfaceComposer");
 
 // ----------------------------------------------------------------------
@@ -298,49 +301,46 @@ status_t BnSurfaceComposer::onTransact(
     switch(code) {
         case CREATE_CONNECTION: {
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
-            sp<IBinder> b = IInterface::asBinder(createConnection());
+            sp<IBinder> b = createConnection()->asBinder();
             reply->writeStrongBinder(b);
             return NO_ERROR;
         }
         case CREATE_GRAPHIC_BUFFER_ALLOC: {
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
-            sp<IBinder> b = IInterface::asBinder(createGraphicBufferAlloc());
+            sp<IBinder> b = createGraphicBufferAlloc()->asBinder();
             reply->writeStrongBinder(b);
             return NO_ERROR;
         }
         case SET_TRANSACTION_STATE: {
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
-
-            size_t count = data.readUint32();
+            size_t count = data.readInt32();
             if (count > data.dataSize()) {
                 return BAD_VALUE;
             }
             ComposerState s;
             Vector<ComposerState> state;
             state.setCapacity(count);
-            for (size_t i = 0; i < count; i++) {
+            for (size_t i=0 ; i<count ; i++) {
                 if (s.read(data) == BAD_VALUE) {
                     return BAD_VALUE;
                 }
                 state.add(s);
             }
-
-            count = data.readUint32();
+            count = data.readInt32();
             if (count > data.dataSize()) {
                 return BAD_VALUE;
             }
             DisplayState d;
             Vector<DisplayState> displays;
             displays.setCapacity(count);
-            for (size_t i = 0; i < count; i++) {
+            for (size_t i=0 ; i<count ; i++) {
                 if (d.read(data) == BAD_VALUE) {
                     return BAD_VALUE;
                 }
                 displays.add(d);
             }
-
-            uint32_t stateFlags = data.readUint32();
-            setTransactionState(state, displays, stateFlags);
+            uint32_t flags = data.readInt32();
+            setTransactionState(state, displays, flags);
             return NO_ERROR;
         }
         case BOOT_FINISHED: {
@@ -355,17 +355,18 @@ status_t BnSurfaceComposer::onTransact(
                     interface_cast<IGraphicBufferProducer>(data.readStrongBinder());
             Rect sourceCrop;
             data.read(sourceCrop);
-            uint32_t reqWidth = data.readUint32();
-            uint32_t reqHeight = data.readUint32();
-            uint32_t minLayerZ = data.readUint32();
-            uint32_t maxLayerZ = data.readUint32();
+            uint32_t reqWidth = data.readInt32();
+            uint32_t reqHeight = data.readInt32();
+            uint32_t minLayerZ = data.readInt32();
+            uint32_t maxLayerZ = data.readInt32();
             bool useIdentityTransform = static_cast<bool>(data.readInt32());
-            int32_t rotation = data.readInt32();
-
+            uint32_t rotation = data.readInt32();
+            bool isCpuConsumer = data.readInt32();
             status_t res = captureScreen(display, producer,
                     sourceCrop, reqWidth, reqHeight, minLayerZ, maxLayerZ,
                     useIdentityTransform,
-                    static_cast<ISurfaceComposer::Rotation>(rotation));
+                    static_cast<ISurfaceComposer::Rotation>(rotation),
+                    isCpuConsumer);
             reply->writeInt32(res);
             return NO_ERROR;
         }
@@ -380,7 +381,7 @@ status_t BnSurfaceComposer::onTransact(
         case CREATE_DISPLAY_EVENT_CONNECTION: {
             CHECK_INTERFACE(ISurfaceComposer, data, reply);
             sp<IDisplayEventConnection> connection(createDisplayEventConnection());
-            reply->writeStrongBinder(IInterface::asBinder(connection));
+            reply->writeStrongBinder(connection->asBinder());
             return NO_ERROR;
         }
         case CREATE_DISPLAY: {
@@ -411,7 +412,7 @@ status_t BnSurfaceComposer::onTransact(
             status_t result = getDisplayConfigs(display, &configs);
             reply->writeInt32(result);
             if (result == NO_ERROR) {
-                reply->writeUint32(static_cast<uint32_t>(configs.size()));
+                reply->writeInt32(static_cast<int32_t>(configs.size()));
                 for (size_t c = 0; c < configs.size(); ++c) {
                     memcpy(reply->writeInplace(sizeof(DisplayInfo)),
                             &configs[c], sizeof(DisplayInfo));
@@ -471,6 +472,8 @@ status_t BnSurfaceComposer::onTransact(
             return BBinder::onTransact(code, data, reply, flags);
         }
     }
+    // should be unreachable
+    return NO_ERROR;
 }
 
 // ----------------------------------------------------------------------------
diff --git a/libs/gui/ISurfaceComposerClient.cpp b/libs/gui/ISurfaceComposerClient.cpp
index 2ecb908..3da6423 100644
--- a/libs/gui/ISurfaceComposerClient.cpp
+++ b/libs/gui/ISurfaceComposerClient.cpp
@@ -51,19 +51,17 @@ public:
         : BpInterface<ISurfaceComposerClient>(impl) {
     }
 
-    virtual ~BpSurfaceComposerClient();
-
-    virtual status_t createSurface(const String8& name, uint32_t width,
-            uint32_t height, PixelFormat format, uint32_t flags,
+    virtual status_t createSurface(const String8& name, uint32_t w,
+            uint32_t h, PixelFormat format, uint32_t flags,
             sp<IBinder>* handle,
             sp<IGraphicBufferProducer>* gbp) {
         Parcel data, reply;
         data.writeInterfaceToken(ISurfaceComposerClient::getInterfaceDescriptor());
         data.writeString8(name);
-        data.writeUint32(width);
-        data.writeUint32(height);
-        data.writeInt32(static_cast<int32_t>(format));
-        data.writeUint32(flags);
+        data.writeInt32(w);
+        data.writeInt32(h);
+        data.writeInt32(format);
+        data.writeInt32(flags);
         remote()->transact(CREATE_SURFACE, data, &reply);
         *handle = reply.readStrongBinder();
         *gbp = interface_cast<IGraphicBufferProducer>(reply.readStrongBinder());
@@ -96,10 +94,6 @@ public:
     }
 };
 
-// Out-of-line virtual method definition to trigger vtable emission in this
-// translation unit (see clang warning -Wweak-vtables)
-BpSurfaceComposerClient::~BpSurfaceComposerClient() {}
-
 IMPLEMENT_META_INTERFACE(SurfaceComposerClient, "android.ui.ISurfaceComposerClient");
 
 // ----------------------------------------------------------------------
@@ -111,31 +105,31 @@ status_t BnSurfaceComposerClient::onTransact(
         case CREATE_SURFACE: {
             CHECK_INTERFACE(ISurfaceComposerClient, data, reply);
             String8 name = data.readString8();
-            uint32_t width = data.readUint32();
-            uint32_t height = data.readUint32();
-            PixelFormat format = static_cast<PixelFormat>(data.readInt32());
-            uint32_t createFlags = data.readUint32();
+            uint32_t w = data.readInt32();
+            uint32_t h = data.readInt32();
+            PixelFormat format = data.readInt32();
+            uint32_t flags = data.readInt32();
             sp<IBinder> handle;
             sp<IGraphicBufferProducer> gbp;
-            status_t result = createSurface(name, width, height, format,
-                    createFlags, &handle, &gbp);
+            status_t result = createSurface(name, w, h, format, flags,
+                    &handle, &gbp);
             reply->writeStrongBinder(handle);
-            reply->writeStrongBinder(IInterface::asBinder(gbp));
+            reply->writeStrongBinder(gbp->asBinder());
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case DESTROY_SURFACE: {
             CHECK_INTERFACE(ISurfaceComposerClient, data, reply);
             reply->writeInt32(destroySurface( data.readStrongBinder() ) );
             return NO_ERROR;
-        }
+        } break;
        case CLEAR_LAYER_FRAME_STATS: {
             CHECK_INTERFACE(ISurfaceComposerClient, data, reply);
             sp<IBinder> handle = data.readStrongBinder();
             status_t result = clearLayerFrameStats(handle);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         case GET_LAYER_FRAME_STATS: {
             CHECK_INTERFACE(ISurfaceComposerClient, data, reply);
             sp<IBinder> handle = data.readStrongBinder();
@@ -144,7 +138,7 @@ status_t BnSurfaceComposerClient::onTransact(
             reply->write(stats);
             reply->writeInt32(result);
             return NO_ERROR;
-        }
+        } break;
         default:
             return BBinder::onTransact(code, data, reply, flags);
     }
diff --git a/libs/gui/LayerState.cpp b/libs/gui/LayerState.cpp
index 00323dc..1183d59 100644
--- a/libs/gui/LayerState.cpp
+++ b/libs/gui/LayerState.cpp
@@ -25,16 +25,16 @@ namespace android {
 status_t layer_state_t::write(Parcel& output) const
 {
     output.writeStrongBinder(surface);
-    output.writeUint32(what);
+    output.writeInt32(what);
     output.writeFloat(x);
     output.writeFloat(y);
-    output.writeUint32(z);
-    output.writeUint32(w);
-    output.writeUint32(h);
-    output.writeUint32(layerStack);
+    output.writeInt32(z);
+    output.writeInt32(w);
+    output.writeInt32(h);
+    output.writeInt32(layerStack);
     output.writeFloat(alpha);
-    output.writeUint32(flags);
-    output.writeUint32(mask);
+    output.writeInt32(flags);
+    output.writeInt32(mask);
     *reinterpret_cast<layer_state_t::matrix22_t *>(
             output.writeInplace(sizeof(layer_state_t::matrix22_t))) = matrix;
     output.write(crop);
@@ -45,16 +45,16 @@ status_t layer_state_t::write(Parcel& output) const
 status_t layer_state_t::read(const Parcel& input)
 {
     surface = input.readStrongBinder();
-    what = input.readUint32();
+    what = input.readInt32();
     x = input.readFloat();
     y = input.readFloat();
-    z = input.readUint32();
-    w = input.readUint32();
-    h = input.readUint32();
-    layerStack = input.readUint32();
+    z = input.readInt32();
+    w = input.readInt32();
+    h = input.readInt32();
+    layerStack = input.readInt32();
     alpha = input.readFloat();
-    flags = static_cast<uint8_t>(input.readUint32());
-    mask = static_cast<uint8_t>(input.readUint32());
+    flags = input.readInt32();
+    mask = input.readInt32();
     const void* matrix_data = input.readInplace(sizeof(layer_state_t::matrix22_t));
     if (matrix_data) {
         matrix = *reinterpret_cast<layer_state_t::matrix22_t const *>(matrix_data);
@@ -67,7 +67,7 @@ status_t layer_state_t::read(const Parcel& input)
 }
 
 status_t ComposerState::write(Parcel& output) const {
-    output.writeStrongBinder(IInterface::asBinder(client));
+    output.writeStrongBinder(client->asBinder());
     return state.write(output);
 }
 
@@ -79,27 +79,27 @@ status_t ComposerState::read(const Parcel& input) {
 
 status_t DisplayState::write(Parcel& output) const {
     output.writeStrongBinder(token);
-    output.writeStrongBinder(IInterface::asBinder(surface));
-    output.writeUint32(what);
-    output.writeUint32(layerStack);
-    output.writeUint32(orientation);
+    output.writeStrongBinder(surface->asBinder());
+    output.writeInt32(what);
+    output.writeInt32(layerStack);
+    output.writeInt32(orientation);
     output.write(viewport);
     output.write(frame);
-    output.writeUint32(width);
-    output.writeUint32(height);
+    output.writeInt32(width);
+    output.writeInt32(height);
     return NO_ERROR;
 }
 
 status_t DisplayState::read(const Parcel& input) {
     token = input.readStrongBinder();
     surface = interface_cast<IGraphicBufferProducer>(input.readStrongBinder());
-    what = input.readUint32();
-    layerStack = input.readUint32();
-    orientation = input.readUint32();
+    what = input.readInt32();
+    layerStack = input.readInt32();
+    orientation = input.readInt32();
     input.read(viewport);
     input.read(frame);
-    width = input.readUint32();
-    height = input.readUint32();
+    width = input.readInt32();
+    height = input.readInt32();
     return NO_ERROR;
 }
 
diff --git a/libs/gui/Sensor.cpp b/libs/gui/Sensor.cpp
index 4b3603e..b4291bb 100644
--- a/libs/gui/Sensor.cpp
+++ b/libs/gui/Sensor.cpp
@@ -25,9 +25,6 @@
 
 #include <hardware/sensors.h>
 
-#include <binder/AppOpsManager.h>
-#include <binder/IServiceManager.h>
-
 #include <gui/Sensor.h>
 #include <log/log.h>
 
@@ -75,7 +72,7 @@ Sensor::Sensor(struct sensor_t const* hwSensor, int halVersion)
                   static_cast<int64_t>(hwSensor->maxDelay));
             mMaxDelay = INT_MAX;
         } else {
-            mMaxDelay = static_cast<int32_t>(hwSensor->maxDelay);
+            mMaxDelay = (int32_t) hwSensor->maxDelay;
         }
     } else {
         // For older hals set maxDelay to 0.
@@ -116,13 +113,11 @@ Sensor::Sensor(struct sensor_t const* hwSensor, int halVersion)
         mStringType = SENSOR_STRING_TYPE_GYROSCOPE_UNCALIBRATED;
         mFlags |= SENSOR_FLAG_CONTINUOUS_MODE;
         break;
-    case SENSOR_TYPE_HEART_RATE: {
+    case SENSOR_TYPE_HEART_RATE:
         mStringType = SENSOR_STRING_TYPE_HEART_RATE;
         mRequiredPermission = SENSOR_PERMISSION_BODY_SENSORS;
-        AppOpsManager appOps;
-        mRequiredAppOp = appOps.permissionToOpCode(String16(SENSOR_PERMISSION_BODY_SENSORS));
         mFlags |= SENSOR_FLAG_ON_CHANGE_MODE;
-        } break;
+        break;
     case SENSOR_TYPE_LIGHT:
         mStringType = SENSOR_STRING_TYPE_LIGHT;
         mFlags |= SENSOR_FLAG_ON_CHANGE_MODE;
@@ -209,13 +204,6 @@ Sensor::Sensor(struct sensor_t const* hwSensor, int halVersion)
             mFlags |= SENSOR_FLAG_WAKE_UP;
         }
         break;
-    case SENSOR_TYPE_WRIST_TILT_GESTURE:
-        mStringType = SENSOR_STRING_TYPE_WRIST_TILT_GESTURE;
-        mFlags |= SENSOR_FLAG_SPECIAL_REPORTING_MODE;
-        if (halVersion < SENSORS_DEVICE_API_VERSION_1_3) {
-            mFlags |= SENSOR_FLAG_WAKE_UP;
-        }
-        break;
     default:
         // Only pipe the stringType, requiredPermission and flags for custom sensors.
         if (halVersion > SENSORS_DEVICE_API_VERSION_1_0 && hwSensor->stringType) {
@@ -223,14 +211,10 @@ Sensor::Sensor(struct sensor_t const* hwSensor, int halVersion)
         }
         if (halVersion > SENSORS_DEVICE_API_VERSION_1_0 && hwSensor->requiredPermission) {
             mRequiredPermission = hwSensor->requiredPermission;
-            if (!strcmp(mRequiredPermission, SENSOR_PERMISSION_BODY_SENSORS)) {
-                AppOpsManager appOps;
-                mRequiredAppOp = appOps.permissionToOpCode(String16(SENSOR_PERMISSION_BODY_SENSORS));
-            }
         }
 
         if (halVersion >= SENSORS_DEVICE_API_VERSION_1_3) {
-            mFlags = static_cast<uint32_t>(hwSensor->flags);
+            mFlags = (int32_t) hwSensor->flags;
         } else {
             // This is an OEM defined sensor on an older HAL. Use minDelay to determine the
             // reporting mode of the sensor.
@@ -261,17 +245,6 @@ Sensor::Sensor(struct sensor_t const* hwSensor, int halVersion)
 
         }
     }
-
-    if (mRequiredPermission.length() > 0) {
-        // If the sensor is protected by a permission we need to know if it is
-        // a runtime one to determine whether we can use the permission cache.
-        sp<IBinder> binder = defaultServiceManager()->getService(String16("permission"));
-        if (binder != 0) {
-            sp<IPermissionController> permCtrl = interface_cast<IPermissionController>(binder);
-            mRequiredPermissionRuntime = permCtrl->isRuntimePermission(
-                    String16(mRequiredPermission));
-        }
-    }
 }
 
 Sensor::~Sensor()
@@ -322,11 +295,11 @@ int32_t Sensor::getVersion() const {
     return mVersion;
 }
 
-uint32_t Sensor::getFifoReservedEventCount() const {
+int32_t Sensor::getFifoReservedEventCount() const {
     return mFifoReservedEventCount;
 }
 
-uint32_t Sensor::getFifoMaxEventCount() const {
+int32_t Sensor::getFifoMaxEventCount() const {
     return mFifoMaxEventCount;
 }
 
@@ -338,19 +311,11 @@ const String8& Sensor::getRequiredPermission() const {
     return mRequiredPermission;
 }
 
-bool Sensor::isRequiredPermissionRuntime() const {
-    return mRequiredPermissionRuntime;
-}
-
-int32_t Sensor::getRequiredAppOp() const {
-    return mRequiredAppOp;
-}
-
 int32_t Sensor::getMaxDelay() const {
     return mMaxDelay;
 }
 
-uint32_t Sensor::getFlags() const {
+int32_t Sensor::getFlags() const {
     return mFlags;
 }
 
@@ -367,8 +332,7 @@ size_t Sensor::getFlattenedSize() const
     size_t fixedSize =
             sizeof(int32_t) * 3 +
             sizeof(float) * 4 +
-            sizeof(int32_t) * 6 +
-            sizeof(bool);
+            sizeof(int32_t) * 5;
 
     size_t variableSize =
             sizeof(uint32_t) + FlattenableUtils::align<4>(mName.length()) +
@@ -398,8 +362,6 @@ status_t Sensor::flatten(void* buffer, size_t size) const {
     FlattenableUtils::write(buffer, size, mFifoMaxEventCount);
     flattenString8(buffer, size, mStringType);
     flattenString8(buffer, size, mRequiredPermission);
-    FlattenableUtils::write(buffer, size, mRequiredPermissionRuntime);
-    FlattenableUtils::write(buffer, size, mRequiredAppOp);
     FlattenableUtils::write(buffer, size, mMaxDelay);
     FlattenableUtils::write(buffer, size, mFlags);
     return NO_ERROR;
@@ -438,8 +400,6 @@ status_t Sensor::unflatten(void const* buffer, size_t size) {
     if (!unflattenString8(buffer, size, mRequiredPermission)) {
         return NO_MEMORY;
     }
-    FlattenableUtils::read(buffer, size, mRequiredPermissionRuntime);
-    FlattenableUtils::read(buffer, size, mRequiredAppOp);
     FlattenableUtils::read(buffer, size, mMaxDelay);
     FlattenableUtils::read(buffer, size, mFlags);
     return NO_ERROR;
@@ -447,7 +407,7 @@ status_t Sensor::unflatten(void const* buffer, size_t size) {
 
 void Sensor::flattenString8(void*& buffer, size_t& size,
         const String8& string8) {
-    uint32_t len = static_cast<uint32_t>(string8.length());
+    uint32_t len = string8.length();
     FlattenableUtils::write(buffer, size, len);
     memcpy(static_cast<char*>(buffer), string8.string(), len);
     FlattenableUtils::advance(buffer, size, FlattenableUtils::align<4>(len));
diff --git a/libs/gui/SensorEventQueue.cpp b/libs/gui/SensorEventQueue.cpp
index 4b7986e..1305e9f 100644
--- a/libs/gui/SensorEventQueue.cpp
+++ b/libs/gui/SensorEventQueue.cpp
@@ -16,11 +16,9 @@
 
 #define LOG_TAG "Sensors"
 
-#include <algorithm>
 #include <stdint.h>
 #include <sys/types.h>
 #include <sys/socket.h>
-#include <linux/errno.h>
 
 #include <utils/Errors.h>
 #include <utils/RefBase.h>
@@ -33,8 +31,6 @@
 
 #include <android/sensor.h>
 
-using std::min;
-
 // ----------------------------------------------------------------------------
 namespace android {
 // ----------------------------------------------------------------------------
@@ -72,14 +68,14 @@ ssize_t SensorEventQueue::read(ASensorEvent* events, size_t numEvents) {
         if (err < 0) {
             return err;
         }
-        mAvailable = static_cast<size_t>(err);
+        mAvailable = err;
         mConsumed = 0;
     }
-    size_t count = min(numEvents, mAvailable);
-    memcpy(events, mRecBuffer + mConsumed, count * sizeof(ASensorEvent));
+    size_t count = numEvents < mAvailable ? numEvents : mAvailable;
+    memcpy(events, mRecBuffer + mConsumed, count*sizeof(ASensorEvent));
     mAvailable -= count;
     mConsumed += count;
-    return static_cast<ssize_t>(count);
+    return count;
 }
 
 sp<Looper> SensorEventQueue::getLooper() const
@@ -150,23 +146,6 @@ status_t SensorEventQueue::setEventRate(Sensor const* sensor, nsecs_t ns) const
     return mSensorEventConnection->setEventRate(sensor->getHandle(), ns);
 }
 
-status_t SensorEventQueue::injectSensorEvent(const ASensorEvent& event) {
-    do {
-        // Blocking call.
-        ssize_t size = ::send(mSensorChannel->getFd(), &event, sizeof(event), MSG_NOSIGNAL);
-        if (size >= 0) {
-            return NO_ERROR;
-        } else if (size < 0 && errno == EAGAIN) {
-            // If send is returning a "Try again" error, sleep for 100ms and try again. In all
-            // other cases log a failure and exit.
-            usleep(100000);
-        } else {
-            ALOGE("injectSensorEvent failure %s %zd", strerror(errno), size);
-            return INVALID_OPERATION;
-        }
-    } while (true);
-}
-
 void SensorEventQueue::sendAck(const ASensorEvent* events, int count) {
     for (int i = 0; i < count; ++i) {
         if (events[i].flags & WAKE_UP_SENSOR_EVENT_NEEDS_ACK) {
@@ -178,7 +157,7 @@ void SensorEventQueue::sendAck(const ASensorEvent* events, int count) {
         ssize_t size = ::send(mSensorChannel->getFd(), &mNumAcksToSend, sizeof(mNumAcksToSend),
                 MSG_DONTWAIT | MSG_NOSIGNAL);
         if (size < 0) {
-            ALOGE("sendAck failure %zd %d", size, mNumAcksToSend);
+            ALOGE("sendAck failure %d %d", size, mNumAcksToSend);
         } else {
             mNumAcksToSend = 0;
         }
diff --git a/libs/gui/SensorManager.cpp b/libs/gui/SensorManager.cpp
index dd37781..7b4fa2f 100644
--- a/libs/gui/SensorManager.cpp
+++ b/libs/gui/SensorManager.cpp
@@ -36,8 +36,10 @@
 namespace android {
 // ----------------------------------------------------------------------------
 
-SensorManager::SensorManager(const String16& opPackageName)
-    : mSensorList(0), mOpPackageName(opPackageName)
+ANDROID_SINGLETON_STATIC_INSTANCE(SensorManager)
+
+SensorManager::SensorManager()
+    : mSensorList(0)
 {
     // okay we're not locked here, but it's not needed during construction
     assertStateLocked();
@@ -84,12 +86,11 @@ status_t SensorManager::assertStateLocked() const {
         };
 
         mDeathObserver = new DeathObserver(*const_cast<SensorManager *>(this));
-        IInterface::asBinder(mSensorServer)->linkToDeath(mDeathObserver);
+        mSensorServer->asBinder()->linkToDeath(mDeathObserver);
 
-        mSensors = mSensorServer->getSensorList(mOpPackageName);
+        mSensors = mSensorServer->getSensorList();
         size_t count = mSensors.size();
-        mSensorList =
-                static_cast<Sensor const**>(malloc(count * sizeof(Sensor*)));
+        mSensorList = (Sensor const**)malloc(count * sizeof(Sensor*));
         for (size_t i=0 ; i<count ; i++) {
             mSensorList[i] = mSensors.array() + i;
         }
@@ -98,15 +99,17 @@ status_t SensorManager::assertStateLocked() const {
     return NO_ERROR;
 }
 
+
+
 ssize_t SensorManager::getSensorList(Sensor const* const** list) const
 {
     Mutex::Autolock _l(mLock);
     status_t err = assertStateLocked();
     if (err < 0) {
-        return static_cast<ssize_t>(err);
+        return ssize_t(err);
     }
     *list = mSensorList;
-    return static_cast<ssize_t>(mSensors.size());
+    return mSensors.size();
 }
 
 Sensor const* SensorManager::getDefaultSensor(int type)
@@ -135,17 +138,18 @@ Sensor const* SensorManager::getDefaultSensor(int type)
     return NULL;
 }
 
-sp<SensorEventQueue> SensorManager::createEventQueue(String8 packageName, int mode) {
+sp<SensorEventQueue> SensorManager::createEventQueue()
+{
     sp<SensorEventQueue> queue;
 
     Mutex::Autolock _l(mLock);
     while (assertStateLocked() == NO_ERROR) {
         sp<ISensorEventConnection> connection =
-                mSensorServer->createSensorEventConnection(packageName, mode, mOpPackageName);
+                mSensorServer->createSensorEventConnection();
         if (connection == NULL) {
-            // SensorService just died or the app doesn't have required permissions.
-            ALOGE("createEventQueue: connection is NULL.");
-            return NULL;
+            // SensorService just died.
+            ALOGE("createEventQueue: connection is NULL. SensorService died.");
+            continue;
         }
         queue = new SensorEventQueue(connection);
         break;
@@ -153,13 +157,5 @@ sp<SensorEventQueue> SensorManager::createEventQueue(String8 packageName, int mo
     return queue;
 }
 
-bool SensorManager::isDataInjectionEnabled() {
-    Mutex::Autolock _l(mLock);
-    if (assertStateLocked() == NO_ERROR) {
-        return mSensorServer->isDataInjectionEnabled();
-    }
-    return false;
-}
-
 // ----------------------------------------------------------------------------
 }; // namespace android
diff --git a/libs/gui/StreamSplitter.cpp b/libs/gui/StreamSplitter.cpp
index 43f9214..5f39905 100644
--- a/libs/gui/StreamSplitter.cpp
+++ b/libs/gui/StreamSplitter.cpp
@@ -20,7 +20,6 @@
 #define ATRACE_TAG ATRACE_TAG_GRAPHICS
 //#define LOG_NDEBUG 0
 
-#include <gui/BufferItem.h>
 #include <gui/IGraphicBufferConsumer.h>
 #include <gui/IGraphicBufferProducer.h>
 #include <gui/StreamSplitter.h>
@@ -81,7 +80,7 @@ status_t StreamSplitter::addOutput(
 
     IGraphicBufferProducer::QueueBufferOutput queueBufferOutput;
     sp<OutputListener> listener(new OutputListener(this, outputQueue));
-    IInterface::asBinder(outputQueue)->linkToDeath(listener);
+    outputQueue->asBinder()->linkToDeath(listener);
     status_t status = outputQueue->connect(listener, NATIVE_WINDOW_API_CPU,
             /* producerControlledByApp */ false, &queueBufferOutput);
     if (status != NO_ERROR) {
@@ -124,7 +123,7 @@ void StreamSplitter::onFrameAvailable(const BufferItem& /* item */) {
     ++mOutstandingBuffers;
 
     // Acquire and detach the buffer from the input
-    BufferItem bufferItem;
+    IGraphicBufferConsumer::BufferItem bufferItem;
     status_t status = mInput->acquireBuffer(&bufferItem, /* presentWhen */ 0);
     LOG_ALWAYS_FATAL_IF(status != NO_ERROR,
             "acquiring buffer from input failed (%d)", status);
@@ -142,8 +141,7 @@ void StreamSplitter::onFrameAvailable(const BufferItem& /* item */) {
 
     IGraphicBufferProducer::QueueBufferInput queueInput(
             bufferItem.mTimestamp, bufferItem.mIsAutoTimestamp,
-            bufferItem.mDataSpace, bufferItem.mCrop,
-            static_cast<int32_t>(bufferItem.mScalingMode),
+            bufferItem.mCrop, bufferItem.mScalingMode,
             bufferItem.mTransform, bufferItem.mIsDroppable,
             bufferItem.mFence);
 
diff --git a/libs/gui/Surface.cpp b/libs/gui/Surface.cpp
index 4b76f98..0e2baa2 100644
--- a/libs/gui/Surface.cpp
+++ b/libs/gui/Surface.cpp
@@ -27,7 +27,6 @@
 #include <utils/NativeHandle.h>
 
 #include <ui/Fence.h>
-#include <ui/Region.h>
 
 #include <gui/IProducerListener.h>
 #include <gui/ISurfaceComposer.h>
@@ -42,8 +41,7 @@ namespace android {
 Surface::Surface(
         const sp<IGraphicBufferProducer>& bufferProducer,
         bool controlledByApp)
-    : mGraphicBufferProducer(bufferProducer),
-      mGenerationNumber(0)
+    : mGraphicBufferProducer(bufferProducer)
 {
     // Initialize the ANativeWindow function pointers.
     ANativeWindow::setSwapInterval  = hook_setSwapInterval;
@@ -66,7 +64,6 @@ Surface::Surface(
     mReqFormat = 0;
     mReqUsage = 0;
     mTimestamp = NATIVE_WINDOW_TIMESTAMP_AUTO;
-    mDataSpace = HAL_DATASPACE_UNKNOWN;
     mCrop.clear();
     mScalingMode = NATIVE_WINDOW_SCALING_MODE_FREEZE;
     mTransform = 0;
@@ -99,20 +96,8 @@ void Surface::setSidebandStream(const sp<NativeHandle>& stream) {
 void Surface::allocateBuffers() {
     uint32_t reqWidth = mReqWidth ? mReqWidth : mUserWidth;
     uint32_t reqHeight = mReqHeight ? mReqHeight : mUserHeight;
-    mGraphicBufferProducer->allocateBuffers(mSwapIntervalZero, reqWidth,
-            reqHeight, mReqFormat, mReqUsage);
-}
-
-status_t Surface::setGenerationNumber(uint32_t generation) {
-    status_t result = mGraphicBufferProducer->setGenerationNumber(generation);
-    if (result == NO_ERROR) {
-        mGenerationNumber = generation;
-    }
-    return result;
-}
-
-String8 Surface::getConsumerName() const {
-    return mGraphicBufferProducer->getConsumerName();
+    mGraphicBufferProducer->allocateBuffers(mSwapIntervalZero, mReqWidth,
+            mReqHeight, mReqFormat, mReqUsage);
 }
 
 int Surface::hook_setSwapInterval(ANativeWindow* window, int interval) {
@@ -208,17 +193,17 @@ int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
     ATRACE_CALL();
     ALOGV("Surface::dequeueBuffer");
 
-    uint32_t reqWidth;
-    uint32_t reqHeight;
+    int reqW;
+    int reqH;
     bool swapIntervalZero;
-    PixelFormat reqFormat;
+    uint32_t reqFormat;
     uint32_t reqUsage;
 
     {
         Mutex::Autolock lock(mMutex);
 
-        reqWidth = mReqWidth ? mReqWidth : mUserWidth;
-        reqHeight = mReqHeight ? mReqHeight : mUserHeight;
+        reqW = mReqWidth ? mReqWidth : mUserWidth;
+        reqH = mReqHeight ? mReqHeight : mUserHeight;
 
         swapIntervalZero = mSwapIntervalZero;
         reqFormat = mReqFormat;
@@ -228,12 +213,12 @@ int Surface::dequeueBuffer(android_native_buffer_t** buffer, int* fenceFd) {
     int buf = -1;
     sp<Fence> fence;
     status_t result = mGraphicBufferProducer->dequeueBuffer(&buf, &fence, swapIntervalZero,
-            reqWidth, reqHeight, reqFormat, reqUsage);
+            reqW, reqH, reqFormat, reqUsage);
 
     if (result < 0) {
         ALOGV("dequeueBuffer: IGraphicBufferProducer::dequeueBuffer(%d, %d, %d, %d, %d)"
-             "failed: %d", swapIntervalZero, reqWidth, reqHeight, reqFormat,
-             reqUsage, result);
+             "failed: %d", swapIntervalZero, reqW, reqH, reqFormat, reqUsage,
+             result);
         return result;
     }
 
@@ -280,9 +265,6 @@ int Surface::cancelBuffer(android_native_buffer_t* buffer,
     Mutex::Autolock lock(mMutex);
     int i = getSlotFromBufferLocked(buffer);
     if (i < 0) {
-        if (fenceFd >= 0) {
-            close(fenceFd);
-        }
         return i;
     }
     sp<Fence> fence(fenceFd >= 0 ? new Fence(fenceFd) : Fence::NO_FENCE);
@@ -292,6 +274,7 @@ int Surface::cancelBuffer(android_native_buffer_t* buffer,
 
 int Surface::getSlotFromBufferLocked(
         android_native_buffer_t* buffer) const {
+    bool dumpedState = false;
     for (int i = 0; i < NUM_BUFFER_SLOTS; i++) {
         if (mSlots[i].buffer != NULL &&
                 mSlots[i].buffer->handle == buffer->handle) {
@@ -324,9 +307,6 @@ int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) {
     }
     int i = getSlotFromBufferLocked(buffer);
     if (i < 0) {
-        if (fenceFd >= 0) {
-            close(fenceFd);
-        }
         return i;
     }
 
@@ -338,72 +318,8 @@ int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) {
     sp<Fence> fence(fenceFd >= 0 ? new Fence(fenceFd) : Fence::NO_FENCE);
     IGraphicBufferProducer::QueueBufferOutput output;
     IGraphicBufferProducer::QueueBufferInput input(timestamp, isAutoTimestamp,
-            mDataSpace, crop, mScalingMode, mTransform ^ mStickyTransform,
-            mSwapIntervalZero, fence, mStickyTransform);
-
-    if (mConnectedToCpu || mDirtyRegion.bounds() == Rect::INVALID_RECT) {
-        input.setSurfaceDamage(Region::INVALID_REGION);
-    } else {
-        // Here we do two things:
-        // 1) The surface damage was specified using the OpenGL ES convention of
-        //    the origin being in the bottom-left corner. Here we flip to the
-        //    convention that the rest of the system uses (top-left corner) by
-        //    subtracting all top/bottom coordinates from the buffer height.
-        // 2) If the buffer is coming in rotated (for example, because the EGL
-        //    implementation is reacting to the transform hint coming back from
-        //    SurfaceFlinger), the surface damage needs to be rotated the
-        //    opposite direction, since it was generated assuming an unrotated
-        //    buffer (the app doesn't know that the EGL implementation is
-        //    reacting to the transform hint behind its back). The
-        //    transformations in the switch statement below apply those
-        //    complementary rotations (e.g., if 90 degrees, rotate 270 degrees).
-
-        int width = buffer->width;
-        int height = buffer->height;
-        bool rotated90 = (mTransform ^ mStickyTransform) &
-                NATIVE_WINDOW_TRANSFORM_ROT_90;
-        if (rotated90) {
-            std::swap(width, height);
-        }
-
-        Region flippedRegion;
-        for (auto rect : mDirtyRegion) {
-            int left = rect.left;
-            int right = rect.right;
-            int top = height - rect.bottom; // Flip from OpenGL convention
-            int bottom = height - rect.top; // Flip from OpenGL convention
-            switch (mTransform ^ mStickyTransform) {
-                case NATIVE_WINDOW_TRANSFORM_ROT_90: {
-                    // Rotate 270 degrees
-                    Rect flippedRect{top, width - right, bottom, width - left};
-                    flippedRegion.orSelf(flippedRect);
-                    break;
-                }
-                case NATIVE_WINDOW_TRANSFORM_ROT_180: {
-                    // Rotate 180 degrees
-                    Rect flippedRect{width - right, height - bottom,
-                            width - left, height - top};
-                    flippedRegion.orSelf(flippedRect);
-                    break;
-                }
-                case NATIVE_WINDOW_TRANSFORM_ROT_270: {
-                    // Rotate 90 degrees
-                    Rect flippedRect{height - bottom, left,
-                            height - top, right};
-                    flippedRegion.orSelf(flippedRect);
-                    break;
-                }
-                default: {
-                    Rect flippedRect{left, top, right, bottom};
-                    flippedRegion.orSelf(flippedRect);
-                    break;
-                }
-            }
-        }
-
-        input.setSurfaceDamage(flippedRegion);
-    }
-
+            crop, mScalingMode, mTransform ^ mStickyTransform, mSwapIntervalZero,
+            fence, mStickyTransform);
     status_t err = mGraphicBufferProducer->queueBuffer(i, input, &output);
     if (err != OK)  {
         ALOGE("queueBuffer: error queuing buffer to SurfaceTexture, %d", err);
@@ -420,11 +336,6 @@ int Surface::queueBuffer(android_native_buffer_t* buffer, int fenceFd) {
 
     mConsumerRunningBehind = (numPendingBuffers >= 2);
 
-    if (!mConnectedToCpu) {
-        // Clear surface damage back to full-buffer
-        mDirtyRegion = Region::INVALID_REGION;
-    }
-
     return err;
 }
 
@@ -436,7 +347,7 @@ int Surface::query(int what, int* value) const {
         switch (what) {
             case NATIVE_WINDOW_FORMAT:
                 if (mReqFormat) {
-                    *value = static_cast<int>(mReqFormat);
+                    *value = mReqFormat;
                     return NO_ERROR;
                 }
                 break;
@@ -454,15 +365,13 @@ int Surface::query(int what, int* value) const {
                 *value = NATIVE_WINDOW_SURFACE;
                 return NO_ERROR;
             case NATIVE_WINDOW_DEFAULT_WIDTH:
-                *value = static_cast<int>(
-                        mUserWidth ? mUserWidth : mDefaultWidth);
+                *value = mUserWidth ? mUserWidth : mDefaultWidth;
                 return NO_ERROR;
             case NATIVE_WINDOW_DEFAULT_HEIGHT:
-                *value = static_cast<int>(
-                        mUserHeight ? mUserHeight : mDefaultHeight);
+                *value = mUserHeight ? mUserHeight : mDefaultHeight;
                 return NO_ERROR;
             case NATIVE_WINDOW_TRANSFORM_HINT:
-                *value = static_cast<int>(mTransformHint);
+                *value = mTransformHint;
                 return NO_ERROR;
             case NATIVE_WINDOW_CONSUMER_RUNNING_BEHIND: {
                 status_t err = NO_ERROR;
@@ -539,12 +448,6 @@ int Surface::perform(int operation, va_list args)
     case NATIVE_WINDOW_SET_SIDEBAND_STREAM:
         res = dispatchSetSidebandStream(args);
         break;
-    case NATIVE_WINDOW_SET_BUFFERS_DATASPACE:
-        res = dispatchSetBuffersDataSpace(args);
-        break;
-    case NATIVE_WINDOW_SET_SURFACE_DAMAGE:
-        res = dispatchSetSurfaceDamage(args);
-        break;
     default:
         res = NAME_NOT_FOUND;
         break;
@@ -564,7 +467,7 @@ int Surface::dispatchDisconnect(va_list args) {
 
 int Surface::dispatchSetUsage(va_list args) {
     int usage = va_arg(args, int);
-    return setUsage(static_cast<uint32_t>(usage));
+    return setUsage(usage);
 }
 
 int Surface::dispatchSetCrop(va_list args) {
@@ -574,49 +477,49 @@ int Surface::dispatchSetCrop(va_list args) {
 
 int Surface::dispatchSetBufferCount(va_list args) {
     size_t bufferCount = va_arg(args, size_t);
-    return setBufferCount(static_cast<int32_t>(bufferCount));
+    return setBufferCount(bufferCount);
 }
 
 int Surface::dispatchSetBuffersGeometry(va_list args) {
-    uint32_t width = va_arg(args, uint32_t);
-    uint32_t height = va_arg(args, uint32_t);
-    PixelFormat format = va_arg(args, PixelFormat);
-    int err = setBuffersDimensions(width, height);
+    int w = va_arg(args, int);
+    int h = va_arg(args, int);
+    int f = va_arg(args, int);
+    int err = setBuffersDimensions(w, h);
     if (err != 0) {
         return err;
     }
-    return setBuffersFormat(format);
+    return setBuffersFormat(f);
 }
 
 int Surface::dispatchSetBuffersDimensions(va_list args) {
-    uint32_t width = va_arg(args, uint32_t);
-    uint32_t height = va_arg(args, uint32_t);
-    return setBuffersDimensions(width, height);
+    int w = va_arg(args, int);
+    int h = va_arg(args, int);
+    return setBuffersDimensions(w, h);
 }
 
 int Surface::dispatchSetBuffersUserDimensions(va_list args) {
-    uint32_t width = va_arg(args, uint32_t);
-    uint32_t height = va_arg(args, uint32_t);
-    return setBuffersUserDimensions(width, height);
+    int w = va_arg(args, int);
+    int h = va_arg(args, int);
+    return setBuffersUserDimensions(w, h);
 }
 
 int Surface::dispatchSetBuffersFormat(va_list args) {
-    PixelFormat format = va_arg(args, PixelFormat);
-    return setBuffersFormat(format);
+    int f = va_arg(args, int);
+    return setBuffersFormat(f);
 }
 
 int Surface::dispatchSetScalingMode(va_list args) {
-    int mode = va_arg(args, int);
-    return setScalingMode(mode);
+    int m = va_arg(args, int);
+    return setScalingMode(m);
 }
 
 int Surface::dispatchSetBuffersTransform(va_list args) {
-    uint32_t transform = va_arg(args, uint32_t);
+    int transform = va_arg(args, int);
     return setBuffersTransform(transform);
 }
 
 int Surface::dispatchSetBuffersStickyTransform(va_list args) {
-    uint32_t transform = va_arg(args, uint32_t);
+    int transform = va_arg(args, int);
     return setBuffersStickyTransform(transform);
 }
 
@@ -642,27 +545,10 @@ int Surface::dispatchSetSidebandStream(va_list args) {
     return OK;
 }
 
-int Surface::dispatchSetBuffersDataSpace(va_list args) {
-    android_dataspace dataspace =
-            static_cast<android_dataspace>(va_arg(args, int));
-    return setBuffersDataSpace(dataspace);
-}
-
-int Surface::dispatchSetSurfaceDamage(va_list args) {
-    android_native_rect_t* rects = va_arg(args, android_native_rect_t*);
-    size_t numRects = va_arg(args, size_t);
-    setSurfaceDamage(rects, numRects);
-    return NO_ERROR;
-}
-
 int Surface::connect(int api) {
-    static sp<IProducerListener> listener = new DummyProducerListener();
-    return connect(api, listener);
-}
-
-int Surface::connect(int api, const sp<IProducerListener>& listener) {
     ATRACE_CALL();
     ALOGV("Surface::connect");
+    static sp<IProducerListener> listener = new DummyProducerListener();
     Mutex::Autolock lock(mMutex);
     IGraphicBufferProducer::QueueBufferOutput output;
     int err = mGraphicBufferProducer->connect(listener, api, mProducerControlledByApp, &output);
@@ -681,13 +567,7 @@ int Surface::connect(int api, const sp<IProducerListener>& listener) {
     }
     if (!err && api == NATIVE_WINDOW_API_CPU) {
         mConnectedToCpu = true;
-        // Clear the dirty region in case we're switching from a non-CPU API
-        mDirtyRegion.clear();
-    } else if (!err) {
-        // Initialize the dirty region for tracking surface damage
-        mDirtyRegion = Region::INVALID_REGION;
     }
-
     return err;
 }
 
@@ -715,58 +595,6 @@ int Surface::disconnect(int api) {
     return err;
 }
 
-int Surface::detachNextBuffer(sp<GraphicBuffer>* outBuffer,
-        sp<Fence>* outFence) {
-    ATRACE_CALL();
-    ALOGV("Surface::detachNextBuffer");
-
-    if (outBuffer == NULL || outFence == NULL) {
-        return BAD_VALUE;
-    }
-
-    Mutex::Autolock lock(mMutex);
-
-    sp<GraphicBuffer> buffer(NULL);
-    sp<Fence> fence(NULL);
-    status_t result = mGraphicBufferProducer->detachNextBuffer(
-            &buffer, &fence);
-    if (result != NO_ERROR) {
-        return result;
-    }
-
-    *outBuffer = buffer;
-    if (fence != NULL && fence->isValid()) {
-        *outFence = fence;
-    } else {
-        *outFence = Fence::NO_FENCE;
-    }
-
-    return NO_ERROR;
-}
-
-int Surface::attachBuffer(ANativeWindowBuffer* buffer)
-{
-    ATRACE_CALL();
-    ALOGV("Surface::attachBuffer");
-
-    Mutex::Autolock lock(mMutex);
-
-    sp<GraphicBuffer> graphicBuffer(static_cast<GraphicBuffer*>(buffer));
-    uint32_t priorGeneration = graphicBuffer->mGenerationNumber;
-    graphicBuffer->mGenerationNumber = mGenerationNumber;
-    int32_t attachedSlot = -1;
-    status_t result = mGraphicBufferProducer->attachBuffer(
-            &attachedSlot, graphicBuffer);
-    if (result != NO_ERROR) {
-        ALOGE("attachBuffer: IGraphicBufferProducer call failed (%d)", result);
-        graphicBuffer->mGenerationNumber = priorGeneration;
-        return result;
-    }
-    mSlots[attachedSlot].buffer = graphicBuffer;
-
-    return NO_ERROR;
-}
-
 int Surface::setUsage(uint32_t reqUsage)
 {
     ALOGV("Surface::setUsage");
@@ -811,38 +639,47 @@ int Surface::setBufferCount(int bufferCount)
     return err;
 }
 
-int Surface::setBuffersDimensions(uint32_t width, uint32_t height)
+int Surface::setBuffersDimensions(int w, int h)
 {
     ATRACE_CALL();
     ALOGV("Surface::setBuffersDimensions");
 
-    if ((width && !height) || (!width && height))
+    if (w<0 || h<0)
+        return BAD_VALUE;
+
+    if ((w && !h) || (!w && h))
         return BAD_VALUE;
 
     Mutex::Autolock lock(mMutex);
-    mReqWidth = width;
-    mReqHeight = height;
+    mReqWidth = w;
+    mReqHeight = h;
     return NO_ERROR;
 }
 
-int Surface::setBuffersUserDimensions(uint32_t width, uint32_t height)
+int Surface::setBuffersUserDimensions(int w, int h)
 {
     ATRACE_CALL();
     ALOGV("Surface::setBuffersUserDimensions");
 
-    if ((width && !height) || (!width && height))
+    if (w<0 || h<0)
+        return BAD_VALUE;
+
+    if ((w && !h) || (!w && h))
         return BAD_VALUE;
 
     Mutex::Autolock lock(mMutex);
-    mUserWidth = width;
-    mUserHeight = height;
+    mUserWidth = w;
+    mUserHeight = h;
     return NO_ERROR;
 }
 
-int Surface::setBuffersFormat(PixelFormat format)
+int Surface::setBuffersFormat(int format)
 {
     ALOGV("Surface::setBuffersFormat");
 
+    if (format<0)
+        return BAD_VALUE;
+
     Mutex::Autolock lock(mMutex);
     mReqFormat = format;
     return NO_ERROR;
@@ -868,7 +705,7 @@ int Surface::setScalingMode(int mode)
     return NO_ERROR;
 }
 
-int Surface::setBuffersTransform(uint32_t transform)
+int Surface::setBuffersTransform(int transform)
 {
     ATRACE_CALL();
     ALOGV("Surface::setBuffersTransform");
@@ -877,7 +714,7 @@ int Surface::setBuffersTransform(uint32_t transform)
     return NO_ERROR;
 }
 
-int Surface::setBuffersStickyTransform(uint32_t transform)
+int Surface::setBuffersStickyTransform(int transform)
 {
     ATRACE_CALL();
     ALOGV("Surface::setBuffersStickyTransform");
@@ -894,41 +731,12 @@ int Surface::setBuffersTimestamp(int64_t timestamp)
     return NO_ERROR;
 }
 
-int Surface::setBuffersDataSpace(android_dataspace dataSpace)
-{
-    ALOGV("Surface::setBuffersDataSpace");
-    Mutex::Autolock lock(mMutex);
-    mDataSpace = dataSpace;
-    return NO_ERROR;
-}
-
 void Surface::freeAllBuffers() {
     for (int i = 0; i < NUM_BUFFER_SLOTS; i++) {
         mSlots[i].buffer = 0;
     }
 }
 
-void Surface::setSurfaceDamage(android_native_rect_t* rects, size_t numRects) {
-    ATRACE_CALL();
-    ALOGV("Surface::setSurfaceDamage");
-    Mutex::Autolock lock(mMutex);
-
-    if (mConnectedToCpu || numRects == 0) {
-        mDirtyRegion = Region::INVALID_REGION;
-        return;
-    }
-
-    mDirtyRegion.clear();
-    for (size_t r = 0; r < numRects; ++r) {
-        // We intentionally flip top and bottom here, since because they're
-        // specified with a bottom-left origin, top > bottom, which fails
-        // validation in the Region class. We will fix this up when we flip to a
-        // top-left origin in queueBuffer.
-        Rect rect(rects[r].left, rects[r].bottom, rects[r].right, rects[r].top);
-        mDirtyRegion.orSelf(rect);
-    }
-}
-
 // ----------------------------------------------------------------------
 // the lock/unlock APIs must be used from the same thread
 
@@ -940,34 +748,30 @@ static status_t copyBlt(
     // src and dst with, height and format must be identical. no verification
     // is done here.
     status_t err;
-    uint8_t* src_bits = NULL;
-    err = src->lock(GRALLOC_USAGE_SW_READ_OFTEN, reg.bounds(),
-            reinterpret_cast<void**>(&src_bits));
+    uint8_t const * src_bits = NULL;
+    err = src->lock(GRALLOC_USAGE_SW_READ_OFTEN, reg.bounds(), (void**)&src_bits);
     ALOGE_IF(err, "error locking src buffer %s", strerror(-err));
 
     uint8_t* dst_bits = NULL;
-    err = dst->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, reg.bounds(),
-            reinterpret_cast<void**>(&dst_bits));
+    err = dst->lock(GRALLOC_USAGE_SW_WRITE_OFTEN, reg.bounds(), (void**)&dst_bits);
     ALOGE_IF(err, "error locking dst buffer %s", strerror(-err));
 
     Region::const_iterator head(reg.begin());
     Region::const_iterator tail(reg.end());
     if (head != tail && src_bits && dst_bits) {
         const size_t bpp = bytesPerPixel(src->format);
-        const size_t dbpr = static_cast<uint32_t>(dst->stride) * bpp;
-        const size_t sbpr = static_cast<uint32_t>(src->stride) * bpp;
+        const size_t dbpr = dst->stride * bpp;
+        const size_t sbpr = src->stride * bpp;
 
         while (head != tail) {
             const Rect& r(*head++);
-            int32_t h = r.height();
+            ssize_t h = r.height();
             if (h <= 0) continue;
-            size_t size = static_cast<uint32_t>(r.width()) * bpp;
-            uint8_t const * s = src_bits +
-                    static_cast<uint32_t>(r.left + src->stride * r.top) * bpp;
-            uint8_t       * d = dst_bits +
-                    static_cast<uint32_t>(r.left + dst->stride * r.top) * bpp;
+            size_t size = r.width() * bpp;
+            uint8_t const * s = src_bits + (r.left + src->stride * r.top) * bpp;
+            uint8_t       * d = dst_bits + (r.left + dst->stride * r.top) * bpp;
             if (dbpr==sbpr && size==sbpr) {
-                size *= static_cast<size_t>(h);
+                size *= h;
                 h = 1;
             }
             do {
diff --git a/libs/gui/SurfaceComposerClient.cpp b/libs/gui/SurfaceComposerClient.cpp
index 6ad47d8..6446926 100644
--- a/libs/gui/SurfaceComposerClient.cpp
+++ b/libs/gui/SurfaceComposerClient.cpp
@@ -71,7 +71,7 @@ void ComposerService::connectLocked() {
     };
 
     mDeathObserver = new DeathObserver(*const_cast<ComposerService*>(this));
-    IInterface::asBinder(mComposerService)->linkToDeath(mDeathObserver);
+    mComposerService->asBinder()->linkToDeath(mDeathObserver);
 }
 
 /*static*/ sp<ISurfaceComposer> ComposerService::getComposerService() {
@@ -143,7 +143,7 @@ public:
     status_t setSize(const sp<SurfaceComposerClient>& client, const sp<IBinder>& id,
             uint32_t w, uint32_t h);
     status_t setLayer(const sp<SurfaceComposerClient>& client, const sp<IBinder>& id,
-            uint32_t z);
+            int32_t z);
     status_t setFlags(const sp<SurfaceComposerClient>& client, const sp<IBinder>& id,
             uint32_t flags, uint32_t mask);
     status_t setTransparentRegionHint(
@@ -293,7 +293,7 @@ status_t Composer::setSize(const sp<SurfaceComposerClient>& client,
 }
 
 status_t Composer::setLayer(const sp<SurfaceComposerClient>& client,
-        const sp<IBinder>& id, uint32_t z) {
+        const sp<IBinder>& id, int32_t z) {
     Mutex::Autolock _l(mLock);
     layer_state_t* s = getLayerStateLocked(client, id);
     if (!s)
@@ -310,10 +310,11 @@ status_t Composer::setFlags(const sp<SurfaceComposerClient>& client,
     layer_state_t* s = getLayerStateLocked(client, id);
     if (!s)
         return BAD_INDEX;
-    if (mask & layer_state_t::eLayerOpaque ||
-            mask & layer_state_t::eLayerHidden ||
-            mask & layer_state_t::eLayerSecure) {
-        s->what |= layer_state_t::eFlagsChanged;
+    if (mask & layer_state_t::eLayerOpaque) {
+        s->what |= layer_state_t::eOpacityChanged;
+    }
+    if (mask & layer_state_t::eLayerHidden) {
+        s->what |= layer_state_t::eVisibilityChanged;
     }
     s->flags &= ~mask;
     s->flags |= (flags & mask);
@@ -394,7 +395,7 @@ DisplayState& Composer::getDisplayStateLocked(const sp<IBinder>& token) {
         s.what = 0;
         index = mDisplayStates.add(s);
     }
-    return mDisplayStates.editItemAt(static_cast<size_t>(index));
+    return mDisplayStates.editItemAt(index);
 }
 
 void Composer::setDisplaySurface(const sp<IBinder>& token,
@@ -461,14 +462,14 @@ status_t SurfaceComposerClient::initCheck() const {
 }
 
 sp<IBinder> SurfaceComposerClient::connection() const {
-    return IInterface::asBinder(mClient);
+    return (mClient != 0) ? mClient->asBinder() : 0;
 }
 
 status_t SurfaceComposerClient::linkToComposerDeath(
         const sp<IBinder::DeathRecipient>& recipient,
         void* cookie, uint32_t flags) {
     sp<ISurfaceComposer> sm(ComposerService::getComposerService());
-    return IInterface::asBinder(sm)->linkToDeath(recipient, cookie, flags);
+    return sm->asBinder()->linkToDeath(recipient, cookie, flags);
 }
 
 void SurfaceComposerClient::dispose() {
@@ -570,7 +571,7 @@ status_t SurfaceComposerClient::setSize(const sp<IBinder>& id, uint32_t w, uint3
     return getComposer().setSize(this, id, w, h);
 }
 
-status_t SurfaceComposerClient::setLayer(const sp<IBinder>& id, uint32_t z) {
+status_t SurfaceComposerClient::setLayer(const sp<IBinder>& id, int32_t z) {
     return getComposer().setLayer(this, id, z);
 }
 
@@ -656,7 +657,7 @@ status_t SurfaceComposerClient::getDisplayInfo(const sp<IBinder>& display,
         return NAME_NOT_FOUND;
     }
 
-    *info = configs[static_cast<size_t>(activeId)];
+    *info = configs[activeId];
     return NO_ERROR;
 }
 
@@ -751,14 +752,14 @@ status_t ScreenshotClient::update(const sp<IBinder>& display,
 
 status_t ScreenshotClient::update(const sp<IBinder>& display, Rect sourceCrop,
         bool useIdentityTransform) {
-    return ScreenshotClient::update(display, sourceCrop, 0, 0, 0, -1U,
+    return ScreenshotClient::update(display, sourceCrop, 0, 0, 0, -1UL,
             useIdentityTransform, ISurfaceComposer::eRotateNone);
 }
 
 status_t ScreenshotClient::update(const sp<IBinder>& display, Rect sourceCrop,
         uint32_t reqWidth, uint32_t reqHeight, bool useIdentityTransform) {
     return ScreenshotClient::update(display, sourceCrop, reqWidth, reqHeight,
-            0, -1U, useIdentityTransform, ISurfaceComposer::eRotateNone);
+            0, -1UL, useIdentityTransform, ISurfaceComposer::eRotateNone);
 }
 
 void ScreenshotClient::release() {
diff --git a/libs/gui/SurfaceControl.cpp b/libs/gui/SurfaceControl.cpp
index 1983027..391548b 100644
--- a/libs/gui/SurfaceControl.cpp
+++ b/libs/gui/SurfaceControl.cpp
@@ -89,12 +89,12 @@ bool SurfaceControl::isSameSurface(
     return lhs->mHandle == rhs->mHandle;
 }
 
-status_t SurfaceControl::setLayerStack(uint32_t layerStack) {
+status_t SurfaceControl::setLayerStack(int32_t layerStack) {
     status_t err = validate();
     if (err < 0) return err;
     return mClient->setLayerStack(mHandle, layerStack);
 }
-status_t SurfaceControl::setLayer(uint32_t layer) {
+status_t SurfaceControl::setLayer(int32_t layer) {
     status_t err = validate();
     if (err < 0) return err;
     return mClient->setLayer(mHandle, layer);
@@ -104,6 +104,11 @@ status_t SurfaceControl::setPosition(float x, float y) {
     if (err < 0) return err;
     return mClient->setPosition(mHandle, x, y);
 }
+#ifdef USES_LEGACY_SET_POSITION
+status_t SurfaceControl::setPosition(int32_t x, int32_t y) {
+    return setPosition((float)x, (float)y);
+}
+#endif
 status_t SurfaceControl::setSize(uint32_t w, uint32_t h) {
     status_t err = validate();
     if (err < 0) return err;
@@ -176,7 +181,7 @@ status_t SurfaceControl::writeSurfaceToParcel(
     if (control != NULL) {
         bp = control->mGraphicBufferProducer;
     }
-    return parcel->writeStrongBinder(IInterface::asBinder(bp));
+    return parcel->writeStrongBinder(bp->asBinder());
 }
 
 sp<Surface> SurfaceControl::getSurface() const
diff --git a/libs/gui/SyncFeatures.cpp b/libs/gui/SyncFeatures.cpp
index 187b211..e5804a7 100644
--- a/libs/gui/SyncFeatures.cpp
+++ b/libs/gui/SyncFeatures.cpp
@@ -16,6 +16,7 @@
 
 #define LOG_TAG "GLConsumer"
 
+#define GL_GLEXT_PROTOTYPES
 #define EGL_EGLEXT_PROTOTYPES
 
 #include <EGL/egl.h>
@@ -77,11 +78,10 @@ bool SyncFeatures::useFenceSync() const {
     // on some devices it's better to not use EGL_KHR_fence_sync
     // even if they have it
     return false;
-#else
+#endif
     // currently we shall only attempt to use EGL_KHR_fence_sync if
     // USE_FENCE_SYNC is set in our makefile
     return !mHasNativeFenceSync && mHasFenceSync;
-#endif
 }
 bool SyncFeatures::useWaitSync() const {
     return (useNativeFenceSync() || useFenceSync()) && mHasWaitSync;
diff --git a/libs/gui/tests/Android.mk b/libs/gui/tests/Android.mk
index 6ad9986..e460290 100644
--- a/libs/gui/tests/Android.mk
+++ b/libs/gui/tests/Android.mk
@@ -1,9 +1,6 @@
 # Build the unit tests,
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
-LOCAL_ADDITIONAL_DEPENDENCIES := $(LOCAL_PATH)/Android.mk
-
-LOCAL_CLANG := true
 
 LOCAL_MODULE := libgui_test
 
@@ -34,10 +31,17 @@ LOCAL_SHARED_LIBRARIES := \
 	libbinder \
 	libcutils \
 	libgui \
+	libstlport \
 	libsync \
 	libui \
 	libutils \
 
+LOCAL_C_INCLUDES := \
+    bionic \
+    bionic/libstdc++/include \
+    external/gtest/include \
+    external/stlport/stlport \
+
 # Build the binary to $(TARGET_OUT_DATA_NATIVE_TESTS)/$(LOCAL_MODULE)
 # to integrate with auto-test framework.
 include $(BUILD_NATIVE_TEST)
diff --git a/libs/gui/tests/BufferQueue_test.cpp b/libs/gui/tests/BufferQueue_test.cpp
index 1a54875..96de11f 100644
--- a/libs/gui/tests/BufferQueue_test.cpp
+++ b/libs/gui/tests/BufferQueue_test.cpp
@@ -17,9 +17,6 @@
 #define LOG_TAG "BufferQueue_test"
 //#define LOG_NDEBUG 0
 
-#include "DummyConsumer.h"
-
-#include <gui/BufferItem.h>
 #include <gui/BufferQueue.h>
 #include <gui/IProducerListener.h>
 
@@ -69,7 +66,11 @@ protected:
     sp<IGraphicBufferConsumer> mConsumer;
 };
 
-static const uint32_t TEST_DATA = 0x12345678u;
+struct DummyConsumer : public BnConsumerListener {
+    virtual void onFrameAvailable(const BufferItem& /* item */) {}
+    virtual void onBuffersReleased() {}
+    virtual void onSidebandStreamChanged() {}
+};
 
 // XXX: Tests that fork a process to hold the BufferQueue must run before tests
 // that use a local BufferQueue, or else Binder will get unhappy
@@ -86,8 +87,8 @@ TEST_F(BufferQueueTest, BufferQueueInAnotherProcess) {
         sp<IGraphicBufferConsumer> consumer;
         BufferQueue::createBufferQueue(&producer, &consumer);
         sp<IServiceManager> serviceManager = defaultServiceManager();
-        serviceManager->addService(PRODUCER_NAME, IInterface::asBinder(producer));
-        serviceManager->addService(CONSUMER_NAME, IInterface::asBinder(consumer));
+        serviceManager->addService(PRODUCER_NAME, producer->asBinder());
+        serviceManager->addService(CONSUMER_NAME, consumer->asBinder());
         ProcessState::self()->startThreadPool();
         IPCThreadState::self()->joinThreadPool();
         LOG_ALWAYS_FATAL("Shouldn't be here");
@@ -120,21 +121,20 @@ TEST_F(BufferQueueTest, BufferQueueInAnotherProcess) {
     uint32_t* dataIn;
     ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
             reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
+    *dataIn = 0x12345678;
     ASSERT_EQ(OK, buffer->unlock());
 
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
+    IGraphicBufferProducer::QueueBufferInput input(0, false, Rect(0, 0, 1, 1),
             NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, false, Fence::NO_FENCE);
     ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
 
-    BufferItem item;
+    IGraphicBufferConsumer::BufferItem item;
     ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, 0));
 
     uint32_t* dataOut;
     ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
             reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
+    ASSERT_EQ(*dataOut, 0x12345678);
     ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
 }
 
@@ -150,10 +150,9 @@ TEST_F(BufferQueueTest, AcquireBuffer_ExceedsMaxAcquireCount_Fails) {
     int slot;
     sp<Fence> fence;
     sp<GraphicBuffer> buf;
-    IGraphicBufferProducer::QueueBufferInput qbi(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
+    IGraphicBufferProducer::QueueBufferInput qbi(0, false, Rect(0, 0, 1, 1),
             NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, false, Fence::NO_FENCE);
-    BufferItem item;
+    BufferQueue::BufferItem item;
 
     for (int i = 0; i < 2; i++) {
         ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
@@ -237,7 +236,7 @@ TEST_F(BufferQueueTest, DetachAndReattachOnProducerSide) {
     uint32_t* dataIn;
     ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
             reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
+    *dataIn = 0x12345678;
     ASSERT_EQ(OK, buffer->unlock());
 
     int newSlot;
@@ -245,18 +244,17 @@ TEST_F(BufferQueueTest, DetachAndReattachOnProducerSide) {
     ASSERT_EQ(BAD_VALUE, mProducer->attachBuffer(&newSlot, NULL));
 
     ASSERT_EQ(OK, mProducer->attachBuffer(&newSlot, buffer));
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
+    IGraphicBufferProducer::QueueBufferInput input(0, false, Rect(0, 0, 1, 1),
             NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, false, Fence::NO_FENCE);
     ASSERT_EQ(OK, mProducer->queueBuffer(newSlot, input, &output));
 
-    BufferItem item;
+    IGraphicBufferConsumer::BufferItem item;
     ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, static_cast<nsecs_t>(0)));
 
     uint32_t* dataOut;
     ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
             reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
+    ASSERT_EQ(*dataOut, 0x12345678);
     ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
 }
 
@@ -275,8 +273,7 @@ TEST_F(BufferQueueTest, DetachAndReattachOnConsumerSide) {
             mProducer->dequeueBuffer(&slot, &fence, false, 0, 0, 0,
                     GRALLOC_USAGE_SW_WRITE_OFTEN));
     ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
+    IGraphicBufferProducer::QueueBufferInput input(0, false, Rect(0, 0, 1, 1),
             NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, false, Fence::NO_FENCE);
     ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
 
@@ -285,7 +282,7 @@ TEST_F(BufferQueueTest, DetachAndReattachOnConsumerSide) {
             BufferQueueDefs::NUM_BUFFER_SLOTS)); // Index too high
     ASSERT_EQ(BAD_VALUE, mConsumer->detachBuffer(0)); // Not acquired
 
-    BufferItem item;
+    IGraphicBufferConsumer::BufferItem item;
     ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, static_cast<nsecs_t>(0)));
 
     ASSERT_EQ(OK, mConsumer->detachBuffer(item.mBuf));
@@ -295,7 +292,7 @@ TEST_F(BufferQueueTest, DetachAndReattachOnConsumerSide) {
     ASSERT_EQ(OK, item.mGraphicBuffer->lock(
             GraphicBuffer::USAGE_SW_WRITE_OFTEN,
             reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
+    *dataIn = 0x12345678;
     ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
 
     int newSlot;
@@ -315,7 +312,7 @@ TEST_F(BufferQueueTest, DetachAndReattachOnConsumerSide) {
     uint32_t* dataOut;
     ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
             reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
+    ASSERT_EQ(*dataOut, 0x12345678);
     ASSERT_EQ(OK, buffer->unlock());
 }
 
@@ -338,15 +335,14 @@ TEST_F(BufferQueueTest, MoveFromConsumerToProducer) {
     uint32_t* dataIn;
     ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
             reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
+    *dataIn = 0x12345678;
     ASSERT_EQ(OK, buffer->unlock());
 
-    IGraphicBufferProducer::QueueBufferInput input(0, false,
-            HAL_DATASPACE_UNKNOWN, Rect(0, 0, 1, 1),
+    IGraphicBufferProducer::QueueBufferInput input(0, false, Rect(0, 0, 1, 1),
             NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, false, Fence::NO_FENCE);
     ASSERT_EQ(OK, mProducer->queueBuffer(slot, input, &output));
 
-    BufferItem item;
+    IGraphicBufferConsumer::BufferItem item;
     ASSERT_EQ(OK, mConsumer->acquireBuffer(&item, static_cast<nsecs_t>(0)));
     ASSERT_EQ(OK, mConsumer->detachBuffer(item.mBuf));
 
@@ -358,86 +354,8 @@ TEST_F(BufferQueueTest, MoveFromConsumerToProducer) {
     uint32_t* dataOut;
     ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
             reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
+    ASSERT_EQ(*dataOut, 0x12345678);
     ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
 }
 
-TEST_F(BufferQueueTest, TestDisallowingAllocation) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    static const uint32_t WIDTH = 320;
-    static const uint32_t HEIGHT = 240;
-
-    ASSERT_EQ(OK, mConsumer->setDefaultBufferSize(WIDTH, HEIGHT));
-
-    int slot;
-    sp<Fence> fence;
-    sp<GraphicBuffer> buffer;
-    // This should return an error since it would require an allocation
-    ASSERT_EQ(OK, mProducer->allowAllocation(false));
-    ASSERT_EQ(WOULD_BLOCK, mProducer->dequeueBuffer(&slot, &fence, false, 0, 0,
-            0, GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    // This should succeed, now that we've lifted the prohibition
-    ASSERT_EQ(OK, mProducer->allowAllocation(true));
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-            mProducer->dequeueBuffer(&slot, &fence, false, 0, 0, 0,
-            GRALLOC_USAGE_SW_WRITE_OFTEN));
-
-    // Release the previous buffer back to the BufferQueue
-    mProducer->cancelBuffer(slot, fence);
-
-    // This should fail since we're requesting a different size
-    ASSERT_EQ(OK, mProducer->allowAllocation(false));
-    ASSERT_EQ(WOULD_BLOCK, mProducer->dequeueBuffer(&slot, &fence, false,
-            WIDTH * 2, HEIGHT * 2, 0, GRALLOC_USAGE_SW_WRITE_OFTEN));
-}
-
-TEST_F(BufferQueueTest, TestGenerationNumbers) {
-    createBufferQueue();
-    sp<DummyConsumer> dc(new DummyConsumer);
-    ASSERT_EQ(OK, mConsumer->consumerConnect(dc, true));
-    IGraphicBufferProducer::QueueBufferOutput output;
-    ASSERT_EQ(OK, mProducer->connect(new DummyProducerListener,
-            NATIVE_WINDOW_API_CPU, true, &output));
-
-    ASSERT_EQ(OK, mProducer->setGenerationNumber(1));
-
-    // Get one buffer to play with
-    int slot;
-    sp<Fence> fence;
-    ASSERT_EQ(IGraphicBufferProducer::BUFFER_NEEDS_REALLOCATION,
-            mProducer->dequeueBuffer(&slot, &fence, false, 0, 0, 0, 0));
-
-    sp<GraphicBuffer> buffer;
-    ASSERT_EQ(OK, mProducer->requestBuffer(slot, &buffer));
-
-    // Ensure that the generation number we set propagates to allocated buffers
-    ASSERT_EQ(1U, buffer->getGenerationNumber());
-
-    ASSERT_EQ(OK, mProducer->detachBuffer(slot));
-
-    ASSERT_EQ(OK, mProducer->setGenerationNumber(2));
-
-    // These should fail, since we've changed the generation number on the queue
-    int outSlot;
-    ASSERT_EQ(BAD_VALUE, mProducer->attachBuffer(&outSlot, buffer));
-    ASSERT_EQ(BAD_VALUE, mConsumer->attachBuffer(&outSlot, buffer));
-
-    buffer->setGenerationNumber(2);
-
-    // This should succeed now that we've changed the buffer's generation number
-    ASSERT_EQ(OK, mProducer->attachBuffer(&outSlot, buffer));
-
-    ASSERT_EQ(OK, mProducer->detachBuffer(outSlot));
-
-    // This should also succeed with the new generation number
-    ASSERT_EQ(OK, mConsumer->attachBuffer(&outSlot, buffer));
-}
-
 } // namespace android
diff --git a/libs/gui/tests/CpuConsumer_test.cpp b/libs/gui/tests/CpuConsumer_test.cpp
index 2dc9ccc..abd3724 100644
--- a/libs/gui/tests/CpuConsumer_test.cpp
+++ b/libs/gui/tests/CpuConsumer_test.cpp
@@ -94,7 +94,7 @@ protected:
             mPendingFrames--;
         }
 
-        virtual void onFrameAvailable(const BufferItem&) {
+        virtual void onFrameAvailable() {
             Mutex::Autolock lock(mMutex);
             mPendingFrames++;
             mCondition.signal();
@@ -125,7 +125,7 @@ protected:
             mPendingFrames--;
         }
 
-        virtual void onFrameAvailable(const BufferItem&) {
+        virtual void onFrameAvailable() {
             Mutex::Autolock lock(mMutex);
             mPendingFrames++;
             mFrameCondition.signal();
@@ -166,7 +166,7 @@ void checkPixel(const CpuConsumer::LockedBuffer &buf,
         uint32_t x, uint32_t y, uint32_t r, uint32_t g=0, uint32_t b=0) {
     // Ignores components that don't exist for given pixel
     switch(buf.format) {
-        case HAL_PIXEL_FORMAT_RAW16: {
+        case HAL_PIXEL_FORMAT_RAW_SENSOR: {
             String8 msg;
             uint16_t *bPtr = (uint16_t*)buf.data;
             bPtr += y * buf.stride + x;
@@ -429,7 +429,7 @@ void checkBayerRawBuffer(const CpuConsumer::LockedBuffer &buf) {
 
 void checkAnyBuffer(const CpuConsumer::LockedBuffer &buf, int format) {
     switch (format) {
-        case HAL_PIXEL_FORMAT_RAW16:
+        case HAL_PIXEL_FORMAT_RAW_SENSOR:
             checkBayerRawBuffer(buf);
             break;
         case HAL_PIXEL_FORMAT_Y8:
@@ -457,12 +457,9 @@ void configureANW(const sp<ANativeWindow>& anw,
         const CpuConsumerTestParams& params,
         int maxBufferSlack) {
     status_t err;
-    err = native_window_set_buffers_dimensions(anw.get(),
-            params.width, params.height);
-    ASSERT_NO_ERROR(err, "set_buffers_dimensions error: ");
-
-    err = native_window_set_buffers_format(anw.get(), params.format);
-    ASSERT_NO_ERROR(err, "set_buffers_format error: ");
+    err = native_window_set_buffers_geometry(anw.get(),
+            params.width, params.height, params.format);
+    ASSERT_NO_ERROR(err, "set_buffers_geometry error: ");
 
     err = native_window_set_usage(anw.get(),
             GRALLOC_USAGE_SW_WRITE_OFTEN);
@@ -508,7 +505,7 @@ void produceOneFrame(const sp<ANativeWindow>& anw,
         case HAL_PIXEL_FORMAT_YV12:
             fillYV12Buffer(img, params.width, params.height, *stride);
             break;
-        case HAL_PIXEL_FORMAT_RAW16:
+        case HAL_PIXEL_FORMAT_RAW_SENSOR:
             fillBayerRawBuffer(img, params.width, params.height, buf->getStride());
             break;
         case HAL_PIXEL_FORMAT_Y8:
@@ -540,7 +537,7 @@ void produceOneFrame(const sp<ANativeWindow>& anw,
     ASSERT_NO_ERROR(err, "queueBuffer error:");
 };
 
-// This test is disabled because the HAL_PIXEL_FORMAT_RAW16 format is not
+// This test is disabled because the HAL_PIXEL_FORMAT_RAW_SENSOR format is not
 // supported on all devices.
 TEST_P(CpuConsumerTest, FromCpuSingle) {
     status_t err;
@@ -574,7 +571,7 @@ TEST_P(CpuConsumerTest, FromCpuSingle) {
     mCC->unlockBuffer(b);
 }
 
-// This test is disabled because the HAL_PIXEL_FORMAT_RAW16 format is not
+// This test is disabled because the HAL_PIXEL_FORMAT_RAW_SENSOR format is not
 // supported on all devices.
 TEST_P(CpuConsumerTest, FromCpuManyInQueue) {
     status_t err;
@@ -617,7 +614,7 @@ TEST_P(CpuConsumerTest, FromCpuManyInQueue) {
     }
 }
 
-// This test is disabled because the HAL_PIXEL_FORMAT_RAW16 format is not
+// This test is disabled because the HAL_PIXEL_FORMAT_RAW_SENSOR format is not
 // supported on all devices.
 TEST_P(CpuConsumerTest, FromCpuLockMax) {
     status_t err;
@@ -713,12 +710,12 @@ CpuConsumerTestParams y16TestSets[] = {
 };
 
 CpuConsumerTestParams rawTestSets[] = {
-    { 512,   512, 1, HAL_PIXEL_FORMAT_RAW16},
-    { 512,   512, 3, HAL_PIXEL_FORMAT_RAW16},
-    { 2608, 1960, 1, HAL_PIXEL_FORMAT_RAW16},
-    { 2608, 1960, 3, HAL_PIXEL_FORMAT_RAW16},
-    { 100,   100, 1, HAL_PIXEL_FORMAT_RAW16},
-    { 100,   100, 3, HAL_PIXEL_FORMAT_RAW16},
+    { 512,   512, 1, HAL_PIXEL_FORMAT_RAW_SENSOR},
+    { 512,   512, 3, HAL_PIXEL_FORMAT_RAW_SENSOR},
+    { 2608, 1960, 1, HAL_PIXEL_FORMAT_RAW_SENSOR},
+    { 2608, 1960, 3, HAL_PIXEL_FORMAT_RAW_SENSOR},
+    { 100,   100, 1, HAL_PIXEL_FORMAT_RAW_SENSOR},
+    { 100,   100, 3, HAL_PIXEL_FORMAT_RAW_SENSOR},
 };
 
 CpuConsumerTestParams rgba8888TestSets[] = {
diff --git a/libs/gui/tests/IGraphicBufferProducer_test.cpp b/libs/gui/tests/IGraphicBufferProducer_test.cpp
index 4ef9a69..8d5fd8f 100644
--- a/libs/gui/tests/IGraphicBufferProducer_test.cpp
+++ b/libs/gui/tests/IGraphicBufferProducer_test.cpp
@@ -38,31 +38,30 @@
 #define TEST_CONTROLLED_BY_APP false
 #define TEST_PRODUCER_USAGE_BITS (0)
 
-namespace android {
-
-namespace {
+// TODO: Make these public constants in a header
+enum {
     // Default dimensions before setDefaultBufferSize is called
-    const uint32_t DEFAULT_WIDTH = 1;
-    const uint32_t DEFAULT_HEIGHT = 1;
+    DEFAULT_WIDTH = 1,
+    DEFAULT_HEIGHT = 1,
 
     // Default format before setDefaultBufferFormat is called
-    const PixelFormat DEFAULT_FORMAT = HAL_PIXEL_FORMAT_RGBA_8888;
+    DEFAULT_FORMAT = HAL_PIXEL_FORMAT_RGBA_8888,
 
     // Default transform hint before setTransformHint is called
-    const uint32_t DEFAULT_TRANSFORM_HINT = 0;
+    DEFAULT_TRANSFORM_HINT = 0,
+};
 
-    // TODO: Make these constants in header
-    const int DEFAULT_CONSUMER_USAGE_BITS = 0;
+namespace android {
 
-    // Parameters for a generic "valid" input for queueBuffer.
-    const int64_t QUEUE_BUFFER_INPUT_TIMESTAMP = 1384888611;
-    const bool QUEUE_BUFFER_INPUT_IS_AUTO_TIMESTAMP = false;
-    const android_dataspace QUEUE_BUFFER_INPUT_DATASPACE = HAL_DATASPACE_UNKNOWN;
-    const Rect QUEUE_BUFFER_INPUT_RECT = Rect(DEFAULT_WIDTH, DEFAULT_HEIGHT);
-    const int QUEUE_BUFFER_INPUT_SCALING_MODE = 0;
-    const int QUEUE_BUFFER_INPUT_TRANSFORM = 0;
-    const bool QUEUE_BUFFER_INPUT_ASYNC = false;
-    const sp<Fence> QUEUE_BUFFER_INPUT_FENCE = Fence::NO_FENCE;
+namespace {
+// Parameters for a generic "valid" input for queueBuffer.
+const int64_t QUEUE_BUFFER_INPUT_TIMESTAMP = 1384888611;
+const bool QUEUE_BUFFER_INPUT_IS_AUTO_TIMESTAMP = false;
+const Rect QUEUE_BUFFER_INPUT_RECT = Rect(DEFAULT_WIDTH, DEFAULT_HEIGHT);
+const int QUEUE_BUFFER_INPUT_SCALING_MODE = 0;
+const int QUEUE_BUFFER_INPUT_TRANSFORM = 0;
+const bool QUEUE_BUFFER_INPUT_ASYNC = false;
+const sp<Fence> QUEUE_BUFFER_INPUT_FENCE = Fence::NO_FENCE;
 }; // namespace anonymous
 
 struct DummyConsumer : public BnConsumerListener {
@@ -127,7 +126,6 @@ protected:
         QueueBufferInputBuilder() {
            timestamp = QUEUE_BUFFER_INPUT_TIMESTAMP;
            isAutoTimestamp = QUEUE_BUFFER_INPUT_IS_AUTO_TIMESTAMP;
-           dataSpace = QUEUE_BUFFER_INPUT_DATASPACE;
            crop = QUEUE_BUFFER_INPUT_RECT;
            scalingMode = QUEUE_BUFFER_INPUT_SCALING_MODE;
            transform = QUEUE_BUFFER_INPUT_TRANSFORM;
@@ -139,7 +137,6 @@ protected:
             return IGraphicBufferProducer::QueueBufferInput(
                     timestamp,
                     isAutoTimestamp,
-                    dataSpace,
                     crop,
                     scalingMode,
                     transform,
@@ -157,11 +154,6 @@ protected:
             return *this;
         }
 
-        QueueBufferInputBuilder& setDataSpace(android_dataspace dataSpace) {
-            this->dataSpace = dataSpace;
-            return *this;
-        }
-
         QueueBufferInputBuilder& setCrop(Rect crop) {
             this->crop = crop;
             return *this;
@@ -190,7 +182,6 @@ protected:
     private:
         int64_t timestamp;
         bool isAutoTimestamp;
-        android_dataspace dataSpace;
         Rect crop;
         int scalingMode;
         uint32_t transform;
@@ -273,12 +264,15 @@ TEST_F(IGraphicBufferProducerTest, Disconnect_ReturnsError) {
 TEST_F(IGraphicBufferProducerTest, Query_Succeeds) {
     ASSERT_NO_FATAL_FAILURE(ConnectProducer());
 
-    int32_t value = -1;
+    // TODO: Make these constants in header
+    const int DEFAULT_CONSUMER_USAGE_BITS = 0;
+
+    int value = -1;
     EXPECT_OK(mProducer->query(NATIVE_WINDOW_WIDTH, &value));
-    EXPECT_EQ(DEFAULT_WIDTH, static_cast<uint32_t>(value));
+    EXPECT_EQ(DEFAULT_WIDTH, value);
 
     EXPECT_OK(mProducer->query(NATIVE_WINDOW_HEIGHT, &value));
-    EXPECT_EQ(DEFAULT_HEIGHT, static_cast<uint32_t>(value));
+    EXPECT_EQ(DEFAULT_HEIGHT, value);
 
     EXPECT_OK(mProducer->query(NATIVE_WINDOW_FORMAT, &value));
     EXPECT_EQ(DEFAULT_FORMAT, value);
@@ -299,7 +293,7 @@ TEST_F(IGraphicBufferProducerTest, Query_ReturnsError) {
     ASSERT_NO_FATAL_FAILURE(ConnectProducer());
 
     // One past the end of the last 'query' enum value. Update this if we add more enums.
-    const int NATIVE_WINDOW_QUERY_LAST_OFF_BY_ONE = NATIVE_WINDOW_BUFFER_AGE + 1;
+    const int NATIVE_WINDOW_QUERY_LAST_OFF_BY_ONE = NATIVE_WINDOW_CONSUMER_USAGE_BITS + 1;
 
     int value;
     // What was out of range
@@ -366,7 +360,7 @@ TEST_F(IGraphicBufferProducerTest, Queue_Succeeds) {
         EXPECT_EQ(DEFAULT_WIDTH, width);
         EXPECT_EQ(DEFAULT_HEIGHT, height);
         EXPECT_EQ(DEFAULT_TRANSFORM_HINT, transformHint);
-        EXPECT_EQ(1u, numPendingBuffers); // since queueBuffer was called exactly once
+        EXPECT_EQ(1, numPendingBuffers); // since queueBuffer was called exactly once
     }
 
     // Buffer was not in the dequeued state
diff --git a/libs/gui/tests/SRGB_test.cpp b/libs/gui/tests/SRGB_test.cpp
index 3b11b97..2d5b8aa 100644
--- a/libs/gui/tests/SRGB_test.cpp
+++ b/libs/gui/tests/SRGB_test.cpp
@@ -17,14 +17,8 @@
 #define LOG_TAG "SRGB_test"
 //#define LOG_NDEBUG 0
 
-// Ignore for this file because it flags every instance of
-// ASSERT_EQ(GL_NO_ERROR, glGetError());
-#pragma clang diagnostic ignored "-Wsign-compare"
-
 #include "GLTest.h"
 
-#include <math.h>
-
 #include <gui/CpuConsumer.h>
 #include <gui/Surface.h>
 #include <gui/SurfaceComposerClient.h>
@@ -218,11 +212,10 @@ protected:
         ASSERT_EQ(GL_NO_ERROR, glGetError());
     }
 
-    void checkLockedBuffer(PixelFormat format, android_dataspace dataSpace) {
+    void checkLockedBuffer(PixelFormat format) {
         ASSERT_EQ(mLockedBuffer.format, format);
         ASSERT_EQ(mLockedBuffer.width, DISPLAY_WIDTH);
         ASSERT_EQ(mLockedBuffer.height, DISPLAY_HEIGHT);
-        ASSERT_EQ(mLockedBuffer.dataSpace, dataSpace);
     }
 
     static bool withinTolerance(int a, int b) {
@@ -333,15 +326,14 @@ private:
         ANativeWindow_Buffer outBuffer;
         ARect outBufferBounds;
         mOutputSurface->lock(&outBuffer, &outBufferBounds);
-        ASSERT_EQ(mLockedBuffer.width, static_cast<uint32_t>(outBuffer.width));
-        ASSERT_EQ(mLockedBuffer.height, static_cast<uint32_t>(outBuffer.height));
-        ASSERT_EQ(mLockedBuffer.stride, static_cast<uint32_t>(outBuffer.stride));
+        ASSERT_EQ(mLockedBuffer.width, outBuffer.width);
+        ASSERT_EQ(mLockedBuffer.height, outBuffer.height);
+        ASSERT_EQ(mLockedBuffer.stride, outBuffer.stride);
 
         if (mLockedBuffer.format == outBuffer.format) {
             memcpy(outBuffer.bits, mLockedBuffer.data, bufferSize);
         } else {
-            ASSERT_EQ(mLockedBuffer.format, PIXEL_FORMAT_RGBA_8888);
-            ASSERT_EQ(mLockedBuffer.dataSpace, HAL_DATASPACE_SRGB);
+            ASSERT_EQ(mLockedBuffer.format, PIXEL_FORMAT_sRGB_A_8888);
             ASSERT_EQ(outBuffer.format, PIXEL_FORMAT_RGBA_8888);
             uint8_t* outPointer = reinterpret_cast<uint8_t*>(outBuffer.bits);
             for (int y = 0; y < outBuffer.height; ++y) {
@@ -386,8 +378,7 @@ TEST_F(SRGBTest, GLRenderFromSRGBTexture) {
 
     // Lock
     ASSERT_EQ(NO_ERROR, mCpuConsumer->lockNextBuffer(&mLockedBuffer));
-    ASSERT_NO_FATAL_FAILURE(
-        checkLockedBuffer(PIXEL_FORMAT_RGBA_8888, HAL_DATASPACE_UNKNOWN));
+    ASSERT_NO_FATAL_FAILURE(checkLockedBuffer(PIXEL_FORMAT_RGBA_8888));
 
     // Compare a pixel in the middle of each texture
     int midSRGBOffset = (DISPLAY_HEIGHT / 4) * mLockedBuffer.stride *
@@ -405,8 +396,7 @@ TEST_F(SRGBTest, GLRenderFromSRGBTexture) {
     // the debug surface if necessary
 }
 
-// XXX: Disabled since we don't currently expect this to work
-TEST_F(SRGBTest, DISABLED_RenderToSRGBSurface) {
+TEST_F(SRGBTest, RenderToSRGBSurface) {
     ASSERT_NO_FATAL_FAILURE(initShaders());
 
     // By default, the first buffer we write into will be RGB
@@ -419,8 +409,7 @@ TEST_F(SRGBTest, DISABLED_RenderToSRGBSurface) {
 
     // Lock
     ASSERT_EQ(NO_ERROR, mCpuConsumer->lockNextBuffer(&mLockedBuffer));
-    ASSERT_NO_FATAL_FAILURE(
-        checkLockedBuffer(PIXEL_FORMAT_RGBA_8888, HAL_DATASPACE_UNKNOWN));
+    ASSERT_NO_FATAL_FAILURE(checkLockedBuffer(PIXEL_FORMAT_RGBA_8888));
 
     // Save the values of the middle pixel for later comparison against SRGB
     uint8_t values[PIXEL_SIZE] = {};
@@ -469,8 +458,7 @@ TEST_F(SRGBTest, DISABLED_RenderToSRGBSurface) {
     ASSERT_EQ(NO_ERROR, mCpuConsumer->lockNextBuffer(&mLockedBuffer));
 
     // Make sure we actually got the SRGB buffer on the consumer side
-    ASSERT_NO_FATAL_FAILURE(
-        checkLockedBuffer(PIXEL_FORMAT_RGBA_8888, HAL_DATASPACE_SRGB));
+    ASSERT_NO_FATAL_FAILURE(checkLockedBuffer(PIXEL_FORMAT_sRGB_A_8888));
 
     // Verify that the stored value is the same, accounting for RGB/SRGB
     for (int c = 0; c < PIXEL_SIZE; ++c) {
diff --git a/libs/gui/tests/StreamSplitter_test.cpp b/libs/gui/tests/StreamSplitter_test.cpp
index 00cc39d..4e63a6f 100644
--- a/libs/gui/tests/StreamSplitter_test.cpp
+++ b/libs/gui/tests/StreamSplitter_test.cpp
@@ -17,7 +17,6 @@
 #define LOG_TAG "StreamSplitter_test"
 //#define LOG_NDEBUG 0
 
-#include <gui/BufferItem.h>
 #include <gui/BufferQueue.h>
 #include <gui/IConsumerListener.h>
 #include <gui/ISurfaceComposer.h>
@@ -76,8 +75,6 @@ private:
     int mAllocCount;
 };
 
-static const uint32_t TEST_DATA = 0x12345678u;
-
 TEST_F(StreamSplitterTest, OneInputOneOutput) {
     sp<CountedAllocator> allocator(new CountedAllocator);
 
@@ -110,22 +107,21 @@ TEST_F(StreamSplitterTest, OneInputOneOutput) {
     uint32_t* dataIn;
     ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
             reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
+    *dataIn = 0x12345678;
     ASSERT_EQ(OK, buffer->unlock());
 
     IGraphicBufferProducer::QueueBufferInput qbInput(0, false,
-            HAL_DATASPACE_UNKNOWN,
             Rect(0, 0, 1, 1), NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, false,
             Fence::NO_FENCE);
     ASSERT_EQ(OK, inputProducer->queueBuffer(slot, qbInput, &qbOutput));
 
-    BufferItem item;
+    IGraphicBufferConsumer::BufferItem item;
     ASSERT_EQ(OK, outputConsumer->acquireBuffer(&item, 0));
 
     uint32_t* dataOut;
     ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
             reinterpret_cast<void**>(&dataOut)));
-    ASSERT_EQ(*dataOut, TEST_DATA);
+    ASSERT_EQ(*dataOut, 0x12345678);
     ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
 
     ASSERT_EQ(OK, outputConsumer->releaseBuffer(item.mBuf, item.mFrameNumber,
@@ -177,23 +173,22 @@ TEST_F(StreamSplitterTest, OneInputMultipleOutputs) {
     uint32_t* dataIn;
     ASSERT_EQ(OK, buffer->lock(GraphicBuffer::USAGE_SW_WRITE_OFTEN,
             reinterpret_cast<void**>(&dataIn)));
-    *dataIn = TEST_DATA;
+    *dataIn = 0x12345678;
     ASSERT_EQ(OK, buffer->unlock());
 
     IGraphicBufferProducer::QueueBufferInput qbInput(0, false,
-            HAL_DATASPACE_UNKNOWN,
             Rect(0, 0, 1, 1), NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, false,
             Fence::NO_FENCE);
     ASSERT_EQ(OK, inputProducer->queueBuffer(slot, qbInput, &qbOutput));
 
     for (int output = 0; output < NUM_OUTPUTS; ++output) {
-        BufferItem item;
+        IGraphicBufferConsumer::BufferItem item;
         ASSERT_EQ(OK, outputConsumers[output]->acquireBuffer(&item, 0));
 
         uint32_t* dataOut;
         ASSERT_EQ(OK, item.mGraphicBuffer->lock(GraphicBuffer::USAGE_SW_READ_OFTEN,
                     reinterpret_cast<void**>(&dataOut)));
-        ASSERT_EQ(*dataOut, TEST_DATA);
+        ASSERT_EQ(*dataOut, 0x12345678);
         ASSERT_EQ(OK, item.mGraphicBuffer->unlock());
 
         ASSERT_EQ(OK, outputConsumers[output]->releaseBuffer(item.mBuf,
@@ -239,7 +234,6 @@ TEST_F(StreamSplitterTest, OutputAbandonment) {
     outputConsumer->consumerDisconnect();
 
     IGraphicBufferProducer::QueueBufferInput qbInput(0, false,
-            HAL_DATASPACE_UNKNOWN,
             Rect(0, 0, 1, 1), NATIVE_WINDOW_SCALING_MODE_FREEZE, 0, false,
             Fence::NO_FENCE);
     ASSERT_EQ(OK, inputProducer->queueBuffer(slot, qbInput, &qbOutput));
diff --git a/libs/gui/tests/SurfaceTextureClient_test.cpp b/libs/gui/tests/SurfaceTextureClient_test.cpp
index 1a50b24..8cdf3bc 100644
--- a/libs/gui/tests/SurfaceTextureClient_test.cpp
+++ b/libs/gui/tests/SurfaceTextureClient_test.cpp
@@ -27,9 +27,6 @@
 #include <utils/Log.h>
 #include <utils/Thread.h>
 
-EGLAPI const char* eglQueryStringImplementationANDROID(EGLDisplay dpy, EGLint name);
-#define CROP_EXT_STR "EGL_ANDROID_image_crop"
-
 namespace android {
 
 class SurfaceTextureClientTest : public ::testing::Test {
@@ -210,8 +207,12 @@ TEST_F(SurfaceTextureClientTest, EglSwapBuffersAbandonErrorIsEglBadSurface) {
 }
 
 TEST_F(SurfaceTextureClientTest, BufferGeometryInvalidSizesFail) {
-    EXPECT_GT(OK, native_window_set_buffers_dimensions(mANW.get(),  0,  8));
-    EXPECT_GT(OK, native_window_set_buffers_dimensions(mANW.get(),  8,  0));
+    EXPECT_GT(OK, native_window_set_buffers_geometry(mANW.get(), -1,  0,  0));
+    EXPECT_GT(OK, native_window_set_buffers_geometry(mANW.get(),  0, -1,  0));
+    EXPECT_GT(OK, native_window_set_buffers_geometry(mANW.get(),  0,  0, -1));
+    EXPECT_GT(OK, native_window_set_buffers_geometry(mANW.get(), -1, -1,  0));
+    EXPECT_GT(OK, native_window_set_buffers_geometry(mANW.get(),  0,  8,  0));
+    EXPECT_GT(OK, native_window_set_buffers_geometry(mANW.get(),  8,  0,  0));
 }
 
 TEST_F(SurfaceTextureClientTest, DefaultGeometryValues) {
@@ -225,8 +226,7 @@ TEST_F(SurfaceTextureClientTest, DefaultGeometryValues) {
 
 TEST_F(SurfaceTextureClientTest, BufferGeometryCanBeSet) {
     ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 16, 8));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), PIXEL_FORMAT_RGB_565));
+    EXPECT_EQ(OK, native_window_set_buffers_geometry(mANW.get(), 16, 8, PIXEL_FORMAT_RGB_565));
     ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
     EXPECT_EQ(16, buf->width);
     EXPECT_EQ(8, buf->height);
@@ -236,8 +236,7 @@ TEST_F(SurfaceTextureClientTest, BufferGeometryCanBeSet) {
 
 TEST_F(SurfaceTextureClientTest, BufferGeometryDefaultSizeSetFormat) {
     ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 0, 0));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), PIXEL_FORMAT_RGB_565));
+    EXPECT_EQ(OK, native_window_set_buffers_geometry(mANW.get(), 0, 0, PIXEL_FORMAT_RGB_565));
     ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
     EXPECT_EQ(1, buf->width);
     EXPECT_EQ(1, buf->height);
@@ -247,8 +246,7 @@ TEST_F(SurfaceTextureClientTest, BufferGeometryDefaultSizeSetFormat) {
 
 TEST_F(SurfaceTextureClientTest, BufferGeometrySetSizeDefaultFormat) {
     ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 16, 8));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
+    EXPECT_EQ(OK, native_window_set_buffers_geometry(mANW.get(), 16, 8, 0));
     ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
     EXPECT_EQ(16, buf->width);
     EXPECT_EQ(8, buf->height);
@@ -258,15 +256,13 @@ TEST_F(SurfaceTextureClientTest, BufferGeometrySetSizeDefaultFormat) {
 
 TEST_F(SurfaceTextureClientTest, BufferGeometrySizeCanBeUnset) {
     ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 16, 8));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
+    EXPECT_EQ(OK, native_window_set_buffers_geometry(mANW.get(), 16, 8, 0));
     ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
     EXPECT_EQ(16, buf->width);
     EXPECT_EQ(8, buf->height);
     EXPECT_EQ(PIXEL_FORMAT_RGBA_8888, buf->format);
     ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf, -1));
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 0, 0));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
+    EXPECT_EQ(OK, native_window_set_buffers_geometry(mANW.get(), 0, 0, 0));
     ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
     EXPECT_EQ(1, buf->width);
     EXPECT_EQ(1, buf->height);
@@ -276,8 +272,7 @@ TEST_F(SurfaceTextureClientTest, BufferGeometrySizeCanBeUnset) {
 
 TEST_F(SurfaceTextureClientTest, BufferGeometrySizeCanBeChangedWithoutFormat) {
     ANativeWindowBuffer* buf;
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 0, 0));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), PIXEL_FORMAT_RGB_565));
+    EXPECT_EQ(OK, native_window_set_buffers_geometry(mANW.get(), 0, 0, PIXEL_FORMAT_RGB_565));
     ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf));
     EXPECT_EQ(1, buf->width);
     EXPECT_EQ(1, buf->height);
@@ -335,8 +330,7 @@ TEST_F(SurfaceTextureClientTest, SurfaceTextureSetDefaultSizeVsGeometry) {
     EXPECT_EQ(8, buf[1]->height);
     ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[0], -1));
     ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[1], -1));
-    EXPECT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 12, 24));
-    EXPECT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
+    EXPECT_EQ(OK, native_window_set_buffers_geometry(mANW.get(), 12, 24, 0));
     ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
     ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
     EXPECT_NE(buf[0], buf[1]);
@@ -474,8 +468,7 @@ TEST_F(SurfaceTextureClientTest, SurfaceTextureSyncModeMinUndequeued) {
 
     // Once we've queued a buffer, however we should not be able to dequeue more
     // than (buffer-count - MIN_UNDEQUEUED_BUFFERS), which is 2 in this case.
-    EXPECT_EQ(INVALID_OPERATION,
-            native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
+    EXPECT_EQ(-EBUSY, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[1]));
 
     ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[0], -1));
     ASSERT_EQ(OK, mANW->cancelBuffer(mANW.get(), buf[2], -1));
@@ -618,18 +611,6 @@ TEST_F(SurfaceTextureClientTest, GetTransformMatrixSucceedsAfterFreeingBuffers)
 }
 
 TEST_F(SurfaceTextureClientTest, GetTransformMatrixSucceedsAfterFreeingBuffersWithCrop) {
-    // Query to see if the image crop extension exists
-    EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
-    const char* exts = eglQueryStringImplementationANDROID(dpy, EGL_EXTENSIONS);
-    size_t cropExtLen = strlen(CROP_EXT_STR);
-    size_t extsLen = strlen(exts);
-    bool equal = !strcmp(CROP_EXT_STR, exts);
-    bool atStart = !strncmp(CROP_EXT_STR " ", exts, cropExtLen+1);
-    bool atEnd = (cropExtLen+1) < extsLen &&
-            !strcmp(" " CROP_EXT_STR, exts + extsLen - (cropExtLen+1));
-    bool inMiddle = strstr(exts, " " CROP_EXT_STR " ");
-    bool hasEglAndroidImageCrop = equal || atStart || atEnd || inMiddle;
-
     android_native_buffer_t* buf[3];
     float mtx[16] = {};
     android_native_rect_t crop;
@@ -639,8 +620,7 @@ TEST_F(SurfaceTextureClientTest, GetTransformMatrixSucceedsAfterFreeingBuffersWi
     crop.bottom = 5;
 
     ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 4));
-    ASSERT_EQ(OK, native_window_set_buffers_dimensions(mANW.get(), 8, 8));
-    ASSERT_EQ(OK, native_window_set_buffers_format(mANW.get(), 0));
+    ASSERT_EQ(OK, native_window_set_buffers_geometry(mANW.get(), 8, 8, 0));
     ASSERT_EQ(OK, native_window_dequeue_buffer_and_wait(mANW.get(), &buf[0]));
     ASSERT_EQ(OK, native_window_set_crop(mANW.get(), &crop));
     ASSERT_EQ(OK, mANW->queueBuffer(mANW.get(), buf[0], -1));
@@ -648,17 +628,15 @@ TEST_F(SurfaceTextureClientTest, GetTransformMatrixSucceedsAfterFreeingBuffersWi
     ASSERT_EQ(OK, native_window_set_buffer_count(mANW.get(), 6)); // frees buffers
     mST->getTransformMatrix(mtx);
 
-    // If the egl image crop extension is not present, this accounts for the
-    // .5 texel shrink for each edge that's included in the transform matrix
-    // to avoid texturing outside the crop region. Otherwise the crop is not
-    // included in the transform matrix.
-    EXPECT_EQ(hasEglAndroidImageCrop ? 1 : 0.5, mtx[0]);
+    // This accounts for the .5 texel shrink for each edge that's included in the
+    // transform matrix to avoid texturing outside the crop region.
+    EXPECT_EQ(0.5, mtx[0]);
     EXPECT_EQ(0.f, mtx[1]);
     EXPECT_EQ(0.f, mtx[2]);
     EXPECT_EQ(0.f, mtx[3]);
 
     EXPECT_EQ(0.f, mtx[4]);
-    EXPECT_EQ(hasEglAndroidImageCrop ? -1 : -0.5, mtx[5]);
+    EXPECT_EQ(-0.5, mtx[5]);
     EXPECT_EQ(0.f, mtx[6]);
     EXPECT_EQ(0.f, mtx[7]);
 
@@ -667,8 +645,8 @@ TEST_F(SurfaceTextureClientTest, GetTransformMatrixSucceedsAfterFreeingBuffersWi
     EXPECT_EQ(1.f, mtx[10]);
     EXPECT_EQ(0.f, mtx[11]);
 
-    EXPECT_EQ(hasEglAndroidImageCrop ? 0 : 0.0625f, mtx[12]);
-    EXPECT_EQ(hasEglAndroidImageCrop ? 1 : 0.5625f, mtx[13]);
+    EXPECT_EQ(0.0625f, mtx[12]);
+    EXPECT_EQ(0.5625f, mtx[13]);
     EXPECT_EQ(0.f, mtx[14]);
     EXPECT_EQ(1.f, mtx[15]);
 }
@@ -690,8 +668,7 @@ TEST_F(SurfaceTextureClientTest, QueryFormatAfterSettingWorks) {
     const int numFmts = (sizeof(fmts) / sizeof(fmts[0]));
     for (int i = 0; i < numFmts; i++) {
       int fmt = -1;
-      ASSERT_EQ(OK, native_window_set_buffers_dimensions(anw.get(), 0, 0));
-      ASSERT_EQ(OK, native_window_set_buffers_format(anw.get(), fmts[i]));
+      ASSERT_EQ(OK, native_window_set_buffers_geometry(anw.get(), 0, 0, fmts[i]));
       ASSERT_EQ(OK, anw->query(anw.get(), NATIVE_WINDOW_FORMAT, &fmt));
       EXPECT_EQ(fmts[i], fmt);
     }
diff --git a/libs/gui/tests/SurfaceTextureFBO_test.cpp b/libs/gui/tests/SurfaceTextureFBO_test.cpp
index c243fc0..b165ae6 100644
--- a/libs/gui/tests/SurfaceTextureFBO_test.cpp
+++ b/libs/gui/tests/SurfaceTextureFBO_test.cpp
@@ -27,10 +27,8 @@ TEST_F(SurfaceTextureFBOTest, BlitFromCpuFilledBufferToFbo) {
     const int texWidth = 64;
     const int texHeight = 64;
 
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_RGBA_8888));
+    ASSERT_EQ(NO_ERROR, native_window_set_buffers_geometry(mANW.get(),
+            texWidth, texHeight, HAL_PIXEL_FORMAT_RGBA_8888));
     ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
             GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
 
diff --git a/libs/gui/tests/SurfaceTextureGLToGL_test.cpp b/libs/gui/tests/SurfaceTextureGLToGL_test.cpp
index 6edbfb8..f4c7961 100644
--- a/libs/gui/tests/SurfaceTextureGLToGL_test.cpp
+++ b/libs/gui/tests/SurfaceTextureGLToGL_test.cpp
@@ -188,10 +188,10 @@ TEST_F(SurfaceTextureGLToGLTest, EglDestroySurfaceUnrefsBuffers) {
     // This test should have the only reference to buffer 0.
     EXPECT_EQ(1, buffers[0]->getStrongCount());
 
-    // The GLConsumer should hold one reference to buffer 1 in its
-    // mCurrentTextureImage member and another reference in mEglSlots. The third
-    // reference is in this test.
-    EXPECT_EQ(3, buffers[1]->getStrongCount());
+    // The GLConsumer should hold a single reference to buffer 1 in its
+    // mCurrentBuffer member.  All of the references in the slots should have
+    // been released.
+    EXPECT_EQ(2, buffers[1]->getStrongCount());
 }
 
 TEST_F(SurfaceTextureGLToGLTest, EglDestroySurfaceAfterAbandonUnrefsBuffers) {
@@ -235,19 +235,14 @@ TEST_F(SurfaceTextureGLToGLTest, EglDestroySurfaceAfterAbandonUnrefsBuffers) {
     ASSERT_EQ(EGL_SUCCESS, eglGetError());
     mProducerEglSurface = EGL_NO_SURFACE;
 
+    EXPECT_EQ(1, buffers[0]->getStrongCount());
     EXPECT_EQ(1, buffers[1]->getStrongCount());
 
     // Depending on how lazily the GL driver dequeues buffers, we may end up
-    // with either two or three total buffers.  If there are three, each entry
-    // of the buffers array will be unique and there should only be one
-    // reference (the one in this test). If there are two the first and last
-    // element in the array will be equal meaning that buffer representing both
-    // 0 and 2 will have two references (one for 0 and one for 2).
+    // with either two or three total buffers.  If there are three, make sure
+    // the last one was properly down-ref'd.
     if (buffers[2] != buffers[0]) {
-        EXPECT_EQ(1, buffers[0]->getStrongCount());
         EXPECT_EQ(1, buffers[2]->getStrongCount());
-    } else {
-        EXPECT_EQ(2, buffers[0]->getStrongCount());
     }
 }
 
diff --git a/libs/gui/tests/SurfaceTextureGL_test.cpp b/libs/gui/tests/SurfaceTextureGL_test.cpp
index fad133f..fa1e1b7 100644
--- a/libs/gui/tests/SurfaceTextureGL_test.cpp
+++ b/libs/gui/tests/SurfaceTextureGL_test.cpp
@@ -28,10 +28,8 @@ TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BufferNpot) {
     const int texWidth = 64;
     const int texHeight = 66;
 
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_YV12));
+    ASSERT_EQ(NO_ERROR, native_window_set_buffers_geometry(mANW.get(),
+            texWidth, texHeight, HAL_PIXEL_FORMAT_YV12));
     ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
             GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
 
@@ -76,10 +74,8 @@ TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BufferPow2) {
     const int texWidth = 64;
     const int texHeight = 64;
 
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_YV12));
+    ASSERT_EQ(NO_ERROR, native_window_set_buffers_geometry(mANW.get(),
+            texWidth, texHeight, HAL_PIXEL_FORMAT_YV12));
     ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
             GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
 
@@ -124,10 +120,8 @@ TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BufferWithCrop) {
     const int texWidth = 64;
     const int texHeight = 66;
 
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_YV12));
+    ASSERT_EQ(NO_ERROR, native_window_set_buffers_geometry(mANW.get(),
+            texWidth, texHeight, HAL_PIXEL_FORMAT_YV12));
     ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
             GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
 
@@ -191,10 +185,8 @@ TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledYV12BuffersRepeatedly) {
     enum { numFrames = 1024 };
 
     ASSERT_EQ(NO_ERROR, mST->setDefaultMaxBufferCount(2));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_YV12));
+    ASSERT_EQ(NO_ERROR, native_window_set_buffers_geometry(mANW.get(),
+            texWidth, texHeight, HAL_PIXEL_FORMAT_YV12));
     ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
             GRALLOC_USAGE_SW_WRITE_OFTEN));
 
@@ -334,10 +326,8 @@ TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledRGBABufferNpot) {
     const int texWidth = 64;
     const int texHeight = 66;
 
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_RGBA_8888));
+    ASSERT_EQ(NO_ERROR, native_window_set_buffers_geometry(mANW.get(),
+            texWidth, texHeight, HAL_PIXEL_FORMAT_RGBA_8888));
     ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
             GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
 
@@ -378,10 +368,8 @@ TEST_F(SurfaceTextureGLTest, TexturingFromCpuFilledRGBABufferPow2) {
     const int texWidth = 64;
     const int texHeight = 64;
 
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_dimensions(mANW.get(),
-            texWidth, texHeight));
-    ASSERT_EQ(NO_ERROR, native_window_set_buffers_format(mANW.get(),
-            HAL_PIXEL_FORMAT_RGBA_8888));
+    ASSERT_EQ(NO_ERROR, native_window_set_buffers_geometry(mANW.get(),
+            texWidth, texHeight, HAL_PIXEL_FORMAT_RGBA_8888));
     ASSERT_EQ(NO_ERROR, native_window_set_usage(mANW.get(),
             GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN));
 
diff --git a/libs/gui/tests/Surface_test.cpp b/libs/gui/tests/Surface_test.cpp
index 3f495f8..5e6aeef 100644
--- a/libs/gui/tests/Surface_test.cpp
+++ b/libs/gui/tests/Surface_test.cpp
@@ -14,8 +14,6 @@
  * limitations under the License.
  */
 
-#include "DummyConsumer.h"
-
 #include <gtest/gtest.h>
 
 #include <binder/IMemory.h>
@@ -157,75 +155,4 @@ TEST_F(SurfaceTest, QueryConsumerUsage) {
     ASSERT_EQ(TEST_USAGE_FLAGS, flags);
 }
 
-TEST_F(SurfaceTest, QueryDefaultBuffersDataSpace) {
-    const android_dataspace TEST_DATASPACE = HAL_DATASPACE_SRGB;
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    sp<CpuConsumer> cpuConsumer = new CpuConsumer(consumer, 1);
-
-    cpuConsumer->setDefaultBufferDataSpace(TEST_DATASPACE);
-
-    sp<Surface> s = new Surface(producer);
-
-    sp<ANativeWindow> anw(s);
-
-    android_dataspace dataSpace;
-
-    int err = anw->query(anw.get(), NATIVE_WINDOW_DEFAULT_DATASPACE,
-            reinterpret_cast<int*>(&dataSpace));
-
-    ASSERT_EQ(NO_ERROR, err);
-    ASSERT_EQ(TEST_DATASPACE, dataSpace);
-}
-
-TEST_F(SurfaceTest, SettingGenerationNumber) {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-    sp<CpuConsumer> cpuConsumer = new CpuConsumer(consumer, 1);
-    sp<Surface> surface = new Surface(producer);
-    sp<ANativeWindow> window(surface);
-
-    // Allocate a buffer with a generation number of 0
-    ANativeWindowBuffer* buffer;
-    int fenceFd;
-    ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffer, &fenceFd));
-    ASSERT_EQ(NO_ERROR, window->cancelBuffer(window.get(), buffer, fenceFd));
-
-    // Detach the buffer and check its generation number
-    sp<GraphicBuffer> graphicBuffer;
-    sp<Fence> fence;
-    ASSERT_EQ(NO_ERROR, surface->detachNextBuffer(&graphicBuffer, &fence));
-    ASSERT_EQ(0U, graphicBuffer->getGenerationNumber());
-
-    ASSERT_EQ(NO_ERROR, surface->setGenerationNumber(1));
-    buffer = static_cast<ANativeWindowBuffer*>(graphicBuffer.get());
-
-    // This should change the generation number of the GraphicBuffer
-    ASSERT_EQ(NO_ERROR, surface->attachBuffer(buffer));
-
-    // Check that the new generation number sticks with the buffer
-    ASSERT_EQ(NO_ERROR, window->cancelBuffer(window.get(), buffer, -1));
-    ASSERT_EQ(NO_ERROR, window->dequeueBuffer(window.get(), &buffer, &fenceFd));
-    graphicBuffer = static_cast<GraphicBuffer*>(buffer);
-    ASSERT_EQ(1U, graphicBuffer->getGenerationNumber());
-}
-
-TEST_F(SurfaceTest, GetConsumerName) {
-    sp<IGraphicBufferProducer> producer;
-    sp<IGraphicBufferConsumer> consumer;
-    BufferQueue::createBufferQueue(&producer, &consumer);
-
-    sp<DummyConsumer> dummyConsumer(new DummyConsumer);
-    consumer->consumerConnect(dummyConsumer, false);
-    consumer->setConsumerName(String8("TestConsumer"));
-
-    sp<Surface> surface = new Surface(producer);
-    sp<ANativeWindow> window(surface);
-    native_window_api_connect(window.get(), NATIVE_WINDOW_API_CPU);
-
-    EXPECT_STREQ("TestConsumer", surface->getConsumerName().string());
-}
-
 }
diff --git a/libs/ui/Android.mk b/libs/ui/Android.mk
index 1ce8626..2991671 100644
--- a/libs/ui/Android.mk
+++ b/libs/ui/Android.mk
@@ -12,28 +12,10 @@
 # See the License for the specific language governing permissions and
 # limitations under the License.
 
-LOCAL_PATH := $(call my-dir)
+LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
-LOCAL_CLANG := true
-LOCAL_CPPFLAGS := -std=c++1y -Weverything -Werror
-
-# The static constructors and destructors in this library have not been noted to
-# introduce significant overheads
-LOCAL_CPPFLAGS += -Wno-exit-time-destructors
-LOCAL_CPPFLAGS += -Wno-global-constructors
-
-# We only care about compiling as C++14
-LOCAL_CPPFLAGS += -Wno-c++98-compat-pedantic
-
-# We use four-character constants for the GraphicBuffer header, and don't care
-# that they're non-portable as long as they're consistent within one execution
-LOCAL_CPPFLAGS += -Wno-four-char-constants
-
-# Don't warn about struct padding
-LOCAL_CPPFLAGS += -Wno-padded
-
-LOCAL_SRC_FILES := \
+LOCAL_SRC_FILES:= \
 	Fence.cpp \
 	FramebufferNativeWindow.cpp \
 	FrameStats.cpp \
@@ -56,7 +38,11 @@ ifneq ($(BOARD_FRAMEBUFFER_FORCE_FORMAT),)
 LOCAL_CFLAGS += -DFRAMEBUFFER_FORCE_FORMAT=$(BOARD_FRAMEBUFFER_FORCE_FORMAT)
 endif
 
-LOCAL_MODULE := libui
+ifeq ($(BOARD_HAVE_PIXEL_FORMAT_INFO),true)
+LOCAL_CFLAGS += -DHAVE_PIXEL_FORMAT_INFO
+endif
+
+LOCAL_MODULE:= libui
 
 include $(BUILD_SHARED_LIBRARY)
 
diff --git a/libs/ui/Fence.cpp b/libs/ui/Fence.cpp
index bf24ffb..3c0306c 100644
--- a/libs/ui/Fence.cpp
+++ b/libs/ui/Fence.cpp
@@ -18,13 +18,10 @@
 #define ATRACE_TAG ATRACE_TAG_GRAPHICS
 //#define LOG_NDEBUG 0
 
-// We would eliminate the non-conforming zero-length array, but we can't since
-// this is effectively included from the Linux kernel
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wzero-length-array"
-#include <sync/sync.h>
-#pragma clang diagnostic pop
+ // This is needed for stdint.h to define INT64_MAX in C++
+ #define __STDC_LIMIT_MACROS
 
+#include <sync/sync.h>
 #include <ui/Fence.h>
 #include <unistd.h>
 #include <utils/Log.h>
@@ -48,7 +45,7 @@ Fence::~Fence() {
     }
 }
 
-status_t Fence::wait(int timeout) {
+status_t Fence::wait(unsigned int timeout) {
     ATRACE_CALL();
     if (mFenceFd == -1) {
         return NO_ERROR;
@@ -62,7 +59,7 @@ status_t Fence::waitForever(const char* logname) {
     if (mFenceFd == -1) {
         return NO_ERROR;
     }
-    int warningTimeout = 3000;
+    unsigned int warningTimeout = 3000;
     int err = sync_wait(mFenceFd, warningTimeout);
     if (err < 0 && errno == ETIME) {
         ALOGE("%s: fence %d didn't signal in %u ms", logname, mFenceFd,
@@ -130,7 +127,7 @@ nsecs_t Fence::getSignalTime() const {
 }
 
 size_t Fence::getFlattenedSize() const {
-    return 4;
+    return 1;
 }
 
 size_t Fence::getFdCount() const {
@@ -141,9 +138,7 @@ status_t Fence::flatten(void*& buffer, size_t& size, int*& fds, size_t& count) c
     if (size < getFlattenedSize() || count < getFdCount()) {
         return NO_MEMORY;
     }
-    // Cast to uint32_t since the size of a size_t can vary between 32- and
-    // 64-bit processes
-    FlattenableUtils::write(buffer, size, static_cast<uint32_t>(getFdCount()));
+    FlattenableUtils::write(buffer, size, (uint32_t)getFdCount());
     if (isValid()) {
         *fds++ = mFenceFd;
         count--;
diff --git a/libs/ui/FramebufferNativeWindow.cpp b/libs/ui/FramebufferNativeWindow.cpp
index 3ead25c..918f2e7 100644
--- a/libs/ui/FramebufferNativeWindow.cpp
+++ b/libs/ui/FramebufferNativeWindow.cpp
@@ -1,17 +1,17 @@
-/*
+/* 
 **
 ** Copyright 2007 The Android Open Source Project
 **
-** Licensed under the Apache License Version 2.0(the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
+** Licensed under the Apache License Version 2.0(the "License"); 
+** you may not use this file except in compliance with the License. 
+** You may obtain a copy of the License at 
 **
-**     http://www.apache.org/licenses/LICENSE-2.0
+**     http://www.apache.org/licenses/LICENSE-2.0 
 **
-** Unless required by applicable law or agreed to in writing software
-** distributed under the License is distributed on an "AS IS" BASIS
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND either express or implied.
-** See the License for the specific language governing permissions and
+** Unless required by applicable law or agreed to in writing software 
+** distributed under the License is distributed on an "AS IS" BASIS 
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND either express or implied. 
+** See the License for the specific language governing permissions and 
 ** limitations under the License.
 */
 
@@ -29,9 +29,7 @@
 
 #include <ui/ANativeObjectBase.h>
 #include <ui/Fence.h>
-#define INCLUDED_FROM_FRAMEBUFFER_NATIVE_WINDOW_CPP
 #include <ui/FramebufferNativeWindow.h>
-#undef INCLUDED_FROM_FRAMEBUFFER_NATIVE_WINDOW_CPP
 #include <ui/Rect.h>
 
 #include <EGL/egl.h>
@@ -43,11 +41,11 @@
 namespace android {
 // ----------------------------------------------------------------------------
 
-class NativeBuffer final
+class NativeBuffer 
     : public ANativeObjectBase<
-        ANativeWindowBuffer,
-        NativeBuffer,
-        LightRefBase<NativeBuffer>>
+        ANativeWindowBuffer, 
+        NativeBuffer, 
+        LightRefBase<NativeBuffer> >
 {
 public:
     NativeBuffer(int w, int h, int f, int u) : BASE() {
@@ -57,41 +55,43 @@ public:
         ANativeWindowBuffer::usage  = u;
     }
 private:
-    friend class LightRefBase<NativeBuffer>;
+    friend class LightRefBase<NativeBuffer>;    
+    ~NativeBuffer() { }; // this class cannot be overloaded
 };
 
 
 /*
  * This implements the (main) framebuffer management. This class is used
  * mostly by SurfaceFlinger, but also by command line GL application.
- *
+ * 
  * In fact this is an implementation of ANativeWindow on top of
  * the framebuffer.
- *
- * Currently it is pretty simple, it manages only two buffers (the front and
+ * 
+ * Currently it is pretty simple, it manages only two buffers (the front and 
  * back buffer).
- *
+ * 
  */
 
-FramebufferNativeWindow::FramebufferNativeWindow()
+FramebufferNativeWindow::FramebufferNativeWindow() 
     : BASE(), fbDev(0), grDev(0), mUpdateOnDemand(false)
 {
     hw_module_t const* module;
     if (hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module) == 0) {
+        int stride;
         int err;
         int i;
         err = framebuffer_open(module, &fbDev);
         ALOGE_IF(err, "couldn't open framebuffer HAL (%s)", strerror(-err));
-
+        
         err = gralloc_open(module, &grDev);
         ALOGE_IF(err, "couldn't open gralloc HAL (%s)", strerror(-err));
 
         // bail out if we can't initialize the modules
         if (!fbDev || !grDev)
             return;
-
+        
         mUpdateOnDemand = (fbDev->setUpdateRect != 0);
-
+        
         // initialize the buffer FIFO
         if(fbDev->numFramebuffers >= MIN_NUM_FRAME_BUFFERS &&
            fbDev->numFramebuffers <= MAX_NUM_FRAME_BUFFERS){
@@ -114,37 +114,36 @@ FramebufferNativeWindow::FramebufferNativeWindow()
         *((uint32_t *)&fbDev->format) = FRAMEBUFFER_FORCE_FORMAT;
 #endif
 
-        for (i = 0; i < mNumBuffers; i++) {
-            buffers[i] = new NativeBuffer(
-                    static_cast<int>(fbDev->width),
-                    static_cast<int>(fbDev->height),
-                    fbDev->format, GRALLOC_USAGE_HW_FB);
+        for (i = 0; i < mNumBuffers; i++)
+        {
+                buffers[i] = new NativeBuffer(
+                        fbDev->width, fbDev->height, fbDev->format, GRALLOC_USAGE_HW_FB);
         }
 
-        for (i = 0; i < mNumBuffers; i++) {
-            err = grDev->alloc(grDev,
-                    static_cast<int>(fbDev->width),
-                    static_cast<int>(fbDev->height),
-                    fbDev->format, GRALLOC_USAGE_HW_FB,
-                    &buffers[i]->handle, &buffers[i]->stride);
-
-            ALOGE_IF(err, "fb buffer %d allocation failed w=%d, h=%d, err=%s",
-                    i, fbDev->width, fbDev->height, strerror(-err));
-
-            if (err) {
-                mNumBuffers = i;
-                mNumFreeBuffers = i;
-                mBufferHead = mNumBuffers-1;
-                break;
-            }
+        for (i = 0; i < mNumBuffers; i++)
+        {
+                err = grDev->alloc(grDev,
+                        fbDev->width, fbDev->height, fbDev->format,
+                        GRALLOC_USAGE_HW_FB, &buffers[i]->handle, &buffers[i]->stride);
+
+                ALOGE_IF(err, "fb buffer %d allocation failed w=%d, h=%d, err=%s",
+                        i, fbDev->width, fbDev->height, strerror(-err));
+
+                if (err)
+                {
+                        mNumBuffers = i;
+                        mNumFreeBuffers = i;
+                        mBufferHead = mNumBuffers-1;
+                        break;
+                }
         }
 
-        const_cast<uint32_t&>(ANativeWindow::flags) = fbDev->flags;
+        const_cast<uint32_t&>(ANativeWindow::flags) = fbDev->flags; 
         const_cast<float&>(ANativeWindow::xdpi) = fbDev->xdpi;
         const_cast<float&>(ANativeWindow::ydpi) = fbDev->ydpi;
-        const_cast<int&>(ANativeWindow::minSwapInterval) =
+        const_cast<int&>(ANativeWindow::minSwapInterval) = 
             fbDev->minSwapInterval;
-        const_cast<int&>(ANativeWindow::maxSwapInterval) =
+        const_cast<int&>(ANativeWindow::maxSwapInterval) = 
             fbDev->maxSwapInterval;
     } else {
         ALOGE("Couldn't get gralloc module");
@@ -161,7 +160,7 @@ FramebufferNativeWindow::FramebufferNativeWindow()
     ANativeWindow::queueBuffer_DEPRECATED = queueBuffer_DEPRECATED;
 }
 
-FramebufferNativeWindow::~FramebufferNativeWindow()
+FramebufferNativeWindow::~FramebufferNativeWindow() 
 {
     if (grDev) {
         for(int i = 0; i < mNumBuffers; i++) {
@@ -177,7 +176,7 @@ FramebufferNativeWindow::~FramebufferNativeWindow()
     }
 }
 
-status_t FramebufferNativeWindow::setUpdateRectangle(const Rect& r)
+status_t FramebufferNativeWindow::setUpdateRectangle(const Rect& r) 
 {
     if (!mUpdateOnDemand) {
         return INVALID_OPERATION;
@@ -194,7 +193,7 @@ status_t FramebufferNativeWindow::compositionComplete()
 }
 
 int FramebufferNativeWindow::setSwapInterval(
-        ANativeWindow* window, int interval)
+        ANativeWindow* window, int interval) 
 {
     framebuffer_device_t* fb = getSelf(window)->fbDev;
     return fb->setSwapInterval(fb, interval);
@@ -218,7 +217,7 @@ int FramebufferNativeWindow::getCurrentBufferIndex() const
     return index;
 }
 
-int FramebufferNativeWindow::dequeueBuffer_DEPRECATED(ANativeWindow* window,
+int FramebufferNativeWindow::dequeueBuffer_DEPRECATED(ANativeWindow* window, 
         ANativeWindowBuffer** buffer)
 {
     int fenceFd = -1;
@@ -233,11 +232,12 @@ int FramebufferNativeWindow::dequeueBuffer_DEPRECATED(ANativeWindow* window,
     return result;
 }
 
-int FramebufferNativeWindow::dequeueBuffer(ANativeWindow* window,
+int FramebufferNativeWindow::dequeueBuffer(ANativeWindow* window, 
         ANativeWindowBuffer** buffer, int* fenceFd)
 {
     FramebufferNativeWindow* self = getSelf(window);
     Mutex::Autolock _l(self->mutex);
+    framebuffer_device_t* fb = self->fbDev;
 
     int index = self->mBufferHead++;
     if (self->mBufferHead >= self->mNumBuffers)
@@ -247,7 +247,7 @@ int FramebufferNativeWindow::dequeueBuffer(ANativeWindow* window,
     while (self->mNumFreeBuffers < 2) {
         self->mCondition.wait(self->mutex);
     }
-    ALOG_ASSERT(self->buffers[index] != self->front, "");
+    ALOG_ASSERT(self->buffers[index] != self->front);
 
     // get this buffer
     self->mNumFreeBuffers--;
@@ -259,19 +259,19 @@ int FramebufferNativeWindow::dequeueBuffer(ANativeWindow* window,
     return 0;
 }
 
-int FramebufferNativeWindow::lockBuffer_DEPRECATED(ANativeWindow* /*window*/,
+int FramebufferNativeWindow::lockBuffer_DEPRECATED(ANativeWindow* /*window*/, 
         ANativeWindowBuffer* /*buffer*/)
 {
     return NO_ERROR;
 }
 
-int FramebufferNativeWindow::queueBuffer_DEPRECATED(ANativeWindow* window,
+int FramebufferNativeWindow::queueBuffer_DEPRECATED(ANativeWindow* window, 
         ANativeWindowBuffer* buffer)
 {
     return queueBuffer(window, buffer, -1);
 }
 
-int FramebufferNativeWindow::queueBuffer(ANativeWindow* window,
+int FramebufferNativeWindow::queueBuffer(ANativeWindow* window, 
         ANativeWindowBuffer* buffer, int fenceFd)
 {
     FramebufferNativeWindow* self = getSelf(window);
@@ -282,6 +282,7 @@ int FramebufferNativeWindow::queueBuffer(ANativeWindow* window,
     sp<Fence> fence(new Fence(fenceFd));
     fence->wait(Fence::TIMEOUT_NEVER);
 
+    const int index = self->mCurrentBufferIndex;
     int res = fb->post(fb, handle);
     self->front = static_cast<NativeBuffer*>(buffer);
     self->mNumFreeBuffers++;
@@ -290,17 +291,17 @@ int FramebufferNativeWindow::queueBuffer(ANativeWindow* window,
 }
 
 int FramebufferNativeWindow::query(const ANativeWindow* window,
-        int what, int* value)
+        int what, int* value) 
 {
     const FramebufferNativeWindow* self = getSelf(window);
     Mutex::Autolock _l(self->mutex);
     framebuffer_device_t* fb = self->fbDev;
     switch (what) {
         case NATIVE_WINDOW_WIDTH:
-            *value = static_cast<int>(fb->width);
+            *value = fb->width;
             return NO_ERROR;
         case NATIVE_WINDOW_HEIGHT:
-            *value = static_cast<int>(fb->height);
+            *value = fb->height;
             return NO_ERROR;
         case NATIVE_WINDOW_FORMAT:
             *value = fb->format;
@@ -312,10 +313,10 @@ int FramebufferNativeWindow::query(const ANativeWindow* window,
             *value = 0;
             return NO_ERROR;
         case NATIVE_WINDOW_DEFAULT_WIDTH:
-            *value = static_cast<int>(fb->width);
+            *value = fb->width;
             return NO_ERROR;
         case NATIVE_WINDOW_DEFAULT_HEIGHT:
-            *value = static_cast<int>(fb->height);
+            *value = fb->height;
             return NO_ERROR;
         case NATIVE_WINDOW_TRANSFORM_HINT:
             *value = 0;
@@ -356,8 +357,7 @@ int FramebufferNativeWindow::perform(ANativeWindow* /*window*/,
 }; // namespace android
 // ----------------------------------------------------------------------------
 
-using android::sp;
-using android::FramebufferNativeWindow;
+using namespace android;
 
 EGLNativeWindowType android_createDisplaySurface(void)
 {
@@ -368,5 +368,5 @@ EGLNativeWindowType android_createDisplaySurface(void)
         sp<FramebufferNativeWindow> ref(w);
         return NULL;
     }
-    return static_cast<EGLNativeWindowType>(w);
+    return (EGLNativeWindowType)w;
 }
diff --git a/libs/ui/GraphicBuffer.cpp b/libs/ui/GraphicBuffer.cpp
index e55db30..4c46deb 100644
--- a/libs/ui/GraphicBuffer.cpp
+++ b/libs/ui/GraphicBuffer.cpp
@@ -45,18 +45,33 @@ GraphicBuffer::GraphicBuffer()
     : BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),
       mInitCheck(NO_ERROR), mId(getUniqueId())
 {
+    width  = 
+    height = 
+    stride = 
+    format = 
+    usage  = 0;
+    handle = NULL;
+}
+
+GraphicBuffer::GraphicBuffer(uint32_t w, uint32_t h,
+        PixelFormat reqFormat, uint32_t reqUsage)
+    : BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),
+      mInitCheck(NO_ERROR), mId(getUniqueId())
+{
     width  =
     height =
     stride =
     format =
     usage  = 0;
     handle = NULL;
+    mInitCheck = initSize(w, h, reqFormat, reqUsage);
 }
 
-GraphicBuffer::GraphicBuffer(uint32_t inWidth, uint32_t inHeight,
-        PixelFormat inFormat, uint32_t inUsage)
+#ifdef QCOM_BSP_LEGACY
+GraphicBuffer::GraphicBuffer(uint32_t w, uint32_t h,
+        PixelFormat reqFormat, uint32_t reqUsage, uint32_t bufferSize)
     : BASE(), mOwner(ownData), mBufferMapper(GraphicBufferMapper::get()),
-      mInitCheck(NO_ERROR), mId(getUniqueId())
+      mInitCheck(NO_ERROR)
 {
     width  =
     height =
@@ -64,21 +79,22 @@ GraphicBuffer::GraphicBuffer(uint32_t inWidth, uint32_t inHeight,
     format =
     usage  = 0;
     handle = NULL;
-    mInitCheck = initSize(inWidth, inHeight, inFormat, inUsage);
+    mInitCheck = initSize(w, h, reqFormat, reqUsage, bufferSize);
 }
+#endif
 
-GraphicBuffer::GraphicBuffer(uint32_t inWidth, uint32_t inHeight,
-        PixelFormat inFormat, uint32_t inUsage, uint32_t inStride,
-        native_handle_t* inHandle, bool keepOwnership)
+GraphicBuffer::GraphicBuffer(uint32_t w, uint32_t h,
+        PixelFormat inFormat, uint32_t inUsage,
+        uint32_t inStride, native_handle_t* inHandle, bool keepOwnership)
     : BASE(), mOwner(keepOwnership ? ownHandle : ownNone),
       mBufferMapper(GraphicBufferMapper::get()),
       mInitCheck(NO_ERROR), mId(getUniqueId())
 {
-    width  = static_cast<int>(inWidth);
-    height = static_cast<int>(inHeight);
-    stride = static_cast<int>(inStride);
+    width  = w;
+    height = h;
+    stride = inStride;
     format = inFormat;
-    usage  = static_cast<int>(inUsage);
+    usage  = inUsage;
     handle = inHandle;
 }
 
@@ -116,7 +132,7 @@ void GraphicBuffer::free_handle()
 }
 
 status_t GraphicBuffer::initCheck() const {
-    return static_cast<status_t>(mInitCheck);
+    return mInitCheck;
 }
 
 void GraphicBuffer::dumpAllocationsToSystemLog()
@@ -131,17 +147,13 @@ ANativeWindowBuffer* GraphicBuffer::getNativeBuffer() const
             const_cast<GraphicBuffer*>(this));
 }
 
-status_t GraphicBuffer::reallocate(uint32_t inWidth, uint32_t inHeight,
-        PixelFormat inFormat, uint32_t inUsage)
+status_t GraphicBuffer::reallocate(uint32_t w, uint32_t h, PixelFormat f,
+        uint32_t reqUsage)
 {
     if (mOwner != ownData)
         return INVALID_OPERATION;
 
-    if (handle &&
-            static_cast<int>(inWidth) == width &&
-            static_cast<int>(inHeight) == height &&
-            inFormat == format &&
-            static_cast<int>(inUsage) == usage)
+    if (handle && w==width && h==height && f==format && reqUsage==usage)
         return NO_ERROR;
 
     if (handle) {
@@ -149,74 +161,78 @@ status_t GraphicBuffer::reallocate(uint32_t inWidth, uint32_t inHeight,
         allocator.free(handle);
         handle = 0;
     }
-    return initSize(inWidth, inHeight, inFormat, inUsage);
+    return initSize(w, h, f, reqUsage);
 }
 
-bool GraphicBuffer::needsReallocation(uint32_t inWidth, uint32_t inHeight,
-        PixelFormat inFormat, uint32_t inUsage)
+status_t GraphicBuffer::initSize(uint32_t w, uint32_t h, PixelFormat format,
+        uint32_t reqUsage)
 {
-    if (static_cast<int>(inWidth) != width) return true;
-    if (static_cast<int>(inHeight) != height) return true;
-    if (inFormat != format) return true;
-    if ((static_cast<uint32_t>(usage) & inUsage) != inUsage) return true;
-    return false;
+    GraphicBufferAllocator& allocator = GraphicBufferAllocator::get();
+    status_t err = allocator.alloc(w, h, format, reqUsage, &handle, &stride);
+    if (err == NO_ERROR) {
+        this->width  = w;
+        this->height = h;
+        this->format = format;
+        this->usage  = reqUsage;
+    }
+    return err;
 }
 
-status_t GraphicBuffer::initSize(uint32_t inWidth, uint32_t inHeight,
-        PixelFormat inFormat, uint32_t inUsage)
+#ifdef QCOM_BSP_LEGACY
+status_t GraphicBuffer::initSize(uint32_t w, uint32_t h, PixelFormat format,
+                                 uint32_t reqUsage, uint32_t bufferSize)
 {
     GraphicBufferAllocator& allocator = GraphicBufferAllocator::get();
-    uint32_t outStride = 0;
-    status_t err = allocator.alloc(inWidth, inHeight, inFormat, inUsage,
-            &handle, &outStride);
+    status_t err = allocator.alloc(w, h, format,
+                                   reqUsage, &handle, &stride, bufferSize);
     if (err == NO_ERROR) {
-        width = static_cast<int>(inWidth);
-        height = static_cast<int>(inHeight);
-        format = inFormat;
-        usage = static_cast<int>(inUsage);
-        stride = static_cast<int>(outStride);
+        this->width  = w;
+        this->height = h;
+        this->format = format;
+        this->usage  = reqUsage;
     }
     return err;
 }
+#endif
 
-status_t GraphicBuffer::lock(uint32_t inUsage, void** vaddr)
+status_t GraphicBuffer::lock(uint32_t usage, void** vaddr)
 {
     const Rect lockBounds(width, height);
-    status_t res = lock(inUsage, lockBounds, vaddr);
+    status_t res = lock(usage, lockBounds, vaddr);
     return res;
 }
 
-status_t GraphicBuffer::lock(uint32_t inUsage, const Rect& rect, void** vaddr)
+status_t GraphicBuffer::lock(uint32_t usage, const Rect& rect, void** vaddr)
 {
-    if (rect.left < 0 || rect.right  > width ||
-        rect.top  < 0 || rect.bottom > height) {
+    if (rect.left < 0 || rect.right  > this->width ||
+        rect.top  < 0 || rect.bottom > this->height) {
         ALOGE("locking pixels (%d,%d,%d,%d) outside of buffer (w=%d, h=%d)",
                 rect.left, rect.top, rect.right, rect.bottom,
-                width, height);
+                this->width, this->height);
         return BAD_VALUE;
     }
-    status_t res = getBufferMapper().lock(handle, inUsage, rect, vaddr);
+    status_t res = getBufferMapper().lock(handle, usage, rect, vaddr);
     return res;
 }
 
-status_t GraphicBuffer::lockYCbCr(uint32_t inUsage, android_ycbcr* ycbcr)
+status_t GraphicBuffer::lockYCbCr(uint32_t usage, android_ycbcr *ycbcr)
 {
     const Rect lockBounds(width, height);
-    status_t res = lockYCbCr(inUsage, lockBounds, ycbcr);
+    status_t res = lockYCbCr(usage, lockBounds, ycbcr);
     return res;
 }
 
-status_t GraphicBuffer::lockYCbCr(uint32_t inUsage, const Rect& rect,
-        android_ycbcr* ycbcr)
+status_t GraphicBuffer::lockYCbCr(uint32_t usage, const Rect& rect,
+        android_ycbcr *ycbcr)
 {
-    if (rect.left < 0 || rect.right  > width ||
-        rect.top  < 0 || rect.bottom > height) {
+    if (rect.left < 0 || rect.right  > this->width ||
+        rect.top  < 0 || rect.bottom > this->height) {
         ALOGE("locking pixels (%d,%d,%d,%d) outside of buffer (w=%d, h=%d)",
                 rect.left, rect.top, rect.right, rect.bottom,
-                width, height);
+                this->width, this->height);
         return BAD_VALUE;
     }
-    status_t res = getBufferMapper().lockYCbCr(handle, inUsage, rect, ycbcr);
+    status_t res = getBufferMapper().lockYCbCr(handle, usage, rect, ycbcr);
     return res;
 }
 
@@ -226,48 +242,43 @@ status_t GraphicBuffer::unlock()
     return res;
 }
 
-status_t GraphicBuffer::lockAsync(uint32_t inUsage, void** vaddr, int fenceFd)
+status_t GraphicBuffer::lockAsync(uint32_t usage, void** vaddr, int fenceFd)
 {
     const Rect lockBounds(width, height);
-    status_t res = lockAsync(inUsage, lockBounds, vaddr, fenceFd);
+    status_t res = lockAsync(usage, lockBounds, vaddr, fenceFd);
     return res;
 }
 
-status_t GraphicBuffer::lockAsync(uint32_t inUsage, const Rect& rect,
-        void** vaddr, int fenceFd)
+status_t GraphicBuffer::lockAsync(uint32_t usage, const Rect& rect, void** vaddr, int fenceFd)
 {
-    if (rect.left < 0 || rect.right  > width ||
-        rect.top  < 0 || rect.bottom > height) {
+    if (rect.left < 0 || rect.right  > this->width ||
+        rect.top  < 0 || rect.bottom > this->height) {
         ALOGE("locking pixels (%d,%d,%d,%d) outside of buffer (w=%d, h=%d)",
                 rect.left, rect.top, rect.right, rect.bottom,
-                width, height);
+                this->width, this->height);
         return BAD_VALUE;
     }
-    status_t res = getBufferMapper().lockAsync(handle, inUsage, rect, vaddr,
-            fenceFd);
+    status_t res = getBufferMapper().lockAsync(handle, usage, rect, vaddr, fenceFd);
     return res;
 }
 
-status_t GraphicBuffer::lockAsyncYCbCr(uint32_t inUsage, android_ycbcr* ycbcr,
-        int fenceFd)
+status_t GraphicBuffer::lockAsyncYCbCr(uint32_t usage, android_ycbcr *ycbcr, int fenceFd)
 {
     const Rect lockBounds(width, height);
-    status_t res = lockAsyncYCbCr(inUsage, lockBounds, ycbcr, fenceFd);
+    status_t res = lockAsyncYCbCr(usage, lockBounds, ycbcr, fenceFd);
     return res;
 }
 
-status_t GraphicBuffer::lockAsyncYCbCr(uint32_t inUsage, const Rect& rect,
-        android_ycbcr* ycbcr, int fenceFd)
+status_t GraphicBuffer::lockAsyncYCbCr(uint32_t usage, const Rect& rect, android_ycbcr *ycbcr, int fenceFd)
 {
-    if (rect.left < 0 || rect.right  > width ||
-        rect.top  < 0 || rect.bottom > height) {
+    if (rect.left < 0 || rect.right  > this->width ||
+        rect.top  < 0 || rect.bottom > this->height) {
         ALOGE("locking pixels (%d,%d,%d,%d) outside of buffer (w=%d, h=%d)",
                 rect.left, rect.top, rect.right, rect.bottom,
-                width, height);
+                this->width, this->height);
         return BAD_VALUE;
     }
-    status_t res = getBufferMapper().lockAsyncYCbCr(handle, inUsage, rect,
-            ycbcr, fenceFd);
+    status_t res = getBufferMapper().lockAsyncYCbCr(handle, usage, rect, ycbcr, fenceFd);
     return res;
 }
 
@@ -278,11 +289,11 @@ status_t GraphicBuffer::unlockAsync(int *fenceFd)
 }
 
 size_t GraphicBuffer::getFlattenedSize() const {
-    return static_cast<size_t>(11 + (handle ? handle->numInts : 0)) * sizeof(int);
+    return (10 + (handle ? handle->numInts : 0))*sizeof(int);
 }
 
 size_t GraphicBuffer::getFdCount() const {
-    return static_cast<size_t>(handle ? handle->numFds : 0);
+    return handle ? handle->numFds : 0;
 }
 
 status_t GraphicBuffer::flatten(void*& buffer, size_t& size, int*& fds, size_t& count) const {
@@ -301,24 +312,22 @@ status_t GraphicBuffer::flatten(void*& buffer, size_t& size, int*& fds, size_t&
     buf[5] = usage;
     buf[6] = static_cast<int32_t>(mId >> 32);
     buf[7] = static_cast<int32_t>(mId & 0xFFFFFFFFull);
-    buf[8] = static_cast<int32_t>(mGenerationNumber);
+    buf[8] = 0;
     buf[9] = 0;
-    buf[10] = 0;
 
     if (handle) {
-        buf[9] = handle->numFds;
-        buf[10] = handle->numInts;
-        memcpy(fds, handle->data,
-                static_cast<size_t>(handle->numFds) * sizeof(int));
-        memcpy(&buf[11], handle->data + handle->numFds,
-                static_cast<size_t>(handle->numInts) * sizeof(int));
+        buf[8] = handle->numFds;
+        buf[9] = handle->numInts;
+        native_handle_t const* const h = handle;
+        memcpy(fds,     h->data,             h->numFds*sizeof(int));
+        memcpy(&buf[10], h->data + h->numFds, h->numInts*sizeof(int));
     }
 
-    buffer = static_cast<void*>(static_cast<uint8_t*>(buffer) + sizeNeeded);
+    buffer = reinterpret_cast<void*>(static_cast<int*>(buffer) + sizeNeeded);
     size -= sizeNeeded;
     if (handle) {
         fds += handle->numFds;
-        count -= static_cast<size_t>(handle->numFds);
+        count -= handle->numFds;
     }
 
     return NO_ERROR;
@@ -326,28 +335,28 @@ status_t GraphicBuffer::flatten(void*& buffer, size_t& size, int*& fds, size_t&
 
 status_t GraphicBuffer::unflatten(
         void const*& buffer, size_t& size, int const*& fds, size_t& count) {
-    if (size < 11 * sizeof(int)) return NO_MEMORY;
+    if (size < 8*sizeof(int)) return NO_MEMORY;
 
     int const* buf = static_cast<int const*>(buffer);
     if (buf[0] != 'GBFR') return BAD_TYPE;
 
-    const size_t numFds  = static_cast<size_t>(buf[9]);
-    const size_t numInts = static_cast<size_t>(buf[10]);
+    const size_t numFds  = buf[8];
+    const size_t numInts = buf[9];
 
     // Limit the maxNumber to be relatively small. The number of fds or ints
     // should not come close to this number, and the number itself was simply
     // chosen to be high enough to not cause issues and low enough to prevent
     // overflow problems.
     const size_t maxNumber = 4096;
-    if (numFds >= maxNumber || numInts >= (maxNumber - 11)) {
+    if (numFds >= maxNumber || numInts >= (maxNumber - 10)) {
         width = height = stride = format = usage = 0;
         handle = NULL;
-        ALOGE("unflatten: numFds or numInts is too large: %zd, %zd",
+        ALOGE("unflatten: numFds or numInts is too large: %d, %d",
                 numFds, numInts);
         return BAD_VALUE;
     }
 
-    const size_t sizeNeeded = (11 + numInts) * sizeof(int);
+    const size_t sizeNeeded = (10 + numInts) * sizeof(int);
     if (size < sizeNeeded) return NO_MEMORY;
 
     size_t fdCountNeeded = numFds;
@@ -364,16 +373,15 @@ status_t GraphicBuffer::unflatten(
         stride = buf[3];
         format = buf[4];
         usage  = buf[5];
-        native_handle* h = native_handle_create(
-                static_cast<int>(numFds), static_cast<int>(numInts));
+        native_handle* h = native_handle_create(numFds, numInts);
         if (!h) {
             width = height = stride = format = usage = 0;
             handle = NULL;
             ALOGE("unflatten: native_handle_create failed");
             return NO_MEMORY;
         }
-        memcpy(h->data, fds, numFds * sizeof(int));
-        memcpy(h->data + numFds, &buf[11], numInts * sizeof(int));
+        memcpy(h->data,          fds,     numFds*sizeof(int));
+        memcpy(h->data + numFds, &buf[10], numInts*sizeof(int));
         handle = h;
     } else {
         width = height = stride = format = usage = 0;
@@ -383,8 +391,6 @@ status_t GraphicBuffer::unflatten(
     mId = static_cast<uint64_t>(buf[6]) << 32;
     mId |= static_cast<uint32_t>(buf[7]);
 
-    mGenerationNumber = static_cast<uint32_t>(buf[8]);
-
     mOwner = ownHandle;
 
     if (handle != 0) {
@@ -398,7 +404,7 @@ status_t GraphicBuffer::unflatten(
         }
     }
 
-    buffer = static_cast<void const*>(static_cast<uint8_t const*>(buffer) + sizeNeeded);
+    buffer = reinterpret_cast<void const*>(static_cast<int const*>(buffer) + sizeNeeded);
     size -= sizeNeeded;
     fds += numFds;
     count -= numFds;
diff --git a/libs/ui/GraphicBufferAllocator.cpp b/libs/ui/GraphicBufferAllocator.cpp
index 9b265af..97744df 100644
--- a/libs/ui/GraphicBufferAllocator.cpp
+++ b/libs/ui/GraphicBufferAllocator.cpp
@@ -66,11 +66,11 @@ void GraphicBufferAllocator::dump(String8& result) const
         if (rec.size) {
             snprintf(buffer, SIZE, "%10p: %7.2f KiB | %4u (%4u) x %4u | %8X | 0x%08x\n",
                     list.keyAt(i), rec.size/1024.0f,
-                    rec.width, rec.stride, rec.height, rec.format, rec.usage);
+                    rec.w, rec.s, rec.h, rec.format, rec.usage);
         } else {
             snprintf(buffer, SIZE, "%10p: unknown     | %4u (%4u) x %4u | %8X | 0x%08x\n",
                     list.keyAt(i),
-                    rec.width, rec.stride, rec.height, rec.format, rec.usage);
+                    rec.w, rec.s, rec.h, rec.format, rec.usage);
         }
         result.append(buffer);
         total += rec.size;
@@ -90,43 +90,59 @@ void GraphicBufferAllocator::dumpToSystemLog()
     ALOGD("%s", s.string());
 }
 
-status_t GraphicBufferAllocator::alloc(uint32_t width, uint32_t height,
-        PixelFormat format, uint32_t usage, buffer_handle_t* handle,
-        uint32_t* stride)
+status_t GraphicBufferAllocator::alloc(uint32_t w, uint32_t h, PixelFormat format,
+        int usage, buffer_handle_t* handle, int32_t* stride)
 {
-    ATRACE_CALL();
+#ifdef QCOM_BSP_LEGACY
+    status_t err = alloc(w, h, format, usage, handle, stride, 0);
+    return err;
+}
 
+status_t GraphicBufferAllocator::alloc(uint32_t w, uint32_t h,
+                                       PixelFormat format, int usage,
+                                       buffer_handle_t* handle,
+                                       int32_t* stride, uint32_t bufferSize)
+{
+#endif
+    ATRACE_CALL();
     // make sure to not allocate a N x 0 or 0 x N buffer, since this is
     // allowed from an API stand-point allocate a 1x1 buffer instead.
-    if (!width || !height)
-        width = height = 1;
+    if (!w || !h)
+        w = h = 1;
 
     // we have a h/w allocator and h/w buffer is requested
     status_t err;
-
-    // Filter out any usage bits that should not be passed to the gralloc module
-    usage &= GRALLOC_USAGE_ALLOC_MASK;
-
-    int outStride = 0;
-    err = mAllocDev->alloc(mAllocDev, static_cast<int>(width),
-            static_cast<int>(height), format, static_cast<int>(usage), handle,
-            &outStride);
-    *stride = static_cast<uint32_t>(outStride);
-
+#ifdef QCOM_BSP_LEGACY
+    if(bufferSize) {
+        err = mAllocDev->allocSize(mAllocDev, w, h,
+                               format, usage, handle, stride, bufferSize);
+    } else {
+        err = mAllocDev->alloc(mAllocDev, w, h, format, usage, handle, stride);
+    }
+    ALOGW_IF(err, "alloc(%u, %u, %d, %08x, %d ...) failed %d (%s)",
+            w, h, format, usage, bufferSize, err, strerror(-err));
+#else
+    err = mAllocDev->alloc(mAllocDev, w, h, format, usage, handle, stride);
     ALOGW_IF(err, "alloc(%u, %u, %d, %08x, ...) failed %d (%s)",
-            width, height, format, usage, err, strerror(-err));
+            w, h, format, usage, err, strerror(-err));
+#endif
 
     if (err == NO_ERROR) {
         Mutex::Autolock _l(sLock);
         KeyedVector<buffer_handle_t, alloc_rec_t>& list(sAllocList);
-        uint32_t bpp = bytesPerPixel(format);
+        int bpp = bytesPerPixel(format);
+        if (bpp < 0) {
+            // probably a HAL custom format. in any case, we don't know
+            // what its pixel size is.
+            bpp = 0;
+        }
         alloc_rec_t rec;
-        rec.width = width;
-        rec.height = height;
-        rec.stride = *stride;
+        rec.w = w;
+        rec.h = h;
+        rec.s = *stride;
         rec.format = format;
         rec.usage = usage;
-        rec.size = static_cast<size_t>(height * (*stride) * bpp);
+        rec.size = h * stride[0] * bpp;
         list.add(*handle, rec);
     }
 
diff --git a/libs/ui/GraphicBufferMapper.cpp b/libs/ui/GraphicBufferMapper.cpp
index 90a1c11..ce76e7a 100644
--- a/libs/ui/GraphicBufferMapper.cpp
+++ b/libs/ui/GraphicBufferMapper.cpp
@@ -20,12 +20,7 @@
 #include <stdint.h>
 #include <errno.h>
 
-// We would eliminate the non-conforming zero-length array, but we can't since
-// this is effectively included from the Linux kernel
-#pragma clang diagnostic push
-#pragma clang diagnostic ignored "-Wzero-length-array"
 #include <sync/sync.h>
-#pragma clang diagnostic pop
 
 #include <utils/Errors.h>
 #include <utils/Log.h>
@@ -49,7 +44,7 @@ GraphicBufferMapper::GraphicBufferMapper()
     int err = hw_get_module(GRALLOC_HARDWARE_MODULE_ID, &module);
     ALOGE_IF(err, "FATAL: can't find the %s module", GRALLOC_HARDWARE_MODULE_ID);
     if (err == 0) {
-        mAllocMod = reinterpret_cast<gralloc_module_t const *>(module);
+        mAllocMod = (gralloc_module_t const *)module;
     }
 }
 
@@ -77,13 +72,13 @@ status_t GraphicBufferMapper::unregisterBuffer(buffer_handle_t handle)
     return err;
 }
 
-status_t GraphicBufferMapper::lock(buffer_handle_t handle,
-        uint32_t usage, const Rect& bounds, void** vaddr)
+status_t GraphicBufferMapper::lock(buffer_handle_t handle, 
+        int usage, const Rect& bounds, void** vaddr)
 {
     ATRACE_CALL();
     status_t err;
 
-    err = mAllocMod->lock(mAllocMod, handle, static_cast<int>(usage),
+    err = mAllocMod->lock(mAllocMod, handle, usage,
             bounds.left, bounds.top, bounds.width(), bounds.height(),
             vaddr);
 
@@ -92,7 +87,7 @@ status_t GraphicBufferMapper::lock(buffer_handle_t handle,
 }
 
 status_t GraphicBufferMapper::lockYCbCr(buffer_handle_t handle,
-        uint32_t usage, const Rect& bounds, android_ycbcr *ycbcr)
+        int usage, const Rect& bounds, android_ycbcr *ycbcr)
 {
     ATRACE_CALL();
     status_t err;
@@ -101,7 +96,7 @@ status_t GraphicBufferMapper::lockYCbCr(buffer_handle_t handle,
         return -EINVAL; // do not log failure
     }
 
-    err = mAllocMod->lock_ycbcr(mAllocMod, handle, static_cast<int>(usage),
+    err = mAllocMod->lock_ycbcr(mAllocMod, handle, usage,
             bounds.left, bounds.top, bounds.width(), bounds.height(),
             ycbcr);
 
@@ -121,21 +116,19 @@ status_t GraphicBufferMapper::unlock(buffer_handle_t handle)
 }
 
 status_t GraphicBufferMapper::lockAsync(buffer_handle_t handle,
-        uint32_t usage, const Rect& bounds, void** vaddr, int fenceFd)
+        int usage, const Rect& bounds, void** vaddr, int fenceFd)
 {
     ATRACE_CALL();
     status_t err;
 
     if (mAllocMod->common.module_api_version >= GRALLOC_MODULE_API_VERSION_0_3) {
-        err = mAllocMod->lockAsync(mAllocMod, handle, static_cast<int>(usage),
+        err = mAllocMod->lockAsync(mAllocMod, handle, usage,
                 bounds.left, bounds.top, bounds.width(), bounds.height(),
                 vaddr, fenceFd);
     } else {
-        if (fenceFd >= 0) {
-            sync_wait(fenceFd, -1);
-            close(fenceFd);
-        }
-        err = mAllocMod->lock(mAllocMod, handle, static_cast<int>(usage),
+        sync_wait(fenceFd, -1);
+        close(fenceFd);
+        err = mAllocMod->lock(mAllocMod, handle, usage,
                 bounds.left, bounds.top, bounds.width(), bounds.height(),
                 vaddr);
     }
@@ -145,28 +138,23 @@ status_t GraphicBufferMapper::lockAsync(buffer_handle_t handle,
 }
 
 status_t GraphicBufferMapper::lockAsyncYCbCr(buffer_handle_t handle,
-        uint32_t usage, const Rect& bounds, android_ycbcr *ycbcr, int fenceFd)
+        int usage, const Rect& bounds, android_ycbcr *ycbcr, int fenceFd)
 {
     ATRACE_CALL();
     status_t err;
 
     if (mAllocMod->common.module_api_version >= GRALLOC_MODULE_API_VERSION_0_3
             && mAllocMod->lockAsync_ycbcr != NULL) {
-        err = mAllocMod->lockAsync_ycbcr(mAllocMod, handle,
-                static_cast<int>(usage), bounds.left, bounds.top,
-                bounds.width(), bounds.height(), ycbcr, fenceFd);
+        err = mAllocMod->lockAsync_ycbcr(mAllocMod, handle, usage,
+                bounds.left, bounds.top, bounds.width(), bounds.height(),
+                ycbcr, fenceFd);
     } else if (mAllocMod->lock_ycbcr != NULL) {
-        if (fenceFd >= 0) {
-            sync_wait(fenceFd, -1);
-            close(fenceFd);
-        }
-        err = mAllocMod->lock_ycbcr(mAllocMod, handle, static_cast<int>(usage),
+        sync_wait(fenceFd, -1);
+        close(fenceFd);
+        err = mAllocMod->lock_ycbcr(mAllocMod, handle, usage,
                 bounds.left, bounds.top, bounds.width(), bounds.height(),
                 ycbcr);
     } else {
-        if (fenceFd >= 0) {
-            close(fenceFd);
-        }
         return -EINVAL; // do not log failure
     }
 
@@ -190,5 +178,19 @@ status_t GraphicBufferMapper::unlockAsync(buffer_handle_t handle, int *fenceFd)
     return err;
 }
 
+#ifdef EXYNOS4_ENHANCEMENTS
+status_t GraphicBufferMapper::getphys(buffer_handle_t handle, void** paddr)
+{
+    status_t err;
+
+    err = mAllocMod->getphys(mAllocMod, handle, paddr);
+
+    ALOGW_IF(err, "getphys(%p) fail %d(%s)",
+    handle, err, strerror(-err));
+    return err;
+}
+#endif
+
+
 // ---------------------------------------------------------------------------
 }; // namespace android
diff --git a/libs/ui/PixelFormat.cpp b/libs/ui/PixelFormat.cpp
index cab1dde..a716949 100644
--- a/libs/ui/PixelFormat.cpp
+++ b/libs/ui/PixelFormat.cpp
@@ -15,16 +15,126 @@
  */
 
 #include <ui/PixelFormat.h>
+#include <hardware/hardware.h>
 
 // ----------------------------------------------------------------------------
 namespace android {
 // ----------------------------------------------------------------------------
 
-uint32_t bytesPerPixel(PixelFormat format) {
+#ifdef HAVE_PIXEL_FORMAT_INFO
+static const int COMPONENT_YUV = 0xFF;
+
+struct Info {
+    size_t      size;
+    size_t      bitsPerPixel;
+    struct {
+        uint8_t     ah;
+        uint8_t     al;
+        uint8_t     rh;
+        uint8_t     rl;
+        uint8_t     gh;
+        uint8_t     gl;
+        uint8_t     bh;
+        uint8_t     bl;
+    };
+    uint8_t     components;
+};
+
+static Info const sPixelFormatInfos[] = {
+        { 0,  0, { 0, 0,   0, 0,   0, 0,   0, 0 }, 0 },
+        { 4, 32, {32,24,   8, 0,  16, 8,  24,16 }, PixelFormatInfo::RGBA },
+        { 4, 24, { 0, 0,   8, 0,  16, 8,  24,16 }, PixelFormatInfo::RGB  },
+        { 3, 24, { 0, 0,   8, 0,  16, 8,  24,16 }, PixelFormatInfo::RGB  },
+        { 2, 16, { 0, 0,  16,11,  11, 5,   5, 0 }, PixelFormatInfo::RGB  },
+        { 4, 32, {32,24,  24,16,  16, 8,   8, 0 }, PixelFormatInfo::RGBA },
+        { 2, 16, { 1, 0,  16,11,  11, 6,   6, 1 }, PixelFormatInfo::RGBA },
+        { 2, 16, { 4, 0,  16,12,  12, 8,   8, 4 }, PixelFormatInfo::RGBA },
+        { 1,  8, { 8, 0,   0, 0,   0, 0,   0, 0 }, PixelFormatInfo::ALPHA},
+        { 1,  8, { 0, 0,   8, 0,   8, 0,   8, 0 }, PixelFormatInfo::L    },
+        { 2, 16, {16, 8,   8, 0,   8, 0,   8, 0 }, PixelFormatInfo::LA   },
+        { 1,  8, { 0, 0,   8, 5,   5, 2,   2, 0 }, PixelFormatInfo::RGB  },
+};
+
+static const Info* gGetPixelFormatTable(size_t* numEntries) {
+    if (numEntries) {
+        *numEntries = sizeof(sPixelFormatInfos)/sizeof(Info);
+    }
+    return sPixelFormatInfos;
+}
+
+// ----------------------------------------------------------------------------
+
+size_t PixelFormatInfo::getScanlineSize(unsigned int width) const
+{
+    size_t size;
+    if (components == COMPONENT_YUV) {
+        // YCbCr formats are different.
+        size = (width * bitsPerPixel)>>3;
+    } else {
+        size = width * bytesPerPixel;
+    }
+    return size;
+}
+
+status_t getPixelFormatInfo(PixelFormat format, PixelFormatInfo* info)
+{
+    if (format <= 0)
+        return BAD_VALUE;
+
+    if (info->version != sizeof(PixelFormatInfo))
+        return INVALID_OPERATION;
+
+    // YUV format from the HAL are handled here
+    switch (format) {
+    case HAL_PIXEL_FORMAT_YCbCr_422_SP:
+    case HAL_PIXEL_FORMAT_YCbCr_422_I:
+        info->bitsPerPixel = 16;
+        goto done;
+    case HAL_PIXEL_FORMAT_YCrCb_420_SP:
+    case HAL_PIXEL_FORMAT_YV12:
+        info->bitsPerPixel = 12;
+     done:
+        info->format = format;
+        info->components = COMPONENT_YUV;
+        info->bytesPerPixel = 1;
+        info->h_alpha = 0;
+        info->l_alpha = 0;
+        info->h_red = info->h_green = info->h_blue = 8;
+        info->l_red = info->l_green = info->l_blue = 0;
+        return NO_ERROR;
+    }
+
+    size_t numEntries;
+    const Info *i = gGetPixelFormatTable(&numEntries) + format;
+    bool valid = uint32_t(format) < numEntries;
+    if (!valid) {
+        return BAD_INDEX;
+    }
+
+    info->format = format;
+    info->bytesPerPixel = i->size;
+    info->bitsPerPixel  = i->bitsPerPixel;
+    info->h_alpha       = i->ah;
+    info->l_alpha       = i->al;
+    info->h_red         = i->rh;
+    info->l_red         = i->rl;
+    info->h_green       = i->gh;
+    info->l_green       = i->gl;
+    info->h_blue        = i->bh;
+    info->l_blue        = i->bl;
+    info->components    = i->components;
+
+    return NO_ERROR;
+}
+#endif
+
+ssize_t bytesPerPixel(PixelFormat format) {
     switch (format) {
         case PIXEL_FORMAT_RGBA_8888:
         case PIXEL_FORMAT_RGBX_8888:
         case PIXEL_FORMAT_BGRA_8888:
+        case PIXEL_FORMAT_sRGB_A_8888:
+        case PIXEL_FORMAT_sRGB_X_8888:
             return 4;
         case PIXEL_FORMAT_RGB_888:
             return 3;
@@ -33,10 +143,10 @@ uint32_t bytesPerPixel(PixelFormat format) {
         case PIXEL_FORMAT_RGBA_4444:
             return 2;
     }
-    return 0;
+    return BAD_VALUE;
 }
 
-uint32_t bitsPerPixel(PixelFormat format) {
+ssize_t bitsPerPixel(PixelFormat format) {
     switch (format) {
         case PIXEL_FORMAT_RGBA_8888:
         case PIXEL_FORMAT_RGBX_8888:
@@ -49,9 +159,10 @@ uint32_t bitsPerPixel(PixelFormat format) {
         case PIXEL_FORMAT_RGBA_4444:
             return 16;
     }
-    return 0;
+    return BAD_VALUE;
 }
 
 // ----------------------------------------------------------------------------
 }; // namespace android
 // ----------------------------------------------------------------------------
+
diff --git a/libs/ui/Rect.cpp b/libs/ui/Rect.cpp
index dcce21f..b480f3a 100644
--- a/libs/ui/Rect.cpp
+++ b/libs/ui/Rect.cpp
@@ -19,8 +19,6 @@
 
 namespace android {
 
-const Rect Rect::INVALID_RECT{0, 0, -1, -1};
-
 static inline int32_t min(int32_t a, int32_t b) {
     return (a < b) ? a : b;
 }
diff --git a/libs/ui/Region.cpp b/libs/ui/Region.cpp
old mode 100644
new mode 100755
index 3810da4..530e713
--- a/libs/ui/Region.cpp
+++ b/libs/ui/Region.cpp
@@ -1,4 +1,7 @@
 /*
+ * Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
+ *
  * Copyright (C) 2007 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
@@ -53,8 +56,6 @@ enum {
     direction_RTL
 };
 
-const Region Region::INVALID_REGION(Rect::INVALID_RECT);
-
 // ----------------------------------------------------------------------------
 
 Region::Region() {
@@ -104,8 +105,8 @@ static void reverseRectsResolvingJunctions(const Rect* begin, const Rect* end,
         current--;
     } while (current->top == lastTop && current >= begin);
 
-    int beginLastSpan = -1;
-    int endLastSpan = -1;
+    unsigned int beginLastSpan = -1;
+    unsigned int endLastSpan = -1;
     int top = -1;
     int bottom = -1;
 
@@ -120,7 +121,7 @@ static void reverseRectsResolvingJunctions(const Rect* begin, const Rect* end,
             } else {
                 beginLastSpan = endLastSpan + 1;
             }
-            endLastSpan = static_cast<int>(dst.size()) - 1;
+            endLastSpan = dst.size() - 1;
 
             top = current->top;
             bottom = current->bottom;
@@ -128,11 +129,8 @@ static void reverseRectsResolvingJunctions(const Rect* begin, const Rect* end,
         int left = current->left;
         int right = current->right;
 
-        for (int prevIndex = beginLastSpan; prevIndex <= endLastSpan; prevIndex++) {
-            // prevIndex can't be -1 here because if endLastSpan is set to a
-            // value greater than -1 (allowing the loop to execute),
-            // beginLastSpan (and therefore prevIndex) will also be increased
-            const Rect prev = dst[static_cast<size_t>(prevIndex)];
+        for (unsigned int prevIndex = beginLastSpan; prevIndex <= endLastSpan; prevIndex++) {
+            const Rect prev = dst[prevIndex];
             if (spanDirection == direction_RTL) {
                 // iterating over previous span RTL, quit if it's too far left
                 if (prev.right <= left) break;
@@ -255,16 +253,10 @@ void Region::set(const Rect& r)
     mStorage.add(r);
 }
 
-void Region::set(int32_t w, int32_t h)
-{
-    mStorage.clear();
-    mStorage.add(Rect(w, h));
-}
-
 void Region::set(uint32_t w, uint32_t h)
 {
     mStorage.clear();
-    mStorage.add(Rect(w, h));
+    mStorage.add(Rect(w,h));
 }
 
 bool Region::isTriviallyEqual(const Region& region) const {
@@ -415,7 +407,7 @@ const Region Region::operation(const Region& rhs, int dx, int dy, int op) const
 
 // This is our region rasterizer, which merges rects and spans together
 // to obtain an optimal region.
-class Region::rasterizer : public region_operator<Rect>::region_rasterizer
+class Region::rasterizer : public region_operator<Rect>::region_rasterizer 
 {
     Rect bounds;
     Vector<Rect>& storage;
@@ -424,91 +416,80 @@ class Region::rasterizer : public region_operator<Rect>::region_rasterizer
     Vector<Rect> span;
     Rect* cur;
 public:
-    rasterizer(Region& reg)
+    rasterizer(Region& reg) 
         : bounds(INT_MAX, 0, INT_MIN, 0), storage(reg.mStorage), head(), tail(), cur() {
         storage.clear();
     }
 
-    virtual ~rasterizer();
-
-    virtual void operator()(const Rect& rect);
-
-private:
-    template<typename T>
-    static inline T min(T rhs, T lhs) { return rhs < lhs ? rhs : lhs; }
-    template<typename T>
-    static inline T max(T rhs, T lhs) { return rhs > lhs ? rhs : lhs; }
-
-    void flushSpan();
-};
-
-Region::rasterizer::~rasterizer()
-{
-    if (span.size()) {
-        flushSpan();
-    }
-    if (storage.size()) {
-        bounds.top = storage.itemAt(0).top;
-        bounds.bottom = storage.top().bottom;
-        if (storage.size() == 1) {
-            storage.clear();
+    ~rasterizer() {
+        if (span.size()) {
+            flushSpan();
         }
-    } else {
-        bounds.left  = 0;
-        bounds.right = 0;
+        if (storage.size()) {
+            bounds.top = storage.itemAt(0).top;
+            bounds.bottom = storage.top().bottom;
+            if (storage.size() == 1) {
+                storage.clear();
+            }
+        } else {
+            bounds.left  = 0;
+            bounds.right = 0;
+        }
+        storage.add(bounds);
     }
-    storage.add(bounds);
-}
-
-void Region::rasterizer::operator()(const Rect& rect)
-{
-    //ALOGD(">>> %3d, %3d, %3d, %3d",
-    //        rect.left, rect.top, rect.right, rect.bottom);
-    if (span.size()) {
-        if (cur->top != rect.top) {
-            flushSpan();
-        } else if (cur->right == rect.left) {
-            cur->right = rect.right;
-            return;
+    
+    virtual void operator()(const Rect& rect) {
+        //ALOGD(">>> %3d, %3d, %3d, %3d",
+        //        rect.left, rect.top, rect.right, rect.bottom);
+        if (span.size()) {
+            if (cur->top != rect.top) {
+                flushSpan();
+            } else if (cur->right == rect.left) {
+                cur->right = rect.right;
+                return;
+            }
         }
+        span.add(rect);
+        cur = span.editArray() + (span.size() - 1);
     }
-    span.add(rect);
-    cur = span.editArray() + (span.size() - 1);
-}
-
-void Region::rasterizer::flushSpan()
-{
-    bool merge = false;
-    if (tail-head == ssize_t(span.size())) {
-        Rect const* p = span.editArray();
-        Rect const* q = head;
-        if (p->top == q->bottom) {
-            merge = true;
-            while (q != tail) {
-                if ((p->left != q->left) || (p->right != q->right)) {
-                    merge = false;
-                    break;
+private:
+    template<typename T> 
+    static inline T min(T rhs, T lhs) { return rhs < lhs ? rhs : lhs; }
+    template<typename T> 
+    static inline T max(T rhs, T lhs) { return rhs > lhs ? rhs : lhs; }
+    void flushSpan() {
+        bool merge = false;
+        if (tail-head == ssize_t(span.size())) {
+            Rect const* p = span.editArray();
+            Rect const* q = head;
+            if (p->top == q->bottom) {
+                merge = true;
+                while (q != tail) {
+                    if ((p->left != q->left) || (p->right != q->right)) {
+                        merge = false;
+                        break;
+                    }
+                    p++, q++;
                 }
-                p++, q++;
             }
         }
-    }
-    if (merge) {
-        const int bottom = span[0].bottom;
-        Rect* r = head;
-        while (r != tail) {
-            r->bottom = bottom;
-            r++;
+        if (merge) {
+            const int bottom = span[0].bottom;
+            Rect* r = head;
+            while (r != tail) {
+                r->bottom = bottom;
+                r++;
+            }
+        } else {
+            bounds.left = min(span.itemAt(0).left, bounds.left);
+            bounds.right = max(span.top().right, bounds.right);
+            storage.appendVector(span);
+            tail = storage.editArray() + storage.size();
+            head = tail - span.size();
         }
-    } else {
-        bounds.left = min(span.itemAt(0).left, bounds.left);
-        bounds.right = max(span.top().right, bounds.right);
-        storage.appendVector(span);
-        tail = storage.editArray() + storage.size();
-        head = tail - span.size();
+        span.clear();
     }
-    span.clear();
-}
+};
 
 bool Region::validate(const Region& reg, const char* name, bool silent)
 {
@@ -519,12 +500,8 @@ bool Region::validate(const Region& reg, const char* name, bool silent)
     Rect b(*prev);
     while (cur != tail) {
         if (cur->isValid() == false) {
-            // We allow this particular flavor of invalid Rect, since it is used
-            // as a signal value in various parts of the system
-            if (*cur != Rect::INVALID_RECT) {
-                ALOGE_IF(!silent, "%s: region contains an invalid Rect", name);
-                result = false;
-            }
+            ALOGE_IF(!silent, "%s: region contains an invalid Rect", name);
+            result = false;
         }
         if (cur->right > region_operator<Rect>::max_value) {
             ALOGE_IF(!silent, "%s: rect->right > max_value", name);
@@ -696,9 +673,7 @@ void Region::boolean_operation(int op, Region& dst,
         const Region& lhs,
         const Rect& rhs, int dx, int dy)
 {
-    // We allow this particular flavor of invalid Rect, since it is used as a
-    // signal value in various parts of the system
-    if (!rhs.isValid() && rhs != Rect::INVALID_RECT) {
+    if (!rhs.isValid()) {
         ALOGE("Region::boolean_operation(op=%d) invalid Rect={%d,%d,%d,%d}",
                 op, rhs.left, rhs.top, rhs.right, rhs.bottom);
         return;
@@ -761,52 +736,35 @@ void Region::translate(Region& dst, const Region& reg, int dx, int dy)
 // ----------------------------------------------------------------------------
 
 size_t Region::getFlattenedSize() const {
-    return sizeof(uint32_t) + mStorage.size() * sizeof(Rect);
+    return mStorage.size() * sizeof(Rect);
 }
 
 status_t Region::flatten(void* buffer, size_t size) const {
 #if VALIDATE_REGIONS
     validate(*this, "Region::flatten");
 #endif
-    if (size < getFlattenedSize()) {
+    if (size < mStorage.size() * sizeof(Rect)) {
         return NO_MEMORY;
     }
-    // Cast to uint32_t since the size of a size_t can vary between 32- and
-    // 64-bit processes
-    FlattenableUtils::write(buffer, size, static_cast<uint32_t>(mStorage.size()));
-    for (auto rect : mStorage) {
-        status_t result = rect.flatten(buffer, size);
-        if (result != NO_ERROR) {
-            return result;
-        }
-        FlattenableUtils::advance(buffer, size, sizeof(rect));
-    }
+    Rect* rects = reinterpret_cast<Rect*>(buffer);
+    memcpy(rects, mStorage.array(), mStorage.size() * sizeof(Rect));
     return NO_ERROR;
 }
 
 status_t Region::unflatten(void const* buffer, size_t size) {
-    if (size < sizeof(uint32_t)) {
-        return NO_MEMORY;
-    }
-
-    uint32_t numRects = 0;
-    FlattenableUtils::read(buffer, size, numRects);
-    if (size < numRects * sizeof(Rect)) {
-        return NO_MEMORY;
-    }
-
     Region result;
-    result.mStorage.clear();
-    for (size_t r = 0; r < numRects; ++r) {
-        Rect rect;
-        status_t status = rect.unflatten(buffer, size);
-        if (status != NO_ERROR) {
-            return status;
+    if (size >= sizeof(Rect)) {
+        Rect const* rects = reinterpret_cast<Rect const*>(buffer);
+        size_t count = size / sizeof(Rect);
+        if (count > 0) {
+            result.mStorage.clear();
+            ssize_t err = result.mStorage.insertAt(0, count);
+            if (err < 0) {
+                return status_t(err);
+            }
+            memcpy(result.mStorage.editArray(), rects, count*sizeof(Rect));
         }
-        FlattenableUtils::advance(buffer, size, sizeof(rect));
-        result.mStorage.push_back(rect);
     }
-
 #if VALIDATE_REGIONS
     validate(result, "Region::unflatten");
 #endif
@@ -831,8 +789,10 @@ Region::const_iterator Region::end() const {
 }
 
 Rect const* Region::getArray(size_t* count) const {
-    if (count) *count = static_cast<size_t>(end() - begin());
-    return begin();
+    const_iterator const b(begin());
+    const_iterator const e(end());
+    if (count) *count = e-b;
+    return b;
 }
 
 SharedBuffer const* Region::getSharedBuffer(size_t* count) const {
@@ -843,28 +803,37 @@ SharedBuffer const* Region::getSharedBuffer(size_t* count) const {
         size_t numRects = isRect() ? 1 : mStorage.size() - 1;
         count[0] = numRects;
     }
-    sb->acquire();
+    if (sb != NULL) {
+       sb->acquire();
+    }
     return sb;
 }
 
 // ----------------------------------------------------------------------------
 
-void Region::dump(String8& out, const char* what, uint32_t /* flags */) const
+void Region::dump(String8& out, const char* what, uint32_t flags) const
 {
+    (void)flags;
     const_iterator head = begin();
     const_iterator const tail = end();
 
-    out.appendFormat("  Region %s (this=%p, count=%" PRIdPTR ")\n",
-            what, this, tail - head);
+    size_t SIZE = 256;
+    char buffer[SIZE];
+
+    snprintf(buffer, SIZE, "  Region %s (this=%p, count=%" PRIdPTR ")\n",
+            what, this, tail-head);
+    out.append(buffer);
     while (head != tail) {
-        out.appendFormat("    [%3d, %3d, %3d, %3d]\n", head->left, head->top,
-                head->right, head->bottom);
-        ++head;
+        snprintf(buffer, SIZE, "    [%3d, %3d, %3d, %3d]\n",
+                head->left, head->top, head->right, head->bottom);
+        out.append(buffer);
+        head++;
     }
 }
 
-void Region::dump(const char* what, uint32_t /* flags */) const
+void Region::dump(const char* what, uint32_t flags) const
 {
+    (void)flags;
     const_iterator head = begin();
     const_iterator const tail = end();
     ALOGD("  Region %s (this=%p, count=%" PRIdPTR ")\n", what, this, tail-head);
diff --git a/libs/ui/UiConfig.cpp b/libs/ui/UiConfig.cpp
index 9e7ba8e..8b2130e 100644
--- a/libs/ui/UiConfig.cpp
+++ b/libs/ui/UiConfig.cpp
@@ -18,11 +18,8 @@
 
 namespace android {
 
-#ifdef FRAMEBUFFER_FORCE_FORMAT
-// We need the two-level macro to stringify the contents of a macro argument
 #define STRINGIFY(x) #x
 #define TOSTRING(x) STRINGIFY(x)
-#endif
 
 void appendUiConfigString(String8& configStr)
 {
diff --git a/libs/ui/tests/Android.mk b/libs/ui/tests/Android.mk
index 6438b1f..b0c57db 100644
--- a/libs/ui/tests/Android.mk
+++ b/libs/ui/tests/Android.mk
@@ -1,36 +1,31 @@
-#
-# Copyright (C) 2014 The Android Open Source Project
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#      http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-#
-
+# Build the unit tests.
 LOCAL_PATH := $(call my-dir)
-
 include $(CLEAR_VARS)
-LOCAL_ADDITIONAL_DEPENDENCIES := $(LOCAL_PATH)/Android.mk
-LOCAL_SHARED_LIBRARIES := libui
-LOCAL_SRC_FILES := Region_test.cpp
-LOCAL_MODULE := Region_test
-include $(BUILD_NATIVE_TEST)
 
-include $(CLEAR_VARS)
-LOCAL_ADDITIONAL_DEPENDENCIES := $(LOCAL_PATH)/Android.mk
-LOCAL_SRC_FILES := vec_test.cpp
-LOCAL_MODULE := vec_test
-include $(BUILD_NATIVE_TEST)
+# Build the unit tests.
+test_src_files := \
+    Region_test.cpp \
+    vec_test.cpp \
+    mat_test.cpp
 
-include $(CLEAR_VARS)
-LOCAL_ADDITIONAL_DEPENDENCIES := $(LOCAL_PATH)/Android.mk
-LOCAL_SRC_FILES := mat_test.cpp
-LOCAL_MODULE := mat_test
-include $(BUILD_NATIVE_TEST)
+shared_libraries := \
+    libutils \
+    libui
+
+static_libraries := \
+    libgtest \
+    libgtest_main
+
+$(foreach file,$(test_src_files), \
+    $(eval include $(CLEAR_VARS)) \
+    $(eval LOCAL_SHARED_LIBRARIES := $(shared_libraries)) \
+    $(eval LOCAL_STATIC_LIBRARIES := $(static_libraries)) \
+    $(eval LOCAL_SRC_FILES := $(file)) \
+    $(eval LOCAL_MODULE := $(notdir $(file:%.cpp=%))) \
+    $(eval include $(BUILD_NATIVE_TEST)) \
+)
+
+# Build the unit tests.
+
+# Build the manual test programs.
+include $(call all-makefiles-under, $(LOCAL_PATH))
diff --git a/libs/ui/tests/vec_test.cpp b/libs/ui/tests/vec_test.cpp
index 454c999..00f737e 100644
--- a/libs/ui/tests/vec_test.cpp
+++ b/libs/ui/tests/vec_test.cpp
@@ -16,18 +16,17 @@
 
 #define LOG_TAG "RegionTest"
 
-#include <math.h>
 #include <stdlib.h>
-
 #include <ui/Region.h>
 #include <ui/Rect.h>
-#include <ui/vec4.h>
-
 #include <gtest/gtest.h>
 
+#include <ui/vec4.h>
+
 namespace android {
 
 class VecTest : public testing::Test {
+protected:
 };
 
 TEST_F(VecTest, Basics) {
diff --git a/opengl/libs/Android.mk b/opengl/libs/Android.mk
index 18ad300..11bd7a2 100644
--- a/opengl/libs/Android.mk
+++ b/opengl/libs/Android.mk
@@ -47,6 +47,16 @@ LOCAL_CFLAGS += -DEGL_TRACE=1
 ifeq ($(BOARD_ALLOW_EGL_HIBERNATION),true)
   LOCAL_CFLAGS += -DBOARD_ALLOW_EGL_HIBERNATION
 endif
+ifeq ($(TARGET_BOARD_PLATFORM), omap4)
+  LOCAL_CFLAGS += -DWORKAROUND_BUG_10194508=1
+endif
+ifeq ($(BOARD_EGL_SYSTEMUI_PBSIZE_HACK),true)
+  # see Loader.cpp for details
+  LOCAL_CFLAGS += -DSYSTEMUI_PBSIZE_HACK=1
+endif
+ifeq ($(BOARD_EGL_WORKAROUND_BUG_10194508),true)
+  LOCAL_CFLAGS += -DWORKAROUND_BUG_10194508=1
+endif
 ifneq ($(MAX_EGL_CACHE_ENTRY_SIZE),)
   LOCAL_CFLAGS += -DMAX_EGL_CACHE_ENTRY_SIZE=$(MAX_EGL_CACHE_ENTRY_SIZE)
 endif
@@ -74,7 +84,6 @@ LOCAL_SRC_FILES:= 		\
 	GLES_CM/gl.cpp.arm 	\
 #
 
-LOCAL_CLANG := false
 LOCAL_SHARED_LIBRARIES += libcutils liblog libEGL
 LOCAL_MODULE:= libGLESv1_CM
 
@@ -86,9 +95,6 @@ LOCAL_CFLAGS += -DLOG_TAG=\"libGLESv1\"
 LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPES
 LOCAL_CFLAGS += -fvisibility=hidden
 
-# TODO: This is to work around b/20093774. Remove after root cause is fixed
-LOCAL_LDFLAGS_arm += -Wl,--hash-style,both
-
 include $(BUILD_SHARED_LIBRARY)
 
 
@@ -102,7 +108,6 @@ LOCAL_SRC_FILES:= 		\
 	GLES2/gl2.cpp.arm 	\
 #
 
-LOCAL_CLANG := false
 LOCAL_SHARED_LIBRARIES += libcutils libutils liblog libEGL
 LOCAL_MODULE:= libGLESv2
 
@@ -114,9 +119,6 @@ LOCAL_CFLAGS += -DLOG_TAG=\"libGLESv2\"
 LOCAL_CFLAGS += -DGL_GLEXT_PROTOTYPES -DEGL_EGLEXT_PROTOTYPES
 LOCAL_CFLAGS += -fvisibility=hidden
 
-# TODO: This is to work around b/20093774. Remove after root cause is fixed
-LOCAL_LDFLAGS_arm += -Wl,--hash-style,both
-
 # Symlink libGLESv3.so -> libGLESv2.so
 # Platform modules should link against libGLESv2.so (-lGLESv2), but NDK apps
 # will be linked against libGLESv3.so.
diff --git a/opengl/libs/EGL/Loader.cpp b/opengl/libs/EGL/Loader.cpp
index 1fcc048..c998f51 100644
--- a/opengl/libs/EGL/Loader.cpp
+++ b/opengl/libs/EGL/Loader.cpp
@@ -393,6 +393,35 @@ void *Loader::load_driver(const char* kind,
         ALOGE_IF(!getProcAddress,
                 "can't find eglGetProcAddress() in %s", driver_absolute_path);
 
+#ifdef SYSTEMUI_PBSIZE_HACK
+#warning "SYSTEMUI_PBSIZE_HACK enabled"
+        /*
+         * TODO: replace SYSTEMUI_PBSIZE_HACK by something less hackish
+         *
+         * Here we adjust the PB size from its default value to 512KB which
+         * is the minimum acceptable for the systemui process.
+         * We do this on low-end devices only because it allows us to enable
+         * h/w acceleration in the systemui process while keeping the
+         * memory usage down.
+         *
+         * Obviously, this is the wrong place and wrong way to make this
+         * adjustment, but at the time of this writing this was the safest
+         * solution.
+         */
+        const char *cmdline = getProcessCmdline();
+        if (strstr(cmdline, "systemui")) {
+            void *imgegl = dlopen("/vendor/lib/libIMGegl.so", RTLD_LAZY);
+            if (imgegl) {
+                unsigned int *PVRDefaultPBS =
+                        (unsigned int *)dlsym(imgegl, "PVRDefaultPBS");
+                if (PVRDefaultPBS) {
+                    ALOGD("setting default PBS to 512KB, was %d KB", *PVRDefaultPBS / 1024);
+                    *PVRDefaultPBS = 512*1024;
+                }
+            }
+        }
+#endif
+
         egl_t* egl = &cnx->egl;
         __eglMustCastToProperFunctionPointerType* curr =
             (__eglMustCastToProperFunctionPointerType*)egl;
diff --git a/opengl/libs/EGL/egl.cpp b/opengl/libs/EGL/egl.cpp
index 4e0e5bc..7c70fa0 100644
--- a/opengl/libs/EGL/egl.cpp
+++ b/opengl/libs/EGL/egl.cpp
@@ -292,44 +292,6 @@ const GLubyte * egl_get_string_for_current_context(GLenum name) {
     return (const GLubyte *)c->gl_extensions.string();
 }
 
-const GLubyte * egl_get_string_for_current_context(GLenum name, GLuint index) {
-    // NOTE: returning NULL here will fall-back to the default
-    // implementation.
-
-    EGLContext context = egl_tls_t::getContext();
-    if (context == EGL_NO_CONTEXT)
-        return NULL;
-
-    egl_context_t const * const c = get_context(context);
-    if (c == NULL) // this should never happen, by construction
-        return NULL;
-
-    if (name != GL_EXTENSIONS)
-        return NULL;
-
-    // if index is out of bounds, assume it will be in the default
-    // implementation too, so we don't have to generate a GL error here
-    if (index >= c->tokenized_gl_extensions.size())
-        return NULL;
-
-    return (const GLubyte *)c->tokenized_gl_extensions.itemAt(index).string();
-}
-
-GLint egl_get_num_extensions_for_current_context() {
-    // NOTE: returning -1 here will fall-back to the default
-    // implementation.
-
-    EGLContext context = egl_tls_t::getContext();
-    if (context == EGL_NO_CONTEXT)
-        return -1;
-
-    egl_context_t const * const c = get_context(context);
-    if (c == NULL) // this should never happen, by construction
-        return -1;
-
-    return (GLint)c->tokenized_gl_extensions.size();
-}
-
 // ----------------------------------------------------------------------------
 
 // this mutex protects:
diff --git a/opengl/libs/EGL/eglApi.cpp b/opengl/libs/EGL/eglApi.cpp
index 8378907..937665b 100644
--- a/opengl/libs/EGL/eglApi.cpp
+++ b/opengl/libs/EGL/eglApi.cpp
@@ -80,7 +80,6 @@ struct extention_map_t {
 extern char const * const gBuiltinExtensionString =
         "EGL_KHR_get_all_proc_addresses "
         "EGL_ANDROID_presentation_time "
-        "EGL_KHR_swap_buffers_with_damage "
         ;
 extern char const * const gExtensionString  =
         "EGL_KHR_image "                        // mandatory
@@ -91,27 +90,16 @@ extern char const * const gExtensionString  =
         "EGL_KHR_gl_colorspace "
 #endif
         "EGL_KHR_gl_texture_2D_image "
-        "EGL_KHR_gl_texture_3D_image "
         "EGL_KHR_gl_texture_cubemap_image "
         "EGL_KHR_gl_renderbuffer_image "
         "EGL_KHR_reusable_sync "
         "EGL_KHR_fence_sync "
         "EGL_KHR_create_context "
-        "EGL_KHR_config_attribs "
-        "EGL_KHR_surfaceless_context "
-        "EGL_KHR_stream "
-        "EGL_KHR_stream_fifo "
-        "EGL_KHR_stream_producer_eglsurface "
-        "EGL_KHR_stream_consumer_gltexture "
-        "EGL_KHR_stream_cross_process_fd "
         "EGL_EXT_create_context_robustness "
         "EGL_NV_system_time "
         "EGL_ANDROID_image_native_buffer "      // mandatory
         "EGL_KHR_wait_sync "                    // strongly recommended
         "EGL_ANDROID_recordable "               // mandatory
-        "EGL_KHR_partial_update "               // strongly recommended
-        "EGL_EXT_buffer_age "                   // strongly recommended with partial_update
-        "EGL_KHR_create_context_no_error "
         ;
 
 // extensions not exposed to applications but used by the ANDROID system
@@ -164,39 +152,6 @@ static const extention_map_t sExtensionMap[] = {
     // EGL_ANDROID_presentation_time
     { "eglPresentationTimeANDROID",
             (__eglMustCastToProperFunctionPointerType)&eglPresentationTimeANDROID },
-
-    // EGL_KHR_swap_buffers_with_damage
-    { "eglSwapBuffersWithDamageKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglSwapBuffersWithDamageKHR },
-
-    // EGL_KHR_partial_update
-    { "eglSetDamageRegionKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglSetDamageRegionKHR },
-
-    { "eglCreateStreamKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamKHR },
-    { "eglDestroyStreamKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglDestroyStreamKHR },
-    { "eglStreamAttribKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamAttribKHR },
-    { "eglQueryStreamKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamKHR },
-    { "eglQueryStreamu64KHR",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamu64KHR },
-    { "eglQueryStreamTimeKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglQueryStreamTimeKHR },
-    { "eglCreateStreamProducerSurfaceKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamProducerSurfaceKHR },
-    { "eglStreamConsumerGLTextureExternalKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerGLTextureExternalKHR },
-    { "eglStreamConsumerAcquireKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerAcquireKHR },
-    { "eglStreamConsumerReleaseKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglStreamConsumerReleaseKHR },
-    { "eglGetStreamFileDescriptorKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglGetStreamFileDescriptorKHR },
-    { "eglCreateStreamFromFileDescriptorKHR",
-            (__eglMustCastToProperFunctionPointerType)&eglCreateStreamFromFileDescriptorKHR },
 };
 
 /*
@@ -207,7 +162,8 @@ static const extention_map_t sExtensionMap[] = {
         (!strcmp((procname), "eglSetBlobCacheFuncsANDROID") ||    \
          !strcmp((procname), "eglHibernateProcessIMG")      ||    \
          !strcmp((procname), "eglAwakenProcessIMG")         ||    \
-         !strcmp((procname), "eglDupNativeFenceFDANDROID"))
+         !strcmp((procname), "eglDupNativeFenceFDANDROID")  ||    \
+         !strcmp((procname), "eglGpuPerfHintQCOM"))
 
 
 
@@ -426,15 +382,20 @@ EGLBoolean eglGetConfigAttrib(EGLDisplay dpy, EGLConfig config,
 // Turn linear formats into corresponding sRGB formats when colorspace is
 // EGL_GL_COLORSPACE_SRGB_KHR, or turn sRGB formats into corresponding linear
 // formats when colorspace is EGL_GL_COLORSPACE_LINEAR_KHR. In any cases where
-// the modification isn't possible, the original dataSpace is returned.
-static android_dataspace modifyBufferDataspace( android_dataspace dataSpace,
-                                                EGLint colorspace) {
+// the modification isn't possible, the original format is returned.
+static int modifyFormatColorspace(int fmt, EGLint colorspace) {
     if (colorspace == EGL_GL_COLORSPACE_LINEAR_KHR) {
-        return HAL_DATASPACE_SRGB_LINEAR;
+        switch (fmt) {
+            case HAL_PIXEL_FORMAT_sRGB_A_8888: return HAL_PIXEL_FORMAT_RGBA_8888;
+            case HAL_PIXEL_FORMAT_sRGB_X_8888: return HAL_PIXEL_FORMAT_RGBX_8888;
+        }
     } else if (colorspace == EGL_GL_COLORSPACE_SRGB_KHR) {
-        return HAL_DATASPACE_SRGB;
+        switch (fmt) {
+            case HAL_PIXEL_FORMAT_RGBA_8888: return HAL_PIXEL_FORMAT_sRGB_A_8888;
+            case HAL_PIXEL_FORMAT_RGBX_8888: return HAL_PIXEL_FORMAT_sRGB_X_8888;
+        }
     }
-    return dataSpace;
+    return fmt;
 }
 
 EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
@@ -461,36 +422,22 @@ EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
         // of our native format. So if sRGB gamma is requested, we have to
         // modify the EGLconfig's format before setting the native window's
         // format.
-
-        // by default, just pick RGBA_8888
-        EGLint format = HAL_PIXEL_FORMAT_RGBA_8888;
-        android_dataspace dataSpace = HAL_DATASPACE_UNKNOWN;
-
-        EGLint a = 0;
-        cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
-        if (a > 0) {
-            // alpha-channel requested, there's really only one suitable format
-            format = HAL_PIXEL_FORMAT_RGBA_8888;
-        } else {
-            EGLint r, g, b;
-            r = g = b = 0;
-            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_RED_SIZE,   &r);
-            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_GREEN_SIZE, &g);
-            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_BLUE_SIZE,  &b);
-            EGLint colorDepth = r + g + b;
-            if (colorDepth <= 16) {
-                format = HAL_PIXEL_FORMAT_RGB_565;
-            } else {
-                format = HAL_PIXEL_FORMAT_RGBX_8888;
-            }
+#if WORKAROUND_BUG_10194508
+#warning "WORKAROUND_10194508 enabled"
+        EGLint format;
+        if (!cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_NATIVE_VISUAL_ID,
+                &format)) {
+            ALOGE("eglGetConfigAttrib(EGL_NATIVE_VISUAL_ID) failed: %#x",
+                    eglGetError());
+            format = 0;
         }
-
-        // now select a corresponding sRGB format if needed
-        if (attrib_list && dp->haveExtension("EGL_KHR_gl_colorspace")) {
-            for (const EGLint* attr = attrib_list; *attr != EGL_NONE; attr += 2) {
-                if (*attr == EGL_GL_COLORSPACE_KHR) {
+        if (attrib_list) {
+            for (const EGLint* attr = attrib_list; *attr != EGL_NONE;
+                    attr += 2) {
+                if (*attr == EGL_GL_COLORSPACE_KHR &&
+                        dp->haveExtension("EGL_KHR_gl_colorspace")) {
                     if (ENABLE_EGL_KHR_GL_COLORSPACE) {
-                        dataSpace = modifyBufferDataspace(dataSpace, *(attr+1));
+                        format = modifyFormatColorspace(format, *(attr+1));
                     } else {
                         // Normally we'd pass through unhandled attributes to
                         // the driver. But in case the driver implements this
@@ -503,7 +450,62 @@ EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
                 }
             }
         }
+#else
+        // by default, just pick RGBA_8888
+        EGLint format = HAL_PIXEL_FORMAT_RGBA_8888;
+        EGLint color_buffer = EGL_RGB_BUFFER;
+
+        if (!cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_COLOR_BUFFER_TYPE, &color_buffer))
+        {
+            ALOGE("Could not configure a color buffer format");
+            return setError(EGL_BAD_ATTRIBUTE, EGL_NO_SURFACE);
+        }
+        if (EGL_RGB_BUFFER != color_buffer &&
+            EGL_LUMINANCE_BUFFER != color_buffer)
+        {
+            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_NATIVE_VISUAL_ID, &format);
+        }
+        else
+        {
+            EGLint a = 0;
+            cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_ALPHA_SIZE, &a);
+            if (a > 0) {
+                // alpha-channel requested, there's really only one suitable format
+                // Format will already be RGBA8888
+            } else {
+                EGLint r, g, b;
+                r = g = b = 0;
+                cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_RED_SIZE,   &r);
+                cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_GREEN_SIZE, &g);
+                cnx->egl.eglGetConfigAttrib(iDpy, config, EGL_BLUE_SIZE,  &b);
+                EGLint colorDepth = r + g + b;
+                if (colorDepth <= 16) {
+                    format = HAL_PIXEL_FORMAT_RGB_565;
+                } else {
+                    format = HAL_PIXEL_FORMAT_RGBX_8888;
+                }
+            }
 
+            // now select a corresponding sRGB format if needed
+            if (attrib_list && dp->haveExtension("EGL_KHR_gl_colorspace")) {
+                for (const EGLint* attr = attrib_list; *attr != EGL_NONE; attr += 2) {
+                    if (*attr == EGL_GL_COLORSPACE_KHR) {
+                        if (ENABLE_EGL_KHR_GL_COLORSPACE) {
+                            format = modifyFormatColorspace(format, *(attr+1));
+                        } else {
+                            // Normally we'd pass through unhandled attributes to
+                            // the driver. But in case the driver implements this
+                            // extension but we're disabling it, we want to prevent
+                            // it getting through -- support will be broken without
+                            // our help.
+                            ALOGE("sRGB window surfaces not supported");
+                            return setError(EGL_BAD_ATTRIBUTE, EGL_NO_SURFACE);
+                        }
+                    }
+                }
+            }
+        }
+#endif
         if (format != 0) {
             int err = native_window_set_buffers_format(window, format);
             if (err != 0) {
@@ -514,16 +516,6 @@ EGLSurface eglCreateWindowSurface(  EGLDisplay dpy, EGLConfig config,
             }
         }
 
-        if (dataSpace != 0) {
-            int err = native_window_set_buffers_data_space(window, dataSpace);
-            if (err != 0) {
-                ALOGE("error setting native window pixel dataSpace: %s (%d)",
-                        strerror(-err), err);
-                native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-                return setError(EGL_BAD_NATIVE_WINDOW, EGL_NO_SURFACE);
-            }
-        }
-
         // the EGL spec requires that a new EGLSurface default to swap interval
         // 1, so explicitly set that on the window here.
         ANativeWindow* anw = reinterpret_cast<ANativeWindow*>(window);
@@ -595,15 +587,6 @@ EGLBoolean eglDestroySurface(EGLDisplay dpy, EGLSurface surface)
         return setError(EGL_BAD_SURFACE, EGL_FALSE);
 
     egl_surface_t * const s = get_surface(surface);
-    ANativeWindow* window = s->win.get();
-    if (window) {
-        int result = native_window_api_disconnect(window, NATIVE_WINDOW_API_EGL);
-        if (result != OK) {
-            ALOGE("eglDestroySurface: native_window_api_disconnect (win=%p) "
-                  "failed (%#x)",
-                  window, result);
-        }
-    }
     EGLBoolean result = s->cnx->egl.eglDestroySurface(dp->disp.dpy, s->surface);
     if (result == EGL_TRUE) {
         _s.terminate();
@@ -1075,8 +1058,7 @@ private:
     Mutex mMutex;
 };
 
-EGLBoolean eglSwapBuffersWithDamageKHR(EGLDisplay dpy, EGLSurface draw,
-        EGLint *rects, EGLint n_rects)
+EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface draw)
 {
     ATRACE_CALL();
     clearError();
@@ -1135,38 +1117,7 @@ EGLBoolean eglSwapBuffersWithDamageKHR(EGLDisplay dpy, EGLSurface draw,
         }
     }
 
-    if (n_rects == 0) {
-        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-    }
-
-    Vector<android_native_rect_t> androidRects;
-    for (int r = 0; r < n_rects; ++r) {
-        int offset = r * 4;
-        int x = rects[offset];
-        int y = rects[offset + 1];
-        int width = rects[offset + 2];
-        int height = rects[offset + 3];
-        android_native_rect_t androidRect;
-        androidRect.left = x;
-        androidRect.top = y + height;
-        androidRect.right = x + width;
-        androidRect.bottom = y;
-        androidRects.push_back(androidRect);
-    }
-    native_window_set_surface_damage(s->win.get(), androidRects.array(),
-            androidRects.size());
-
-    if (s->cnx->egl.eglSwapBuffersWithDamageKHR) {
-        return s->cnx->egl.eglSwapBuffersWithDamageKHR(dp->disp.dpy, s->surface,
-                rects, n_rects);
-    } else {
-        return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
-    }
-}
-
-EGLBoolean eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
-{
-    return eglSwapBuffersWithDamageKHR(dpy, surface, NULL, 0);
+    return s->cnx->egl.eglSwapBuffers(dp->disp.dpy, s->surface);
 }
 
 EGLBoolean eglCopyBuffers(  EGLDisplay dpy, EGLSurface surface,
@@ -1560,212 +1511,6 @@ EGLBoolean eglGetSyncAttribKHR(EGLDisplay dpy, EGLSyncKHR sync,
     return result;
 }
 
-EGLStreamKHR eglCreateStreamKHR(EGLDisplay dpy, const EGLint *attrib_list)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_STREAM_KHR;
-
-    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateStreamKHR) {
-        result = cnx->egl.eglCreateStreamKHR(
-                dp->disp.dpy, attrib_list);
-    }
-    return result;
-}
-
-EGLBoolean eglDestroyStreamKHR(EGLDisplay dpy, EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglDestroyStreamKHR) {
-        result = cnx->egl.eglDestroyStreamKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLBoolean eglStreamAttribKHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLint value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamAttribKHR) {
-        result = cnx->egl.eglStreamAttribKHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLBoolean eglQueryStreamKHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLint *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryStreamKHR) {
-        result = cnx->egl.eglQueryStreamKHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLBoolean eglQueryStreamu64KHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLuint64KHR *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryStreamu64KHR) {
-        result = cnx->egl.eglQueryStreamu64KHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLBoolean eglQueryStreamTimeKHR(EGLDisplay dpy, EGLStreamKHR stream,
-        EGLenum attribute, EGLTimeKHR *value)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglQueryStreamTimeKHR) {
-        result = cnx->egl.eglQueryStreamTimeKHR(
-                dp->disp.dpy, stream, attribute, value);
-    }
-    return result;
-}
-
-EGLSurface eglCreateStreamProducerSurfaceKHR(EGLDisplay dpy, EGLConfig config,
-        EGLStreamKHR stream, const EGLint *attrib_list)
-{
-    clearError();
-
-    egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_SURFACE;
-
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateStreamProducerSurfaceKHR) {
-        EGLSurface surface = cnx->egl.eglCreateStreamProducerSurfaceKHR(
-                dp->disp.dpy, config, stream, attrib_list);
-        if (surface != EGL_NO_SURFACE) {
-            egl_surface_t* s = new egl_surface_t(dp.get(), config, NULL,
-                    surface, cnx);
-            return s;
-        }
-    }
-    return EGL_NO_SURFACE;
-}
-
-EGLBoolean eglStreamConsumerGLTextureExternalKHR(EGLDisplay dpy,
-        EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamConsumerGLTextureExternalKHR) {
-        result = cnx->egl.eglStreamConsumerGLTextureExternalKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLBoolean eglStreamConsumerAcquireKHR(EGLDisplay dpy,
-        EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamConsumerAcquireKHR) {
-        result = cnx->egl.eglStreamConsumerAcquireKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLBoolean eglStreamConsumerReleaseKHR(EGLDisplay dpy,
-        EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_FALSE;
-
-    EGLBoolean result = EGL_FALSE;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglStreamConsumerReleaseKHR) {
-        result = cnx->egl.eglStreamConsumerReleaseKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLNativeFileDescriptorKHR eglGetStreamFileDescriptorKHR(
-        EGLDisplay dpy, EGLStreamKHR stream)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_FILE_DESCRIPTOR_KHR;
-
-    EGLNativeFileDescriptorKHR result = EGL_NO_FILE_DESCRIPTOR_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglGetStreamFileDescriptorKHR) {
-        result = cnx->egl.eglGetStreamFileDescriptorKHR(
-                dp->disp.dpy, stream);
-    }
-    return result;
-}
-
-EGLStreamKHR eglCreateStreamFromFileDescriptorKHR(
-        EGLDisplay dpy, EGLNativeFileDescriptorKHR file_descriptor)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) return EGL_NO_STREAM_KHR;
-
-    EGLStreamKHR result = EGL_NO_STREAM_KHR;
-    egl_connection_t* const cnx = &gEGLImpl;
-    if (cnx->dso && cnx->egl.eglCreateStreamFromFileDescriptorKHR) {
-        result = cnx->egl.eglCreateStreamFromFileDescriptorKHR(
-                dp->disp.dpy, file_descriptor);
-    }
-    return result;
-}
-
 // ----------------------------------------------------------------------------
 // EGL_EGLEXT_VERSION 15
 // ----------------------------------------------------------------------------
@@ -1824,6 +1569,45 @@ EGLBoolean eglPresentationTimeANDROID(EGLDisplay dpy, EGLSurface surface,
 }
 
 // ----------------------------------------------------------------------------
+// QCOM extensions
+// ----------------------------------------------------------------------------
+#ifdef __cplusplus
+extern "C" {
+#endif
+EGLAPI EGLBoolean eglGpuPerfHintQCOM(EGLDisplay dpy, EGLContext ctx, EGLint *attrib_list);
+#ifdef __cplusplus
+}
+#endif
+
+EGLBoolean eglGpuPerfHintQCOM(EGLDisplay dpy, EGLContext ctx, EGLint *attrib_list)
+{
+    clearError();
+
+    const egl_display_ptr dp = validate_display(dpy);
+    if (!dp) return EGL_FALSE;
+
+    ContextRef _c(dp.get(), ctx);
+    if ((ctx != EGL_NO_CONTEXT) && !_c.get()) {
+        // ctx is not valid
+        return setError(EGL_BAD_CONTEXT, EGL_FALSE);
+    }
+
+    egl_context_t * c = NULL;
+    c = get_context(ctx);
+
+    EGLint result = EGL_FALSE;
+    egl_connection_t* const cnx = &gEGLImpl;
+    if (cnx->dso && cnx->egl.eglGpuPerfHintQCOM) {
+        result = cnx->egl.eglGpuPerfHintQCOM(
+                dp->disp.dpy,
+                c->context,
+                attrib_list);
+    }
+    return result;
+
+}
+
+// ----------------------------------------------------------------------------
 // NVIDIA extensions
 // ----------------------------------------------------------------------------
 EGLuint64NV eglGetSystemTimeFrequencyNV()
@@ -1861,32 +1645,3 @@ EGLuint64NV eglGetSystemTimeNV()
 
     return setErrorQuiet(EGL_BAD_DISPLAY, 0);
 }
-
-// ----------------------------------------------------------------------------
-// Partial update extension
-// ----------------------------------------------------------------------------
-EGLBoolean eglSetDamageRegionKHR(EGLDisplay dpy, EGLSurface surface,
-        EGLint *rects, EGLint n_rects)
-{
-    clearError();
-
-    const egl_display_ptr dp = validate_display(dpy);
-    if (!dp) {
-        setError(EGL_BAD_DISPLAY, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    SurfaceRef _s(dp.get(), surface);
-    if (!_s.get()) {
-        setError(EGL_BAD_SURFACE, EGL_FALSE);
-        return EGL_FALSE;
-    }
-
-    egl_surface_t const * const s = get_surface(surface);
-    if (s->cnx->egl.eglSetDamageRegionKHR) {
-        return s->cnx->egl.eglSetDamageRegionKHR(dp->disp.dpy, s->surface,
-                rects, n_rects);
-    }
-
-    return EGL_FALSE;
-}
diff --git a/opengl/libs/EGL/egl_display.h b/opengl/libs/EGL/egl_display.h
index 2d86295..4949ef2 100644
--- a/opengl/libs/EGL/egl_display.h
+++ b/opengl/libs/EGL/egl_display.h
@@ -39,7 +39,7 @@ namespace android {
 
 class egl_object_t;
 class egl_context_t;
-struct egl_connection_t;
+class egl_connection_t;
 
 // ----------------------------------------------------------------------------
 
diff --git a/opengl/libs/EGL/egl_entries.in b/opengl/libs/EGL/egl_entries.in
index 498b2fc..aa92ea0 100644
--- a/opengl/libs/EGL/egl_entries.in
+++ b/opengl/libs/EGL/egl_entries.in
@@ -61,18 +61,18 @@ EGL_ENTRY(EGLBoolean,   eglGetSyncAttribKHR,    EGLDisplay, EGLSyncKHR, EGLint,
 
 /* EGL_EGLEXT_VERSION 15 */
 
-EGL_ENTRY(EGLStreamKHR, eglCreateStreamKHR,     EGLDisplay, const EGLint *)
-EGL_ENTRY(EGLBoolean,   eglDestroyStreamKHR,    EGLDisplay, EGLStreamKHR)
-EGL_ENTRY(EGLBoolean,   eglStreamAttribKHR,     EGLDisplay, EGLStreamKHR, EGLenum, EGLint)
-EGL_ENTRY(EGLBoolean,   eglQueryStreamKHR,      EGLDisplay, EGLStreamKHR, EGLenum, EGLint *)
-EGL_ENTRY(EGLBoolean,   eglQueryStreamu64KHR,   EGLDisplay, EGLStreamKHR, EGLenum, EGLuint64KHR *)
-EGL_ENTRY(EGLBoolean,   eglStreamConsumerGLTextureExternalKHR,  EGLDisplay, EGLStreamKHR)
-EGL_ENTRY(EGLBoolean,   eglStreamConsumerAcquireKHR,            EGLDisplay, EGLStreamKHR)
-EGL_ENTRY(EGLBoolean,   eglStreamConsumerReleaseKHR,            EGLDisplay, EGLStreamKHR)
-EGL_ENTRY(EGLSurface,   eglCreateStreamProducerSurfaceKHR,      EGLDisplay, EGLConfig, EGLStreamKHR, const EGLint *)
-EGL_ENTRY(EGLBoolean,   eglQueryStreamTimeKHR,  EGLDisplay, EGLStreamKHR, EGLenum, EGLTimeKHR*)
-EGL_ENTRY(EGLNativeFileDescriptorKHR,   eglGetStreamFileDescriptorKHR,          EGLDisplay, EGLStreamKHR)
-EGL_ENTRY(EGLStreamKHR, eglCreateStreamFromFileDescriptorKHR,   EGLDisplay, EGLNativeFileDescriptorKHR)
+//    EGL_ENTRY(EGLStreamKHR, eglCreateStreamKHR,     EGLDisplay, const EGLint *)
+//    EGL_ENTRY(EGLBoolean,   eglDestroyStreamKHR,    EGLDisplay, EGLStreamKHR)
+//    EGL_ENTRY(EGLBoolean,   eglStreamAttribKHR,     EGLDisplay, EGLStreamKHR, EGLenum, EGLint)
+//    EGL_ENTRY(EGLBoolean,   eglQueryStreamKHR,      EGLDisplay, EGLStreamKHR, EGLenum, EGLint *)
+//    EGL_ENTRY(EGLBoolean,   eglQueryStreamu64KHR,   EGLDisplay, EGLStreamKHR, EGLenum, EGLuint64KHR *)
+//    EGL_ENTRY(EGLBoolean,   eglStreamConsumerGLTextureExternalKHR,  EGLDisplay, EGLStreamKHR)
+//    EGL_ENTRY(EGLBoolean,   eglStreamConsumerAcquireKHR,            EGLDisplay, EGLStreamKHR)
+//    EGL_ENTRY(EGLBoolean,   eglStreamConsumerReleaseKHR,            EGLDisplay, EGLStreamKHR)
+//    EGL_ENTRY(EGLSurface,   eglCreateStreamProducerSurfaceKHR,      EGLDisplay, EGLConfig, EGLStreamKHR, const EGLint *)
+//    EGL_ENTRY(EGLBoolean,   eglQueryStreamTimeKHR,  EGLDisplay, EGLStreamKHR, EGLenum, EGLTimeKHR*)
+//    EGL_ENTRY(EGLNativeFileDescriptorKHR,   eglGetStreamFileDescriptorKHR,          EGLDisplay, EGLStreamKHR)
+//    EGL_ENTRY(EGLStreamKHR, eglCreateStreamFromFileDescriptorKHR,   EGLDisplay, EGLNativeFileDescriptorKHR)
 EGL_ENTRY(EGLint,       eglWaitSyncKHR,         EGLDisplay, EGLSyncKHR, EGLint)
 
 /* ANDROID extensions */
@@ -81,6 +81,10 @@ EGL_ENTRY(EGLBoolean, eglSetSwapRectangleANDROID, EGLDisplay, EGLSurface, EGLint
 EGL_ENTRY(EGLClientBuffer, eglGetRenderBufferANDROID, EGLDisplay, EGLSurface)
 EGL_ENTRY(EGLint, eglDupNativeFenceFDANDROID, EGLDisplay, EGLSyncKHR)
 
+/* QCOM extensions */
+
+EGL_ENTRY(EGLBoolean, eglGpuPerfHintQCOM, EGLDisplay, EGLContext, EGLint *)
+
 /* NVIDIA extensions */
 
 EGL_ENTRY(EGLuint64NV, eglGetSystemTimeFrequencyNV, void)
@@ -89,9 +93,4 @@ EGL_ENTRY(EGLuint64NV, eglGetSystemTimeNV, void)
 /* IMG extensions */
 
 EGL_ENTRY(EGLBoolean, eglHibernateProcessIMG, void)
-EGL_ENTRY(EGLBoolean, eglAwakenProcessIMG, void)
-
-/* Partial update extensions */
-
-EGL_ENTRY(EGLBoolean, eglSwapBuffersWithDamageKHR, EGLDisplay, EGLSurface, EGLint *, EGLint)
-EGL_ENTRY(EGLBoolean, eglSetDamageRegionKHR, EGLDisplay, EGLSurface, EGLint *, EGLint)
+EGL_ENTRY(EGLBoolean, eglAwakenProcessIMG, void)
\ No newline at end of file
diff --git a/opengl/libs/EGL/egl_object.cpp b/opengl/libs/EGL/egl_object.cpp
index 918faa8..d3ee76d 100644
--- a/opengl/libs/EGL/egl_object.cpp
+++ b/opengl/libs/EGL/egl_object.cpp
@@ -14,9 +14,6 @@
  ** limitations under the License.
  */
 
-#include <string>
-#include <sstream>
-
 #include <ctype.h>
 #include <stdint.h>
 #include <stdlib.h>
@@ -116,14 +113,6 @@ void egl_context_t::onMakeCurrent(EGLSurface draw, EGLSurface read) {
             temp.append(gl_extensions);
             gl_extensions.setTo(temp);
         }
-
-        // tokenize the supported extensions for the glGetStringi() wrapper
-        std::stringstream ss;
-        std::string str;
-        ss << gl_extensions.string();
-        while (ss >> str) {
-            tokenized_gl_extensions.push(String8(str.c_str()));
-        }
     }
 }
 
diff --git a/opengl/libs/EGL/egl_object.h b/opengl/libs/EGL/egl_object.h
index f5a9f58..518fdec 100644
--- a/opengl/libs/EGL/egl_object.h
+++ b/opengl/libs/EGL/egl_object.h
@@ -27,7 +27,6 @@
 
 #include <utils/threads.h>
 #include <utils/String8.h>
-#include <utils/Vector.h>
 
 #include <system/window.h>
 
@@ -160,7 +159,6 @@ public:
     egl_connection_t const* cnx;
     int version;
     String8 gl_extensions;
-    Vector<String8> tokenized_gl_extensions;
 };
 
 // ----------------------------------------------------------------------------
diff --git a/opengl/libs/EGL/getProcAddress.cpp b/opengl/libs/EGL/getProcAddress.cpp
index 660af33..fc61134 100644
--- a/opengl/libs/EGL/getProcAddress.cpp
+++ b/opengl/libs/EGL/getProcAddress.cpp
@@ -78,7 +78,7 @@ namespace android {
 
 #elif defined(__i386__)
 
-    #define API_ENTRY(_api) __attribute__((noinline,optimize("omit-frame-pointer"))) _api
+    #define API_ENTRY(_api) __attribute__((noinline)) _api
 
     #define CALL_GL_EXTENSION_API(_api)                         \
          register void** fn;                                    \
@@ -100,7 +100,7 @@ namespace android {
 
 #elif defined(__x86_64__)
 
-    #define API_ENTRY(_api) __attribute__((noinline,optimize("omit-frame-pointer"))) _api
+    #define API_ENTRY(_api) __attribute__((noinline)) _api
 
     #define CALL_GL_EXTENSION_API(_api)                         \
          register void** fn;                                    \
@@ -120,46 +120,14 @@ namespace android {
             : "cc"                                              \
             );
 
-#elif defined(__mips64)
-
-        #define API_ENTRY(_api) __attribute__((noinline)) _api
-
-        #define CALL_GL_EXTENSION_API(_api, ...)                    \
-            register unsigned int _t0 asm("$12");                   \
-            register unsigned int _fn asm("$25");                   \
-            register unsigned int _tls asm("$3");                   \
-            asm volatile(                                           \
-                ".set  push\n\t"                                    \
-                ".set  noreorder\n\t"                               \
-                "rdhwr %[tls], $29\n\t"                             \
-                "ld    %[t0], %[OPENGL_API](%[tls])\n\t"            \
-                "beqz  %[t0], 1f\n\t"                               \
-                " move %[fn], $ra\n\t"                              \
-                "ld    %[t0], %[API](%[t0])\n\t"                    \
-                "beqz  %[t0], 1f\n\t"                               \
-                " nop\n\t"                                          \
-                "move  %[fn], %[t0]\n\t"                            \
-                "1:\n\t"                                            \
-                "jalr  $0, %[fn]\n\t"                               \
-                " nop\n\t"                                          \
-                ".set  pop\n\t"                                     \
-                : [fn] "=c"(_fn),                                   \
-                  [tls] "=&r"(_tls),                                \
-                  [t0] "=&r"(_t0)                                   \
-                : [OPENGL_API] "I"(TLS_SLOT_OPENGL_API*4),          \
-                  [API] "I"(__builtin_offsetof(gl_hooks_t,          \
-                                          ext.extensions[_api]))    \
-                :                                                   \
-            );
-
 #elif defined(__mips__)
 
         #define API_ENTRY(_api) __attribute__((noinline)) _api
 
         #define CALL_GL_EXTENSION_API(_api, ...)                    \
-            register unsigned int _t0 asm("$8");                    \
-            register unsigned int _fn asm("$25");                    \
-            register unsigned int _tls asm("$3");                   \
+            register unsigned int _t0 asm("t0");                    \
+            register unsigned int _fn asm("t1");                    \
+            register unsigned int _tls asm("v1");                   \
             asm volatile(                                           \
                 ".set  push\n\t"                                    \
                 ".set  noreorder\n\t"                               \
@@ -168,12 +136,10 @@ namespace android {
                 "lw    %[t0], %[OPENGL_API](%[tls])\n\t"            \
                 "beqz  %[t0], 1f\n\t"                               \
                 " move %[fn], $ra\n\t"                              \
-                "lw    %[t0], %[API](%[t0])\n\t"                    \
-                "beqz  %[t0], 1f\n\t"                               \
-                " nop\n\t"                                          \
-                "move  %[fn], %[t0]\n\t"                            \
+                "lw    %[fn], %[API](%[t0])\n\t"                    \
+                "movz  %[fn], $ra, %[fn]\n\t"                       \
                 "1:\n\t"                                            \
-                "jalr  $0, %[fn]\n\t"                               \
+                "j     %[fn]\n\t"                                   \
                 " nop\n\t"                                          \
                 ".set  pop\n\t"                                     \
                 : [fn] "=c"(_fn),                                   \
diff --git a/opengl/libs/GLES2/gl2.cpp b/opengl/libs/GLES2/gl2.cpp
index 6034a8e..b07228f 100644
--- a/opengl/libs/GLES2/gl2.cpp
+++ b/opengl/libs/GLES2/gl2.cpp
@@ -82,7 +82,7 @@ using namespace android;
 
 #elif defined(__i386__)
 
-    #define API_ENTRY(_api) __attribute__((noinline,optimize("omit-frame-pointer"))) _api
+    #define API_ENTRY(_api) __attribute__((noinline)) _api
 
     #define CALL_GL_API(_api, ...)                                  \
         register void** fn;                                         \
@@ -101,7 +101,7 @@ using namespace android;
 
 #elif defined(__x86_64__)
 
-    #define API_ENTRY(_api) __attribute__((noinline,optimize("omit-frame-pointer"))) _api
+    #define API_ENTRY(_api) __attribute__((noinline)) _api
 
     #define CALL_GL_API(_api, ...)                                  \
          register void** fn;                                        \
@@ -118,62 +118,27 @@ using namespace android;
             : "cc"                                                  \
             );
 
-#elif defined(__mips64)
-
-    #define API_ENTRY(_api) __attribute__((noinline)) _api
-
-    #define CALL_GL_API(_api, ...)                            \
-    register unsigned long _t0 asm("$12");                    \
-    register unsigned long _fn asm("$25");                    \
-    register unsigned long _tls asm("$3");                    \
-    register unsigned long _v0 asm("$2");                     \
-    asm volatile(                                             \
-        ".set  push\n\t"                                      \
-        ".set  noreorder\n\t"                                 \
-        "rdhwr %[tls], $29\n\t"                               \
-        "ld    %[t0], %[OPENGL_API](%[tls])\n\t"              \
-        "beqz  %[t0], 1f\n\t"                                 \
-        " move %[fn], $ra\n\t"                                \
-        "ld    %[t0], %[API](%[t0])\n\t"                      \
-        "beqz  %[t0], 1f\n\t"                                 \
-        " nop\n\t"                                            \
-        "move  %[fn], %[t0]\n\t"                              \
-        "1:\n\t"                                              \
-        "jalr  $0, %[fn]\n\t"                                 \
-        " move %[v0], $0\n\t"                                 \
-        ".set  pop\n\t"                                       \
-        : [fn] "=c"(_fn),                                     \
-          [tls] "=&r"(_tls),                                  \
-          [t0] "=&r"(_t0),                                    \
-          [v0] "=&r"(_v0)                                     \
-        : [OPENGL_API] "I"(TLS_SLOT_OPENGL_API*sizeof(void*)),\
-          [API] "I"(__builtin_offsetof(gl_hooks_t, gl._api))  \
-        :                                                     \
-        );
-
 #elif defined(__mips__)
 
     #define API_ENTRY(_api) __attribute__((noinline)) _api
 
     #define CALL_GL_API(_api, ...)                               \
-        register unsigned int _t0 asm("$8");                     \
-        register unsigned int _fn asm("$25");                    \
-        register unsigned int _tls asm("$3");                    \
-        register unsigned int _v0 asm("$2");                     \
+        register unsigned int _t0 asm("t0");                     \
+        register unsigned int _fn asm("t1");                     \
+        register unsigned int _tls asm("v1");                    \
+        register unsigned int _v0 asm("v0");                     \
         asm volatile(                                            \
             ".set  push\n\t"                                     \
             ".set  noreorder\n\t"                                \
-            ".set  mips32r2\n\t"                                 \
+            ".set mips32r2\n\t"                                  \
             "rdhwr %[tls], $29\n\t"                              \
             "lw    %[t0], %[OPENGL_API](%[tls])\n\t"             \
             "beqz  %[t0], 1f\n\t"                                \
             " move %[fn],$ra\n\t"                                \
-            "lw    %[t0], %[API](%[t0])\n\t"                     \
-            "beqz  %[t0], 1f\n\t"                                \
-            " nop\n\t"                                           \
-            "move  %[fn], %[t0]\n\t"                             \
+            "lw    %[fn], %[API](%[t0])\n\t"                     \
+            "movz  %[fn], $ra, %[fn]\n\t"                        \
             "1:\n\t"                                             \
-            "jalr  $0, %[fn]\n\t"                                \
+            "j     %[fn]\n\t"                                    \
             " move %[v0], $0\n\t"                                \
             ".set  pop\n\t"                                      \
             : [fn] "=c"(_fn),                                    \
@@ -205,87 +170,17 @@ extern "C" {
 #undef CALL_GL_API_RETURN
 
 /*
- * glGetString() and glGetStringi() are special because we expose some
- * extensions in the wrapper. Also, wrapping glGetXXX() is required because
- * the value returned for GL_NUM_EXTENSIONS may have been altered by the
- * injection of the additional extensions.
+ * glGetString() is special because we expose some extensions in the wrapper
  */
 
-extern "C" {
-    const GLubyte * __glGetString(GLenum name);
-    const GLubyte * __glGetStringi(GLenum name, GLuint index);
-    void __glGetBooleanv(GLenum pname, GLboolean * data);
-    void __glGetFloatv(GLenum pname, GLfloat * data);
-    void __glGetIntegerv(GLenum pname, GLint * data);
-    void __glGetInteger64v(GLenum pname, GLint64 * data);
-}
+extern "C" const GLubyte * __glGetString(GLenum name);
 
-const GLubyte * glGetString(GLenum name) {
+const GLubyte * glGetString(GLenum name)
+{
     const GLubyte * ret = egl_get_string_for_current_context(name);
     if (ret == NULL) {
         gl_hooks_t::gl_t const * const _c = &getGlThreadSpecific()->gl;
-        if(_c) ret = _c->glGetString(name);
-    }
-    return ret;
-}
-
-const GLubyte * glGetStringi(GLenum name, GLuint index) {
-    const GLubyte * ret = egl_get_string_for_current_context(name, index);
-    if (ret == NULL) {
-        gl_hooks_t::gl_t const * const _c = &getGlThreadSpecific()->gl;
-        if(_c) ret = _c->glGetStringi(name, index);
+        ret = _c->glGetString(name);
     }
     return ret;
 }
-
-void glGetBooleanv(GLenum pname, GLboolean * data) {
-    if (pname == GL_NUM_EXTENSIONS) {
-        int num_exts = egl_get_num_extensions_for_current_context();
-        if (num_exts >= 0) {
-            *data = num_exts > 0 ? GL_TRUE : GL_FALSE;
-            return;
-        }
-    }
-
-    gl_hooks_t::gl_t const * const _c = &getGlThreadSpecific()->gl;
-    if (_c) _c->glGetBooleanv(pname, data);
-}
-
-void glGetFloatv(GLenum pname, GLfloat * data) {
-    if (pname == GL_NUM_EXTENSIONS) {
-        int num_exts = egl_get_num_extensions_for_current_context();
-        if (num_exts >= 0) {
-            *data = (GLfloat)num_exts;
-            return;
-        }
-    }
-
-    gl_hooks_t::gl_t const * const _c = &getGlThreadSpecific()->gl;
-    if (_c) _c->glGetFloatv(pname, data);
-}
-
-void glGetIntegerv(GLenum pname, GLint * data) {
-    if (pname == GL_NUM_EXTENSIONS) {
-        int num_exts = egl_get_num_extensions_for_current_context();
-        if (num_exts >= 0) {
-            *data = (GLint)num_exts;
-            return;
-        }
-    }
-
-    gl_hooks_t::gl_t const * const _c = &getGlThreadSpecific()->gl;
-    if (_c) _c->glGetIntegerv(pname, data);
-}
-
-void glGetInteger64v(GLenum pname, GLint64 * data) {
-    if (pname == GL_NUM_EXTENSIONS) {
-        int num_exts = egl_get_num_extensions_for_current_context();
-        if (num_exts >= 0) {
-            *data = (GLint64)num_exts;
-            return;
-        }
-    }
-
-    gl_hooks_t::gl_t const * const _c = &getGlThreadSpecific()->gl;
-    if (_c) _c->glGetInteger64v(pname, data);
-}
diff --git a/opengl/libs/GLES2/gl2_api.in b/opengl/libs/GLES2/gl2_api.in
index 09d8b00..8363960 100644
--- a/opengl/libs/GLES2/gl2_api.in
+++ b/opengl/libs/GLES2/gl2_api.in
@@ -172,7 +172,7 @@ void API_ENTRY(glGetAttachedShaders)(GLuint program, GLsizei maxCount, GLsizei *
 GLint API_ENTRY(glGetAttribLocation)(GLuint program, const GLchar * name) {
     CALL_GL_API_RETURN(glGetAttribLocation, program, name);
 }
-void API_ENTRY(__glGetBooleanv)(GLenum pname, GLboolean * data) {
+void API_ENTRY(glGetBooleanv)(GLenum pname, GLboolean * data) {
     CALL_GL_API(glGetBooleanv, pname, data);
 }
 void API_ENTRY(glGetBufferParameteriv)(GLenum target, GLenum pname, GLint * params) {
@@ -181,13 +181,13 @@ void API_ENTRY(glGetBufferParameteriv)(GLenum target, GLenum pname, GLint * para
 GLenum API_ENTRY(glGetError)(void) {
     CALL_GL_API_RETURN(glGetError);
 }
-void API_ENTRY(__glGetFloatv)(GLenum pname, GLfloat * data) {
+void API_ENTRY(glGetFloatv)(GLenum pname, GLfloat * data) {
     CALL_GL_API(glGetFloatv, pname, data);
 }
 void API_ENTRY(glGetFramebufferAttachmentParameteriv)(GLenum target, GLenum attachment, GLenum pname, GLint * params) {
     CALL_GL_API(glGetFramebufferAttachmentParameteriv, target, attachment, pname, params);
 }
-void API_ENTRY(__glGetIntegerv)(GLenum pname, GLint * data) {
+void API_ENTRY(glGetIntegerv)(GLenum pname, GLint * data) {
     CALL_GL_API(glGetIntegerv, pname, data);
 }
 void API_ENTRY(glGetProgramiv)(GLuint program, GLenum pname, GLint * params) {
@@ -604,7 +604,7 @@ void API_ENTRY(glClearBufferfv)(GLenum buffer, GLint drawbuffer, const GLfloat *
 void API_ENTRY(glClearBufferfi)(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) {
     CALL_GL_API(glClearBufferfi, buffer, drawbuffer, depth, stencil);
 }
-const GLubyte * API_ENTRY(__glGetStringi)(GLenum name, GLuint index) {
+const GLubyte * API_ENTRY(glGetStringi)(GLenum name, GLuint index) {
     CALL_GL_API_RETURN(glGetStringi, name, index);
 }
 void API_ENTRY(glCopyBufferSubData)(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
@@ -649,7 +649,7 @@ GLenum API_ENTRY(glClientWaitSync)(GLsync sync, GLbitfield flags, GLuint64 timeo
 void API_ENTRY(glWaitSync)(GLsync sync, GLbitfield flags, GLuint64 timeout) {
     CALL_GL_API(glWaitSync, sync, flags, timeout);
 }
-void API_ENTRY(__glGetInteger64v)(GLenum pname, GLint64 * data) {
+void API_ENTRY(glGetInteger64v)(GLenum pname, GLint64 * data) {
     CALL_GL_API(glGetInteger64v, pname, data);
 }
 void API_ENTRY(glGetSynciv)(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values) {
diff --git a/opengl/libs/GLES_CM/gl.cpp b/opengl/libs/GLES_CM/gl.cpp
index b1b31f8..f05983c 100644
--- a/opengl/libs/GLES_CM/gl.cpp
+++ b/opengl/libs/GLES_CM/gl.cpp
@@ -138,7 +138,7 @@ GL_API void GL_APIENTRY glWeightPointerOESBounds(GLint size, GLenum type,
 
 #elif defined(__i386__)
 
-    #define API_ENTRY(_api) __attribute__((noinline,optimize("omit-frame-pointer"))) _api
+    #define API_ENTRY(_api) __attribute__((noinline)) _api
 
     #define CALL_GL_API(_api, ...)                                  \
         register void* fn;                                          \
@@ -157,7 +157,7 @@ GL_API void GL_APIENTRY glWeightPointerOESBounds(GLint size, GLenum type,
 
 #elif defined(__x86_64__)
 
-    #define API_ENTRY(_api) __attribute__((noinline,optimize("omit-frame-pointer"))) _api
+    #define API_ENTRY(_api) __attribute__((noinline)) _api
 
     #define CALL_GL_API(_api, ...)                                  \
          register void** fn;                                        \
@@ -174,48 +174,15 @@ GL_API void GL_APIENTRY glWeightPointerOESBounds(GLint size, GLenum type,
             : "cc"                                                  \
             );
 
-#elif defined(__mips64)
-
-    #define API_ENTRY(_api) __attribute__((noinline)) _api
-
-    #define CALL_GL_API(_api, ...)                            \
-    register unsigned long _t0 asm("$12");                    \
-    register unsigned long _fn asm("$25");                    \
-    register unsigned long _tls asm("$3");                    \
-    register unsigned long _v0 asm("$2");                     \
-    asm volatile(                                             \
-        ".set  push\n\t"                                      \
-        ".set  noreorder\n\t"                                 \
-        "rdhwr %[tls], $29\n\t"                               \
-        "ld    %[t0], %[OPENGL_API](%[tls])\n\t"              \
-        "beqz  %[t0], 1f\n\t"                                 \
-        " move %[fn], $ra\n\t"                                \
-        "ld    %[t0], %[API](%[t0])\n\t"                      \
-        "beqz  %[t0], 1f\n\t"                                 \
-        " nop\n\t"                                            \
-        "move  %[fn], %[t0]\n\t"                              \
-        "1:\n\t"                                              \
-        "jalr  $0, %[fn]\n\t"                                 \
-        " move %[v0], $0\n\t"                                 \
-        ".set  pop\n\t"                                       \
-        : [fn] "=c"(_fn),                                     \
-          [tls] "=&r"(_tls),                                  \
-          [t0] "=&r"(_t0),                                    \
-          [v0] "=&r"(_v0)                                     \
-        : [OPENGL_API] "I"(TLS_SLOT_OPENGL_API*sizeof(void*)),\
-          [API] "I"(__builtin_offsetof(gl_hooks_t, gl._api))  \
-        :                                                     \
-        );
-
 #elif defined(__mips__)
 
     #define API_ENTRY(_api) __attribute__((noinline)) _api
 
     #define CALL_GL_API(_api, ...)                               \
-        register unsigned int _t0 asm("$8");                     \
-        register unsigned int _fn asm("$25");                    \
-        register unsigned int _tls asm("$3");                    \
-        register unsigned int _v0 asm("$2");                     \
+        register unsigned int _t0 asm("t0");                     \
+        register unsigned int _fn asm("t1");                     \
+        register unsigned int _tls asm("v1");                    \
+        register unsigned int _v0 asm("v0");                     \
         asm volatile(                                            \
             ".set  push\n\t"                                     \
             ".set  noreorder\n\t"                                \
@@ -224,12 +191,10 @@ GL_API void GL_APIENTRY glWeightPointerOESBounds(GLint size, GLenum type,
             "lw    %[t0], %[OPENGL_API](%[tls])\n\t"             \
             "beqz  %[t0], 1f\n\t"                                \
             " move %[fn], $ra\n\t"                               \
-            "lw    %[t0], %[API](%[t0])\n\t"                     \
-            "beqz  %[t0], 1f\n\t"                                \
-            " nop\n\t"                                           \
-            "move  %[fn], %[t0]\n\t"                             \
+            "lw    %[fn], %[API](%[t0])\n\t"                     \
+            "movz  %[fn], $ra, %[fn]\n\t"                        \
             "1:\n\t"                                             \
-            "jalr  $0, %[fn]\n\t"                                \
+            "j     %[fn]\n\t"                                    \
             " move %[v0], $0\n\t"                                \
             ".set  pop\n\t"                                      \
             : [fn] "=c"(_fn),                                    \
diff --git a/opengl/libs/GLES_trace/Android.mk b/opengl/libs/GLES_trace/Android.mk
index 24c4be2..846932d 100644
--- a/opengl/libs/GLES_trace/Android.mk
+++ b/opengl/libs/GLES_trace/Android.mk
@@ -1,7 +1,6 @@
 LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
-LOCAL_ADDITIONAL_DEPENDENCIES := $(LOCAL_PATH)/Android.mk
 
 LOCAL_SRC_FILES := \
     src/gltrace_api.cpp \
@@ -10,18 +9,20 @@ LOCAL_SRC_FILES := \
     src/gltrace_eglapi.cpp \
     src/gltrace_fixup.cpp \
     src/gltrace_hooks.cpp \
-    src/gltrace_transport.cpp \
-    $(call all-proto-files-under, proto)
+    src/gltrace.pb.cpp \
+    src/gltrace_transport.cpp
 
 LOCAL_C_INCLUDES := \
     $(LOCAL_PATH) \
     $(LOCAL_PATH)/../ \
-    external
-
-LOCAL_STATIC_LIBRARIES := liblzf
-LOCAL_SHARED_LIBRARIES := libcutils libutils liblog
-
-LOCAL_PROTOC_OPTIMIZE_TYPE := lite
+    external/stlport/stlport \
+    external/protobuf/src \
+    external \
+    bionic
+
+LOCAL_CFLAGS := -DGOOGLE_PROTOBUF_NO_RTTI
+LOCAL_STATIC_LIBRARIES := libprotobuf-cpp-2.3.0-lite liblzf
+LOCAL_SHARED_LIBRARIES := libcutils libutils liblog libstlport
 
 LOCAL_CFLAGS += -DLOG_TAG=\"libGLES_trace\"
 
diff --git a/opengl/libs/GLES_trace/dev.make b/opengl/libs/GLES_trace/dev.make
index 3405d8e..a46260c 100644
--- a/opengl/libs/GLES_trace/dev.make
+++ b/opengl/libs/GLES_trace/dev.make
@@ -1,6 +1,11 @@
 ## NOTE
 ## This file is used for development purposes only. It is not used by the build system.
 
+# generate protocol buffer files
+genproto: gltrace.proto
+	aprotoc --cpp_out=src --java_out=java gltrace.proto
+	mv src/gltrace.pb.cc src/gltrace.pb.cpp
+
 sync:
 	adb root
 	adb remount
diff --git a/opengl/libs/GLES_trace/gltrace.proto b/opengl/libs/GLES_trace/gltrace.proto
new file mode 100644
index 0000000..00303c2
--- /dev/null
+++ b/opengl/libs/GLES_trace/gltrace.proto
@@ -0,0 +1,851 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.gltrace;
+
+option optimize_for = LITE_RUNTIME;
+
+option java_package = "com.android.ide.eclipse.gltrace";
+option java_outer_classname = "GLProtoBuf";
+
+message GLMessage {
+    enum Function {
+        glActiveTexture = 0;
+        glAlphaFunc = 1;
+        glAlphaFuncx = 2;
+        glAlphaFuncxOES = 3;
+        glAttachShader = 4;
+        glBeginPerfMonitorAMD = 5;
+        glBindAttribLocation = 6;
+        glBindBuffer = 7;
+        glBindFramebuffer = 8;
+        glBindFramebufferOES = 9;
+        glBindRenderbuffer = 10;
+        glBindRenderbufferOES = 11;
+        glBindTexture = 12;
+        glBindVertexArrayOES = 13;
+        glBlendColor = 14;
+        glBlendEquation = 15;
+        glBlendEquationOES = 16;
+        glBlendEquationSeparate = 17;
+        glBlendEquationSeparateOES = 18;
+        glBlendFunc = 19;
+        glBlendFuncSeparate = 20;
+        glBlendFuncSeparateOES = 21;
+        glBufferData = 22;
+        glBufferSubData = 23;
+        glCheckFramebufferStatus = 24;
+        glCheckFramebufferStatusOES = 25;
+        glClearColor = 26;
+        glClearColorx = 27;
+        glClearColorxOES = 28;
+        glClearDepthf = 29;
+        glClearDepthfOES = 30;
+        glClearDepthx = 31;
+        glClearDepthxOES = 32;
+        glClear = 33;
+        glClearStencil = 34;
+        glClientActiveTexture = 35;
+        glClipPlanef = 36;
+        glClipPlanefIMG = 37;
+        glClipPlanefOES = 38;
+        glClipPlanex = 39;
+        glClipPlanexIMG = 40;
+        glClipPlanexOES = 41;
+        glColor4f = 42;
+        glColor4ub = 43;
+        glColor4x = 44;
+        glColor4xOES = 45;
+        glColorMask = 46;
+        glColorPointer = 47;
+        glCompileShader = 48;
+        glCompressedTexImage2D = 49;
+        glCompressedTexImage3DOES = 50;
+        glCompressedTexSubImage2D = 51;
+        glCompressedTexSubImage3DOES = 52;
+        glCopyTexImage2D = 53;
+        glCopyTexSubImage2D = 54;
+        glCopyTexSubImage3DOES = 55;
+        glCoverageMaskNV = 56;
+        glCoverageOperationNV = 57;
+        glCreateProgram = 58;
+        glCreateShader = 59;
+        glCullFace = 60;
+        glCurrentPaletteMatrixOES = 61;
+        glDeleteBuffers = 62;
+        glDeleteFencesNV = 63;
+        glDeleteFramebuffers = 64;
+        glDeleteFramebuffersOES = 65;
+        glDeletePerfMonitorsAMD = 66;
+        glDeleteProgram = 67;
+        glDeleteRenderbuffers = 68;
+        glDeleteRenderbuffersOES = 69;
+        glDeleteShader = 70;
+        glDeleteTextures = 71;
+        glDeleteVertexArraysOES = 72;
+        glDepthFunc = 73;
+        glDepthMask = 74;
+        glDepthRangef = 75;
+        glDepthRangefOES = 76;
+        glDepthRangex = 77;
+        glDepthRangexOES = 78;
+        glDetachShader = 79;
+        glDisableClientState = 80;
+        glDisableDriverControlQCOM = 81;
+        glDisable = 82;
+        glDisableVertexAttribArray = 83;
+        glDiscardFramebufferEXT = 84;
+        glDrawArrays = 85;
+        glDrawElements = 86;
+        glDrawTexfOES = 87;
+        glDrawTexfvOES = 88;
+        glDrawTexiOES = 89;
+        glDrawTexivOES = 90;
+        glDrawTexsOES = 91;
+        glDrawTexsvOES = 92;
+        glDrawTexxOES = 93;
+        glDrawTexxvOES = 94;
+        glEGLImageTargetRenderbufferStorageOES = 95;
+        glEGLImageTargetTexture2DOES = 96;
+        glEnableClientState = 97;
+        glEnableDriverControlQCOM = 98;
+        glEnable = 99;
+        glEnableVertexAttribArray = 100;
+        glEndPerfMonitorAMD = 101;
+        glEndTilingQCOM = 102;
+        glExtGetBufferPointervQCOM = 103;
+        glExtGetBuffersQCOM = 104;
+        glExtGetFramebuffersQCOM = 105;
+        glExtGetProgramBinarySourceQCOM = 106;
+        glExtGetProgramsQCOM = 107;
+        glExtGetRenderbuffersQCOM = 108;
+        glExtGetShadersQCOM = 109;
+        glExtGetTexLevelParameterivQCOM = 110;
+        glExtGetTexSubImageQCOM = 111;
+        glExtGetTexturesQCOM = 112;
+        glExtIsProgramBinaryQCOM = 113;
+        glExtTexObjectStateOverrideiQCOM = 114;
+        glFinishFenceNV = 115;
+        glFinish = 116;
+        glFlush = 117;
+        glFogf = 118;
+        glFogfv = 119;
+        glFogx = 120;
+        glFogxOES = 121;
+        glFogxv = 122;
+        glFogxvOES = 123;
+        glFramebufferRenderbuffer = 124;
+        glFramebufferRenderbufferOES = 125;
+        glFramebufferTexture2D = 126;
+        glFramebufferTexture2DMultisampleIMG = 127;
+        glFramebufferTexture2DOES = 128;
+        glFramebufferTexture3DOES = 129;
+        glFrontFace = 130;
+        glFrustumf = 131;
+        glFrustumfOES = 132;
+        glFrustumx = 133;
+        glFrustumxOES = 134;
+        glGenBuffers = 135;
+        glGenerateMipmap = 136;
+        glGenerateMipmapOES = 137;
+        glGenFencesNV = 138;
+        glGenFramebuffers = 139;
+        glGenFramebuffersOES = 140;
+        glGenPerfMonitorsAMD = 141;
+        glGenRenderbuffers = 142;
+        glGenRenderbuffersOES = 143;
+        glGenTextures = 144;
+        glGenVertexArraysOES = 145;
+        glGetActiveAttrib = 146;
+        glGetActiveUniform = 147;
+        glGetAttachedShaders = 148;
+        glGetAttribLocation = 149;
+        glGetBooleanv = 150;
+        glGetBufferParameteriv = 151;
+        glGetBufferPointervOES = 152;
+        glGetClipPlanef = 153;
+        glGetClipPlanefOES = 154;
+        glGetClipPlanex = 155;
+        glGetClipPlanexOES = 156;
+        glGetDriverControlsQCOM = 157;
+        glGetDriverControlStringQCOM = 158;
+        glGetError = 159;
+        glGetFenceivNV = 160;
+        glGetFixedv = 161;
+        glGetFixedvOES = 162;
+        glGetFloatv = 163;
+        glGetFramebufferAttachmentParameteriv = 164;
+        glGetFramebufferAttachmentParameterivOES = 165;
+        glGetIntegerv = 166;
+        glGetLightfv = 167;
+        glGetLightxv = 168;
+        glGetLightxvOES = 169;
+        glGetMaterialfv = 170;
+        glGetMaterialxv = 171;
+        glGetMaterialxvOES = 172;
+        glGetPerfMonitorCounterDataAMD = 173;
+        glGetPerfMonitorCounterInfoAMD = 174;
+        glGetPerfMonitorCountersAMD = 175;
+        glGetPerfMonitorCounterStringAMD = 176;
+        glGetPerfMonitorGroupsAMD = 177;
+        glGetPerfMonitorGroupStringAMD = 178;
+        glGetPointerv = 179;
+        glGetProgramBinaryOES = 180;
+        glGetProgramInfoLog = 181;
+        glGetProgramiv = 182;
+        glGetRenderbufferParameteriv = 183;
+        glGetRenderbufferParameterivOES = 184;
+        glGetShaderInfoLog = 185;
+        glGetShaderiv = 186;
+        glGetShaderPrecisionFormat = 187;
+        glGetShaderSource = 188;
+        glGetString = 189;
+        glGetTexEnvfv = 190;
+        glGetTexEnviv = 191;
+        glGetTexEnvxv = 192;
+        glGetTexEnvxvOES = 193;
+        glGetTexGenfvOES = 194;
+        glGetTexGenivOES = 195;
+        glGetTexGenxvOES = 196;
+        glGetTexParameterfv = 197;
+        glGetTexParameteriv = 198;
+        glGetTexParameterxv = 199;
+        glGetTexParameterxvOES = 200;
+        glGetUniformfv = 201;
+        glGetUniformiv = 202;
+        glGetUniformLocation = 203;
+        glGetVertexAttribfv = 204;
+        glGetVertexAttribiv = 205;
+        glGetVertexAttribPointerv = 206;
+        glHint = 207;
+        glIsBuffer = 208;
+        glIsEnabled = 209;
+        glIsFenceNV = 210;
+        glIsFramebuffer = 211;
+        glIsFramebufferOES = 212;
+        glIsProgram = 213;
+        glIsRenderbuffer = 214;
+        glIsRenderbufferOES = 215;
+        glIsShader = 216;
+        glIsTexture = 217;
+        glIsVertexArrayOES = 218;
+        glLightf = 219;
+        glLightfv = 220;
+        glLightModelf = 221;
+        glLightModelfv = 222;
+        glLightModelx = 223;
+        glLightModelxOES = 224;
+        glLightModelxv = 225;
+        glLightModelxvOES = 226;
+        glLightx = 227;
+        glLightxOES = 228;
+        glLightxv = 229;
+        glLightxvOES = 230;
+        glLineWidth = 231;
+        glLineWidthx = 232;
+        glLineWidthxOES = 233;
+        glLinkProgram = 234;
+        glLoadIdentity = 235;
+        glLoadMatrixf = 236;
+        glLoadMatrixx = 237;
+        glLoadMatrixxOES = 238;
+        glLoadPaletteFromModelViewMatrixOES = 239;
+        glLogicOp = 240;
+        glMapBufferOES = 241;
+        glMaterialf = 242;
+        glMaterialfv = 243;
+        glMaterialx = 244;
+        glMaterialxOES = 245;
+        glMaterialxv = 246;
+        glMaterialxvOES = 247;
+        glMatrixIndexPointerOES = 248;
+        glMatrixMode = 249;
+        glMultiDrawArraysEXT = 250;
+        glMultiDrawElementsEXT = 251;
+        glMultiTexCoord4f = 252;
+        glMultiTexCoord4x = 253;
+        glMultiTexCoord4xOES = 254;
+        glMultMatrixf = 255;
+        glMultMatrixx = 256;
+        glMultMatrixxOES = 257;
+        glNormal3f = 258;
+        glNormal3x = 259;
+        glNormal3xOES = 260;
+        glNormalPointer = 261;
+        glOrthof = 262;
+        glOrthofOES = 263;
+        glOrthox = 264;
+        glOrthoxOES = 265;
+        glPixelStorei = 266;
+        glPointParameterf = 267;
+        glPointParameterfv = 268;
+        glPointParameterx = 269;
+        glPointParameterxOES = 270;
+        glPointParameterxv = 271;
+        glPointParameterxvOES = 272;
+        glPointSize = 273;
+        glPointSizePointerOES = 274;
+        glPointSizex = 275;
+        glPointSizexOES = 276;
+        glPolygonOffset = 277;
+        glPolygonOffsetx = 278;
+        glPolygonOffsetxOES = 279;
+        glPopMatrix = 280;
+        glProgramBinaryOES = 281;
+        glPushMatrix = 282;
+        glQueryMatrixxOES = 283;
+        glReadPixels = 284;
+        glReleaseShaderCompiler = 285;
+        glRenderbufferStorage = 286;
+        glRenderbufferStorageMultisampleIMG = 287;
+        glRenderbufferStorageOES = 288;
+        glRotatef = 289;
+        glRotatex = 290;
+        glRotatexOES = 291;
+        glSampleCoverage = 292;
+        glSampleCoveragex = 293;
+        glSampleCoveragexOES = 294;
+        glScalef = 295;
+        glScalex = 296;
+        glScalexOES = 297;
+        glScissor = 298;
+        glSelectPerfMonitorCountersAMD = 299;
+        glSetFenceNV = 300;
+        glShadeModel = 301;
+        glShaderBinary = 302;
+        glShaderSource = 303;
+        glStartTilingQCOM = 304;
+        glStencilFunc = 305;
+        glStencilFuncSeparate = 306;
+        glStencilMask = 307;
+        glStencilMaskSeparate = 308;
+        glStencilOp = 309;
+        glStencilOpSeparate = 310;
+        glTestFenceNV = 311;
+        glTexCoordPointer = 312;
+        glTexEnvf = 313;
+        glTexEnvfv = 314;
+        glTexEnvi = 315;
+        glTexEnviv = 316;
+        glTexEnvx = 317;
+        glTexEnvxOES = 318;
+        glTexEnvxv = 319;
+        glTexEnvxvOES = 320;
+        glTexGenfOES = 321;
+        glTexGenfvOES = 322;
+        glTexGeniOES = 323;
+        glTexGenivOES = 324;
+        glTexGenxOES = 325;
+        glTexGenxvOES = 326;
+        glTexImage2D = 327;
+        glTexImage3DOES = 328;
+        glTexParameterf = 329;
+        glTexParameterfv = 330;
+        glTexParameteri = 331;
+        glTexParameteriv = 332;
+        glTexParameterx = 333;
+        glTexParameterxOES = 334;
+        glTexParameterxv = 335;
+        glTexParameterxvOES = 336;
+        glTexSubImage2D = 337;
+        glTexSubImage3DOES = 338;
+        glTranslatef = 339;
+        glTranslatex = 340;
+        glTranslatexOES = 341;
+        glUniform1f = 342;
+        glUniform1fv = 343;
+        glUniform1i = 344;
+        glUniform1iv = 345;
+        glUniform2f = 346;
+        glUniform2fv = 347;
+        glUniform2i = 348;
+        glUniform2iv = 349;
+        glUniform3f = 350;
+        glUniform3fv = 351;
+        glUniform3i = 352;
+        glUniform3iv = 353;
+        glUniform4f = 354;
+        glUniform4fv = 355;
+        glUniform4i = 356;
+        glUniform4iv = 357;
+        glUniformMatrix2fv = 358;
+        glUniformMatrix3fv = 359;
+        glUniformMatrix4fv = 360;
+        glUnmapBufferOES = 361;
+        glUseProgram = 362;
+        glValidateProgram = 363;
+        glVertexAttrib1f = 364;
+        glVertexAttrib1fv = 365;
+        glVertexAttrib2f = 366;
+        glVertexAttrib2fv = 367;
+        glVertexAttrib3f = 368;
+        glVertexAttrib3fv = 369;
+        glVertexAttrib4f = 370;
+        glVertexAttrib4fv = 371;
+        glVertexAttribPointer = 372;
+        glVertexPointer = 373;
+        glViewport = 374;
+        glWeightPointerOES = 375;
+        glReadBuffer = 376;
+        glDrawRangeElements = 377;
+        glTexImage3D = 378;
+        glTexSubImage3D = 379;
+        glCopyTexSubImage3D = 380;
+        glCompressedTexImage3D = 381;
+        glCompressedTexSubImage3D = 382;
+        glGenQueries = 383;
+        glDeleteQueries = 384;
+        glIsQuery = 385;
+        glBeginQuery = 386;
+        glEndQuery = 387;
+        glGetQueryiv = 388;
+        glGetQueryObjectuiv = 389;
+        glUnmapBuffer = 390;
+        glGetBufferPointerv = 391;
+        glDrawBuffers = 392;
+        glUniformMatrix2x3fv = 393;
+        glUniformMatrix3x2fv = 394;
+        glUniformMatrix2x4fv = 395;
+        glUniformMatrix4x2fv = 396;
+        glUniformMatrix3x4fv = 397;
+        glUniformMatrix4x3fv = 398;
+        glBlitFramebuffer = 399;
+        glRenderbufferStorageMultisample = 400;
+        glFramebufferTextureLayer = 401;
+        glMapBufferRange = 402;
+        glFlushMappedBufferRange = 403;
+        glBindVertexArray = 404;
+        glDeleteVertexArrays = 405;
+        glGenVertexArrays = 406;
+        glIsVertexArray = 407;
+        glGetIntegeri_v = 408;
+        glBeginTransformFeedback = 409;
+        glEndTransformFeedback = 410;
+        glBindBufferRange = 411;
+        glBindBufferBase = 412;
+        glTransformFeedbackVaryings = 413;
+        glGetTransformFeedbackVarying = 414;
+        glVertexAttribIPointer = 415;
+        glGetVertexAttribIiv = 416;
+        glGetVertexAttribIuiv = 417;
+        glVertexAttribI4i = 418;
+        glVertexAttribI4ui = 419;
+        glVertexAttribI4iv = 420;
+        glVertexAttribI4uiv = 421;
+        glGetUniformuiv = 422;
+        glGetFragDataLocation = 423;
+        glUniform1ui = 424;
+        glUniform2ui = 425;
+        glUniform3ui = 426;
+        glUniform4ui = 427;
+        glUniform1uiv = 428;
+        glUniform2uiv = 429;
+        glUniform3uiv = 430;
+        glUniform4uiv = 431;
+        glClearBufferiv = 432;
+        glClearBufferuiv = 433;
+        glClearBufferfv = 434;
+        glClearBufferfi = 435;
+        glGetStringi = 436;
+        glCopyBufferSubData = 437;
+        glGetUniformIndices = 438;
+        glGetActiveUniformsiv = 439;
+        glGetUniformBlockIndex = 440;
+        glGetActiveUniformBlockiv = 441;
+        glGetActiveUniformBlockName = 442;
+        glUniformBlockBinding = 443;
+        glDrawArraysInstanced = 444;
+        glDrawElementsInstanced = 445;
+        glFenceSync = 446;
+        glIsSync = 447;
+        glDeleteSync = 448;
+        glClientWaitSync = 449;
+        glWaitSync = 450;
+        glGetInteger64v = 451;
+        glGetSynciv = 452;
+        glGetInteger64i_v = 453;
+        glGetBufferParameteri64v = 454;
+        glGenSamplers = 455;
+        glDeleteSamplers = 456;
+        glIsSampler = 457;
+        glBindSampler = 458;
+        glSamplerParameteri = 459;
+        glSamplerParameteriv = 460;
+        glSamplerParameterf = 461;
+        glSamplerParameterfv = 462;
+        glGetSamplerParameteriv = 463;
+        glGetSamplerParameterfv = 464;
+        glVertexAttribDivisor = 465;
+        glBindTransformFeedback = 466;
+        glDeleteTransformFeedbacks = 467;
+        glGenTransformFeedbacks = 468;
+        glIsTransformFeedback = 469;
+        glPauseTransformFeedback = 470;
+        glResumeTransformFeedback = 471;
+        glGetProgramBinary = 472;
+        glProgramBinary = 473;
+        glProgramParameteri = 474;
+        glInvalidateFramebuffer = 475;
+        glInvalidateSubFramebuffer = 476;
+        glTexStorage2D = 477;
+        glTexStorage3D = 478;
+        glGetInternalformativ = 479;
+        glBeginPerfQueryINTEL = 480;
+        glCreatePerfQueryINTEL = 481;
+        glDeletePerfQueryINTEL = 482;
+        glEndPerfQueryINTEL = 483;
+        glGetFirstPerfQueryIdINTEL = 484;
+        glGetNextPerfQueryIdINTEL = 485;
+        glGetPerfCounterInfoINTEL = 486;
+        glGetPerfQueryDataINTEL = 487;
+        glGetPerfQueryIdByNameINTEL = 488;
+        glGetPerfQueryInfoINTEL = 489;
+        glBlendBarrierKHR = 490;
+        glBlendBarrierNV = 491;
+        glBlendParameteriNV = 492;
+        glBlitFramebufferNV = 493;
+        glFenceSyncAPPLE = 494;
+        glIsSyncAPPLE = 495;
+        glDeleteSyncAPPLE = 496;
+        glClientWaitSyncAPPLE = 497;
+        glWaitSyncAPPLE = 498;
+        glGetInteger64vAPPLE = 499;
+        glGetSyncivAPPLE = 500;
+        glCopyBufferSubDataNV = 501;
+        glActiveShaderProgramEXT = 502;
+        glAlphaFuncQCOM = 503;
+        glBeginQueryEXT = 504;
+        glBindProgramPipelineEXT = 505;
+        glBlitFramebufferANGLE = 506;
+        glCreateShaderProgramvEXT = 507;
+        glDeleteProgramPipelinesEXT = 508;
+        glDeleteQueriesEXT = 509;
+        glDrawBuffersNV = 510;
+        glEndQueryEXT = 511;
+        glFramebufferTexture2DMultisampleEXT = 512;
+        glGenProgramPipelinesEXT = 513;
+        glGenQueriesEXT = 514;
+        glGetGraphicsResetStatusEXT = 515;
+        glGetObjectLabelEXT = 516;
+        glGetProgramPipelineInfoLogEXT = 517;
+        glGetProgramPipelineivEXT = 518;
+        glGetQueryObjectuivEXT = 519;
+        glGetQueryivEXT = 520;
+        glGetnUniformfvEXT = 521;
+        glGetnUniformivEXT = 521;
+        glInsertEventMarkerEXT = 522;
+        glIsProgramPipelineEXT = 523;
+        glIsQueryEXT = 524;
+        glLabelObjectEXT = 525;
+        glPopGroupMarkerEXT = 526;
+        glProgramParameteriEXT = 527;
+        glProgramUniform1fEXT = 528;
+        glProgramUniform1fvEXT = 529;
+        glProgramUniform1iEXT = 530;
+        glProgramUniform1ivEXT = 531;
+        glProgramUniform2fEXT = 532;
+        glProgramUniform2fvEXT = 533;
+        glProgramUniform2iEXT = 534;
+        glProgramUniform2ivEXT = 535;
+        glProgramUniform3fEXT = 536;
+        glProgramUniform3fvEXT = 537;
+        glProgramUniform3iEXT = 538;
+        glProgramUniform3ivEXT = 539;
+        glProgramUniform4fEXT = 540;
+        glProgramUniform4fvEXT = 541;
+        glProgramUniform4iEXT = 542;
+        glProgramUniform4ivEXT = 543;
+        glProgramUniformMatrix2fvEXT = 544;
+        glProgramUniformMatrix3fvEXT = 545;
+        glProgramUniformMatrix4fvEXT = 546;
+        glPushGroupMarkerEXT = 547;
+        glReadBufferNV = 548;
+        glReadnPixelsEXT = 549;
+        glRenderbufferStorageMultisampleANGLE = 550;
+        glRenderbufferStorageMultisampleAPPLE = 551;
+        glRenderbufferStorageMultisampleEXT = 552;
+        glResolveMultisampleFramebufferAPPLE = 553;
+        glTexStorage1DEXT = 554;
+        glTexStorage2DEXT = 555;
+        glTexStorage3DEXT = 556;
+        glTextureStorage1DEXT = 557;
+        glTextureStorage2DEXT = 558;
+        glTextureStorage3DEXT = 559;
+        glUseProgramStagesEXT = 560;
+        glValidateProgramPipelineEXT = 561;
+        glCopyTextureLevelsAPPLE = 562;
+        glDebugMessageControlKHR = 563;
+        glDebugMessageInsertKHR = 564;
+        glDebugMessageCallbackKHR = 565;
+        glGetDebugMessageLogKHR = 566;
+        glPushDebugGroupKHR = 567;
+        glPopDebugGroupKHR = 568;
+        glObjectLabelKHR = 569;
+        glGetObjectLabelKHR = 570;
+        glObjectPtrLabelKHR = 571;
+        glGetObjectPtrLabelKHR = 572;
+        glGetPointervKHR = 573;
+        glDrawArraysInstancedANGLE = 574;
+        glDrawElementsInstancedANGLE = 575;
+        glVertexAttribDivisorANGLE = 576;
+        glDrawArraysInstancedEXT = 577;
+        glDrawElementsInstancedEXT = 578;
+        glVertexAttribDivisorEXT = 579;
+        glDrawArraysInstancedNV = 580;
+        glDrawElementsInstancedNV = 581;
+        glVertexAttribDivisorNV = 582;
+        glDrawBuffersEXT = 583;
+        glReadBufferIndexedEXT = 584;
+        glDrawBuffersIndexedEXT = 585;
+        glGetIntegeri_vEXT = 586;
+        glMapBufferRangeEXT = 587;
+        glFlushMappedBufferRangeEXT = 588;
+        glQueryCounterEXT = 589;
+        glGetQueryObjecti64vEXT = 590;
+        glGetQueryObjectivEXT = 591;
+        glGetQueryObjectui64vEXT = 592;
+        glGetTranslatedShaderSourceANGLE = 593;
+        glMinSampleShadingOES = 594;
+        glMultiTexCoord1bOES = 595;
+        glMultiTexCoord1bvOES = 596;
+        glMultiTexCoord2bOES = 597;
+        glMultiTexCoord2bvOES = 598;
+        glMultiTexCoord3bOES = 599;
+        glMultiTexCoord3bvOES = 600;
+        glMultiTexCoord4bOES = 601;
+        glMultiTexCoord4bvOES = 602;
+        glTexCoord1bOES = 603;
+        glTexCoord1bvOES = 604;
+        glTexCoord2bOES = 605;
+        glTexCoord2bvOES = 606;
+        glTexCoord3bOES = 607;
+        glTexCoord3bvOES = 608;
+        glTexCoord4bOES = 609;
+        glTexCoord4bvOES = 610;
+        glVertex2bOES = 611;
+        glVertex2bvOES = 612;
+        glVertex3bOES = 613;
+        glVertex3bvOES = 614;
+        glVertex4bOES = 615;
+        glVertex4bvOES = 616;
+        glProgramUniform1uiEXT = 617;
+        glProgramUniform2uiEXT = 618;
+        glProgramUniform3uiEXT = 619;
+        glProgramUniform4uiEXT = 620;
+        glProgramUniform1uivEXT = 621;
+        glProgramUniform2uivEXT = 622;
+        glProgramUniform3uivEXT = 623;
+        glProgramUniform4uivEXT = 624;
+        glProgramUniformMatrix2x3fvEXT = 625;
+        glProgramUniformMatrix3x2fvEXT = 626;
+        glProgramUniformMatrix2x4fvEXT = 627;
+        glProgramUniformMatrix4x2fvEXT = 628;
+        glProgramUniformMatrix3x4fvEXT = 629;
+        glProgramUniformMatrix4x3fvEXT = 630;
+        glRenderbufferStorageMultisampleNV = 631;
+        glSampleCoverageOES = 632;
+        glTexStorage3DMultisampleOES = 633;
+        glUniformMatrix2x3fvNV = 634;
+        glUniformMatrix3x2fvNV = 635;
+        glUniformMatrix2x4fvNV = 636;
+        glUniformMatrix4x2fvNV = 637;
+        glUniformMatrix3x4fvNV = 638;
+        glUniformMatrix4x3fvNV = 639;
+        glActiveShaderProgram = 640;
+        glBindImageTexture = 641;
+        glBindProgramPipeline = 642;
+        glBindVertexBuffer = 643;
+        glCreateShaderProgramv = 644;
+        glDeleteProgramPipelines = 645;
+        glDispatchCompute = 646;
+        glDispatchComputeIndirect = 647;
+        glDrawArraysIndirect = 648;
+        glDrawElementsIndirect = 649;
+        glFramebufferParameteri = 650;
+        glGenProgramPipelines = 651;
+        glGetBooleani_v = 652;
+        glGetFramebufferParameteriv = 653;
+        glGetMultisamplefv = 654;
+        glGetProgramInterfaceiv = 655;
+        glGetProgramPipelineInfoLog = 656;
+        glGetProgramPipelineiv = 657;
+        glGetProgramResourceIndex = 658;
+        glGetProgramResourceLocation = 659;
+        glGetProgramResourceName = 660;
+        glGetProgramResourceiv = 661;
+        glGetTexLevelParameterfv = 662;
+        glGetTexLevelParameteriv = 663;
+        glIsProgramPipeline = 664;
+        glMemoryBarrier = 665;
+        glMemoryBarrierByRegion = 666;
+        glProgramUniform1f = 667;
+        glProgramUniform1fv = 668;
+        glProgramUniform1i = 669;
+        glProgramUniform1iv = 670;
+        glProgramUniform1ui = 671;
+        glProgramUniform1uiv = 672;
+        glProgramUniform2f = 673;
+        glProgramUniform2fv = 674;
+        glProgramUniform2i = 675;
+        glProgramUniform2iv = 676;
+        glProgramUniform2ui = 677;
+        glProgramUniform2uiv = 678;
+        glProgramUniform3f = 679;
+        glProgramUniform3fv = 680;
+        glProgramUniform3i = 681;
+        glProgramUniform3iv = 682;
+        glProgramUniform3ui = 683;
+        glProgramUniform3uiv = 684;
+        glProgramUniform4f = 685;
+        glProgramUniform4fv = 686;
+        glProgramUniform4i = 687;
+        glProgramUniform4iv = 688;
+        glProgramUniform4ui = 689;
+        glProgramUniform4uiv = 690;
+        glProgramUniformMatrix2fv = 691;
+        glProgramUniformMatrix2x3fv = 692;
+        glProgramUniformMatrix2x4fv = 693;
+        glProgramUniformMatrix3fv = 694;
+        glProgramUniformMatrix3x2fv = 695;
+        glProgramUniformMatrix3x4fv = 696;
+        glProgramUniformMatrix4fv = 697;
+        glProgramUniformMatrix4x2fv = 698;
+        glProgramUniformMatrix4x3fv = 699;
+        glSampleMaski = 700;
+        glTexStorage2DMultisample = 701;
+        glUseProgramStages = 702;
+        glValidateProgramPipeline = 703;
+        glVertexAttribBinding = 704;
+        glVertexAttribFormat = 705;
+        glVertexAttribIFormat = 706;
+        glVertexBindingDivisor = 707;
+        glBlendEquationSeparateiEXT = 708;
+        glBlendEquationiEXT = 709;
+        glBlendFuncSeparateiEXT = 710;
+        glBlendFunciEXT = 711;
+        glColorMaskiEXT = 712;
+        glCopyImageSubDataEXT = 713;
+        glDisableiEXT = 714;
+        glEnableiEXT = 715;
+        glFramebufferTextureEXT = 716;
+        glGetSamplerParameterIivEXT = 717;
+        glGetSamplerParameterIuivEXT = 718;
+        glGetTexParameterIivEXT = 719;
+        glGetTexParameterIuivEXT = 720;
+        glIsEnablediEXT = 721;
+        glPatchParameteriEXT = 722;
+        glPrimitiveBoundingBoxEXT = 723;
+        glSamplerParameterIivEXT = 724;
+        glSamplerParameterIuivEXT = 725;
+        glTexBufferEXT = 726;
+        glTexBufferRangeEXT = 727;
+        glTexParameterIivEXT = 728;
+        glTexParameterIuivEXT = 729;
+        glTextureViewEXT = 730;
+
+        eglGetDisplay = 2000;
+        eglInitialize = 2001;
+        eglTerminate = 2002;
+        eglGetConfigs = 2003;
+        eglChooseConfig = 2004;
+        eglGetConfigAttrib = 2005;
+        eglCreateWindowSurface = 2006;
+        eglCreatePixmapSurface = 2007;
+        eglCreatePbufferSurface = 2008;
+        eglDestroySurface = 2009;
+        eglQuerySurface = 2010;
+        eglCreateContext = 2011;
+        eglDestroyContext = 2012;
+        eglMakeCurrent = 2013;
+        eglGetCurrentContext = 2014;
+        eglGetCurrentSurface = 2015;
+        eglGetCurrentDisplay = 2016;
+        eglQueryContext = 2017;
+        eglWaitGL = 2018;
+        eglWaitNative = 2019;
+        eglSwapBuffers = 2020;
+        eglCopyBuffers = 2021;
+        eglGetError = 2022;
+        eglQueryString = 2023;
+        eglGetProcAddress = 2024;
+        eglSurfaceAttrib = 2025;
+        eglBindTexImage = 2026;
+        eglReleaseTexImage = 2027;
+        eglSwapInterval = 2028;
+        eglBindAPI = 2029;
+        eglQueryAPI = 2030;
+        eglWaitClient = 2031;
+        eglReleaseThread = 2032;
+        eglCreatePbufferFromClientBuffer = 2033;
+        eglLockSurfaceKHR = 2034;
+        eglUnlockSurfaceKHR = 2035;
+        eglCreateImageKHR = 2036;
+        eglDestroyImageKHR = 2037;
+        eglCreateSyncKHR = 2038;
+        eglDestroySyncKHR = 2039;
+        eglClientWaitSyncKHR = 2040;
+        eglGetSyncAttribKHR = 2041;
+        eglSetSwapRectangleANDROID = 2042;
+        eglGetRenderBufferANDROID = 2043;
+        eglGetSystemTimeFrequencyNV = 2044;
+        eglGetSystemTimeNV = 2045;
+
+        invalid = 3000;
+        glVertexAttribPointerData = 3001;
+    }
+
+    // A GL call's return data and arguments are formatted into this DataType
+    message DataType {
+        enum Type {
+            VOID = 1;       // GLvoid
+            CHAR = 2;       // GLchar
+            BYTE = 3;       // GLbyte, GLubyte
+            INT = 4;        // GLbitfield, GLshort, GLint, GLsizei, GLushort, GLuint, GLfixed
+            FLOAT = 5;      // GLfloat, GLclampf
+            BOOL = 6;       // GLboolean
+            ENUM = 7;       // GLenum
+            INT64 = 8;      // GLint64, GLuint64
+        };
+
+        required Type   type = 1 [default = VOID];
+        required bool   isArray = 2 [default = false];
+
+        repeated int32  intValue = 3;
+        repeated float  floatValue = 4;
+        repeated bytes  charValue = 5;
+        repeated bytes  rawBytes = 6;
+        repeated bool   boolValue = 7;
+        repeated int64  int64Value = 8;
+    }
+
+    message FrameBuffer {
+        required int32  width = 1;
+        required int32  height = 2;
+        repeated bytes  contents = 3;
+    }
+
+    required int32      context_id = 1;                     // GL context ID
+    required int64      start_time = 2;                     // time when call was invoked
+    required int32      duration = 3;                       // duration of the call (MONOTONIC TIME)
+
+    required Function   function = 4 [default = invalid];   // GL function called
+    repeated DataType   args = 5;                           // GL function's arguments
+    optional DataType   returnValue = 6;                    // GL function's return value
+
+    optional FrameBuffer fb = 7;                            // contents of the framebuffer
+
+    optional int32      threadtime = 8;                     // duration of the call (THREAD TIME)
+};
diff --git a/opengl/libs/GLES_trace/src/gltrace.pb.cpp b/opengl/libs/GLES_trace/src/gltrace.pb.cpp
new file mode 100644
index 0000000..c0867cd
--- /dev/null
+++ b/opengl/libs/GLES_trace/src/gltrace.pb.cpp
@@ -0,0 +1,2715 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+
+#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
+#include "gltrace.pb.h"
+#include <google/protobuf/stubs/once.h>
+#include <google/protobuf/io/coded_stream.h>
+#include <google/protobuf/wire_format_lite_inl.h>
+// @@protoc_insertion_point(includes)
+
+namespace android {
+namespace gltrace {
+
+void protobuf_ShutdownFile_gltrace_2eproto() {
+  delete GLMessage::default_instance_;
+  delete GLMessage_DataType::default_instance_;
+  delete GLMessage_FrameBuffer::default_instance_;
+}
+
+void protobuf_AddDesc_gltrace_2eproto() {
+  static bool already_here = false;
+  if (already_here) return;
+  already_here = true;
+  GOOGLE_PROTOBUF_VERIFY_VERSION;
+
+  GLMessage::default_instance_ = new GLMessage();
+  GLMessage_DataType::default_instance_ = new GLMessage_DataType();
+  GLMessage_FrameBuffer::default_instance_ = new GLMessage_FrameBuffer();
+  GLMessage::default_instance_->InitAsDefaultInstance();
+  GLMessage_DataType::default_instance_->InitAsDefaultInstance();
+  GLMessage_FrameBuffer::default_instance_->InitAsDefaultInstance();
+  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_gltrace_2eproto);
+}
+
+// Force AddDescriptors() to be called at static initialization time.
+struct StaticDescriptorInitializer_gltrace_2eproto {
+  StaticDescriptorInitializer_gltrace_2eproto() {
+    protobuf_AddDesc_gltrace_2eproto();
+  }
+} static_descriptor_initializer_gltrace_2eproto_;
+
+
+// ===================================================================
+
+bool GLMessage_Function_IsValid(int value) {
+  switch(value) {
+    case 0:
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+    case 8:
+    case 9:
+    case 10:
+    case 11:
+    case 12:
+    case 13:
+    case 14:
+    case 15:
+    case 16:
+    case 17:
+    case 18:
+    case 19:
+    case 20:
+    case 21:
+    case 22:
+    case 23:
+    case 24:
+    case 25:
+    case 26:
+    case 27:
+    case 28:
+    case 29:
+    case 30:
+    case 31:
+    case 32:
+    case 33:
+    case 34:
+    case 35:
+    case 36:
+    case 37:
+    case 38:
+    case 39:
+    case 40:
+    case 41:
+    case 42:
+    case 43:
+    case 44:
+    case 45:
+    case 46:
+    case 47:
+    case 48:
+    case 49:
+    case 50:
+    case 51:
+    case 52:
+    case 53:
+    case 54:
+    case 55:
+    case 56:
+    case 57:
+    case 58:
+    case 59:
+    case 60:
+    case 61:
+    case 62:
+    case 63:
+    case 64:
+    case 65:
+    case 66:
+    case 67:
+    case 68:
+    case 69:
+    case 70:
+    case 71:
+    case 72:
+    case 73:
+    case 74:
+    case 75:
+    case 76:
+    case 77:
+    case 78:
+    case 79:
+    case 80:
+    case 81:
+    case 82:
+    case 83:
+    case 84:
+    case 85:
+    case 86:
+    case 87:
+    case 88:
+    case 89:
+    case 90:
+    case 91:
+    case 92:
+    case 93:
+    case 94:
+    case 95:
+    case 96:
+    case 97:
+    case 98:
+    case 99:
+    case 100:
+    case 101:
+    case 102:
+    case 103:
+    case 104:
+    case 105:
+    case 106:
+    case 107:
+    case 108:
+    case 109:
+    case 110:
+    case 111:
+    case 112:
+    case 113:
+    case 114:
+    case 115:
+    case 116:
+    case 117:
+    case 118:
+    case 119:
+    case 120:
+    case 121:
+    case 122:
+    case 123:
+    case 124:
+    case 125:
+    case 126:
+    case 127:
+    case 128:
+    case 129:
+    case 130:
+    case 131:
+    case 132:
+    case 133:
+    case 134:
+    case 135:
+    case 136:
+    case 137:
+    case 138:
+    case 139:
+    case 140:
+    case 141:
+    case 142:
+    case 143:
+    case 144:
+    case 145:
+    case 146:
+    case 147:
+    case 148:
+    case 149:
+    case 150:
+    case 151:
+    case 152:
+    case 153:
+    case 154:
+    case 155:
+    case 156:
+    case 157:
+    case 158:
+    case 159:
+    case 160:
+    case 161:
+    case 162:
+    case 163:
+    case 164:
+    case 165:
+    case 166:
+    case 167:
+    case 168:
+    case 169:
+    case 170:
+    case 171:
+    case 172:
+    case 173:
+    case 174:
+    case 175:
+    case 176:
+    case 177:
+    case 178:
+    case 179:
+    case 180:
+    case 181:
+    case 182:
+    case 183:
+    case 184:
+    case 185:
+    case 186:
+    case 187:
+    case 188:
+    case 189:
+    case 190:
+    case 191:
+    case 192:
+    case 193:
+    case 194:
+    case 195:
+    case 196:
+    case 197:
+    case 198:
+    case 199:
+    case 200:
+    case 201:
+    case 202:
+    case 203:
+    case 204:
+    case 205:
+    case 206:
+    case 207:
+    case 208:
+    case 209:
+    case 210:
+    case 211:
+    case 212:
+    case 213:
+    case 214:
+    case 215:
+    case 216:
+    case 217:
+    case 218:
+    case 219:
+    case 220:
+    case 221:
+    case 222:
+    case 223:
+    case 224:
+    case 225:
+    case 226:
+    case 227:
+    case 228:
+    case 229:
+    case 230:
+    case 231:
+    case 232:
+    case 233:
+    case 234:
+    case 235:
+    case 236:
+    case 237:
+    case 238:
+    case 239:
+    case 240:
+    case 241:
+    case 242:
+    case 243:
+    case 244:
+    case 245:
+    case 246:
+    case 247:
+    case 248:
+    case 249:
+    case 250:
+    case 251:
+    case 252:
+    case 253:
+    case 254:
+    case 255:
+    case 256:
+    case 257:
+    case 258:
+    case 259:
+    case 260:
+    case 261:
+    case 262:
+    case 263:
+    case 264:
+    case 265:
+    case 266:
+    case 267:
+    case 268:
+    case 269:
+    case 270:
+    case 271:
+    case 272:
+    case 273:
+    case 274:
+    case 275:
+    case 276:
+    case 277:
+    case 278:
+    case 279:
+    case 280:
+    case 281:
+    case 282:
+    case 283:
+    case 284:
+    case 285:
+    case 286:
+    case 287:
+    case 288:
+    case 289:
+    case 290:
+    case 291:
+    case 292:
+    case 293:
+    case 294:
+    case 295:
+    case 296:
+    case 297:
+    case 298:
+    case 299:
+    case 300:
+    case 301:
+    case 302:
+    case 303:
+    case 304:
+    case 305:
+    case 306:
+    case 307:
+    case 308:
+    case 309:
+    case 310:
+    case 311:
+    case 312:
+    case 313:
+    case 314:
+    case 315:
+    case 316:
+    case 317:
+    case 318:
+    case 319:
+    case 320:
+    case 321:
+    case 322:
+    case 323:
+    case 324:
+    case 325:
+    case 326:
+    case 327:
+    case 328:
+    case 329:
+    case 330:
+    case 331:
+    case 332:
+    case 333:
+    case 334:
+    case 335:
+    case 336:
+    case 337:
+    case 338:
+    case 339:
+    case 340:
+    case 341:
+    case 342:
+    case 343:
+    case 344:
+    case 345:
+    case 346:
+    case 347:
+    case 348:
+    case 349:
+    case 350:
+    case 351:
+    case 352:
+    case 353:
+    case 354:
+    case 355:
+    case 356:
+    case 357:
+    case 358:
+    case 359:
+    case 360:
+    case 361:
+    case 362:
+    case 363:
+    case 364:
+    case 365:
+    case 366:
+    case 367:
+    case 368:
+    case 369:
+    case 370:
+    case 371:
+    case 372:
+    case 373:
+    case 374:
+    case 375:
+    case 376:
+    case 377:
+    case 378:
+    case 379:
+    case 380:
+    case 381:
+    case 382:
+    case 383:
+    case 384:
+    case 385:
+    case 386:
+    case 387:
+    case 388:
+    case 389:
+    case 390:
+    case 391:
+    case 392:
+    case 393:
+    case 394:
+    case 395:
+    case 396:
+    case 397:
+    case 398:
+    case 399:
+    case 400:
+    case 401:
+    case 402:
+    case 403:
+    case 404:
+    case 405:
+    case 406:
+    case 407:
+    case 408:
+    case 409:
+    case 410:
+    case 411:
+    case 412:
+    case 413:
+    case 414:
+    case 415:
+    case 416:
+    case 417:
+    case 418:
+    case 419:
+    case 420:
+    case 421:
+    case 422:
+    case 423:
+    case 424:
+    case 425:
+    case 426:
+    case 427:
+    case 428:
+    case 429:
+    case 430:
+    case 431:
+    case 432:
+    case 433:
+    case 434:
+    case 435:
+    case 436:
+    case 437:
+    case 438:
+    case 439:
+    case 440:
+    case 441:
+    case 442:
+    case 443:
+    case 444:
+    case 445:
+    case 446:
+    case 447:
+    case 448:
+    case 449:
+    case 450:
+    case 451:
+    case 452:
+    case 453:
+    case 454:
+    case 455:
+    case 456:
+    case 457:
+    case 458:
+    case 459:
+    case 460:
+    case 461:
+    case 462:
+    case 463:
+    case 464:
+    case 465:
+    case 466:
+    case 467:
+    case 468:
+    case 469:
+    case 470:
+    case 471:
+    case 472:
+    case 473:
+    case 474:
+    case 475:
+    case 476:
+    case 477:
+    case 478:
+    case 479:
+    case 480:
+    case 481:
+    case 482:
+    case 483:
+    case 484:
+    case 485:
+    case 486:
+    case 487:
+    case 488:
+    case 489:
+    case 490:
+    case 491:
+    case 492:
+    case 493:
+    case 494:
+    case 495:
+    case 496:
+    case 497:
+    case 498:
+    case 499:
+    case 500:
+    case 501:
+    case 502:
+    case 503:
+    case 504:
+    case 505:
+    case 506:
+    case 507:
+    case 508:
+    case 509:
+    case 510:
+    case 511:
+    case 512:
+    case 513:
+    case 514:
+    case 515:
+    case 516:
+    case 517:
+    case 518:
+    case 519:
+    case 520:
+    case 521:
+    case 522:
+    case 523:
+    case 524:
+    case 525:
+    case 526:
+    case 527:
+    case 528:
+    case 529:
+    case 530:
+    case 531:
+    case 532:
+    case 533:
+    case 534:
+    case 535:
+    case 536:
+    case 537:
+    case 538:
+    case 539:
+    case 540:
+    case 541:
+    case 542:
+    case 543:
+    case 544:
+    case 545:
+    case 546:
+    case 547:
+    case 548:
+    case 549:
+    case 550:
+    case 551:
+    case 552:
+    case 553:
+    case 554:
+    case 555:
+    case 556:
+    case 557:
+    case 558:
+    case 559:
+    case 560:
+    case 561:
+    case 562:
+    case 563:
+    case 564:
+    case 565:
+    case 566:
+    case 567:
+    case 568:
+    case 569:
+    case 570:
+    case 571:
+    case 572:
+    case 573:
+    case 574:
+    case 575:
+    case 576:
+    case 577:
+    case 578:
+    case 579:
+    case 580:
+    case 581:
+    case 582:
+    case 583:
+    case 584:
+    case 585:
+    case 586:
+    case 587:
+    case 588:
+    case 589:
+    case 590:
+    case 591:
+    case 592:
+    case 593:
+    case 594:
+    case 595:
+    case 596:
+    case 597:
+    case 598:
+    case 599:
+    case 600:
+    case 601:
+    case 602:
+    case 603:
+    case 604:
+    case 605:
+    case 606:
+    case 607:
+    case 608:
+    case 609:
+    case 610:
+    case 611:
+    case 612:
+    case 613:
+    case 614:
+    case 615:
+    case 616:
+    case 617:
+    case 618:
+    case 619:
+    case 620:
+    case 621:
+    case 622:
+    case 623:
+    case 624:
+    case 625:
+    case 626:
+    case 627:
+    case 628:
+    case 629:
+    case 630:
+    case 631:
+    case 632:
+    case 633:
+    case 634:
+    case 635:
+    case 636:
+    case 637:
+    case 638:
+    case 639:
+    case 640:
+    case 641:
+    case 642:
+    case 643:
+    case 644:
+    case 645:
+    case 646:
+    case 647:
+    case 648:
+    case 649:
+    case 650:
+    case 651:
+    case 652:
+    case 653:
+    case 654:
+    case 655:
+    case 656:
+    case 657:
+    case 658:
+    case 659:
+    case 660:
+    case 661:
+    case 662:
+    case 663:
+    case 664:
+    case 665:
+    case 666:
+    case 667:
+    case 668:
+    case 669:
+    case 670:
+    case 671:
+    case 672:
+    case 673:
+    case 674:
+    case 675:
+    case 676:
+    case 677:
+    case 678:
+    case 679:
+    case 680:
+    case 681:
+    case 682:
+    case 683:
+    case 684:
+    case 685:
+    case 686:
+    case 687:
+    case 688:
+    case 689:
+    case 690:
+    case 691:
+    case 692:
+    case 693:
+    case 694:
+    case 695:
+    case 696:
+    case 697:
+    case 698:
+    case 699:
+    case 700:
+    case 701:
+    case 702:
+    case 703:
+    case 704:
+    case 705:
+    case 706:
+    case 707:
+    case 708:
+    case 709:
+    case 710:
+    case 711:
+    case 712:
+    case 713:
+    case 714:
+    case 715:
+    case 716:
+    case 717:
+    case 718:
+    case 719:
+    case 720:
+    case 721:
+    case 722:
+    case 723:
+    case 724:
+    case 725:
+    case 726:
+    case 727:
+    case 728:
+    case 729:
+    case 730:
+    case 2000:
+    case 2001:
+    case 2002:
+    case 2003:
+    case 2004:
+    case 2005:
+    case 2006:
+    case 2007:
+    case 2008:
+    case 2009:
+    case 2010:
+    case 2011:
+    case 2012:
+    case 2013:
+    case 2014:
+    case 2015:
+    case 2016:
+    case 2017:
+    case 2018:
+    case 2019:
+    case 2020:
+    case 2021:
+    case 2022:
+    case 2023:
+    case 2024:
+    case 2025:
+    case 2026:
+    case 2027:
+    case 2028:
+    case 2029:
+    case 2030:
+    case 2031:
+    case 2032:
+    case 2033:
+    case 2034:
+    case 2035:
+    case 2036:
+    case 2037:
+    case 2038:
+    case 2039:
+    case 2040:
+    case 2041:
+    case 2042:
+    case 2043:
+    case 2044:
+    case 2045:
+    case 3000:
+    case 3001:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#ifndef _MSC_VER
+const GLMessage_Function GLMessage::glActiveTexture;
+const GLMessage_Function GLMessage::glAlphaFunc;
+const GLMessage_Function GLMessage::glAlphaFuncx;
+const GLMessage_Function GLMessage::glAlphaFuncxOES;
+const GLMessage_Function GLMessage::glAttachShader;
+const GLMessage_Function GLMessage::glBeginPerfMonitorAMD;
+const GLMessage_Function GLMessage::glBindAttribLocation;
+const GLMessage_Function GLMessage::glBindBuffer;
+const GLMessage_Function GLMessage::glBindFramebuffer;
+const GLMessage_Function GLMessage::glBindFramebufferOES;
+const GLMessage_Function GLMessage::glBindRenderbuffer;
+const GLMessage_Function GLMessage::glBindRenderbufferOES;
+const GLMessage_Function GLMessage::glBindTexture;
+const GLMessage_Function GLMessage::glBindVertexArrayOES;
+const GLMessage_Function GLMessage::glBlendColor;
+const GLMessage_Function GLMessage::glBlendEquation;
+const GLMessage_Function GLMessage::glBlendEquationOES;
+const GLMessage_Function GLMessage::glBlendEquationSeparate;
+const GLMessage_Function GLMessage::glBlendEquationSeparateOES;
+const GLMessage_Function GLMessage::glBlendFunc;
+const GLMessage_Function GLMessage::glBlendFuncSeparate;
+const GLMessage_Function GLMessage::glBlendFuncSeparateOES;
+const GLMessage_Function GLMessage::glBufferData;
+const GLMessage_Function GLMessage::glBufferSubData;
+const GLMessage_Function GLMessage::glCheckFramebufferStatus;
+const GLMessage_Function GLMessage::glCheckFramebufferStatusOES;
+const GLMessage_Function GLMessage::glClearColor;
+const GLMessage_Function GLMessage::glClearColorx;
+const GLMessage_Function GLMessage::glClearColorxOES;
+const GLMessage_Function GLMessage::glClearDepthf;
+const GLMessage_Function GLMessage::glClearDepthfOES;
+const GLMessage_Function GLMessage::glClearDepthx;
+const GLMessage_Function GLMessage::glClearDepthxOES;
+const GLMessage_Function GLMessage::glClear;
+const GLMessage_Function GLMessage::glClearStencil;
+const GLMessage_Function GLMessage::glClientActiveTexture;
+const GLMessage_Function GLMessage::glClipPlanef;
+const GLMessage_Function GLMessage::glClipPlanefIMG;
+const GLMessage_Function GLMessage::glClipPlanefOES;
+const GLMessage_Function GLMessage::glClipPlanex;
+const GLMessage_Function GLMessage::glClipPlanexIMG;
+const GLMessage_Function GLMessage::glClipPlanexOES;
+const GLMessage_Function GLMessage::glColor4f;
+const GLMessage_Function GLMessage::glColor4ub;
+const GLMessage_Function GLMessage::glColor4x;
+const GLMessage_Function GLMessage::glColor4xOES;
+const GLMessage_Function GLMessage::glColorMask;
+const GLMessage_Function GLMessage::glColorPointer;
+const GLMessage_Function GLMessage::glCompileShader;
+const GLMessage_Function GLMessage::glCompressedTexImage2D;
+const GLMessage_Function GLMessage::glCompressedTexImage3DOES;
+const GLMessage_Function GLMessage::glCompressedTexSubImage2D;
+const GLMessage_Function GLMessage::glCompressedTexSubImage3DOES;
+const GLMessage_Function GLMessage::glCopyTexImage2D;
+const GLMessage_Function GLMessage::glCopyTexSubImage2D;
+const GLMessage_Function GLMessage::glCopyTexSubImage3DOES;
+const GLMessage_Function GLMessage::glCoverageMaskNV;
+const GLMessage_Function GLMessage::glCoverageOperationNV;
+const GLMessage_Function GLMessage::glCreateProgram;
+const GLMessage_Function GLMessage::glCreateShader;
+const GLMessage_Function GLMessage::glCullFace;
+const GLMessage_Function GLMessage::glCurrentPaletteMatrixOES;
+const GLMessage_Function GLMessage::glDeleteBuffers;
+const GLMessage_Function GLMessage::glDeleteFencesNV;
+const GLMessage_Function GLMessage::glDeleteFramebuffers;
+const GLMessage_Function GLMessage::glDeleteFramebuffersOES;
+const GLMessage_Function GLMessage::glDeletePerfMonitorsAMD;
+const GLMessage_Function GLMessage::glDeleteProgram;
+const GLMessage_Function GLMessage::glDeleteRenderbuffers;
+const GLMessage_Function GLMessage::glDeleteRenderbuffersOES;
+const GLMessage_Function GLMessage::glDeleteShader;
+const GLMessage_Function GLMessage::glDeleteTextures;
+const GLMessage_Function GLMessage::glDeleteVertexArraysOES;
+const GLMessage_Function GLMessage::glDepthFunc;
+const GLMessage_Function GLMessage::glDepthMask;
+const GLMessage_Function GLMessage::glDepthRangef;
+const GLMessage_Function GLMessage::glDepthRangefOES;
+const GLMessage_Function GLMessage::glDepthRangex;
+const GLMessage_Function GLMessage::glDepthRangexOES;
+const GLMessage_Function GLMessage::glDetachShader;
+const GLMessage_Function GLMessage::glDisableClientState;
+const GLMessage_Function GLMessage::glDisableDriverControlQCOM;
+const GLMessage_Function GLMessage::glDisable;
+const GLMessage_Function GLMessage::glDisableVertexAttribArray;
+const GLMessage_Function GLMessage::glDiscardFramebufferEXT;
+const GLMessage_Function GLMessage::glDrawArrays;
+const GLMessage_Function GLMessage::glDrawElements;
+const GLMessage_Function GLMessage::glDrawTexfOES;
+const GLMessage_Function GLMessage::glDrawTexfvOES;
+const GLMessage_Function GLMessage::glDrawTexiOES;
+const GLMessage_Function GLMessage::glDrawTexivOES;
+const GLMessage_Function GLMessage::glDrawTexsOES;
+const GLMessage_Function GLMessage::glDrawTexsvOES;
+const GLMessage_Function GLMessage::glDrawTexxOES;
+const GLMessage_Function GLMessage::glDrawTexxvOES;
+const GLMessage_Function GLMessage::glEGLImageTargetRenderbufferStorageOES;
+const GLMessage_Function GLMessage::glEGLImageTargetTexture2DOES;
+const GLMessage_Function GLMessage::glEnableClientState;
+const GLMessage_Function GLMessage::glEnableDriverControlQCOM;
+const GLMessage_Function GLMessage::glEnable;
+const GLMessage_Function GLMessage::glEnableVertexAttribArray;
+const GLMessage_Function GLMessage::glEndPerfMonitorAMD;
+const GLMessage_Function GLMessage::glEndTilingQCOM;
+const GLMessage_Function GLMessage::glExtGetBufferPointervQCOM;
+const GLMessage_Function GLMessage::glExtGetBuffersQCOM;
+const GLMessage_Function GLMessage::glExtGetFramebuffersQCOM;
+const GLMessage_Function GLMessage::glExtGetProgramBinarySourceQCOM;
+const GLMessage_Function GLMessage::glExtGetProgramsQCOM;
+const GLMessage_Function GLMessage::glExtGetRenderbuffersQCOM;
+const GLMessage_Function GLMessage::glExtGetShadersQCOM;
+const GLMessage_Function GLMessage::glExtGetTexLevelParameterivQCOM;
+const GLMessage_Function GLMessage::glExtGetTexSubImageQCOM;
+const GLMessage_Function GLMessage::glExtGetTexturesQCOM;
+const GLMessage_Function GLMessage::glExtIsProgramBinaryQCOM;
+const GLMessage_Function GLMessage::glExtTexObjectStateOverrideiQCOM;
+const GLMessage_Function GLMessage::glFinishFenceNV;
+const GLMessage_Function GLMessage::glFinish;
+const GLMessage_Function GLMessage::glFlush;
+const GLMessage_Function GLMessage::glFogf;
+const GLMessage_Function GLMessage::glFogfv;
+const GLMessage_Function GLMessage::glFogx;
+const GLMessage_Function GLMessage::glFogxOES;
+const GLMessage_Function GLMessage::glFogxv;
+const GLMessage_Function GLMessage::glFogxvOES;
+const GLMessage_Function GLMessage::glFramebufferRenderbuffer;
+const GLMessage_Function GLMessage::glFramebufferRenderbufferOES;
+const GLMessage_Function GLMessage::glFramebufferTexture2D;
+const GLMessage_Function GLMessage::glFramebufferTexture2DMultisampleIMG;
+const GLMessage_Function GLMessage::glFramebufferTexture2DOES;
+const GLMessage_Function GLMessage::glFramebufferTexture3DOES;
+const GLMessage_Function GLMessage::glFrontFace;
+const GLMessage_Function GLMessage::glFrustumf;
+const GLMessage_Function GLMessage::glFrustumfOES;
+const GLMessage_Function GLMessage::glFrustumx;
+const GLMessage_Function GLMessage::glFrustumxOES;
+const GLMessage_Function GLMessage::glGenBuffers;
+const GLMessage_Function GLMessage::glGenerateMipmap;
+const GLMessage_Function GLMessage::glGenerateMipmapOES;
+const GLMessage_Function GLMessage::glGenFencesNV;
+const GLMessage_Function GLMessage::glGenFramebuffers;
+const GLMessage_Function GLMessage::glGenFramebuffersOES;
+const GLMessage_Function GLMessage::glGenPerfMonitorsAMD;
+const GLMessage_Function GLMessage::glGenRenderbuffers;
+const GLMessage_Function GLMessage::glGenRenderbuffersOES;
+const GLMessage_Function GLMessage::glGenTextures;
+const GLMessage_Function GLMessage::glGenVertexArraysOES;
+const GLMessage_Function GLMessage::glGetActiveAttrib;
+const GLMessage_Function GLMessage::glGetActiveUniform;
+const GLMessage_Function GLMessage::glGetAttachedShaders;
+const GLMessage_Function GLMessage::glGetAttribLocation;
+const GLMessage_Function GLMessage::glGetBooleanv;
+const GLMessage_Function GLMessage::glGetBufferParameteriv;
+const GLMessage_Function GLMessage::glGetBufferPointervOES;
+const GLMessage_Function GLMessage::glGetClipPlanef;
+const GLMessage_Function GLMessage::glGetClipPlanefOES;
+const GLMessage_Function GLMessage::glGetClipPlanex;
+const GLMessage_Function GLMessage::glGetClipPlanexOES;
+const GLMessage_Function GLMessage::glGetDriverControlsQCOM;
+const GLMessage_Function GLMessage::glGetDriverControlStringQCOM;
+const GLMessage_Function GLMessage::glGetError;
+const GLMessage_Function GLMessage::glGetFenceivNV;
+const GLMessage_Function GLMessage::glGetFixedv;
+const GLMessage_Function GLMessage::glGetFixedvOES;
+const GLMessage_Function GLMessage::glGetFloatv;
+const GLMessage_Function GLMessage::glGetFramebufferAttachmentParameteriv;
+const GLMessage_Function GLMessage::glGetFramebufferAttachmentParameterivOES;
+const GLMessage_Function GLMessage::glGetIntegerv;
+const GLMessage_Function GLMessage::glGetLightfv;
+const GLMessage_Function GLMessage::glGetLightxv;
+const GLMessage_Function GLMessage::glGetLightxvOES;
+const GLMessage_Function GLMessage::glGetMaterialfv;
+const GLMessage_Function GLMessage::glGetMaterialxv;
+const GLMessage_Function GLMessage::glGetMaterialxvOES;
+const GLMessage_Function GLMessage::glGetPerfMonitorCounterDataAMD;
+const GLMessage_Function GLMessage::glGetPerfMonitorCounterInfoAMD;
+const GLMessage_Function GLMessage::glGetPerfMonitorCountersAMD;
+const GLMessage_Function GLMessage::glGetPerfMonitorCounterStringAMD;
+const GLMessage_Function GLMessage::glGetPerfMonitorGroupsAMD;
+const GLMessage_Function GLMessage::glGetPerfMonitorGroupStringAMD;
+const GLMessage_Function GLMessage::glGetPointerv;
+const GLMessage_Function GLMessage::glGetProgramBinaryOES;
+const GLMessage_Function GLMessage::glGetProgramInfoLog;
+const GLMessage_Function GLMessage::glGetProgramiv;
+const GLMessage_Function GLMessage::glGetRenderbufferParameteriv;
+const GLMessage_Function GLMessage::glGetRenderbufferParameterivOES;
+const GLMessage_Function GLMessage::glGetShaderInfoLog;
+const GLMessage_Function GLMessage::glGetShaderiv;
+const GLMessage_Function GLMessage::glGetShaderPrecisionFormat;
+const GLMessage_Function GLMessage::glGetShaderSource;
+const GLMessage_Function GLMessage::glGetString;
+const GLMessage_Function GLMessage::glGetTexEnvfv;
+const GLMessage_Function GLMessage::glGetTexEnviv;
+const GLMessage_Function GLMessage::glGetTexEnvxv;
+const GLMessage_Function GLMessage::glGetTexEnvxvOES;
+const GLMessage_Function GLMessage::glGetTexGenfvOES;
+const GLMessage_Function GLMessage::glGetTexGenivOES;
+const GLMessage_Function GLMessage::glGetTexGenxvOES;
+const GLMessage_Function GLMessage::glGetTexParameterfv;
+const GLMessage_Function GLMessage::glGetTexParameteriv;
+const GLMessage_Function GLMessage::glGetTexParameterxv;
+const GLMessage_Function GLMessage::glGetTexParameterxvOES;
+const GLMessage_Function GLMessage::glGetUniformfv;
+const GLMessage_Function GLMessage::glGetUniformiv;
+const GLMessage_Function GLMessage::glGetUniformLocation;
+const GLMessage_Function GLMessage::glGetVertexAttribfv;
+const GLMessage_Function GLMessage::glGetVertexAttribiv;
+const GLMessage_Function GLMessage::glGetVertexAttribPointerv;
+const GLMessage_Function GLMessage::glHint;
+const GLMessage_Function GLMessage::glIsBuffer;
+const GLMessage_Function GLMessage::glIsEnabled;
+const GLMessage_Function GLMessage::glIsFenceNV;
+const GLMessage_Function GLMessage::glIsFramebuffer;
+const GLMessage_Function GLMessage::glIsFramebufferOES;
+const GLMessage_Function GLMessage::glIsProgram;
+const GLMessage_Function GLMessage::glIsRenderbuffer;
+const GLMessage_Function GLMessage::glIsRenderbufferOES;
+const GLMessage_Function GLMessage::glIsShader;
+const GLMessage_Function GLMessage::glIsTexture;
+const GLMessage_Function GLMessage::glIsVertexArrayOES;
+const GLMessage_Function GLMessage::glLightf;
+const GLMessage_Function GLMessage::glLightfv;
+const GLMessage_Function GLMessage::glLightModelf;
+const GLMessage_Function GLMessage::glLightModelfv;
+const GLMessage_Function GLMessage::glLightModelx;
+const GLMessage_Function GLMessage::glLightModelxOES;
+const GLMessage_Function GLMessage::glLightModelxv;
+const GLMessage_Function GLMessage::glLightModelxvOES;
+const GLMessage_Function GLMessage::glLightx;
+const GLMessage_Function GLMessage::glLightxOES;
+const GLMessage_Function GLMessage::glLightxv;
+const GLMessage_Function GLMessage::glLightxvOES;
+const GLMessage_Function GLMessage::glLineWidth;
+const GLMessage_Function GLMessage::glLineWidthx;
+const GLMessage_Function GLMessage::glLineWidthxOES;
+const GLMessage_Function GLMessage::glLinkProgram;
+const GLMessage_Function GLMessage::glLoadIdentity;
+const GLMessage_Function GLMessage::glLoadMatrixf;
+const GLMessage_Function GLMessage::glLoadMatrixx;
+const GLMessage_Function GLMessage::glLoadMatrixxOES;
+const GLMessage_Function GLMessage::glLoadPaletteFromModelViewMatrixOES;
+const GLMessage_Function GLMessage::glLogicOp;
+const GLMessage_Function GLMessage::glMapBufferOES;
+const GLMessage_Function GLMessage::glMaterialf;
+const GLMessage_Function GLMessage::glMaterialfv;
+const GLMessage_Function GLMessage::glMaterialx;
+const GLMessage_Function GLMessage::glMaterialxOES;
+const GLMessage_Function GLMessage::glMaterialxv;
+const GLMessage_Function GLMessage::glMaterialxvOES;
+const GLMessage_Function GLMessage::glMatrixIndexPointerOES;
+const GLMessage_Function GLMessage::glMatrixMode;
+const GLMessage_Function GLMessage::glMultiDrawArraysEXT;
+const GLMessage_Function GLMessage::glMultiDrawElementsEXT;
+const GLMessage_Function GLMessage::glMultiTexCoord4f;
+const GLMessage_Function GLMessage::glMultiTexCoord4x;
+const GLMessage_Function GLMessage::glMultiTexCoord4xOES;
+const GLMessage_Function GLMessage::glMultMatrixf;
+const GLMessage_Function GLMessage::glMultMatrixx;
+const GLMessage_Function GLMessage::glMultMatrixxOES;
+const GLMessage_Function GLMessage::glNormal3f;
+const GLMessage_Function GLMessage::glNormal3x;
+const GLMessage_Function GLMessage::glNormal3xOES;
+const GLMessage_Function GLMessage::glNormalPointer;
+const GLMessage_Function GLMessage::glOrthof;
+const GLMessage_Function GLMessage::glOrthofOES;
+const GLMessage_Function GLMessage::glOrthox;
+const GLMessage_Function GLMessage::glOrthoxOES;
+const GLMessage_Function GLMessage::glPixelStorei;
+const GLMessage_Function GLMessage::glPointParameterf;
+const GLMessage_Function GLMessage::glPointParameterfv;
+const GLMessage_Function GLMessage::glPointParameterx;
+const GLMessage_Function GLMessage::glPointParameterxOES;
+const GLMessage_Function GLMessage::glPointParameterxv;
+const GLMessage_Function GLMessage::glPointParameterxvOES;
+const GLMessage_Function GLMessage::glPointSize;
+const GLMessage_Function GLMessage::glPointSizePointerOES;
+const GLMessage_Function GLMessage::glPointSizex;
+const GLMessage_Function GLMessage::glPointSizexOES;
+const GLMessage_Function GLMessage::glPolygonOffset;
+const GLMessage_Function GLMessage::glPolygonOffsetx;
+const GLMessage_Function GLMessage::glPolygonOffsetxOES;
+const GLMessage_Function GLMessage::glPopMatrix;
+const GLMessage_Function GLMessage::glProgramBinaryOES;
+const GLMessage_Function GLMessage::glPushMatrix;
+const GLMessage_Function GLMessage::glQueryMatrixxOES;
+const GLMessage_Function GLMessage::glReadPixels;
+const GLMessage_Function GLMessage::glReleaseShaderCompiler;
+const GLMessage_Function GLMessage::glRenderbufferStorage;
+const GLMessage_Function GLMessage::glRenderbufferStorageMultisampleIMG;
+const GLMessage_Function GLMessage::glRenderbufferStorageOES;
+const GLMessage_Function GLMessage::glRotatef;
+const GLMessage_Function GLMessage::glRotatex;
+const GLMessage_Function GLMessage::glRotatexOES;
+const GLMessage_Function GLMessage::glSampleCoverage;
+const GLMessage_Function GLMessage::glSampleCoveragex;
+const GLMessage_Function GLMessage::glSampleCoveragexOES;
+const GLMessage_Function GLMessage::glScalef;
+const GLMessage_Function GLMessage::glScalex;
+const GLMessage_Function GLMessage::glScalexOES;
+const GLMessage_Function GLMessage::glScissor;
+const GLMessage_Function GLMessage::glSelectPerfMonitorCountersAMD;
+const GLMessage_Function GLMessage::glSetFenceNV;
+const GLMessage_Function GLMessage::glShadeModel;
+const GLMessage_Function GLMessage::glShaderBinary;
+const GLMessage_Function GLMessage::glShaderSource;
+const GLMessage_Function GLMessage::glStartTilingQCOM;
+const GLMessage_Function GLMessage::glStencilFunc;
+const GLMessage_Function GLMessage::glStencilFuncSeparate;
+const GLMessage_Function GLMessage::glStencilMask;
+const GLMessage_Function GLMessage::glStencilMaskSeparate;
+const GLMessage_Function GLMessage::glStencilOp;
+const GLMessage_Function GLMessage::glStencilOpSeparate;
+const GLMessage_Function GLMessage::glTestFenceNV;
+const GLMessage_Function GLMessage::glTexCoordPointer;
+const GLMessage_Function GLMessage::glTexEnvf;
+const GLMessage_Function GLMessage::glTexEnvfv;
+const GLMessage_Function GLMessage::glTexEnvi;
+const GLMessage_Function GLMessage::glTexEnviv;
+const GLMessage_Function GLMessage::glTexEnvx;
+const GLMessage_Function GLMessage::glTexEnvxOES;
+const GLMessage_Function GLMessage::glTexEnvxv;
+const GLMessage_Function GLMessage::glTexEnvxvOES;
+const GLMessage_Function GLMessage::glTexGenfOES;
+const GLMessage_Function GLMessage::glTexGenfvOES;
+const GLMessage_Function GLMessage::glTexGeniOES;
+const GLMessage_Function GLMessage::glTexGenivOES;
+const GLMessage_Function GLMessage::glTexGenxOES;
+const GLMessage_Function GLMessage::glTexGenxvOES;
+const GLMessage_Function GLMessage::glTexImage2D;
+const GLMessage_Function GLMessage::glTexImage3DOES;
+const GLMessage_Function GLMessage::glTexParameterf;
+const GLMessage_Function GLMessage::glTexParameterfv;
+const GLMessage_Function GLMessage::glTexParameteri;
+const GLMessage_Function GLMessage::glTexParameteriv;
+const GLMessage_Function GLMessage::glTexParameterx;
+const GLMessage_Function GLMessage::glTexParameterxOES;
+const GLMessage_Function GLMessage::glTexParameterxv;
+const GLMessage_Function GLMessage::glTexParameterxvOES;
+const GLMessage_Function GLMessage::glTexSubImage2D;
+const GLMessage_Function GLMessage::glTexSubImage3DOES;
+const GLMessage_Function GLMessage::glTranslatef;
+const GLMessage_Function GLMessage::glTranslatex;
+const GLMessage_Function GLMessage::glTranslatexOES;
+const GLMessage_Function GLMessage::glUniform1f;
+const GLMessage_Function GLMessage::glUniform1fv;
+const GLMessage_Function GLMessage::glUniform1i;
+const GLMessage_Function GLMessage::glUniform1iv;
+const GLMessage_Function GLMessage::glUniform2f;
+const GLMessage_Function GLMessage::glUniform2fv;
+const GLMessage_Function GLMessage::glUniform2i;
+const GLMessage_Function GLMessage::glUniform2iv;
+const GLMessage_Function GLMessage::glUniform3f;
+const GLMessage_Function GLMessage::glUniform3fv;
+const GLMessage_Function GLMessage::glUniform3i;
+const GLMessage_Function GLMessage::glUniform3iv;
+const GLMessage_Function GLMessage::glUniform4f;
+const GLMessage_Function GLMessage::glUniform4fv;
+const GLMessage_Function GLMessage::glUniform4i;
+const GLMessage_Function GLMessage::glUniform4iv;
+const GLMessage_Function GLMessage::glUniformMatrix2fv;
+const GLMessage_Function GLMessage::glUniformMatrix3fv;
+const GLMessage_Function GLMessage::glUniformMatrix4fv;
+const GLMessage_Function GLMessage::glUnmapBufferOES;
+const GLMessage_Function GLMessage::glUseProgram;
+const GLMessage_Function GLMessage::glValidateProgram;
+const GLMessage_Function GLMessage::glVertexAttrib1f;
+const GLMessage_Function GLMessage::glVertexAttrib1fv;
+const GLMessage_Function GLMessage::glVertexAttrib2f;
+const GLMessage_Function GLMessage::glVertexAttrib2fv;
+const GLMessage_Function GLMessage::glVertexAttrib3f;
+const GLMessage_Function GLMessage::glVertexAttrib3fv;
+const GLMessage_Function GLMessage::glVertexAttrib4f;
+const GLMessage_Function GLMessage::glVertexAttrib4fv;
+const GLMessage_Function GLMessage::glVertexAttribPointer;
+const GLMessage_Function GLMessage::glVertexPointer;
+const GLMessage_Function GLMessage::glViewport;
+const GLMessage_Function GLMessage::glWeightPointerOES;
+const GLMessage_Function GLMessage::glReadBuffer;
+const GLMessage_Function GLMessage::glDrawRangeElements;
+const GLMessage_Function GLMessage::glTexImage3D;
+const GLMessage_Function GLMessage::glTexSubImage3D;
+const GLMessage_Function GLMessage::glCopyTexSubImage3D;
+const GLMessage_Function GLMessage::glCompressedTexImage3D;
+const GLMessage_Function GLMessage::glCompressedTexSubImage3D;
+const GLMessage_Function GLMessage::glGenQueries;
+const GLMessage_Function GLMessage::glDeleteQueries;
+const GLMessage_Function GLMessage::glIsQuery;
+const GLMessage_Function GLMessage::glBeginQuery;
+const GLMessage_Function GLMessage::glEndQuery;
+const GLMessage_Function GLMessage::glGetQueryiv;
+const GLMessage_Function GLMessage::glGetQueryObjectuiv;
+const GLMessage_Function GLMessage::glUnmapBuffer;
+const GLMessage_Function GLMessage::glGetBufferPointerv;
+const GLMessage_Function GLMessage::glDrawBuffers;
+const GLMessage_Function GLMessage::glUniformMatrix2x3fv;
+const GLMessage_Function GLMessage::glUniformMatrix3x2fv;
+const GLMessage_Function GLMessage::glUniformMatrix2x4fv;
+const GLMessage_Function GLMessage::glUniformMatrix4x2fv;
+const GLMessage_Function GLMessage::glUniformMatrix3x4fv;
+const GLMessage_Function GLMessage::glUniformMatrix4x3fv;
+const GLMessage_Function GLMessage::glBlitFramebuffer;
+const GLMessage_Function GLMessage::glRenderbufferStorageMultisample;
+const GLMessage_Function GLMessage::glFramebufferTextureLayer;
+const GLMessage_Function GLMessage::glMapBufferRange;
+const GLMessage_Function GLMessage::glFlushMappedBufferRange;
+const GLMessage_Function GLMessage::glBindVertexArray;
+const GLMessage_Function GLMessage::glDeleteVertexArrays;
+const GLMessage_Function GLMessage::glGenVertexArrays;
+const GLMessage_Function GLMessage::glIsVertexArray;
+const GLMessage_Function GLMessage::glGetIntegeri_v;
+const GLMessage_Function GLMessage::glBeginTransformFeedback;
+const GLMessage_Function GLMessage::glEndTransformFeedback;
+const GLMessage_Function GLMessage::glBindBufferRange;
+const GLMessage_Function GLMessage::glBindBufferBase;
+const GLMessage_Function GLMessage::glTransformFeedbackVaryings;
+const GLMessage_Function GLMessage::glGetTransformFeedbackVarying;
+const GLMessage_Function GLMessage::glVertexAttribIPointer;
+const GLMessage_Function GLMessage::glGetVertexAttribIiv;
+const GLMessage_Function GLMessage::glGetVertexAttribIuiv;
+const GLMessage_Function GLMessage::glVertexAttribI4i;
+const GLMessage_Function GLMessage::glVertexAttribI4ui;
+const GLMessage_Function GLMessage::glVertexAttribI4iv;
+const GLMessage_Function GLMessage::glVertexAttribI4uiv;
+const GLMessage_Function GLMessage::glGetUniformuiv;
+const GLMessage_Function GLMessage::glGetFragDataLocation;
+const GLMessage_Function GLMessage::glUniform1ui;
+const GLMessage_Function GLMessage::glUniform2ui;
+const GLMessage_Function GLMessage::glUniform3ui;
+const GLMessage_Function GLMessage::glUniform4ui;
+const GLMessage_Function GLMessage::glUniform1uiv;
+const GLMessage_Function GLMessage::glUniform2uiv;
+const GLMessage_Function GLMessage::glUniform3uiv;
+const GLMessage_Function GLMessage::glUniform4uiv;
+const GLMessage_Function GLMessage::glClearBufferiv;
+const GLMessage_Function GLMessage::glClearBufferuiv;
+const GLMessage_Function GLMessage::glClearBufferfv;
+const GLMessage_Function GLMessage::glClearBufferfi;
+const GLMessage_Function GLMessage::glGetStringi;
+const GLMessage_Function GLMessage::glCopyBufferSubData;
+const GLMessage_Function GLMessage::glGetUniformIndices;
+const GLMessage_Function GLMessage::glGetActiveUniformsiv;
+const GLMessage_Function GLMessage::glGetUniformBlockIndex;
+const GLMessage_Function GLMessage::glGetActiveUniformBlockiv;
+const GLMessage_Function GLMessage::glGetActiveUniformBlockName;
+const GLMessage_Function GLMessage::glUniformBlockBinding;
+const GLMessage_Function GLMessage::glDrawArraysInstanced;
+const GLMessage_Function GLMessage::glDrawElementsInstanced;
+const GLMessage_Function GLMessage::glFenceSync;
+const GLMessage_Function GLMessage::glIsSync;
+const GLMessage_Function GLMessage::glDeleteSync;
+const GLMessage_Function GLMessage::glClientWaitSync;
+const GLMessage_Function GLMessage::glWaitSync;
+const GLMessage_Function GLMessage::glGetInteger64v;
+const GLMessage_Function GLMessage::glGetSynciv;
+const GLMessage_Function GLMessage::glGetInteger64i_v;
+const GLMessage_Function GLMessage::glGetBufferParameteri64v;
+const GLMessage_Function GLMessage::glGenSamplers;
+const GLMessage_Function GLMessage::glDeleteSamplers;
+const GLMessage_Function GLMessage::glIsSampler;
+const GLMessage_Function GLMessage::glBindSampler;
+const GLMessage_Function GLMessage::glSamplerParameteri;
+const GLMessage_Function GLMessage::glSamplerParameteriv;
+const GLMessage_Function GLMessage::glSamplerParameterf;
+const GLMessage_Function GLMessage::glSamplerParameterfv;
+const GLMessage_Function GLMessage::glGetSamplerParameteriv;
+const GLMessage_Function GLMessage::glGetSamplerParameterfv;
+const GLMessage_Function GLMessage::glVertexAttribDivisor;
+const GLMessage_Function GLMessage::glBindTransformFeedback;
+const GLMessage_Function GLMessage::glDeleteTransformFeedbacks;
+const GLMessage_Function GLMessage::glGenTransformFeedbacks;
+const GLMessage_Function GLMessage::glIsTransformFeedback;
+const GLMessage_Function GLMessage::glPauseTransformFeedback;
+const GLMessage_Function GLMessage::glResumeTransformFeedback;
+const GLMessage_Function GLMessage::glGetProgramBinary;
+const GLMessage_Function GLMessage::glProgramBinary;
+const GLMessage_Function GLMessage::glProgramParameteri;
+const GLMessage_Function GLMessage::glInvalidateFramebuffer;
+const GLMessage_Function GLMessage::glInvalidateSubFramebuffer;
+const GLMessage_Function GLMessage::glTexStorage2D;
+const GLMessage_Function GLMessage::glTexStorage3D;
+const GLMessage_Function GLMessage::glGetInternalformativ;
+const GLMessage_Function GLMessage::glBeginPerfQueryINTEL;
+const GLMessage_Function GLMessage::glCreatePerfQueryINTEL;
+const GLMessage_Function GLMessage::glDeletePerfQueryINTEL;
+const GLMessage_Function GLMessage::glEndPerfQueryINTEL;
+const GLMessage_Function GLMessage::glGetFirstPerfQueryIdINTEL;
+const GLMessage_Function GLMessage::glGetNextPerfQueryIdINTEL;
+const GLMessage_Function GLMessage::glGetPerfCounterInfoINTEL;
+const GLMessage_Function GLMessage::glGetPerfQueryDataINTEL;
+const GLMessage_Function GLMessage::glGetPerfQueryIdByNameINTEL;
+const GLMessage_Function GLMessage::glGetPerfQueryInfoINTEL;
+const GLMessage_Function GLMessage::glBlendBarrierKHR;
+const GLMessage_Function GLMessage::glBlendBarrierNV;
+const GLMessage_Function GLMessage::glBlendParameteriNV;
+const GLMessage_Function GLMessage::glBlitFramebufferNV;
+const GLMessage_Function GLMessage::glFenceSyncAPPLE;
+const GLMessage_Function GLMessage::glIsSyncAPPLE;
+const GLMessage_Function GLMessage::glDeleteSyncAPPLE;
+const GLMessage_Function GLMessage::glClientWaitSyncAPPLE;
+const GLMessage_Function GLMessage::glWaitSyncAPPLE;
+const GLMessage_Function GLMessage::glGetInteger64vAPPLE;
+const GLMessage_Function GLMessage::glGetSyncivAPPLE;
+const GLMessage_Function GLMessage::glCopyBufferSubDataNV;
+const GLMessage_Function GLMessage::glActiveShaderProgramEXT;
+const GLMessage_Function GLMessage::glAlphaFuncQCOM;
+const GLMessage_Function GLMessage::glBeginQueryEXT;
+const GLMessage_Function GLMessage::glBindProgramPipelineEXT;
+const GLMessage_Function GLMessage::glBlitFramebufferANGLE;
+const GLMessage_Function GLMessage::glCreateShaderProgramvEXT;
+const GLMessage_Function GLMessage::glDeleteProgramPipelinesEXT;
+const GLMessage_Function GLMessage::glDeleteQueriesEXT;
+const GLMessage_Function GLMessage::glDrawBuffersNV;
+const GLMessage_Function GLMessage::glEndQueryEXT;
+const GLMessage_Function GLMessage::glFramebufferTexture2DMultisampleEXT;
+const GLMessage_Function GLMessage::glGenProgramPipelinesEXT;
+const GLMessage_Function GLMessage::glGenQueriesEXT;
+const GLMessage_Function GLMessage::glGetGraphicsResetStatusEXT;
+const GLMessage_Function GLMessage::glGetObjectLabelEXT;
+const GLMessage_Function GLMessage::glGetProgramPipelineInfoLogEXT;
+const GLMessage_Function GLMessage::glGetProgramPipelineivEXT;
+const GLMessage_Function GLMessage::glGetQueryObjectuivEXT;
+const GLMessage_Function GLMessage::glGetQueryivEXT;
+const GLMessage_Function GLMessage::glGetnUniformfvEXT;
+const GLMessage_Function GLMessage::glGetnUniformivEXT;
+const GLMessage_Function GLMessage::glInsertEventMarkerEXT;
+const GLMessage_Function GLMessage::glIsProgramPipelineEXT;
+const GLMessage_Function GLMessage::glIsQueryEXT;
+const GLMessage_Function GLMessage::glLabelObjectEXT;
+const GLMessage_Function GLMessage::glPopGroupMarkerEXT;
+const GLMessage_Function GLMessage::glProgramParameteriEXT;
+const GLMessage_Function GLMessage::glProgramUniform1fEXT;
+const GLMessage_Function GLMessage::glProgramUniform1fvEXT;
+const GLMessage_Function GLMessage::glProgramUniform1iEXT;
+const GLMessage_Function GLMessage::glProgramUniform1ivEXT;
+const GLMessage_Function GLMessage::glProgramUniform2fEXT;
+const GLMessage_Function GLMessage::glProgramUniform2fvEXT;
+const GLMessage_Function GLMessage::glProgramUniform2iEXT;
+const GLMessage_Function GLMessage::glProgramUniform2ivEXT;
+const GLMessage_Function GLMessage::glProgramUniform3fEXT;
+const GLMessage_Function GLMessage::glProgramUniform3fvEXT;
+const GLMessage_Function GLMessage::glProgramUniform3iEXT;
+const GLMessage_Function GLMessage::glProgramUniform3ivEXT;
+const GLMessage_Function GLMessage::glProgramUniform4fEXT;
+const GLMessage_Function GLMessage::glProgramUniform4fvEXT;
+const GLMessage_Function GLMessage::glProgramUniform4iEXT;
+const GLMessage_Function GLMessage::glProgramUniform4ivEXT;
+const GLMessage_Function GLMessage::glProgramUniformMatrix2fvEXT;
+const GLMessage_Function GLMessage::glProgramUniformMatrix3fvEXT;
+const GLMessage_Function GLMessage::glProgramUniformMatrix4fvEXT;
+const GLMessage_Function GLMessage::glPushGroupMarkerEXT;
+const GLMessage_Function GLMessage::glReadBufferNV;
+const GLMessage_Function GLMessage::glReadnPixelsEXT;
+const GLMessage_Function GLMessage::glRenderbufferStorageMultisampleANGLE;
+const GLMessage_Function GLMessage::glRenderbufferStorageMultisampleAPPLE;
+const GLMessage_Function GLMessage::glRenderbufferStorageMultisampleEXT;
+const GLMessage_Function GLMessage::glResolveMultisampleFramebufferAPPLE;
+const GLMessage_Function GLMessage::glTexStorage1DEXT;
+const GLMessage_Function GLMessage::glTexStorage2DEXT;
+const GLMessage_Function GLMessage::glTexStorage3DEXT;
+const GLMessage_Function GLMessage::glTextureStorage1DEXT;
+const GLMessage_Function GLMessage::glTextureStorage2DEXT;
+const GLMessage_Function GLMessage::glTextureStorage3DEXT;
+const GLMessage_Function GLMessage::glUseProgramStagesEXT;
+const GLMessage_Function GLMessage::glValidateProgramPipelineEXT;
+const GLMessage_Function GLMessage::glCopyTextureLevelsAPPLE;
+const GLMessage_Function GLMessage::glDebugMessageControlKHR;
+const GLMessage_Function GLMessage::glDebugMessageInsertKHR;
+const GLMessage_Function GLMessage::glDebugMessageCallbackKHR;
+const GLMessage_Function GLMessage::glGetDebugMessageLogKHR;
+const GLMessage_Function GLMessage::glPushDebugGroupKHR;
+const GLMessage_Function GLMessage::glPopDebugGroupKHR;
+const GLMessage_Function GLMessage::glObjectLabelKHR;
+const GLMessage_Function GLMessage::glGetObjectLabelKHR;
+const GLMessage_Function GLMessage::glObjectPtrLabelKHR;
+const GLMessage_Function GLMessage::glGetObjectPtrLabelKHR;
+const GLMessage_Function GLMessage::glGetPointervKHR;
+const GLMessage_Function GLMessage::glDrawArraysInstancedANGLE;
+const GLMessage_Function GLMessage::glDrawElementsInstancedANGLE;
+const GLMessage_Function GLMessage::glVertexAttribDivisorANGLE;
+const GLMessage_Function GLMessage::glDrawArraysInstancedEXT;
+const GLMessage_Function GLMessage::glDrawElementsInstancedEXT;
+const GLMessage_Function GLMessage::glVertexAttribDivisorEXT;
+const GLMessage_Function GLMessage::glDrawArraysInstancedNV;
+const GLMessage_Function GLMessage::glDrawElementsInstancedNV;
+const GLMessage_Function GLMessage::glVertexAttribDivisorNV;
+const GLMessage_Function GLMessage::glDrawBuffersEXT;
+const GLMessage_Function GLMessage::glReadBufferIndexedEXT;
+const GLMessage_Function GLMessage::glDrawBuffersIndexedEXT;
+const GLMessage_Function GLMessage::glGetIntegeri_vEXT;
+const GLMessage_Function GLMessage::glMapBufferRangeEXT;
+const GLMessage_Function GLMessage::glFlushMappedBufferRangeEXT;
+const GLMessage_Function GLMessage::glQueryCounterEXT;
+const GLMessage_Function GLMessage::glGetQueryObjecti64vEXT;
+const GLMessage_Function GLMessage::glGetQueryObjectivEXT;
+const GLMessage_Function GLMessage::glGetQueryObjectui64vEXT;
+const GLMessage_Function GLMessage::glGetTranslatedShaderSourceANGLE;
+const GLMessage_Function GLMessage::glMinSampleShadingOES;
+const GLMessage_Function GLMessage::glMultiTexCoord1bOES;
+const GLMessage_Function GLMessage::glMultiTexCoord1bvOES;
+const GLMessage_Function GLMessage::glMultiTexCoord2bOES;
+const GLMessage_Function GLMessage::glMultiTexCoord2bvOES;
+const GLMessage_Function GLMessage::glMultiTexCoord3bOES;
+const GLMessage_Function GLMessage::glMultiTexCoord3bvOES;
+const GLMessage_Function GLMessage::glMultiTexCoord4bOES;
+const GLMessage_Function GLMessage::glMultiTexCoord4bvOES;
+const GLMessage_Function GLMessage::glTexCoord1bOES;
+const GLMessage_Function GLMessage::glTexCoord1bvOES;
+const GLMessage_Function GLMessage::glTexCoord2bOES;
+const GLMessage_Function GLMessage::glTexCoord2bvOES;
+const GLMessage_Function GLMessage::glTexCoord3bOES;
+const GLMessage_Function GLMessage::glTexCoord3bvOES;
+const GLMessage_Function GLMessage::glTexCoord4bOES;
+const GLMessage_Function GLMessage::glTexCoord4bvOES;
+const GLMessage_Function GLMessage::glVertex2bOES;
+const GLMessage_Function GLMessage::glVertex2bvOES;
+const GLMessage_Function GLMessage::glVertex3bOES;
+const GLMessage_Function GLMessage::glVertex3bvOES;
+const GLMessage_Function GLMessage::glVertex4bOES;
+const GLMessage_Function GLMessage::glVertex4bvOES;
+const GLMessage_Function GLMessage::glProgramUniform1uiEXT;
+const GLMessage_Function GLMessage::glProgramUniform2uiEXT;
+const GLMessage_Function GLMessage::glProgramUniform3uiEXT;
+const GLMessage_Function GLMessage::glProgramUniform4uiEXT;
+const GLMessage_Function GLMessage::glProgramUniform1uivEXT;
+const GLMessage_Function GLMessage::glProgramUniform2uivEXT;
+const GLMessage_Function GLMessage::glProgramUniform3uivEXT;
+const GLMessage_Function GLMessage::glProgramUniform4uivEXT;
+const GLMessage_Function GLMessage::glProgramUniformMatrix2x3fvEXT;
+const GLMessage_Function GLMessage::glProgramUniformMatrix3x2fvEXT;
+const GLMessage_Function GLMessage::glProgramUniformMatrix2x4fvEXT;
+const GLMessage_Function GLMessage::glProgramUniformMatrix4x2fvEXT;
+const GLMessage_Function GLMessage::glProgramUniformMatrix3x4fvEXT;
+const GLMessage_Function GLMessage::glProgramUniformMatrix4x3fvEXT;
+const GLMessage_Function GLMessage::glRenderbufferStorageMultisampleNV;
+const GLMessage_Function GLMessage::glSampleCoverageOES;
+const GLMessage_Function GLMessage::glTexStorage3DMultisampleOES;
+const GLMessage_Function GLMessage::glUniformMatrix2x3fvNV;
+const GLMessage_Function GLMessage::glUniformMatrix3x2fvNV;
+const GLMessage_Function GLMessage::glUniformMatrix2x4fvNV;
+const GLMessage_Function GLMessage::glUniformMatrix4x2fvNV;
+const GLMessage_Function GLMessage::glUniformMatrix3x4fvNV;
+const GLMessage_Function GLMessage::glUniformMatrix4x3fvNV;
+const GLMessage_Function GLMessage::glActiveShaderProgram;
+const GLMessage_Function GLMessage::glBindImageTexture;
+const GLMessage_Function GLMessage::glBindProgramPipeline;
+const GLMessage_Function GLMessage::glBindVertexBuffer;
+const GLMessage_Function GLMessage::glCreateShaderProgramv;
+const GLMessage_Function GLMessage::glDeleteProgramPipelines;
+const GLMessage_Function GLMessage::glDispatchCompute;
+const GLMessage_Function GLMessage::glDispatchComputeIndirect;
+const GLMessage_Function GLMessage::glDrawArraysIndirect;
+const GLMessage_Function GLMessage::glDrawElementsIndirect;
+const GLMessage_Function GLMessage::glFramebufferParameteri;
+const GLMessage_Function GLMessage::glGenProgramPipelines;
+const GLMessage_Function GLMessage::glGetBooleani_v;
+const GLMessage_Function GLMessage::glGetFramebufferParameteriv;
+const GLMessage_Function GLMessage::glGetMultisamplefv;
+const GLMessage_Function GLMessage::glGetProgramInterfaceiv;
+const GLMessage_Function GLMessage::glGetProgramPipelineInfoLog;
+const GLMessage_Function GLMessage::glGetProgramPipelineiv;
+const GLMessage_Function GLMessage::glGetProgramResourceIndex;
+const GLMessage_Function GLMessage::glGetProgramResourceLocation;
+const GLMessage_Function GLMessage::glGetProgramResourceName;
+const GLMessage_Function GLMessage::glGetProgramResourceiv;
+const GLMessage_Function GLMessage::glGetTexLevelParameterfv;
+const GLMessage_Function GLMessage::glGetTexLevelParameteriv;
+const GLMessage_Function GLMessage::glIsProgramPipeline;
+const GLMessage_Function GLMessage::glMemoryBarrier;
+const GLMessage_Function GLMessage::glMemoryBarrierByRegion;
+const GLMessage_Function GLMessage::glProgramUniform1f;
+const GLMessage_Function GLMessage::glProgramUniform1fv;
+const GLMessage_Function GLMessage::glProgramUniform1i;
+const GLMessage_Function GLMessage::glProgramUniform1iv;
+const GLMessage_Function GLMessage::glProgramUniform1ui;
+const GLMessage_Function GLMessage::glProgramUniform1uiv;
+const GLMessage_Function GLMessage::glProgramUniform2f;
+const GLMessage_Function GLMessage::glProgramUniform2fv;
+const GLMessage_Function GLMessage::glProgramUniform2i;
+const GLMessage_Function GLMessage::glProgramUniform2iv;
+const GLMessage_Function GLMessage::glProgramUniform2ui;
+const GLMessage_Function GLMessage::glProgramUniform2uiv;
+const GLMessage_Function GLMessage::glProgramUniform3f;
+const GLMessage_Function GLMessage::glProgramUniform3fv;
+const GLMessage_Function GLMessage::glProgramUniform3i;
+const GLMessage_Function GLMessage::glProgramUniform3iv;
+const GLMessage_Function GLMessage::glProgramUniform3ui;
+const GLMessage_Function GLMessage::glProgramUniform3uiv;
+const GLMessage_Function GLMessage::glProgramUniform4f;
+const GLMessage_Function GLMessage::glProgramUniform4fv;
+const GLMessage_Function GLMessage::glProgramUniform4i;
+const GLMessage_Function GLMessage::glProgramUniform4iv;
+const GLMessage_Function GLMessage::glProgramUniform4ui;
+const GLMessage_Function GLMessage::glProgramUniform4uiv;
+const GLMessage_Function GLMessage::glProgramUniformMatrix2fv;
+const GLMessage_Function GLMessage::glProgramUniformMatrix2x3fv;
+const GLMessage_Function GLMessage::glProgramUniformMatrix2x4fv;
+const GLMessage_Function GLMessage::glProgramUniformMatrix3fv;
+const GLMessage_Function GLMessage::glProgramUniformMatrix3x2fv;
+const GLMessage_Function GLMessage::glProgramUniformMatrix3x4fv;
+const GLMessage_Function GLMessage::glProgramUniformMatrix4fv;
+const GLMessage_Function GLMessage::glProgramUniformMatrix4x2fv;
+const GLMessage_Function GLMessage::glProgramUniformMatrix4x3fv;
+const GLMessage_Function GLMessage::glSampleMaski;
+const GLMessage_Function GLMessage::glTexStorage2DMultisample;
+const GLMessage_Function GLMessage::glUseProgramStages;
+const GLMessage_Function GLMessage::glValidateProgramPipeline;
+const GLMessage_Function GLMessage::glVertexAttribBinding;
+const GLMessage_Function GLMessage::glVertexAttribFormat;
+const GLMessage_Function GLMessage::glVertexAttribIFormat;
+const GLMessage_Function GLMessage::glVertexBindingDivisor;
+const GLMessage_Function GLMessage::glBlendEquationSeparateiEXT;
+const GLMessage_Function GLMessage::glBlendEquationiEXT;
+const GLMessage_Function GLMessage::glBlendFuncSeparateiEXT;
+const GLMessage_Function GLMessage::glBlendFunciEXT;
+const GLMessage_Function GLMessage::glColorMaskiEXT;
+const GLMessage_Function GLMessage::glCopyImageSubDataEXT;
+const GLMessage_Function GLMessage::glDisableiEXT;
+const GLMessage_Function GLMessage::glEnableiEXT;
+const GLMessage_Function GLMessage::glFramebufferTextureEXT;
+const GLMessage_Function GLMessage::glGetSamplerParameterIivEXT;
+const GLMessage_Function GLMessage::glGetSamplerParameterIuivEXT;
+const GLMessage_Function GLMessage::glGetTexParameterIivEXT;
+const GLMessage_Function GLMessage::glGetTexParameterIuivEXT;
+const GLMessage_Function GLMessage::glIsEnablediEXT;
+const GLMessage_Function GLMessage::glPatchParameteriEXT;
+const GLMessage_Function GLMessage::glPrimitiveBoundingBoxEXT;
+const GLMessage_Function GLMessage::glSamplerParameterIivEXT;
+const GLMessage_Function GLMessage::glSamplerParameterIuivEXT;
+const GLMessage_Function GLMessage::glTexBufferEXT;
+const GLMessage_Function GLMessage::glTexBufferRangeEXT;
+const GLMessage_Function GLMessage::glTexParameterIivEXT;
+const GLMessage_Function GLMessage::glTexParameterIuivEXT;
+const GLMessage_Function GLMessage::glTextureViewEXT;
+const GLMessage_Function GLMessage::eglGetDisplay;
+const GLMessage_Function GLMessage::eglInitialize;
+const GLMessage_Function GLMessage::eglTerminate;
+const GLMessage_Function GLMessage::eglGetConfigs;
+const GLMessage_Function GLMessage::eglChooseConfig;
+const GLMessage_Function GLMessage::eglGetConfigAttrib;
+const GLMessage_Function GLMessage::eglCreateWindowSurface;
+const GLMessage_Function GLMessage::eglCreatePixmapSurface;
+const GLMessage_Function GLMessage::eglCreatePbufferSurface;
+const GLMessage_Function GLMessage::eglDestroySurface;
+const GLMessage_Function GLMessage::eglQuerySurface;
+const GLMessage_Function GLMessage::eglCreateContext;
+const GLMessage_Function GLMessage::eglDestroyContext;
+const GLMessage_Function GLMessage::eglMakeCurrent;
+const GLMessage_Function GLMessage::eglGetCurrentContext;
+const GLMessage_Function GLMessage::eglGetCurrentSurface;
+const GLMessage_Function GLMessage::eglGetCurrentDisplay;
+const GLMessage_Function GLMessage::eglQueryContext;
+const GLMessage_Function GLMessage::eglWaitGL;
+const GLMessage_Function GLMessage::eglWaitNative;
+const GLMessage_Function GLMessage::eglSwapBuffers;
+const GLMessage_Function GLMessage::eglCopyBuffers;
+const GLMessage_Function GLMessage::eglGetError;
+const GLMessage_Function GLMessage::eglQueryString;
+const GLMessage_Function GLMessage::eglGetProcAddress;
+const GLMessage_Function GLMessage::eglSurfaceAttrib;
+const GLMessage_Function GLMessage::eglBindTexImage;
+const GLMessage_Function GLMessage::eglReleaseTexImage;
+const GLMessage_Function GLMessage::eglSwapInterval;
+const GLMessage_Function GLMessage::eglBindAPI;
+const GLMessage_Function GLMessage::eglQueryAPI;
+const GLMessage_Function GLMessage::eglWaitClient;
+const GLMessage_Function GLMessage::eglReleaseThread;
+const GLMessage_Function GLMessage::eglCreatePbufferFromClientBuffer;
+const GLMessage_Function GLMessage::eglLockSurfaceKHR;
+const GLMessage_Function GLMessage::eglUnlockSurfaceKHR;
+const GLMessage_Function GLMessage::eglCreateImageKHR;
+const GLMessage_Function GLMessage::eglDestroyImageKHR;
+const GLMessage_Function GLMessage::eglCreateSyncKHR;
+const GLMessage_Function GLMessage::eglDestroySyncKHR;
+const GLMessage_Function GLMessage::eglClientWaitSyncKHR;
+const GLMessage_Function GLMessage::eglGetSyncAttribKHR;
+const GLMessage_Function GLMessage::eglSetSwapRectangleANDROID;
+const GLMessage_Function GLMessage::eglGetRenderBufferANDROID;
+const GLMessage_Function GLMessage::eglGetSystemTimeFrequencyNV;
+const GLMessage_Function GLMessage::eglGetSystemTimeNV;
+const GLMessage_Function GLMessage::invalid;
+const GLMessage_Function GLMessage::glVertexAttribPointerData;
+const GLMessage_Function GLMessage::Function_MIN;
+const GLMessage_Function GLMessage::Function_MAX;
+const int GLMessage::Function_ARRAYSIZE;
+#endif  // _MSC_VER
+bool GLMessage_DataType_Type_IsValid(int value) {
+  switch(value) {
+    case 1:
+    case 2:
+    case 3:
+    case 4:
+    case 5:
+    case 6:
+    case 7:
+    case 8:
+      return true;
+    default:
+      return false;
+  }
+}
+
+#ifndef _MSC_VER
+const GLMessage_DataType_Type GLMessage_DataType::VOID;
+const GLMessage_DataType_Type GLMessage_DataType::CHAR;
+const GLMessage_DataType_Type GLMessage_DataType::BYTE;
+const GLMessage_DataType_Type GLMessage_DataType::INT;
+const GLMessage_DataType_Type GLMessage_DataType::FLOAT;
+const GLMessage_DataType_Type GLMessage_DataType::BOOL;
+const GLMessage_DataType_Type GLMessage_DataType::ENUM;
+const GLMessage_DataType_Type GLMessage_DataType::INT64;
+const GLMessage_DataType_Type GLMessage_DataType::Type_MIN;
+const GLMessage_DataType_Type GLMessage_DataType::Type_MAX;
+const int GLMessage_DataType::Type_ARRAYSIZE;
+#endif  // _MSC_VER
+#ifndef _MSC_VER
+const int GLMessage_DataType::kTypeFieldNumber;
+const int GLMessage_DataType::kIsArrayFieldNumber;
+const int GLMessage_DataType::kIntValueFieldNumber;
+const int GLMessage_DataType::kFloatValueFieldNumber;
+const int GLMessage_DataType::kCharValueFieldNumber;
+const int GLMessage_DataType::kRawBytesFieldNumber;
+const int GLMessage_DataType::kBoolValueFieldNumber;
+const int GLMessage_DataType::kInt64ValueFieldNumber;
+#endif  // !_MSC_VER
+
+GLMessage_DataType::GLMessage_DataType()
+  : ::google::protobuf::MessageLite() {
+  SharedCtor();
+}
+
+void GLMessage_DataType::InitAsDefaultInstance() {
+}
+
+GLMessage_DataType::GLMessage_DataType(const GLMessage_DataType& from)
+  : ::google::protobuf::MessageLite() {
+  SharedCtor();
+  MergeFrom(from);
+}
+
+void GLMessage_DataType::SharedCtor() {
+  _cached_size_ = 0;
+  type_ = 1;
+  isarray_ = false;
+  ::memset(_has_bits_, 0, sizeof(_has_bits_));
+}
+
+GLMessage_DataType::~GLMessage_DataType() {
+  SharedDtor();
+}
+
+void GLMessage_DataType::SharedDtor() {
+  if (this != default_instance_) {
+  }
+}
+
+void GLMessage_DataType::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const GLMessage_DataType& GLMessage_DataType::default_instance() {
+  if (default_instance_ == NULL) protobuf_AddDesc_gltrace_2eproto();  return *default_instance_;
+}
+
+GLMessage_DataType* GLMessage_DataType::default_instance_ = NULL;
+
+GLMessage_DataType* GLMessage_DataType::New() const {
+  return new GLMessage_DataType;
+}
+
+void GLMessage_DataType::Clear() {
+  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
+    type_ = 1;
+    isarray_ = false;
+  }
+  intvalue_.Clear();
+  floatvalue_.Clear();
+  charvalue_.Clear();
+  rawbytes_.Clear();
+  boolvalue_.Clear();
+  int64value_.Clear();
+  ::memset(_has_bits_, 0, sizeof(_has_bits_));
+}
+
+bool GLMessage_DataType::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
+  ::google::protobuf::uint32 tag;
+  while ((tag = input->ReadTag()) != 0) {
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // required .android.gltrace.GLMessage.DataType.Type type = 1 [default = VOID];
+      case 1: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
+          int value;
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
+                 input, &value)));
+          if (::android::gltrace::GLMessage_DataType_Type_IsValid(value)) {
+            set_type(static_cast< ::android::gltrace::GLMessage_DataType_Type >(value));
+          }
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(16)) goto parse_isArray;
+        break;
+      }
+      
+      // required bool isArray = 2 [default = false];
+      case 2: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
+         parse_isArray:
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
+                 input, &isarray_)));
+          _set_bit(1);
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(24)) goto parse_intValue;
+        break;
+      }
+      
+      // repeated int32 intValue = 3;
+      case 3: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
+         parse_intValue:
+          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 1, 24, input, this->mutable_intvalue())));
+        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
+                   == ::google::protobuf::internal::WireFormatLite::
+                      WIRETYPE_LENGTH_DELIMITED) {
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 input, this->mutable_intvalue())));
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(24)) goto parse_intValue;
+        if (input->ExpectTag(37)) goto parse_floatValue;
+        break;
+      }
+      
+      // repeated float floatValue = 4;
+      case 4: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
+         parse_floatValue:
+          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
+                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
+                 1, 37, input, this->mutable_floatvalue())));
+        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
+                   == ::google::protobuf::internal::WireFormatLite::
+                      WIRETYPE_LENGTH_DELIMITED) {
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
+                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
+                 input, this->mutable_floatvalue())));
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(37)) goto parse_floatValue;
+        if (input->ExpectTag(42)) goto parse_charValue;
+        break;
+      }
+      
+      // repeated bytes charValue = 5;
+      case 5: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
+         parse_charValue:
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->add_charvalue()));
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(42)) goto parse_charValue;
+        if (input->ExpectTag(50)) goto parse_rawBytes;
+        break;
+      }
+      
+      // repeated bytes rawBytes = 6;
+      case 6: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
+         parse_rawBytes:
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->add_rawbytes()));
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(50)) goto parse_rawBytes;
+        if (input->ExpectTag(56)) goto parse_boolValue;
+        break;
+      }
+      
+      // repeated bool boolValue = 7;
+      case 7: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
+         parse_boolValue:
+          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
+                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
+                 1, 56, input, this->mutable_boolvalue())));
+        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
+                   == ::google::protobuf::internal::WireFormatLite::
+                      WIRETYPE_LENGTH_DELIMITED) {
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
+                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
+                 input, this->mutable_boolvalue())));
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(56)) goto parse_boolValue;
+        if (input->ExpectTag(64)) goto parse_int64Value;
+        break;
+      }
+      
+      // repeated int64 int64Value = 8;
+      case 8: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
+         parse_int64Value:
+          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
+                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
+                 1, 64, input, this->mutable_int64value())));
+        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
+                   == ::google::protobuf::internal::WireFormatLite::
+                      WIRETYPE_LENGTH_DELIMITED) {
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
+                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
+                 input, this->mutable_int64value())));
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(64)) goto parse_int64Value;
+        if (input->ExpectAtEnd()) return true;
+        break;
+      }
+      
+      default: {
+      handle_uninterpreted:
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          return true;
+        }
+        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
+        break;
+      }
+    }
+  }
+  return true;
+#undef DO_
+}
+
+void GLMessage_DataType::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // required .android.gltrace.GLMessage.DataType.Type type = 1 [default = VOID];
+  if (_has_bit(0)) {
+    ::google::protobuf::internal::WireFormatLite::WriteEnum(
+      1, this->type(), output);
+  }
+  
+  // required bool isArray = 2 [default = false];
+  if (_has_bit(1)) {
+    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->isarray(), output);
+  }
+  
+  // repeated int32 intValue = 3;
+  for (int i = 0; i < this->intvalue_size(); i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt32(
+      3, this->intvalue(i), output);
+  }
+  
+  // repeated float floatValue = 4;
+  for (int i = 0; i < this->floatvalue_size(); i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteFloat(
+      4, this->floatvalue(i), output);
+  }
+  
+  // repeated bytes charValue = 5;
+  for (int i = 0; i < this->charvalue_size(); i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytes(
+      5, this->charvalue(i), output);
+  }
+  
+  // repeated bytes rawBytes = 6;
+  for (int i = 0; i < this->rawbytes_size(); i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytes(
+      6, this->rawbytes(i), output);
+  }
+  
+  // repeated bool boolValue = 7;
+  for (int i = 0; i < this->boolvalue_size(); i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteBool(
+      7, this->boolvalue(i), output);
+  }
+  
+  // repeated int64 int64Value = 8;
+  for (int i = 0; i < this->int64value_size(); i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt64(
+      8, this->int64value(i), output);
+  }
+  
+}
+
+int GLMessage_DataType::ByteSize() const {
+  int total_size = 0;
+  
+  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
+    // required .android.gltrace.GLMessage.DataType.Type type = 1 [default = VOID];
+    if (has_type()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
+    }
+    
+    // required bool isArray = 2 [default = false];
+    if (has_isarray()) {
+      total_size += 1 + 1;
+    }
+    
+  }
+  // repeated int32 intValue = 3;
+  {
+    int data_size = 0;
+    for (int i = 0; i < this->intvalue_size(); i++) {
+      data_size += ::google::protobuf::internal::WireFormatLite::
+        Int32Size(this->intvalue(i));
+    }
+    total_size += 1 * this->intvalue_size() + data_size;
+  }
+  
+  // repeated float floatValue = 4;
+  {
+    int data_size = 0;
+    data_size = 4 * this->floatvalue_size();
+    total_size += 1 * this->floatvalue_size() + data_size;
+  }
+  
+  // repeated bytes charValue = 5;
+  total_size += 1 * this->charvalue_size();
+  for (int i = 0; i < this->charvalue_size(); i++) {
+    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
+      this->charvalue(i));
+  }
+  
+  // repeated bytes rawBytes = 6;
+  total_size += 1 * this->rawbytes_size();
+  for (int i = 0; i < this->rawbytes_size(); i++) {
+    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
+      this->rawbytes(i));
+  }
+  
+  // repeated bool boolValue = 7;
+  {
+    int data_size = 0;
+    data_size = 1 * this->boolvalue_size();
+    total_size += 1 * this->boolvalue_size() + data_size;
+  }
+  
+  // repeated int64 int64Value = 8;
+  {
+    int data_size = 0;
+    for (int i = 0; i < this->int64value_size(); i++) {
+      data_size += ::google::protobuf::internal::WireFormatLite::
+        Int64Size(this->int64value(i));
+    }
+    total_size += 1 * this->int64value_size() + data_size;
+  }
+  
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = total_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void GLMessage_DataType::CheckTypeAndMergeFrom(
+    const ::google::protobuf::MessageLite& from) {
+  MergeFrom(*::google::protobuf::down_cast<const GLMessage_DataType*>(&from));
+}
+
+void GLMessage_DataType::MergeFrom(const GLMessage_DataType& from) {
+  GOOGLE_CHECK_NE(&from, this);
+  intvalue_.MergeFrom(from.intvalue_);
+  floatvalue_.MergeFrom(from.floatvalue_);
+  charvalue_.MergeFrom(from.charvalue_);
+  rawbytes_.MergeFrom(from.rawbytes_);
+  boolvalue_.MergeFrom(from.boolvalue_);
+  int64value_.MergeFrom(from.int64value_);
+  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
+    if (from._has_bit(0)) {
+      set_type(from.type());
+    }
+    if (from._has_bit(1)) {
+      set_isarray(from.isarray());
+    }
+  }
+}
+
+void GLMessage_DataType::CopyFrom(const GLMessage_DataType& from) {
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool GLMessage_DataType::IsInitialized() const {
+  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
+  
+  return true;
+}
+
+void GLMessage_DataType::Swap(GLMessage_DataType* other) {
+  if (other != this) {
+    std::swap(type_, other->type_);
+    std::swap(isarray_, other->isarray_);
+    intvalue_.Swap(&other->intvalue_);
+    floatvalue_.Swap(&other->floatvalue_);
+    charvalue_.Swap(&other->charvalue_);
+    rawbytes_.Swap(&other->rawbytes_);
+    boolvalue_.Swap(&other->boolvalue_);
+    int64value_.Swap(&other->int64value_);
+    std::swap(_has_bits_[0], other->_has_bits_[0]);
+    std::swap(_cached_size_, other->_cached_size_);
+  }
+}
+
+::std::string GLMessage_DataType::GetTypeName() const {
+  return "android.gltrace.GLMessage.DataType";
+}
+
+
+// -------------------------------------------------------------------
+
+#ifndef _MSC_VER
+const int GLMessage_FrameBuffer::kWidthFieldNumber;
+const int GLMessage_FrameBuffer::kHeightFieldNumber;
+const int GLMessage_FrameBuffer::kContentsFieldNumber;
+#endif  // !_MSC_VER
+
+GLMessage_FrameBuffer::GLMessage_FrameBuffer()
+  : ::google::protobuf::MessageLite() {
+  SharedCtor();
+}
+
+void GLMessage_FrameBuffer::InitAsDefaultInstance() {
+}
+
+GLMessage_FrameBuffer::GLMessage_FrameBuffer(const GLMessage_FrameBuffer& from)
+  : ::google::protobuf::MessageLite() {
+  SharedCtor();
+  MergeFrom(from);
+}
+
+void GLMessage_FrameBuffer::SharedCtor() {
+  _cached_size_ = 0;
+  width_ = 0;
+  height_ = 0;
+  ::memset(_has_bits_, 0, sizeof(_has_bits_));
+}
+
+GLMessage_FrameBuffer::~GLMessage_FrameBuffer() {
+  SharedDtor();
+}
+
+void GLMessage_FrameBuffer::SharedDtor() {
+  if (this != default_instance_) {
+  }
+}
+
+void GLMessage_FrameBuffer::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const GLMessage_FrameBuffer& GLMessage_FrameBuffer::default_instance() {
+  if (default_instance_ == NULL) protobuf_AddDesc_gltrace_2eproto();  return *default_instance_;
+}
+
+GLMessage_FrameBuffer* GLMessage_FrameBuffer::default_instance_ = NULL;
+
+GLMessage_FrameBuffer* GLMessage_FrameBuffer::New() const {
+  return new GLMessage_FrameBuffer;
+}
+
+void GLMessage_FrameBuffer::Clear() {
+  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
+    width_ = 0;
+    height_ = 0;
+  }
+  contents_.Clear();
+  ::memset(_has_bits_, 0, sizeof(_has_bits_));
+}
+
+bool GLMessage_FrameBuffer::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
+  ::google::protobuf::uint32 tag;
+  while ((tag = input->ReadTag()) != 0) {
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // required int32 width = 1;
+      case 1: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 input, &width_)));
+          _set_bit(0);
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(16)) goto parse_height;
+        break;
+      }
+      
+      // required int32 height = 2;
+      case 2: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
+         parse_height:
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 input, &height_)));
+          _set_bit(1);
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(26)) goto parse_contents;
+        break;
+      }
+      
+      // repeated bytes contents = 3;
+      case 3: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
+         parse_contents:
+          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
+                input, this->add_contents()));
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(26)) goto parse_contents;
+        if (input->ExpectAtEnd()) return true;
+        break;
+      }
+      
+      default: {
+      handle_uninterpreted:
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          return true;
+        }
+        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
+        break;
+      }
+    }
+  }
+  return true;
+#undef DO_
+}
+
+void GLMessage_FrameBuffer::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // required int32 width = 1;
+  if (_has_bit(0)) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->width(), output);
+  }
+  
+  // required int32 height = 2;
+  if (_has_bit(1)) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->height(), output);
+  }
+  
+  // repeated bytes contents = 3;
+  for (int i = 0; i < this->contents_size(); i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteBytes(
+      3, this->contents(i), output);
+  }
+  
+}
+
+int GLMessage_FrameBuffer::ByteSize() const {
+  int total_size = 0;
+  
+  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
+    // required int32 width = 1;
+    if (has_width()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::Int32Size(
+          this->width());
+    }
+    
+    // required int32 height = 2;
+    if (has_height()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::Int32Size(
+          this->height());
+    }
+    
+  }
+  // repeated bytes contents = 3;
+  total_size += 1 * this->contents_size();
+  for (int i = 0; i < this->contents_size(); i++) {
+    total_size += ::google::protobuf::internal::WireFormatLite::BytesSize(
+      this->contents(i));
+  }
+  
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = total_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void GLMessage_FrameBuffer::CheckTypeAndMergeFrom(
+    const ::google::protobuf::MessageLite& from) {
+  MergeFrom(*::google::protobuf::down_cast<const GLMessage_FrameBuffer*>(&from));
+}
+
+void GLMessage_FrameBuffer::MergeFrom(const GLMessage_FrameBuffer& from) {
+  GOOGLE_CHECK_NE(&from, this);
+  contents_.MergeFrom(from.contents_);
+  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
+    if (from._has_bit(0)) {
+      set_width(from.width());
+    }
+    if (from._has_bit(1)) {
+      set_height(from.height());
+    }
+  }
+}
+
+void GLMessage_FrameBuffer::CopyFrom(const GLMessage_FrameBuffer& from) {
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool GLMessage_FrameBuffer::IsInitialized() const {
+  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
+  
+  return true;
+}
+
+void GLMessage_FrameBuffer::Swap(GLMessage_FrameBuffer* other) {
+  if (other != this) {
+    std::swap(width_, other->width_);
+    std::swap(height_, other->height_);
+    contents_.Swap(&other->contents_);
+    std::swap(_has_bits_[0], other->_has_bits_[0]);
+    std::swap(_cached_size_, other->_cached_size_);
+  }
+}
+
+::std::string GLMessage_FrameBuffer::GetTypeName() const {
+  return "android.gltrace.GLMessage.FrameBuffer";
+}
+
+
+// -------------------------------------------------------------------
+
+#ifndef _MSC_VER
+const int GLMessage::kContextIdFieldNumber;
+const int GLMessage::kStartTimeFieldNumber;
+const int GLMessage::kDurationFieldNumber;
+const int GLMessage::kFunctionFieldNumber;
+const int GLMessage::kArgsFieldNumber;
+const int GLMessage::kReturnValueFieldNumber;
+const int GLMessage::kFbFieldNumber;
+const int GLMessage::kThreadtimeFieldNumber;
+#endif  // !_MSC_VER
+
+GLMessage::GLMessage()
+  : ::google::protobuf::MessageLite() {
+  SharedCtor();
+}
+
+void GLMessage::InitAsDefaultInstance() {
+  returnvalue_ = const_cast< ::android::gltrace::GLMessage_DataType*>(&::android::gltrace::GLMessage_DataType::default_instance());
+  fb_ = const_cast< ::android::gltrace::GLMessage_FrameBuffer*>(&::android::gltrace::GLMessage_FrameBuffer::default_instance());
+}
+
+GLMessage::GLMessage(const GLMessage& from)
+  : ::google::protobuf::MessageLite() {
+  SharedCtor();
+  MergeFrom(from);
+}
+
+void GLMessage::SharedCtor() {
+  _cached_size_ = 0;
+  context_id_ = 0;
+  start_time_ = GOOGLE_LONGLONG(0);
+  duration_ = 0;
+  function_ = 3000;
+  returnvalue_ = NULL;
+  fb_ = NULL;
+  threadtime_ = 0;
+  ::memset(_has_bits_, 0, sizeof(_has_bits_));
+}
+
+GLMessage::~GLMessage() {
+  SharedDtor();
+}
+
+void GLMessage::SharedDtor() {
+  if (this != default_instance_) {
+    delete returnvalue_;
+    delete fb_;
+  }
+}
+
+void GLMessage::SetCachedSize(int size) const {
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+}
+const GLMessage& GLMessage::default_instance() {
+  if (default_instance_ == NULL) protobuf_AddDesc_gltrace_2eproto();  return *default_instance_;
+}
+
+GLMessage* GLMessage::default_instance_ = NULL;
+
+GLMessage* GLMessage::New() const {
+  return new GLMessage;
+}
+
+void GLMessage::Clear() {
+  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
+    context_id_ = 0;
+    start_time_ = GOOGLE_LONGLONG(0);
+    duration_ = 0;
+    function_ = 3000;
+    if (_has_bit(5)) {
+      if (returnvalue_ != NULL) returnvalue_->::android::gltrace::GLMessage_DataType::Clear();
+    }
+    if (_has_bit(6)) {
+      if (fb_ != NULL) fb_->::android::gltrace::GLMessage_FrameBuffer::Clear();
+    }
+    threadtime_ = 0;
+  }
+  args_.Clear();
+  ::memset(_has_bits_, 0, sizeof(_has_bits_));
+}
+
+bool GLMessage::MergePartialFromCodedStream(
+    ::google::protobuf::io::CodedInputStream* input) {
+#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
+  ::google::protobuf::uint32 tag;
+  while ((tag = input->ReadTag()) != 0) {
+    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
+      // required int32 context_id = 1;
+      case 1: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 input, &context_id_)));
+          _set_bit(0);
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(16)) goto parse_start_time;
+        break;
+      }
+      
+      // required int64 start_time = 2;
+      case 2: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
+         parse_start_time:
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
+                 input, &start_time_)));
+          _set_bit(1);
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(24)) goto parse_duration;
+        break;
+      }
+      
+      // required int32 duration = 3;
+      case 3: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
+         parse_duration:
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 input, &duration_)));
+          _set_bit(2);
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(32)) goto parse_function;
+        break;
+      }
+      
+      // required .android.gltrace.GLMessage.Function function = 4 [default = invalid];
+      case 4: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
+         parse_function:
+          int value;
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
+                 input, &value)));
+          if (::android::gltrace::GLMessage_Function_IsValid(value)) {
+            set_function(static_cast< ::android::gltrace::GLMessage_Function >(value));
+          }
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(42)) goto parse_args;
+        break;
+      }
+      
+      // repeated .android.gltrace.GLMessage.DataType args = 5;
+      case 5: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
+         parse_args:
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+                input, add_args()));
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(42)) goto parse_args;
+        if (input->ExpectTag(50)) goto parse_returnValue;
+        break;
+      }
+      
+      // optional .android.gltrace.GLMessage.DataType returnValue = 6;
+      case 6: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
+         parse_returnValue:
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_returnvalue()));
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(58)) goto parse_fb;
+        break;
+      }
+      
+      // optional .android.gltrace.GLMessage.FrameBuffer fb = 7;
+      case 7: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
+         parse_fb:
+          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
+               input, mutable_fb()));
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectTag(64)) goto parse_threadtime;
+        break;
+      }
+      
+      // optional int32 threadtime = 8;
+      case 8: {
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
+         parse_threadtime:
+          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
+                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
+                 input, &threadtime_)));
+          _set_bit(7);
+        } else {
+          goto handle_uninterpreted;
+        }
+        if (input->ExpectAtEnd()) return true;
+        break;
+      }
+      
+      default: {
+      handle_uninterpreted:
+        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
+            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
+          return true;
+        }
+        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
+        break;
+      }
+    }
+  }
+  return true;
+#undef DO_
+}
+
+void GLMessage::SerializeWithCachedSizes(
+    ::google::protobuf::io::CodedOutputStream* output) const {
+  // required int32 context_id = 1;
+  if (_has_bit(0)) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->context_id(), output);
+  }
+  
+  // required int64 start_time = 2;
+  if (_has_bit(1)) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->start_time(), output);
+  }
+  
+  // required int32 duration = 3;
+  if (_has_bit(2)) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->duration(), output);
+  }
+  
+  // required .android.gltrace.GLMessage.Function function = 4 [default = invalid];
+  if (_has_bit(3)) {
+    ::google::protobuf::internal::WireFormatLite::WriteEnum(
+      4, this->function(), output);
+  }
+  
+  // repeated .android.gltrace.GLMessage.DataType args = 5;
+  for (int i = 0; i < this->args_size(); i++) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessage(
+      5, this->args(i), output);
+  }
+  
+  // optional .android.gltrace.GLMessage.DataType returnValue = 6;
+  if (_has_bit(5)) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessage(
+      6, this->returnvalue(), output);
+  }
+  
+  // optional .android.gltrace.GLMessage.FrameBuffer fb = 7;
+  if (_has_bit(6)) {
+    ::google::protobuf::internal::WireFormatLite::WriteMessage(
+      7, this->fb(), output);
+  }
+  
+  // optional int32 threadtime = 8;
+  if (_has_bit(7)) {
+    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->threadtime(), output);
+  }
+  
+}
+
+int GLMessage::ByteSize() const {
+  int total_size = 0;
+  
+  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
+    // required int32 context_id = 1;
+    if (has_context_id()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::Int32Size(
+          this->context_id());
+    }
+    
+    // required int64 start_time = 2;
+    if (has_start_time()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::Int64Size(
+          this->start_time());
+    }
+    
+    // required int32 duration = 3;
+    if (has_duration()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::Int32Size(
+          this->duration());
+    }
+    
+    // required .android.gltrace.GLMessage.Function function = 4 [default = invalid];
+    if (has_function()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::EnumSize(this->function());
+    }
+    
+    // optional .android.gltrace.GLMessage.DataType returnValue = 6;
+    if (has_returnvalue()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          this->returnvalue());
+    }
+    
+    // optional .android.gltrace.GLMessage.FrameBuffer fb = 7;
+    if (has_fb()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+          this->fb());
+    }
+    
+    // optional int32 threadtime = 8;
+    if (has_threadtime()) {
+      total_size += 1 +
+        ::google::protobuf::internal::WireFormatLite::Int32Size(
+          this->threadtime());
+    }
+    
+  }
+  // repeated .android.gltrace.GLMessage.DataType args = 5;
+  total_size += 1 * this->args_size();
+  for (int i = 0; i < this->args_size(); i++) {
+    total_size +=
+      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
+        this->args(i));
+  }
+  
+  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
+  _cached_size_ = total_size;
+  GOOGLE_SAFE_CONCURRENT_WRITES_END();
+  return total_size;
+}
+
+void GLMessage::CheckTypeAndMergeFrom(
+    const ::google::protobuf::MessageLite& from) {
+  MergeFrom(*::google::protobuf::down_cast<const GLMessage*>(&from));
+}
+
+void GLMessage::MergeFrom(const GLMessage& from) {
+  GOOGLE_CHECK_NE(&from, this);
+  args_.MergeFrom(from.args_);
+  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
+    if (from._has_bit(0)) {
+      set_context_id(from.context_id());
+    }
+    if (from._has_bit(1)) {
+      set_start_time(from.start_time());
+    }
+    if (from._has_bit(2)) {
+      set_duration(from.duration());
+    }
+    if (from._has_bit(3)) {
+      set_function(from.function());
+    }
+    if (from._has_bit(5)) {
+      mutable_returnvalue()->::android::gltrace::GLMessage_DataType::MergeFrom(from.returnvalue());
+    }
+    if (from._has_bit(6)) {
+      mutable_fb()->::android::gltrace::GLMessage_FrameBuffer::MergeFrom(from.fb());
+    }
+    if (from._has_bit(7)) {
+      set_threadtime(from.threadtime());
+    }
+  }
+}
+
+void GLMessage::CopyFrom(const GLMessage& from) {
+  if (&from == this) return;
+  Clear();
+  MergeFrom(from);
+}
+
+bool GLMessage::IsInitialized() const {
+  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;
+  
+  for (int i = 0; i < args_size(); i++) {
+    if (!this->args(i).IsInitialized()) return false;
+  }
+  if (has_returnvalue()) {
+    if (!this->returnvalue().IsInitialized()) return false;
+  }
+  if (has_fb()) {
+    if (!this->fb().IsInitialized()) return false;
+  }
+  return true;
+}
+
+void GLMessage::Swap(GLMessage* other) {
+  if (other != this) {
+    std::swap(context_id_, other->context_id_);
+    std::swap(start_time_, other->start_time_);
+    std::swap(duration_, other->duration_);
+    std::swap(function_, other->function_);
+    args_.Swap(&other->args_);
+    std::swap(returnvalue_, other->returnvalue_);
+    std::swap(fb_, other->fb_);
+    std::swap(threadtime_, other->threadtime_);
+    std::swap(_has_bits_[0], other->_has_bits_[0]);
+    std::swap(_cached_size_, other->_cached_size_);
+  }
+}
+
+::std::string GLMessage::GetTypeName() const {
+  return "android.gltrace.GLMessage";
+}
+
+
+// @@protoc_insertion_point(namespace_scope)
+
+}  // namespace gltrace
+}  // namespace android
+
+// @@protoc_insertion_point(global_scope)
diff --git a/opengl/libs/GLES_trace/src/gltrace.pb.h b/opengl/libs/GLES_trace/src/gltrace.pb.h
new file mode 100644
index 0000000..9bc7c58
--- /dev/null
+++ b/opengl/libs/GLES_trace/src/gltrace.pb.h
@@ -0,0 +1,2525 @@
+// Generated by the protocol buffer compiler.  DO NOT EDIT!
+// source: gltrace.proto
+
+#ifndef PROTOBUF_gltrace_2eproto__INCLUDED
+#define PROTOBUF_gltrace_2eproto__INCLUDED
+
+#include <string>
+
+#include <google/protobuf/stubs/common.h>
+
+#if GOOGLE_PROTOBUF_VERSION < 2003000
+#error This file was generated by a newer version of protoc which is
+#error incompatible with your Protocol Buffer headers.  Please update
+#error your headers.
+#endif
+#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
+#error This file was generated by an older version of protoc which is
+#error incompatible with your Protocol Buffer headers.  Please
+#error regenerate this file with a newer version of protoc.
+#endif
+
+#include <google/protobuf/generated_message_util.h>
+#include <google/protobuf/repeated_field.h>
+#include <google/protobuf/extension_set.h>
+// @@protoc_insertion_point(includes)
+
+namespace android {
+namespace gltrace {
+
+// Internal implementation detail -- do not call these.
+void  protobuf_AddDesc_gltrace_2eproto();
+void protobuf_AssignDesc_gltrace_2eproto();
+void protobuf_ShutdownFile_gltrace_2eproto();
+
+class GLMessage;
+class GLMessage_DataType;
+class GLMessage_FrameBuffer;
+
+enum GLMessage_DataType_Type {
+  GLMessage_DataType_Type_VOID = 1,
+  GLMessage_DataType_Type_CHAR = 2,
+  GLMessage_DataType_Type_BYTE = 3,
+  GLMessage_DataType_Type_INT = 4,
+  GLMessage_DataType_Type_FLOAT = 5,
+  GLMessage_DataType_Type_BOOL = 6,
+  GLMessage_DataType_Type_ENUM = 7,
+  GLMessage_DataType_Type_INT64 = 8
+};
+bool GLMessage_DataType_Type_IsValid(int value);
+const GLMessage_DataType_Type GLMessage_DataType_Type_Type_MIN = GLMessage_DataType_Type_VOID;
+const GLMessage_DataType_Type GLMessage_DataType_Type_Type_MAX = GLMessage_DataType_Type_INT64;
+const int GLMessage_DataType_Type_Type_ARRAYSIZE = GLMessage_DataType_Type_Type_MAX + 1;
+
+enum GLMessage_Function {
+  GLMessage_Function_glActiveTexture = 0,
+  GLMessage_Function_glAlphaFunc = 1,
+  GLMessage_Function_glAlphaFuncx = 2,
+  GLMessage_Function_glAlphaFuncxOES = 3,
+  GLMessage_Function_glAttachShader = 4,
+  GLMessage_Function_glBeginPerfMonitorAMD = 5,
+  GLMessage_Function_glBindAttribLocation = 6,
+  GLMessage_Function_glBindBuffer = 7,
+  GLMessage_Function_glBindFramebuffer = 8,
+  GLMessage_Function_glBindFramebufferOES = 9,
+  GLMessage_Function_glBindRenderbuffer = 10,
+  GLMessage_Function_glBindRenderbufferOES = 11,
+  GLMessage_Function_glBindTexture = 12,
+  GLMessage_Function_glBindVertexArrayOES = 13,
+  GLMessage_Function_glBlendColor = 14,
+  GLMessage_Function_glBlendEquation = 15,
+  GLMessage_Function_glBlendEquationOES = 16,
+  GLMessage_Function_glBlendEquationSeparate = 17,
+  GLMessage_Function_glBlendEquationSeparateOES = 18,
+  GLMessage_Function_glBlendFunc = 19,
+  GLMessage_Function_glBlendFuncSeparate = 20,
+  GLMessage_Function_glBlendFuncSeparateOES = 21,
+  GLMessage_Function_glBufferData = 22,
+  GLMessage_Function_glBufferSubData = 23,
+  GLMessage_Function_glCheckFramebufferStatus = 24,
+  GLMessage_Function_glCheckFramebufferStatusOES = 25,
+  GLMessage_Function_glClearColor = 26,
+  GLMessage_Function_glClearColorx = 27,
+  GLMessage_Function_glClearColorxOES = 28,
+  GLMessage_Function_glClearDepthf = 29,
+  GLMessage_Function_glClearDepthfOES = 30,
+  GLMessage_Function_glClearDepthx = 31,
+  GLMessage_Function_glClearDepthxOES = 32,
+  GLMessage_Function_glClear = 33,
+  GLMessage_Function_glClearStencil = 34,
+  GLMessage_Function_glClientActiveTexture = 35,
+  GLMessage_Function_glClipPlanef = 36,
+  GLMessage_Function_glClipPlanefIMG = 37,
+  GLMessage_Function_glClipPlanefOES = 38,
+  GLMessage_Function_glClipPlanex = 39,
+  GLMessage_Function_glClipPlanexIMG = 40,
+  GLMessage_Function_glClipPlanexOES = 41,
+  GLMessage_Function_glColor4f = 42,
+  GLMessage_Function_glColor4ub = 43,
+  GLMessage_Function_glColor4x = 44,
+  GLMessage_Function_glColor4xOES = 45,
+  GLMessage_Function_glColorMask = 46,
+  GLMessage_Function_glColorPointer = 47,
+  GLMessage_Function_glCompileShader = 48,
+  GLMessage_Function_glCompressedTexImage2D = 49,
+  GLMessage_Function_glCompressedTexImage3DOES = 50,
+  GLMessage_Function_glCompressedTexSubImage2D = 51,
+  GLMessage_Function_glCompressedTexSubImage3DOES = 52,
+  GLMessage_Function_glCopyTexImage2D = 53,
+  GLMessage_Function_glCopyTexSubImage2D = 54,
+  GLMessage_Function_glCopyTexSubImage3DOES = 55,
+  GLMessage_Function_glCoverageMaskNV = 56,
+  GLMessage_Function_glCoverageOperationNV = 57,
+  GLMessage_Function_glCreateProgram = 58,
+  GLMessage_Function_glCreateShader = 59,
+  GLMessage_Function_glCullFace = 60,
+  GLMessage_Function_glCurrentPaletteMatrixOES = 61,
+  GLMessage_Function_glDeleteBuffers = 62,
+  GLMessage_Function_glDeleteFencesNV = 63,
+  GLMessage_Function_glDeleteFramebuffers = 64,
+  GLMessage_Function_glDeleteFramebuffersOES = 65,
+  GLMessage_Function_glDeletePerfMonitorsAMD = 66,
+  GLMessage_Function_glDeleteProgram = 67,
+  GLMessage_Function_glDeleteRenderbuffers = 68,
+  GLMessage_Function_glDeleteRenderbuffersOES = 69,
+  GLMessage_Function_glDeleteShader = 70,
+  GLMessage_Function_glDeleteTextures = 71,
+  GLMessage_Function_glDeleteVertexArraysOES = 72,
+  GLMessage_Function_glDepthFunc = 73,
+  GLMessage_Function_glDepthMask = 74,
+  GLMessage_Function_glDepthRangef = 75,
+  GLMessage_Function_glDepthRangefOES = 76,
+  GLMessage_Function_glDepthRangex = 77,
+  GLMessage_Function_glDepthRangexOES = 78,
+  GLMessage_Function_glDetachShader = 79,
+  GLMessage_Function_glDisableClientState = 80,
+  GLMessage_Function_glDisableDriverControlQCOM = 81,
+  GLMessage_Function_glDisable = 82,
+  GLMessage_Function_glDisableVertexAttribArray = 83,
+  GLMessage_Function_glDiscardFramebufferEXT = 84,
+  GLMessage_Function_glDrawArrays = 85,
+  GLMessage_Function_glDrawElements = 86,
+  GLMessage_Function_glDrawTexfOES = 87,
+  GLMessage_Function_glDrawTexfvOES = 88,
+  GLMessage_Function_glDrawTexiOES = 89,
+  GLMessage_Function_glDrawTexivOES = 90,
+  GLMessage_Function_glDrawTexsOES = 91,
+  GLMessage_Function_glDrawTexsvOES = 92,
+  GLMessage_Function_glDrawTexxOES = 93,
+  GLMessage_Function_glDrawTexxvOES = 94,
+  GLMessage_Function_glEGLImageTargetRenderbufferStorageOES = 95,
+  GLMessage_Function_glEGLImageTargetTexture2DOES = 96,
+  GLMessage_Function_glEnableClientState = 97,
+  GLMessage_Function_glEnableDriverControlQCOM = 98,
+  GLMessage_Function_glEnable = 99,
+  GLMessage_Function_glEnableVertexAttribArray = 100,
+  GLMessage_Function_glEndPerfMonitorAMD = 101,
+  GLMessage_Function_glEndTilingQCOM = 102,
+  GLMessage_Function_glExtGetBufferPointervQCOM = 103,
+  GLMessage_Function_glExtGetBuffersQCOM = 104,
+  GLMessage_Function_glExtGetFramebuffersQCOM = 105,
+  GLMessage_Function_glExtGetProgramBinarySourceQCOM = 106,
+  GLMessage_Function_glExtGetProgramsQCOM = 107,
+  GLMessage_Function_glExtGetRenderbuffersQCOM = 108,
+  GLMessage_Function_glExtGetShadersQCOM = 109,
+  GLMessage_Function_glExtGetTexLevelParameterivQCOM = 110,
+  GLMessage_Function_glExtGetTexSubImageQCOM = 111,
+  GLMessage_Function_glExtGetTexturesQCOM = 112,
+  GLMessage_Function_glExtIsProgramBinaryQCOM = 113,
+  GLMessage_Function_glExtTexObjectStateOverrideiQCOM = 114,
+  GLMessage_Function_glFinishFenceNV = 115,
+  GLMessage_Function_glFinish = 116,
+  GLMessage_Function_glFlush = 117,
+  GLMessage_Function_glFogf = 118,
+  GLMessage_Function_glFogfv = 119,
+  GLMessage_Function_glFogx = 120,
+  GLMessage_Function_glFogxOES = 121,
+  GLMessage_Function_glFogxv = 122,
+  GLMessage_Function_glFogxvOES = 123,
+  GLMessage_Function_glFramebufferRenderbuffer = 124,
+  GLMessage_Function_glFramebufferRenderbufferOES = 125,
+  GLMessage_Function_glFramebufferTexture2D = 126,
+  GLMessage_Function_glFramebufferTexture2DMultisampleIMG = 127,
+  GLMessage_Function_glFramebufferTexture2DOES = 128,
+  GLMessage_Function_glFramebufferTexture3DOES = 129,
+  GLMessage_Function_glFrontFace = 130,
+  GLMessage_Function_glFrustumf = 131,
+  GLMessage_Function_glFrustumfOES = 132,
+  GLMessage_Function_glFrustumx = 133,
+  GLMessage_Function_glFrustumxOES = 134,
+  GLMessage_Function_glGenBuffers = 135,
+  GLMessage_Function_glGenerateMipmap = 136,
+  GLMessage_Function_glGenerateMipmapOES = 137,
+  GLMessage_Function_glGenFencesNV = 138,
+  GLMessage_Function_glGenFramebuffers = 139,
+  GLMessage_Function_glGenFramebuffersOES = 140,
+  GLMessage_Function_glGenPerfMonitorsAMD = 141,
+  GLMessage_Function_glGenRenderbuffers = 142,
+  GLMessage_Function_glGenRenderbuffersOES = 143,
+  GLMessage_Function_glGenTextures = 144,
+  GLMessage_Function_glGenVertexArraysOES = 145,
+  GLMessage_Function_glGetActiveAttrib = 146,
+  GLMessage_Function_glGetActiveUniform = 147,
+  GLMessage_Function_glGetAttachedShaders = 148,
+  GLMessage_Function_glGetAttribLocation = 149,
+  GLMessage_Function_glGetBooleanv = 150,
+  GLMessage_Function_glGetBufferParameteriv = 151,
+  GLMessage_Function_glGetBufferPointervOES = 152,
+  GLMessage_Function_glGetClipPlanef = 153,
+  GLMessage_Function_glGetClipPlanefOES = 154,
+  GLMessage_Function_glGetClipPlanex = 155,
+  GLMessage_Function_glGetClipPlanexOES = 156,
+  GLMessage_Function_glGetDriverControlsQCOM = 157,
+  GLMessage_Function_glGetDriverControlStringQCOM = 158,
+  GLMessage_Function_glGetError = 159,
+  GLMessage_Function_glGetFenceivNV = 160,
+  GLMessage_Function_glGetFixedv = 161,
+  GLMessage_Function_glGetFixedvOES = 162,
+  GLMessage_Function_glGetFloatv = 163,
+  GLMessage_Function_glGetFramebufferAttachmentParameteriv = 164,
+  GLMessage_Function_glGetFramebufferAttachmentParameterivOES = 165,
+  GLMessage_Function_glGetIntegerv = 166,
+  GLMessage_Function_glGetLightfv = 167,
+  GLMessage_Function_glGetLightxv = 168,
+  GLMessage_Function_glGetLightxvOES = 169,
+  GLMessage_Function_glGetMaterialfv = 170,
+  GLMessage_Function_glGetMaterialxv = 171,
+  GLMessage_Function_glGetMaterialxvOES = 172,
+  GLMessage_Function_glGetPerfMonitorCounterDataAMD = 173,
+  GLMessage_Function_glGetPerfMonitorCounterInfoAMD = 174,
+  GLMessage_Function_glGetPerfMonitorCountersAMD = 175,
+  GLMessage_Function_glGetPerfMonitorCounterStringAMD = 176,
+  GLMessage_Function_glGetPerfMonitorGroupsAMD = 177,
+  GLMessage_Function_glGetPerfMonitorGroupStringAMD = 178,
+  GLMessage_Function_glGetPointerv = 179,
+  GLMessage_Function_glGetProgramBinaryOES = 180,
+  GLMessage_Function_glGetProgramInfoLog = 181,
+  GLMessage_Function_glGetProgramiv = 182,
+  GLMessage_Function_glGetRenderbufferParameteriv = 183,
+  GLMessage_Function_glGetRenderbufferParameterivOES = 184,
+  GLMessage_Function_glGetShaderInfoLog = 185,
+  GLMessage_Function_glGetShaderiv = 186,
+  GLMessage_Function_glGetShaderPrecisionFormat = 187,
+  GLMessage_Function_glGetShaderSource = 188,
+  GLMessage_Function_glGetString = 189,
+  GLMessage_Function_glGetTexEnvfv = 190,
+  GLMessage_Function_glGetTexEnviv = 191,
+  GLMessage_Function_glGetTexEnvxv = 192,
+  GLMessage_Function_glGetTexEnvxvOES = 193,
+  GLMessage_Function_glGetTexGenfvOES = 194,
+  GLMessage_Function_glGetTexGenivOES = 195,
+  GLMessage_Function_glGetTexGenxvOES = 196,
+  GLMessage_Function_glGetTexParameterfv = 197,
+  GLMessage_Function_glGetTexParameteriv = 198,
+  GLMessage_Function_glGetTexParameterxv = 199,
+  GLMessage_Function_glGetTexParameterxvOES = 200,
+  GLMessage_Function_glGetUniformfv = 201,
+  GLMessage_Function_glGetUniformiv = 202,
+  GLMessage_Function_glGetUniformLocation = 203,
+  GLMessage_Function_glGetVertexAttribfv = 204,
+  GLMessage_Function_glGetVertexAttribiv = 205,
+  GLMessage_Function_glGetVertexAttribPointerv = 206,
+  GLMessage_Function_glHint = 207,
+  GLMessage_Function_glIsBuffer = 208,
+  GLMessage_Function_glIsEnabled = 209,
+  GLMessage_Function_glIsFenceNV = 210,
+  GLMessage_Function_glIsFramebuffer = 211,
+  GLMessage_Function_glIsFramebufferOES = 212,
+  GLMessage_Function_glIsProgram = 213,
+  GLMessage_Function_glIsRenderbuffer = 214,
+  GLMessage_Function_glIsRenderbufferOES = 215,
+  GLMessage_Function_glIsShader = 216,
+  GLMessage_Function_glIsTexture = 217,
+  GLMessage_Function_glIsVertexArrayOES = 218,
+  GLMessage_Function_glLightf = 219,
+  GLMessage_Function_glLightfv = 220,
+  GLMessage_Function_glLightModelf = 221,
+  GLMessage_Function_glLightModelfv = 222,
+  GLMessage_Function_glLightModelx = 223,
+  GLMessage_Function_glLightModelxOES = 224,
+  GLMessage_Function_glLightModelxv = 225,
+  GLMessage_Function_glLightModelxvOES = 226,
+  GLMessage_Function_glLightx = 227,
+  GLMessage_Function_glLightxOES = 228,
+  GLMessage_Function_glLightxv = 229,
+  GLMessage_Function_glLightxvOES = 230,
+  GLMessage_Function_glLineWidth = 231,
+  GLMessage_Function_glLineWidthx = 232,
+  GLMessage_Function_glLineWidthxOES = 233,
+  GLMessage_Function_glLinkProgram = 234,
+  GLMessage_Function_glLoadIdentity = 235,
+  GLMessage_Function_glLoadMatrixf = 236,
+  GLMessage_Function_glLoadMatrixx = 237,
+  GLMessage_Function_glLoadMatrixxOES = 238,
+  GLMessage_Function_glLoadPaletteFromModelViewMatrixOES = 239,
+  GLMessage_Function_glLogicOp = 240,
+  GLMessage_Function_glMapBufferOES = 241,
+  GLMessage_Function_glMaterialf = 242,
+  GLMessage_Function_glMaterialfv = 243,
+  GLMessage_Function_glMaterialx = 244,
+  GLMessage_Function_glMaterialxOES = 245,
+  GLMessage_Function_glMaterialxv = 246,
+  GLMessage_Function_glMaterialxvOES = 247,
+  GLMessage_Function_glMatrixIndexPointerOES = 248,
+  GLMessage_Function_glMatrixMode = 249,
+  GLMessage_Function_glMultiDrawArraysEXT = 250,
+  GLMessage_Function_glMultiDrawElementsEXT = 251,
+  GLMessage_Function_glMultiTexCoord4f = 252,
+  GLMessage_Function_glMultiTexCoord4x = 253,
+  GLMessage_Function_glMultiTexCoord4xOES = 254,
+  GLMessage_Function_glMultMatrixf = 255,
+  GLMessage_Function_glMultMatrixx = 256,
+  GLMessage_Function_glMultMatrixxOES = 257,
+  GLMessage_Function_glNormal3f = 258,
+  GLMessage_Function_glNormal3x = 259,
+  GLMessage_Function_glNormal3xOES = 260,
+  GLMessage_Function_glNormalPointer = 261,
+  GLMessage_Function_glOrthof = 262,
+  GLMessage_Function_glOrthofOES = 263,
+  GLMessage_Function_glOrthox = 264,
+  GLMessage_Function_glOrthoxOES = 265,
+  GLMessage_Function_glPixelStorei = 266,
+  GLMessage_Function_glPointParameterf = 267,
+  GLMessage_Function_glPointParameterfv = 268,
+  GLMessage_Function_glPointParameterx = 269,
+  GLMessage_Function_glPointParameterxOES = 270,
+  GLMessage_Function_glPointParameterxv = 271,
+  GLMessage_Function_glPointParameterxvOES = 272,
+  GLMessage_Function_glPointSize = 273,
+  GLMessage_Function_glPointSizePointerOES = 274,
+  GLMessage_Function_glPointSizex = 275,
+  GLMessage_Function_glPointSizexOES = 276,
+  GLMessage_Function_glPolygonOffset = 277,
+  GLMessage_Function_glPolygonOffsetx = 278,
+  GLMessage_Function_glPolygonOffsetxOES = 279,
+  GLMessage_Function_glPopMatrix = 280,
+  GLMessage_Function_glProgramBinaryOES = 281,
+  GLMessage_Function_glPushMatrix = 282,
+  GLMessage_Function_glQueryMatrixxOES = 283,
+  GLMessage_Function_glReadPixels = 284,
+  GLMessage_Function_glReleaseShaderCompiler = 285,
+  GLMessage_Function_glRenderbufferStorage = 286,
+  GLMessage_Function_glRenderbufferStorageMultisampleIMG = 287,
+  GLMessage_Function_glRenderbufferStorageOES = 288,
+  GLMessage_Function_glRotatef = 289,
+  GLMessage_Function_glRotatex = 290,
+  GLMessage_Function_glRotatexOES = 291,
+  GLMessage_Function_glSampleCoverage = 292,
+  GLMessage_Function_glSampleCoveragex = 293,
+  GLMessage_Function_glSampleCoveragexOES = 294,
+  GLMessage_Function_glScalef = 295,
+  GLMessage_Function_glScalex = 296,
+  GLMessage_Function_glScalexOES = 297,
+  GLMessage_Function_glScissor = 298,
+  GLMessage_Function_glSelectPerfMonitorCountersAMD = 299,
+  GLMessage_Function_glSetFenceNV = 300,
+  GLMessage_Function_glShadeModel = 301,
+  GLMessage_Function_glShaderBinary = 302,
+  GLMessage_Function_glShaderSource = 303,
+  GLMessage_Function_glStartTilingQCOM = 304,
+  GLMessage_Function_glStencilFunc = 305,
+  GLMessage_Function_glStencilFuncSeparate = 306,
+  GLMessage_Function_glStencilMask = 307,
+  GLMessage_Function_glStencilMaskSeparate = 308,
+  GLMessage_Function_glStencilOp = 309,
+  GLMessage_Function_glStencilOpSeparate = 310,
+  GLMessage_Function_glTestFenceNV = 311,
+  GLMessage_Function_glTexCoordPointer = 312,
+  GLMessage_Function_glTexEnvf = 313,
+  GLMessage_Function_glTexEnvfv = 314,
+  GLMessage_Function_glTexEnvi = 315,
+  GLMessage_Function_glTexEnviv = 316,
+  GLMessage_Function_glTexEnvx = 317,
+  GLMessage_Function_glTexEnvxOES = 318,
+  GLMessage_Function_glTexEnvxv = 319,
+  GLMessage_Function_glTexEnvxvOES = 320,
+  GLMessage_Function_glTexGenfOES = 321,
+  GLMessage_Function_glTexGenfvOES = 322,
+  GLMessage_Function_glTexGeniOES = 323,
+  GLMessage_Function_glTexGenivOES = 324,
+  GLMessage_Function_glTexGenxOES = 325,
+  GLMessage_Function_glTexGenxvOES = 326,
+  GLMessage_Function_glTexImage2D = 327,
+  GLMessage_Function_glTexImage3DOES = 328,
+  GLMessage_Function_glTexParameterf = 329,
+  GLMessage_Function_glTexParameterfv = 330,
+  GLMessage_Function_glTexParameteri = 331,
+  GLMessage_Function_glTexParameteriv = 332,
+  GLMessage_Function_glTexParameterx = 333,
+  GLMessage_Function_glTexParameterxOES = 334,
+  GLMessage_Function_glTexParameterxv = 335,
+  GLMessage_Function_glTexParameterxvOES = 336,
+  GLMessage_Function_glTexSubImage2D = 337,
+  GLMessage_Function_glTexSubImage3DOES = 338,
+  GLMessage_Function_glTranslatef = 339,
+  GLMessage_Function_glTranslatex = 340,
+  GLMessage_Function_glTranslatexOES = 341,
+  GLMessage_Function_glUniform1f = 342,
+  GLMessage_Function_glUniform1fv = 343,
+  GLMessage_Function_glUniform1i = 344,
+  GLMessage_Function_glUniform1iv = 345,
+  GLMessage_Function_glUniform2f = 346,
+  GLMessage_Function_glUniform2fv = 347,
+  GLMessage_Function_glUniform2i = 348,
+  GLMessage_Function_glUniform2iv = 349,
+  GLMessage_Function_glUniform3f = 350,
+  GLMessage_Function_glUniform3fv = 351,
+  GLMessage_Function_glUniform3i = 352,
+  GLMessage_Function_glUniform3iv = 353,
+  GLMessage_Function_glUniform4f = 354,
+  GLMessage_Function_glUniform4fv = 355,
+  GLMessage_Function_glUniform4i = 356,
+  GLMessage_Function_glUniform4iv = 357,
+  GLMessage_Function_glUniformMatrix2fv = 358,
+  GLMessage_Function_glUniformMatrix3fv = 359,
+  GLMessage_Function_glUniformMatrix4fv = 360,
+  GLMessage_Function_glUnmapBufferOES = 361,
+  GLMessage_Function_glUseProgram = 362,
+  GLMessage_Function_glValidateProgram = 363,
+  GLMessage_Function_glVertexAttrib1f = 364,
+  GLMessage_Function_glVertexAttrib1fv = 365,
+  GLMessage_Function_glVertexAttrib2f = 366,
+  GLMessage_Function_glVertexAttrib2fv = 367,
+  GLMessage_Function_glVertexAttrib3f = 368,
+  GLMessage_Function_glVertexAttrib3fv = 369,
+  GLMessage_Function_glVertexAttrib4f = 370,
+  GLMessage_Function_glVertexAttrib4fv = 371,
+  GLMessage_Function_glVertexAttribPointer = 372,
+  GLMessage_Function_glVertexPointer = 373,
+  GLMessage_Function_glViewport = 374,
+  GLMessage_Function_glWeightPointerOES = 375,
+  GLMessage_Function_glReadBuffer = 376,
+  GLMessage_Function_glDrawRangeElements = 377,
+  GLMessage_Function_glTexImage3D = 378,
+  GLMessage_Function_glTexSubImage3D = 379,
+  GLMessage_Function_glCopyTexSubImage3D = 380,
+  GLMessage_Function_glCompressedTexImage3D = 381,
+  GLMessage_Function_glCompressedTexSubImage3D = 382,
+  GLMessage_Function_glGenQueries = 383,
+  GLMessage_Function_glDeleteQueries = 384,
+  GLMessage_Function_glIsQuery = 385,
+  GLMessage_Function_glBeginQuery = 386,
+  GLMessage_Function_glEndQuery = 387,
+  GLMessage_Function_glGetQueryiv = 388,
+  GLMessage_Function_glGetQueryObjectuiv = 389,
+  GLMessage_Function_glUnmapBuffer = 390,
+  GLMessage_Function_glGetBufferPointerv = 391,
+  GLMessage_Function_glDrawBuffers = 392,
+  GLMessage_Function_glUniformMatrix2x3fv = 393,
+  GLMessage_Function_glUniformMatrix3x2fv = 394,
+  GLMessage_Function_glUniformMatrix2x4fv = 395,
+  GLMessage_Function_glUniformMatrix4x2fv = 396,
+  GLMessage_Function_glUniformMatrix3x4fv = 397,
+  GLMessage_Function_glUniformMatrix4x3fv = 398,
+  GLMessage_Function_glBlitFramebuffer = 399,
+  GLMessage_Function_glRenderbufferStorageMultisample = 400,
+  GLMessage_Function_glFramebufferTextureLayer = 401,
+  GLMessage_Function_glMapBufferRange = 402,
+  GLMessage_Function_glFlushMappedBufferRange = 403,
+  GLMessage_Function_glBindVertexArray = 404,
+  GLMessage_Function_glDeleteVertexArrays = 405,
+  GLMessage_Function_glGenVertexArrays = 406,
+  GLMessage_Function_glIsVertexArray = 407,
+  GLMessage_Function_glGetIntegeri_v = 408,
+  GLMessage_Function_glBeginTransformFeedback = 409,
+  GLMessage_Function_glEndTransformFeedback = 410,
+  GLMessage_Function_glBindBufferRange = 411,
+  GLMessage_Function_glBindBufferBase = 412,
+  GLMessage_Function_glTransformFeedbackVaryings = 413,
+  GLMessage_Function_glGetTransformFeedbackVarying = 414,
+  GLMessage_Function_glVertexAttribIPointer = 415,
+  GLMessage_Function_glGetVertexAttribIiv = 416,
+  GLMessage_Function_glGetVertexAttribIuiv = 417,
+  GLMessage_Function_glVertexAttribI4i = 418,
+  GLMessage_Function_glVertexAttribI4ui = 419,
+  GLMessage_Function_glVertexAttribI4iv = 420,
+  GLMessage_Function_glVertexAttribI4uiv = 421,
+  GLMessage_Function_glGetUniformuiv = 422,
+  GLMessage_Function_glGetFragDataLocation = 423,
+  GLMessage_Function_glUniform1ui = 424,
+  GLMessage_Function_glUniform2ui = 425,
+  GLMessage_Function_glUniform3ui = 426,
+  GLMessage_Function_glUniform4ui = 427,
+  GLMessage_Function_glUniform1uiv = 428,
+  GLMessage_Function_glUniform2uiv = 429,
+  GLMessage_Function_glUniform3uiv = 430,
+  GLMessage_Function_glUniform4uiv = 431,
+  GLMessage_Function_glClearBufferiv = 432,
+  GLMessage_Function_glClearBufferuiv = 433,
+  GLMessage_Function_glClearBufferfv = 434,
+  GLMessage_Function_glClearBufferfi = 435,
+  GLMessage_Function_glGetStringi = 436,
+  GLMessage_Function_glCopyBufferSubData = 437,
+  GLMessage_Function_glGetUniformIndices = 438,
+  GLMessage_Function_glGetActiveUniformsiv = 439,
+  GLMessage_Function_glGetUniformBlockIndex = 440,
+  GLMessage_Function_glGetActiveUniformBlockiv = 441,
+  GLMessage_Function_glGetActiveUniformBlockName = 442,
+  GLMessage_Function_glUniformBlockBinding = 443,
+  GLMessage_Function_glDrawArraysInstanced = 444,
+  GLMessage_Function_glDrawElementsInstanced = 445,
+  GLMessage_Function_glFenceSync = 446,
+  GLMessage_Function_glIsSync = 447,
+  GLMessage_Function_glDeleteSync = 448,
+  GLMessage_Function_glClientWaitSync = 449,
+  GLMessage_Function_glWaitSync = 450,
+  GLMessage_Function_glGetInteger64v = 451,
+  GLMessage_Function_glGetSynciv = 452,
+  GLMessage_Function_glGetInteger64i_v = 453,
+  GLMessage_Function_glGetBufferParameteri64v = 454,
+  GLMessage_Function_glGenSamplers = 455,
+  GLMessage_Function_glDeleteSamplers = 456,
+  GLMessage_Function_glIsSampler = 457,
+  GLMessage_Function_glBindSampler = 458,
+  GLMessage_Function_glSamplerParameteri = 459,
+  GLMessage_Function_glSamplerParameteriv = 460,
+  GLMessage_Function_glSamplerParameterf = 461,
+  GLMessage_Function_glSamplerParameterfv = 462,
+  GLMessage_Function_glGetSamplerParameteriv = 463,
+  GLMessage_Function_glGetSamplerParameterfv = 464,
+  GLMessage_Function_glVertexAttribDivisor = 465,
+  GLMessage_Function_glBindTransformFeedback = 466,
+  GLMessage_Function_glDeleteTransformFeedbacks = 467,
+  GLMessage_Function_glGenTransformFeedbacks = 468,
+  GLMessage_Function_glIsTransformFeedback = 469,
+  GLMessage_Function_glPauseTransformFeedback = 470,
+  GLMessage_Function_glResumeTransformFeedback = 471,
+  GLMessage_Function_glGetProgramBinary = 472,
+  GLMessage_Function_glProgramBinary = 473,
+  GLMessage_Function_glProgramParameteri = 474,
+  GLMessage_Function_glInvalidateFramebuffer = 475,
+  GLMessage_Function_glInvalidateSubFramebuffer = 476,
+  GLMessage_Function_glTexStorage2D = 477,
+  GLMessage_Function_glTexStorage3D = 478,
+  GLMessage_Function_glGetInternalformativ = 479,
+  GLMessage_Function_glBeginPerfQueryINTEL = 480,
+  GLMessage_Function_glCreatePerfQueryINTEL = 481,
+  GLMessage_Function_glDeletePerfQueryINTEL = 482,
+  GLMessage_Function_glEndPerfQueryINTEL = 483,
+  GLMessage_Function_glGetFirstPerfQueryIdINTEL = 484,
+  GLMessage_Function_glGetNextPerfQueryIdINTEL = 485,
+  GLMessage_Function_glGetPerfCounterInfoINTEL = 486,
+  GLMessage_Function_glGetPerfQueryDataINTEL = 487,
+  GLMessage_Function_glGetPerfQueryIdByNameINTEL = 488,
+  GLMessage_Function_glGetPerfQueryInfoINTEL = 489,
+  GLMessage_Function_glBlendBarrierKHR = 490,
+  GLMessage_Function_glBlendBarrierNV = 491,
+  GLMessage_Function_glBlendParameteriNV = 492,
+  GLMessage_Function_glBlitFramebufferNV = 493,
+  GLMessage_Function_glFenceSyncAPPLE = 494,
+  GLMessage_Function_glIsSyncAPPLE = 495,
+  GLMessage_Function_glDeleteSyncAPPLE = 496,
+  GLMessage_Function_glClientWaitSyncAPPLE = 497,
+  GLMessage_Function_glWaitSyncAPPLE = 498,
+  GLMessage_Function_glGetInteger64vAPPLE = 499,
+  GLMessage_Function_glGetSyncivAPPLE = 500,
+  GLMessage_Function_glCopyBufferSubDataNV = 501,
+  GLMessage_Function_glActiveShaderProgramEXT = 502,
+  GLMessage_Function_glAlphaFuncQCOM = 503,
+  GLMessage_Function_glBeginQueryEXT = 504,
+  GLMessage_Function_glBindProgramPipelineEXT = 505,
+  GLMessage_Function_glBlitFramebufferANGLE = 506,
+  GLMessage_Function_glCreateShaderProgramvEXT = 507,
+  GLMessage_Function_glDeleteProgramPipelinesEXT = 508,
+  GLMessage_Function_glDeleteQueriesEXT = 509,
+  GLMessage_Function_glDrawBuffersNV = 510,
+  GLMessage_Function_glEndQueryEXT = 511,
+  GLMessage_Function_glFramebufferTexture2DMultisampleEXT = 512,
+  GLMessage_Function_glGenProgramPipelinesEXT = 513,
+  GLMessage_Function_glGenQueriesEXT = 514,
+  GLMessage_Function_glGetGraphicsResetStatusEXT = 515,
+  GLMessage_Function_glGetObjectLabelEXT = 516,
+  GLMessage_Function_glGetProgramPipelineInfoLogEXT = 517,
+  GLMessage_Function_glGetProgramPipelineivEXT = 518,
+  GLMessage_Function_glGetQueryObjectuivEXT = 519,
+  GLMessage_Function_glGetQueryivEXT = 520,
+  GLMessage_Function_glGetnUniformfvEXT = 521,
+  GLMessage_Function_glGetnUniformivEXT = 521,
+  GLMessage_Function_glInsertEventMarkerEXT = 522,
+  GLMessage_Function_glIsProgramPipelineEXT = 523,
+  GLMessage_Function_glIsQueryEXT = 524,
+  GLMessage_Function_glLabelObjectEXT = 525,
+  GLMessage_Function_glPopGroupMarkerEXT = 526,
+  GLMessage_Function_glProgramParameteriEXT = 527,
+  GLMessage_Function_glProgramUniform1fEXT = 528,
+  GLMessage_Function_glProgramUniform1fvEXT = 529,
+  GLMessage_Function_glProgramUniform1iEXT = 530,
+  GLMessage_Function_glProgramUniform1ivEXT = 531,
+  GLMessage_Function_glProgramUniform2fEXT = 532,
+  GLMessage_Function_glProgramUniform2fvEXT = 533,
+  GLMessage_Function_glProgramUniform2iEXT = 534,
+  GLMessage_Function_glProgramUniform2ivEXT = 535,
+  GLMessage_Function_glProgramUniform3fEXT = 536,
+  GLMessage_Function_glProgramUniform3fvEXT = 537,
+  GLMessage_Function_glProgramUniform3iEXT = 538,
+  GLMessage_Function_glProgramUniform3ivEXT = 539,
+  GLMessage_Function_glProgramUniform4fEXT = 540,
+  GLMessage_Function_glProgramUniform4fvEXT = 541,
+  GLMessage_Function_glProgramUniform4iEXT = 542,
+  GLMessage_Function_glProgramUniform4ivEXT = 543,
+  GLMessage_Function_glProgramUniformMatrix2fvEXT = 544,
+  GLMessage_Function_glProgramUniformMatrix3fvEXT = 545,
+  GLMessage_Function_glProgramUniformMatrix4fvEXT = 546,
+  GLMessage_Function_glPushGroupMarkerEXT = 547,
+  GLMessage_Function_glReadBufferNV = 548,
+  GLMessage_Function_glReadnPixelsEXT = 549,
+  GLMessage_Function_glRenderbufferStorageMultisampleANGLE = 550,
+  GLMessage_Function_glRenderbufferStorageMultisampleAPPLE = 551,
+  GLMessage_Function_glRenderbufferStorageMultisampleEXT = 552,
+  GLMessage_Function_glResolveMultisampleFramebufferAPPLE = 553,
+  GLMessage_Function_glTexStorage1DEXT = 554,
+  GLMessage_Function_glTexStorage2DEXT = 555,
+  GLMessage_Function_glTexStorage3DEXT = 556,
+  GLMessage_Function_glTextureStorage1DEXT = 557,
+  GLMessage_Function_glTextureStorage2DEXT = 558,
+  GLMessage_Function_glTextureStorage3DEXT = 559,
+  GLMessage_Function_glUseProgramStagesEXT = 560,
+  GLMessage_Function_glValidateProgramPipelineEXT = 561,
+  GLMessage_Function_glCopyTextureLevelsAPPLE = 562,
+  GLMessage_Function_glDebugMessageControlKHR = 563,
+  GLMessage_Function_glDebugMessageInsertKHR = 564,
+  GLMessage_Function_glDebugMessageCallbackKHR = 565,
+  GLMessage_Function_glGetDebugMessageLogKHR = 566,
+  GLMessage_Function_glPushDebugGroupKHR = 567,
+  GLMessage_Function_glPopDebugGroupKHR = 568,
+  GLMessage_Function_glObjectLabelKHR = 569,
+  GLMessage_Function_glGetObjectLabelKHR = 570,
+  GLMessage_Function_glObjectPtrLabelKHR = 571,
+  GLMessage_Function_glGetObjectPtrLabelKHR = 572,
+  GLMessage_Function_glGetPointervKHR = 573,
+  GLMessage_Function_glDrawArraysInstancedANGLE = 574,
+  GLMessage_Function_glDrawElementsInstancedANGLE = 575,
+  GLMessage_Function_glVertexAttribDivisorANGLE = 576,
+  GLMessage_Function_glDrawArraysInstancedEXT = 577,
+  GLMessage_Function_glDrawElementsInstancedEXT = 578,
+  GLMessage_Function_glVertexAttribDivisorEXT = 579,
+  GLMessage_Function_glDrawArraysInstancedNV = 580,
+  GLMessage_Function_glDrawElementsInstancedNV = 581,
+  GLMessage_Function_glVertexAttribDivisorNV = 582,
+  GLMessage_Function_glDrawBuffersEXT = 583,
+  GLMessage_Function_glReadBufferIndexedEXT = 584,
+  GLMessage_Function_glDrawBuffersIndexedEXT = 585,
+  GLMessage_Function_glGetIntegeri_vEXT = 586,
+  GLMessage_Function_glMapBufferRangeEXT = 587,
+  GLMessage_Function_glFlushMappedBufferRangeEXT = 588,
+  GLMessage_Function_glQueryCounterEXT = 589,
+  GLMessage_Function_glGetQueryObjecti64vEXT = 590,
+  GLMessage_Function_glGetQueryObjectivEXT = 591,
+  GLMessage_Function_glGetQueryObjectui64vEXT = 592,
+  GLMessage_Function_glGetTranslatedShaderSourceANGLE = 593,
+  GLMessage_Function_glMinSampleShadingOES = 594,
+  GLMessage_Function_glMultiTexCoord1bOES = 595,
+  GLMessage_Function_glMultiTexCoord1bvOES = 596,
+  GLMessage_Function_glMultiTexCoord2bOES = 597,
+  GLMessage_Function_glMultiTexCoord2bvOES = 598,
+  GLMessage_Function_glMultiTexCoord3bOES = 599,
+  GLMessage_Function_glMultiTexCoord3bvOES = 600,
+  GLMessage_Function_glMultiTexCoord4bOES = 601,
+  GLMessage_Function_glMultiTexCoord4bvOES = 602,
+  GLMessage_Function_glTexCoord1bOES = 603,
+  GLMessage_Function_glTexCoord1bvOES = 604,
+  GLMessage_Function_glTexCoord2bOES = 605,
+  GLMessage_Function_glTexCoord2bvOES = 606,
+  GLMessage_Function_glTexCoord3bOES = 607,
+  GLMessage_Function_glTexCoord3bvOES = 608,
+  GLMessage_Function_glTexCoord4bOES = 609,
+  GLMessage_Function_glTexCoord4bvOES = 610,
+  GLMessage_Function_glVertex2bOES = 611,
+  GLMessage_Function_glVertex2bvOES = 612,
+  GLMessage_Function_glVertex3bOES = 613,
+  GLMessage_Function_glVertex3bvOES = 614,
+  GLMessage_Function_glVertex4bOES = 615,
+  GLMessage_Function_glVertex4bvOES = 616,
+  GLMessage_Function_glProgramUniform1uiEXT = 617,
+  GLMessage_Function_glProgramUniform2uiEXT = 618,
+  GLMessage_Function_glProgramUniform3uiEXT = 619,
+  GLMessage_Function_glProgramUniform4uiEXT = 620,
+  GLMessage_Function_glProgramUniform1uivEXT = 621,
+  GLMessage_Function_glProgramUniform2uivEXT = 622,
+  GLMessage_Function_glProgramUniform3uivEXT = 623,
+  GLMessage_Function_glProgramUniform4uivEXT = 624,
+  GLMessage_Function_glProgramUniformMatrix2x3fvEXT = 625,
+  GLMessage_Function_glProgramUniformMatrix3x2fvEXT = 626,
+  GLMessage_Function_glProgramUniformMatrix2x4fvEXT = 627,
+  GLMessage_Function_glProgramUniformMatrix4x2fvEXT = 628,
+  GLMessage_Function_glProgramUniformMatrix3x4fvEXT = 629,
+  GLMessage_Function_glProgramUniformMatrix4x3fvEXT = 630,
+  GLMessage_Function_glRenderbufferStorageMultisampleNV = 631,
+  GLMessage_Function_glSampleCoverageOES = 632,
+  GLMessage_Function_glTexStorage3DMultisampleOES = 633,
+  GLMessage_Function_glUniformMatrix2x3fvNV = 634,
+  GLMessage_Function_glUniformMatrix3x2fvNV = 635,
+  GLMessage_Function_glUniformMatrix2x4fvNV = 636,
+  GLMessage_Function_glUniformMatrix4x2fvNV = 637,
+  GLMessage_Function_glUniformMatrix3x4fvNV = 638,
+  GLMessage_Function_glUniformMatrix4x3fvNV = 639,
+  GLMessage_Function_glActiveShaderProgram = 640,
+  GLMessage_Function_glBindImageTexture = 641,
+  GLMessage_Function_glBindProgramPipeline = 642,
+  GLMessage_Function_glBindVertexBuffer = 643,
+  GLMessage_Function_glCreateShaderProgramv = 644,
+  GLMessage_Function_glDeleteProgramPipelines = 645,
+  GLMessage_Function_glDispatchCompute = 646,
+  GLMessage_Function_glDispatchComputeIndirect = 647,
+  GLMessage_Function_glDrawArraysIndirect = 648,
+  GLMessage_Function_glDrawElementsIndirect = 649,
+  GLMessage_Function_glFramebufferParameteri = 650,
+  GLMessage_Function_glGenProgramPipelines = 651,
+  GLMessage_Function_glGetBooleani_v = 652,
+  GLMessage_Function_glGetFramebufferParameteriv = 653,
+  GLMessage_Function_glGetMultisamplefv = 654,
+  GLMessage_Function_glGetProgramInterfaceiv = 655,
+  GLMessage_Function_glGetProgramPipelineInfoLog = 656,
+  GLMessage_Function_glGetProgramPipelineiv = 657,
+  GLMessage_Function_glGetProgramResourceIndex = 658,
+  GLMessage_Function_glGetProgramResourceLocation = 659,
+  GLMessage_Function_glGetProgramResourceName = 660,
+  GLMessage_Function_glGetProgramResourceiv = 661,
+  GLMessage_Function_glGetTexLevelParameterfv = 662,
+  GLMessage_Function_glGetTexLevelParameteriv = 663,
+  GLMessage_Function_glIsProgramPipeline = 664,
+  GLMessage_Function_glMemoryBarrier = 665,
+  GLMessage_Function_glMemoryBarrierByRegion = 666,
+  GLMessage_Function_glProgramUniform1f = 667,
+  GLMessage_Function_glProgramUniform1fv = 668,
+  GLMessage_Function_glProgramUniform1i = 669,
+  GLMessage_Function_glProgramUniform1iv = 670,
+  GLMessage_Function_glProgramUniform1ui = 671,
+  GLMessage_Function_glProgramUniform1uiv = 672,
+  GLMessage_Function_glProgramUniform2f = 673,
+  GLMessage_Function_glProgramUniform2fv = 674,
+  GLMessage_Function_glProgramUniform2i = 675,
+  GLMessage_Function_glProgramUniform2iv = 676,
+  GLMessage_Function_glProgramUniform2ui = 677,
+  GLMessage_Function_glProgramUniform2uiv = 678,
+  GLMessage_Function_glProgramUniform3f = 679,
+  GLMessage_Function_glProgramUniform3fv = 680,
+  GLMessage_Function_glProgramUniform3i = 681,
+  GLMessage_Function_glProgramUniform3iv = 682,
+  GLMessage_Function_glProgramUniform3ui = 683,
+  GLMessage_Function_glProgramUniform3uiv = 684,
+  GLMessage_Function_glProgramUniform4f = 685,
+  GLMessage_Function_glProgramUniform4fv = 686,
+  GLMessage_Function_glProgramUniform4i = 687,
+  GLMessage_Function_glProgramUniform4iv = 688,
+  GLMessage_Function_glProgramUniform4ui = 689,
+  GLMessage_Function_glProgramUniform4uiv = 690,
+  GLMessage_Function_glProgramUniformMatrix2fv = 691,
+  GLMessage_Function_glProgramUniformMatrix2x3fv = 692,
+  GLMessage_Function_glProgramUniformMatrix2x4fv = 693,
+  GLMessage_Function_glProgramUniformMatrix3fv = 694,
+  GLMessage_Function_glProgramUniformMatrix3x2fv = 695,
+  GLMessage_Function_glProgramUniformMatrix3x4fv = 696,
+  GLMessage_Function_glProgramUniformMatrix4fv = 697,
+  GLMessage_Function_glProgramUniformMatrix4x2fv = 698,
+  GLMessage_Function_glProgramUniformMatrix4x3fv = 699,
+  GLMessage_Function_glSampleMaski = 700,
+  GLMessage_Function_glTexStorage2DMultisample = 701,
+  GLMessage_Function_glUseProgramStages = 702,
+  GLMessage_Function_glValidateProgramPipeline = 703,
+  GLMessage_Function_glVertexAttribBinding = 704,
+  GLMessage_Function_glVertexAttribFormat = 705,
+  GLMessage_Function_glVertexAttribIFormat = 706,
+  GLMessage_Function_glVertexBindingDivisor = 707,
+  GLMessage_Function_glBlendEquationSeparateiEXT = 708,
+  GLMessage_Function_glBlendEquationiEXT = 709,
+  GLMessage_Function_glBlendFuncSeparateiEXT = 710,
+  GLMessage_Function_glBlendFunciEXT = 711,
+  GLMessage_Function_glColorMaskiEXT = 712,
+  GLMessage_Function_glCopyImageSubDataEXT = 713,
+  GLMessage_Function_glDisableiEXT = 714,
+  GLMessage_Function_glEnableiEXT = 715,
+  GLMessage_Function_glFramebufferTextureEXT = 716,
+  GLMessage_Function_glGetSamplerParameterIivEXT = 717,
+  GLMessage_Function_glGetSamplerParameterIuivEXT = 718,
+  GLMessage_Function_glGetTexParameterIivEXT = 719,
+  GLMessage_Function_glGetTexParameterIuivEXT = 720,
+  GLMessage_Function_glIsEnablediEXT = 721,
+  GLMessage_Function_glPatchParameteriEXT = 722,
+  GLMessage_Function_glPrimitiveBoundingBoxEXT = 723,
+  GLMessage_Function_glSamplerParameterIivEXT = 724,
+  GLMessage_Function_glSamplerParameterIuivEXT = 725,
+  GLMessage_Function_glTexBufferEXT = 726,
+  GLMessage_Function_glTexBufferRangeEXT = 727,
+  GLMessage_Function_glTexParameterIivEXT = 728,
+  GLMessage_Function_glTexParameterIuivEXT = 729,
+  GLMessage_Function_glTextureViewEXT = 730,
+  GLMessage_Function_eglGetDisplay = 2000,
+  GLMessage_Function_eglInitialize = 2001,
+  GLMessage_Function_eglTerminate = 2002,
+  GLMessage_Function_eglGetConfigs = 2003,
+  GLMessage_Function_eglChooseConfig = 2004,
+  GLMessage_Function_eglGetConfigAttrib = 2005,
+  GLMessage_Function_eglCreateWindowSurface = 2006,
+  GLMessage_Function_eglCreatePixmapSurface = 2007,
+  GLMessage_Function_eglCreatePbufferSurface = 2008,
+  GLMessage_Function_eglDestroySurface = 2009,
+  GLMessage_Function_eglQuerySurface = 2010,
+  GLMessage_Function_eglCreateContext = 2011,
+  GLMessage_Function_eglDestroyContext = 2012,
+  GLMessage_Function_eglMakeCurrent = 2013,
+  GLMessage_Function_eglGetCurrentContext = 2014,
+  GLMessage_Function_eglGetCurrentSurface = 2015,
+  GLMessage_Function_eglGetCurrentDisplay = 2016,
+  GLMessage_Function_eglQueryContext = 2017,
+  GLMessage_Function_eglWaitGL = 2018,
+  GLMessage_Function_eglWaitNative = 2019,
+  GLMessage_Function_eglSwapBuffers = 2020,
+  GLMessage_Function_eglCopyBuffers = 2021,
+  GLMessage_Function_eglGetError = 2022,
+  GLMessage_Function_eglQueryString = 2023,
+  GLMessage_Function_eglGetProcAddress = 2024,
+  GLMessage_Function_eglSurfaceAttrib = 2025,
+  GLMessage_Function_eglBindTexImage = 2026,
+  GLMessage_Function_eglReleaseTexImage = 2027,
+  GLMessage_Function_eglSwapInterval = 2028,
+  GLMessage_Function_eglBindAPI = 2029,
+  GLMessage_Function_eglQueryAPI = 2030,
+  GLMessage_Function_eglWaitClient = 2031,
+  GLMessage_Function_eglReleaseThread = 2032,
+  GLMessage_Function_eglCreatePbufferFromClientBuffer = 2033,
+  GLMessage_Function_eglLockSurfaceKHR = 2034,
+  GLMessage_Function_eglUnlockSurfaceKHR = 2035,
+  GLMessage_Function_eglCreateImageKHR = 2036,
+  GLMessage_Function_eglDestroyImageKHR = 2037,
+  GLMessage_Function_eglCreateSyncKHR = 2038,
+  GLMessage_Function_eglDestroySyncKHR = 2039,
+  GLMessage_Function_eglClientWaitSyncKHR = 2040,
+  GLMessage_Function_eglGetSyncAttribKHR = 2041,
+  GLMessage_Function_eglSetSwapRectangleANDROID = 2042,
+  GLMessage_Function_eglGetRenderBufferANDROID = 2043,
+  GLMessage_Function_eglGetSystemTimeFrequencyNV = 2044,
+  GLMessage_Function_eglGetSystemTimeNV = 2045,
+  GLMessage_Function_invalid = 3000,
+  GLMessage_Function_glVertexAttribPointerData = 3001
+};
+bool GLMessage_Function_IsValid(int value);
+const GLMessage_Function GLMessage_Function_Function_MIN = GLMessage_Function_glActiveTexture;
+const GLMessage_Function GLMessage_Function_Function_MAX = GLMessage_Function_glVertexAttribPointerData;
+const int GLMessage_Function_Function_ARRAYSIZE = GLMessage_Function_Function_MAX + 1;
+
+// ===================================================================
+
+class GLMessage_DataType : public ::google::protobuf::MessageLite {
+ public:
+  GLMessage_DataType();
+  virtual ~GLMessage_DataType();
+  
+  GLMessage_DataType(const GLMessage_DataType& from);
+  
+  inline GLMessage_DataType& operator=(const GLMessage_DataType& from) {
+    CopyFrom(from);
+    return *this;
+  }
+  
+  static const GLMessage_DataType& default_instance();
+  
+  void Swap(GLMessage_DataType* other);
+  
+  // implements Message ----------------------------------------------
+  
+  GLMessage_DataType* New() const;
+  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
+  void CopyFrom(const GLMessage_DataType& from);
+  void MergeFrom(const GLMessage_DataType& from);
+  void Clear();
+  bool IsInitialized() const;
+  
+  int ByteSize() const;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input);
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const;
+  int GetCachedSize() const { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const;
+  public:
+  
+  ::std::string GetTypeName() const;
+  
+  // nested types ----------------------------------------------------
+  
+  typedef GLMessage_DataType_Type Type;
+  static const Type VOID = GLMessage_DataType_Type_VOID;
+  static const Type CHAR = GLMessage_DataType_Type_CHAR;
+  static const Type BYTE = GLMessage_DataType_Type_BYTE;
+  static const Type INT = GLMessage_DataType_Type_INT;
+  static const Type FLOAT = GLMessage_DataType_Type_FLOAT;
+  static const Type BOOL = GLMessage_DataType_Type_BOOL;
+  static const Type ENUM = GLMessage_DataType_Type_ENUM;
+  static const Type INT64 = GLMessage_DataType_Type_INT64;
+  static inline bool Type_IsValid(int value) {
+    return GLMessage_DataType_Type_IsValid(value);
+  }
+  static const Type Type_MIN =
+    GLMessage_DataType_Type_Type_MIN;
+  static const Type Type_MAX =
+    GLMessage_DataType_Type_Type_MAX;
+  static const int Type_ARRAYSIZE =
+    GLMessage_DataType_Type_Type_ARRAYSIZE;
+  
+  // accessors -------------------------------------------------------
+  
+  // required .android.gltrace.GLMessage.DataType.Type type = 1 [default = VOID];
+  inline bool has_type() const;
+  inline void clear_type();
+  static const int kTypeFieldNumber = 1;
+  inline ::android::gltrace::GLMessage_DataType_Type type() const;
+  inline void set_type(::android::gltrace::GLMessage_DataType_Type value);
+  
+  // required bool isArray = 2 [default = false];
+  inline bool has_isarray() const;
+  inline void clear_isarray();
+  static const int kIsArrayFieldNumber = 2;
+  inline bool isarray() const;
+  inline void set_isarray(bool value);
+  
+  // repeated int32 intValue = 3;
+  inline int intvalue_size() const;
+  inline void clear_intvalue();
+  static const int kIntValueFieldNumber = 3;
+  inline ::google::protobuf::int32 intvalue(int index) const;
+  inline void set_intvalue(int index, ::google::protobuf::int32 value);
+  inline void add_intvalue(::google::protobuf::int32 value);
+  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
+      intvalue() const;
+  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
+      mutable_intvalue();
+  
+  // repeated float floatValue = 4;
+  inline int floatvalue_size() const;
+  inline void clear_floatvalue();
+  static const int kFloatValueFieldNumber = 4;
+  inline float floatvalue(int index) const;
+  inline void set_floatvalue(int index, float value);
+  inline void add_floatvalue(float value);
+  inline const ::google::protobuf::RepeatedField< float >&
+      floatvalue() const;
+  inline ::google::protobuf::RepeatedField< float >*
+      mutable_floatvalue();
+  
+  // repeated bytes charValue = 5;
+  inline int charvalue_size() const;
+  inline void clear_charvalue();
+  static const int kCharValueFieldNumber = 5;
+  inline const ::std::string& charvalue(int index) const;
+  inline ::std::string* mutable_charvalue(int index);
+  inline void set_charvalue(int index, const ::std::string& value);
+  inline void set_charvalue(int index, const char* value);
+  inline void set_charvalue(int index, const void* value, size_t size);
+  inline ::std::string* add_charvalue();
+  inline void add_charvalue(const ::std::string& value);
+  inline void add_charvalue(const char* value);
+  inline void add_charvalue(const void* value, size_t size);
+  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& charvalue() const;
+  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_charvalue();
+  
+  // repeated bytes rawBytes = 6;
+  inline int rawbytes_size() const;
+  inline void clear_rawbytes();
+  static const int kRawBytesFieldNumber = 6;
+  inline const ::std::string& rawbytes(int index) const;
+  inline ::std::string* mutable_rawbytes(int index);
+  inline void set_rawbytes(int index, const ::std::string& value);
+  inline void set_rawbytes(int index, const char* value);
+  inline void set_rawbytes(int index, const void* value, size_t size);
+  inline ::std::string* add_rawbytes();
+  inline void add_rawbytes(const ::std::string& value);
+  inline void add_rawbytes(const char* value);
+  inline void add_rawbytes(const void* value, size_t size);
+  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& rawbytes() const;
+  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_rawbytes();
+  
+  // repeated bool boolValue = 7;
+  inline int boolvalue_size() const;
+  inline void clear_boolvalue();
+  static const int kBoolValueFieldNumber = 7;
+  inline bool boolvalue(int index) const;
+  inline void set_boolvalue(int index, bool value);
+  inline void add_boolvalue(bool value);
+  inline const ::google::protobuf::RepeatedField< bool >&
+      boolvalue() const;
+  inline ::google::protobuf::RepeatedField< bool >*
+      mutable_boolvalue();
+  
+  // repeated int64 int64Value = 8;
+  inline int int64value_size() const;
+  inline void clear_int64value();
+  static const int kInt64ValueFieldNumber = 8;
+  inline ::google::protobuf::int64 int64value(int index) const;
+  inline void set_int64value(int index, ::google::protobuf::int64 value);
+  inline void add_int64value(::google::protobuf::int64 value);
+  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
+      int64value() const;
+  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
+      mutable_int64value();
+  
+  // @@protoc_insertion_point(class_scope:android.gltrace.GLMessage.DataType)
+ private:
+  mutable int _cached_size_;
+  
+  int type_;
+  bool isarray_;
+  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > intvalue_;
+  ::google::protobuf::RepeatedField< float > floatvalue_;
+  ::google::protobuf::RepeatedPtrField< ::std::string> charvalue_;
+  ::google::protobuf::RepeatedPtrField< ::std::string> rawbytes_;
+  ::google::protobuf::RepeatedField< bool > boolvalue_;
+  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > int64value_;
+  friend void  protobuf_AddDesc_gltrace_2eproto();
+  friend void protobuf_AssignDesc_gltrace_2eproto();
+  friend void protobuf_ShutdownFile_gltrace_2eproto();
+  
+  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
+  
+  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
+  inline bool _has_bit(int index) const {
+    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
+  }
+  inline void _set_bit(int index) {
+    _has_bits_[index / 32] |= (1u << (index % 32));
+  }
+  inline void _clear_bit(int index) {
+    _has_bits_[index / 32] &= ~(1u << (index % 32));
+  }
+  
+  void InitAsDefaultInstance();
+  static GLMessage_DataType* default_instance_;
+};
+// -------------------------------------------------------------------
+
+class GLMessage_FrameBuffer : public ::google::protobuf::MessageLite {
+ public:
+  GLMessage_FrameBuffer();
+  virtual ~GLMessage_FrameBuffer();
+  
+  GLMessage_FrameBuffer(const GLMessage_FrameBuffer& from);
+  
+  inline GLMessage_FrameBuffer& operator=(const GLMessage_FrameBuffer& from) {
+    CopyFrom(from);
+    return *this;
+  }
+  
+  static const GLMessage_FrameBuffer& default_instance();
+  
+  void Swap(GLMessage_FrameBuffer* other);
+  
+  // implements Message ----------------------------------------------
+  
+  GLMessage_FrameBuffer* New() const;
+  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
+  void CopyFrom(const GLMessage_FrameBuffer& from);
+  void MergeFrom(const GLMessage_FrameBuffer& from);
+  void Clear();
+  bool IsInitialized() const;
+  
+  int ByteSize() const;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input);
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const;
+  int GetCachedSize() const { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const;
+  public:
+  
+  ::std::string GetTypeName() const;
+  
+  // nested types ----------------------------------------------------
+  
+  // accessors -------------------------------------------------------
+  
+  // required int32 width = 1;
+  inline bool has_width() const;
+  inline void clear_width();
+  static const int kWidthFieldNumber = 1;
+  inline ::google::protobuf::int32 width() const;
+  inline void set_width(::google::protobuf::int32 value);
+  
+  // required int32 height = 2;
+  inline bool has_height() const;
+  inline void clear_height();
+  static const int kHeightFieldNumber = 2;
+  inline ::google::protobuf::int32 height() const;
+  inline void set_height(::google::protobuf::int32 value);
+  
+  // repeated bytes contents = 3;
+  inline int contents_size() const;
+  inline void clear_contents();
+  static const int kContentsFieldNumber = 3;
+  inline const ::std::string& contents(int index) const;
+  inline ::std::string* mutable_contents(int index);
+  inline void set_contents(int index, const ::std::string& value);
+  inline void set_contents(int index, const char* value);
+  inline void set_contents(int index, const void* value, size_t size);
+  inline ::std::string* add_contents();
+  inline void add_contents(const ::std::string& value);
+  inline void add_contents(const char* value);
+  inline void add_contents(const void* value, size_t size);
+  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& contents() const;
+  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_contents();
+  
+  // @@protoc_insertion_point(class_scope:android.gltrace.GLMessage.FrameBuffer)
+ private:
+  mutable int _cached_size_;
+  
+  ::google::protobuf::int32 width_;
+  ::google::protobuf::int32 height_;
+  ::google::protobuf::RepeatedPtrField< ::std::string> contents_;
+  friend void  protobuf_AddDesc_gltrace_2eproto();
+  friend void protobuf_AssignDesc_gltrace_2eproto();
+  friend void protobuf_ShutdownFile_gltrace_2eproto();
+  
+  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
+  
+  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
+  inline bool _has_bit(int index) const {
+    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
+  }
+  inline void _set_bit(int index) {
+    _has_bits_[index / 32] |= (1u << (index % 32));
+  }
+  inline void _clear_bit(int index) {
+    _has_bits_[index / 32] &= ~(1u << (index % 32));
+  }
+  
+  void InitAsDefaultInstance();
+  static GLMessage_FrameBuffer* default_instance_;
+};
+// -------------------------------------------------------------------
+
+class GLMessage : public ::google::protobuf::MessageLite {
+ public:
+  GLMessage();
+  virtual ~GLMessage();
+  
+  GLMessage(const GLMessage& from);
+  
+  inline GLMessage& operator=(const GLMessage& from) {
+    CopyFrom(from);
+    return *this;
+  }
+  
+  static const GLMessage& default_instance();
+  
+  void Swap(GLMessage* other);
+  
+  // implements Message ----------------------------------------------
+  
+  GLMessage* New() const;
+  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
+  void CopyFrom(const GLMessage& from);
+  void MergeFrom(const GLMessage& from);
+  void Clear();
+  bool IsInitialized() const;
+  
+  int ByteSize() const;
+  bool MergePartialFromCodedStream(
+      ::google::protobuf::io::CodedInputStream* input);
+  void SerializeWithCachedSizes(
+      ::google::protobuf::io::CodedOutputStream* output) const;
+  int GetCachedSize() const { return _cached_size_; }
+  private:
+  void SharedCtor();
+  void SharedDtor();
+  void SetCachedSize(int size) const;
+  public:
+  
+  ::std::string GetTypeName() const;
+  
+  // nested types ----------------------------------------------------
+  
+  typedef GLMessage_DataType DataType;
+  typedef GLMessage_FrameBuffer FrameBuffer;
+  
+  typedef GLMessage_Function Function;
+  static const Function glActiveTexture = GLMessage_Function_glActiveTexture;
+  static const Function glAlphaFunc = GLMessage_Function_glAlphaFunc;
+  static const Function glAlphaFuncx = GLMessage_Function_glAlphaFuncx;
+  static const Function glAlphaFuncxOES = GLMessage_Function_glAlphaFuncxOES;
+  static const Function glAttachShader = GLMessage_Function_glAttachShader;
+  static const Function glBeginPerfMonitorAMD = GLMessage_Function_glBeginPerfMonitorAMD;
+  static const Function glBindAttribLocation = GLMessage_Function_glBindAttribLocation;
+  static const Function glBindBuffer = GLMessage_Function_glBindBuffer;
+  static const Function glBindFramebuffer = GLMessage_Function_glBindFramebuffer;
+  static const Function glBindFramebufferOES = GLMessage_Function_glBindFramebufferOES;
+  static const Function glBindRenderbuffer = GLMessage_Function_glBindRenderbuffer;
+  static const Function glBindRenderbufferOES = GLMessage_Function_glBindRenderbufferOES;
+  static const Function glBindTexture = GLMessage_Function_glBindTexture;
+  static const Function glBindVertexArrayOES = GLMessage_Function_glBindVertexArrayOES;
+  static const Function glBlendColor = GLMessage_Function_glBlendColor;
+  static const Function glBlendEquation = GLMessage_Function_glBlendEquation;
+  static const Function glBlendEquationOES = GLMessage_Function_glBlendEquationOES;
+  static const Function glBlendEquationSeparate = GLMessage_Function_glBlendEquationSeparate;
+  static const Function glBlendEquationSeparateOES = GLMessage_Function_glBlendEquationSeparateOES;
+  static const Function glBlendFunc = GLMessage_Function_glBlendFunc;
+  static const Function glBlendFuncSeparate = GLMessage_Function_glBlendFuncSeparate;
+  static const Function glBlendFuncSeparateOES = GLMessage_Function_glBlendFuncSeparateOES;
+  static const Function glBufferData = GLMessage_Function_glBufferData;
+  static const Function glBufferSubData = GLMessage_Function_glBufferSubData;
+  static const Function glCheckFramebufferStatus = GLMessage_Function_glCheckFramebufferStatus;
+  static const Function glCheckFramebufferStatusOES = GLMessage_Function_glCheckFramebufferStatusOES;
+  static const Function glClearColor = GLMessage_Function_glClearColor;
+  static const Function glClearColorx = GLMessage_Function_glClearColorx;
+  static const Function glClearColorxOES = GLMessage_Function_glClearColorxOES;
+  static const Function glClearDepthf = GLMessage_Function_glClearDepthf;
+  static const Function glClearDepthfOES = GLMessage_Function_glClearDepthfOES;
+  static const Function glClearDepthx = GLMessage_Function_glClearDepthx;
+  static const Function glClearDepthxOES = GLMessage_Function_glClearDepthxOES;
+  static const Function glClear = GLMessage_Function_glClear;
+  static const Function glClearStencil = GLMessage_Function_glClearStencil;
+  static const Function glClientActiveTexture = GLMessage_Function_glClientActiveTexture;
+  static const Function glClipPlanef = GLMessage_Function_glClipPlanef;
+  static const Function glClipPlanefIMG = GLMessage_Function_glClipPlanefIMG;
+  static const Function glClipPlanefOES = GLMessage_Function_glClipPlanefOES;
+  static const Function glClipPlanex = GLMessage_Function_glClipPlanex;
+  static const Function glClipPlanexIMG = GLMessage_Function_glClipPlanexIMG;
+  static const Function glClipPlanexOES = GLMessage_Function_glClipPlanexOES;
+  static const Function glColor4f = GLMessage_Function_glColor4f;
+  static const Function glColor4ub = GLMessage_Function_glColor4ub;
+  static const Function glColor4x = GLMessage_Function_glColor4x;
+  static const Function glColor4xOES = GLMessage_Function_glColor4xOES;
+  static const Function glColorMask = GLMessage_Function_glColorMask;
+  static const Function glColorPointer = GLMessage_Function_glColorPointer;
+  static const Function glCompileShader = GLMessage_Function_glCompileShader;
+  static const Function glCompressedTexImage2D = GLMessage_Function_glCompressedTexImage2D;
+  static const Function glCompressedTexImage3DOES = GLMessage_Function_glCompressedTexImage3DOES;
+  static const Function glCompressedTexSubImage2D = GLMessage_Function_glCompressedTexSubImage2D;
+  static const Function glCompressedTexSubImage3DOES = GLMessage_Function_glCompressedTexSubImage3DOES;
+  static const Function glCopyTexImage2D = GLMessage_Function_glCopyTexImage2D;
+  static const Function glCopyTexSubImage2D = GLMessage_Function_glCopyTexSubImage2D;
+  static const Function glCopyTexSubImage3DOES = GLMessage_Function_glCopyTexSubImage3DOES;
+  static const Function glCoverageMaskNV = GLMessage_Function_glCoverageMaskNV;
+  static const Function glCoverageOperationNV = GLMessage_Function_glCoverageOperationNV;
+  static const Function glCreateProgram = GLMessage_Function_glCreateProgram;
+  static const Function glCreateShader = GLMessage_Function_glCreateShader;
+  static const Function glCullFace = GLMessage_Function_glCullFace;
+  static const Function glCurrentPaletteMatrixOES = GLMessage_Function_glCurrentPaletteMatrixOES;
+  static const Function glDeleteBuffers = GLMessage_Function_glDeleteBuffers;
+  static const Function glDeleteFencesNV = GLMessage_Function_glDeleteFencesNV;
+  static const Function glDeleteFramebuffers = GLMessage_Function_glDeleteFramebuffers;
+  static const Function glDeleteFramebuffersOES = GLMessage_Function_glDeleteFramebuffersOES;
+  static const Function glDeletePerfMonitorsAMD = GLMessage_Function_glDeletePerfMonitorsAMD;
+  static const Function glDeleteProgram = GLMessage_Function_glDeleteProgram;
+  static const Function glDeleteRenderbuffers = GLMessage_Function_glDeleteRenderbuffers;
+  static const Function glDeleteRenderbuffersOES = GLMessage_Function_glDeleteRenderbuffersOES;
+  static const Function glDeleteShader = GLMessage_Function_glDeleteShader;
+  static const Function glDeleteTextures = GLMessage_Function_glDeleteTextures;
+  static const Function glDeleteVertexArraysOES = GLMessage_Function_glDeleteVertexArraysOES;
+  static const Function glDepthFunc = GLMessage_Function_glDepthFunc;
+  static const Function glDepthMask = GLMessage_Function_glDepthMask;
+  static const Function glDepthRangef = GLMessage_Function_glDepthRangef;
+  static const Function glDepthRangefOES = GLMessage_Function_glDepthRangefOES;
+  static const Function glDepthRangex = GLMessage_Function_glDepthRangex;
+  static const Function glDepthRangexOES = GLMessage_Function_glDepthRangexOES;
+  static const Function glDetachShader = GLMessage_Function_glDetachShader;
+  static const Function glDisableClientState = GLMessage_Function_glDisableClientState;
+  static const Function glDisableDriverControlQCOM = GLMessage_Function_glDisableDriverControlQCOM;
+  static const Function glDisable = GLMessage_Function_glDisable;
+  static const Function glDisableVertexAttribArray = GLMessage_Function_glDisableVertexAttribArray;
+  static const Function glDiscardFramebufferEXT = GLMessage_Function_glDiscardFramebufferEXT;
+  static const Function glDrawArrays = GLMessage_Function_glDrawArrays;
+  static const Function glDrawElements = GLMessage_Function_glDrawElements;
+  static const Function glDrawTexfOES = GLMessage_Function_glDrawTexfOES;
+  static const Function glDrawTexfvOES = GLMessage_Function_glDrawTexfvOES;
+  static const Function glDrawTexiOES = GLMessage_Function_glDrawTexiOES;
+  static const Function glDrawTexivOES = GLMessage_Function_glDrawTexivOES;
+  static const Function glDrawTexsOES = GLMessage_Function_glDrawTexsOES;
+  static const Function glDrawTexsvOES = GLMessage_Function_glDrawTexsvOES;
+  static const Function glDrawTexxOES = GLMessage_Function_glDrawTexxOES;
+  static const Function glDrawTexxvOES = GLMessage_Function_glDrawTexxvOES;
+  static const Function glEGLImageTargetRenderbufferStorageOES = GLMessage_Function_glEGLImageTargetRenderbufferStorageOES;
+  static const Function glEGLImageTargetTexture2DOES = GLMessage_Function_glEGLImageTargetTexture2DOES;
+  static const Function glEnableClientState = GLMessage_Function_glEnableClientState;
+  static const Function glEnableDriverControlQCOM = GLMessage_Function_glEnableDriverControlQCOM;
+  static const Function glEnable = GLMessage_Function_glEnable;
+  static const Function glEnableVertexAttribArray = GLMessage_Function_glEnableVertexAttribArray;
+  static const Function glEndPerfMonitorAMD = GLMessage_Function_glEndPerfMonitorAMD;
+  static const Function glEndTilingQCOM = GLMessage_Function_glEndTilingQCOM;
+  static const Function glExtGetBufferPointervQCOM = GLMessage_Function_glExtGetBufferPointervQCOM;
+  static const Function glExtGetBuffersQCOM = GLMessage_Function_glExtGetBuffersQCOM;
+  static const Function glExtGetFramebuffersQCOM = GLMessage_Function_glExtGetFramebuffersQCOM;
+  static const Function glExtGetProgramBinarySourceQCOM = GLMessage_Function_glExtGetProgramBinarySourceQCOM;
+  static const Function glExtGetProgramsQCOM = GLMessage_Function_glExtGetProgramsQCOM;
+  static const Function glExtGetRenderbuffersQCOM = GLMessage_Function_glExtGetRenderbuffersQCOM;
+  static const Function glExtGetShadersQCOM = GLMessage_Function_glExtGetShadersQCOM;
+  static const Function glExtGetTexLevelParameterivQCOM = GLMessage_Function_glExtGetTexLevelParameterivQCOM;
+  static const Function glExtGetTexSubImageQCOM = GLMessage_Function_glExtGetTexSubImageQCOM;
+  static const Function glExtGetTexturesQCOM = GLMessage_Function_glExtGetTexturesQCOM;
+  static const Function glExtIsProgramBinaryQCOM = GLMessage_Function_glExtIsProgramBinaryQCOM;
+  static const Function glExtTexObjectStateOverrideiQCOM = GLMessage_Function_glExtTexObjectStateOverrideiQCOM;
+  static const Function glFinishFenceNV = GLMessage_Function_glFinishFenceNV;
+  static const Function glFinish = GLMessage_Function_glFinish;
+  static const Function glFlush = GLMessage_Function_glFlush;
+  static const Function glFogf = GLMessage_Function_glFogf;
+  static const Function glFogfv = GLMessage_Function_glFogfv;
+  static const Function glFogx = GLMessage_Function_glFogx;
+  static const Function glFogxOES = GLMessage_Function_glFogxOES;
+  static const Function glFogxv = GLMessage_Function_glFogxv;
+  static const Function glFogxvOES = GLMessage_Function_glFogxvOES;
+  static const Function glFramebufferRenderbuffer = GLMessage_Function_glFramebufferRenderbuffer;
+  static const Function glFramebufferRenderbufferOES = GLMessage_Function_glFramebufferRenderbufferOES;
+  static const Function glFramebufferTexture2D = GLMessage_Function_glFramebufferTexture2D;
+  static const Function glFramebufferTexture2DMultisampleIMG = GLMessage_Function_glFramebufferTexture2DMultisampleIMG;
+  static const Function glFramebufferTexture2DOES = GLMessage_Function_glFramebufferTexture2DOES;
+  static const Function glFramebufferTexture3DOES = GLMessage_Function_glFramebufferTexture3DOES;
+  static const Function glFrontFace = GLMessage_Function_glFrontFace;
+  static const Function glFrustumf = GLMessage_Function_glFrustumf;
+  static const Function glFrustumfOES = GLMessage_Function_glFrustumfOES;
+  static const Function glFrustumx = GLMessage_Function_glFrustumx;
+  static const Function glFrustumxOES = GLMessage_Function_glFrustumxOES;
+  static const Function glGenBuffers = GLMessage_Function_glGenBuffers;
+  static const Function glGenerateMipmap = GLMessage_Function_glGenerateMipmap;
+  static const Function glGenerateMipmapOES = GLMessage_Function_glGenerateMipmapOES;
+  static const Function glGenFencesNV = GLMessage_Function_glGenFencesNV;
+  static const Function glGenFramebuffers = GLMessage_Function_glGenFramebuffers;
+  static const Function glGenFramebuffersOES = GLMessage_Function_glGenFramebuffersOES;
+  static const Function glGenPerfMonitorsAMD = GLMessage_Function_glGenPerfMonitorsAMD;
+  static const Function glGenRenderbuffers = GLMessage_Function_glGenRenderbuffers;
+  static const Function glGenRenderbuffersOES = GLMessage_Function_glGenRenderbuffersOES;
+  static const Function glGenTextures = GLMessage_Function_glGenTextures;
+  static const Function glGenVertexArraysOES = GLMessage_Function_glGenVertexArraysOES;
+  static const Function glGetActiveAttrib = GLMessage_Function_glGetActiveAttrib;
+  static const Function glGetActiveUniform = GLMessage_Function_glGetActiveUniform;
+  static const Function glGetAttachedShaders = GLMessage_Function_glGetAttachedShaders;
+  static const Function glGetAttribLocation = GLMessage_Function_glGetAttribLocation;
+  static const Function glGetBooleanv = GLMessage_Function_glGetBooleanv;
+  static const Function glGetBufferParameteriv = GLMessage_Function_glGetBufferParameteriv;
+  static const Function glGetBufferPointervOES = GLMessage_Function_glGetBufferPointervOES;
+  static const Function glGetClipPlanef = GLMessage_Function_glGetClipPlanef;
+  static const Function glGetClipPlanefOES = GLMessage_Function_glGetClipPlanefOES;
+  static const Function glGetClipPlanex = GLMessage_Function_glGetClipPlanex;
+  static const Function glGetClipPlanexOES = GLMessage_Function_glGetClipPlanexOES;
+  static const Function glGetDriverControlsQCOM = GLMessage_Function_glGetDriverControlsQCOM;
+  static const Function glGetDriverControlStringQCOM = GLMessage_Function_glGetDriverControlStringQCOM;
+  static const Function glGetError = GLMessage_Function_glGetError;
+  static const Function glGetFenceivNV = GLMessage_Function_glGetFenceivNV;
+  static const Function glGetFixedv = GLMessage_Function_glGetFixedv;
+  static const Function glGetFixedvOES = GLMessage_Function_glGetFixedvOES;
+  static const Function glGetFloatv = GLMessage_Function_glGetFloatv;
+  static const Function glGetFramebufferAttachmentParameteriv = GLMessage_Function_glGetFramebufferAttachmentParameteriv;
+  static const Function glGetFramebufferAttachmentParameterivOES = GLMessage_Function_glGetFramebufferAttachmentParameterivOES;
+  static const Function glGetIntegerv = GLMessage_Function_glGetIntegerv;
+  static const Function glGetLightfv = GLMessage_Function_glGetLightfv;
+  static const Function glGetLightxv = GLMessage_Function_glGetLightxv;
+  static const Function glGetLightxvOES = GLMessage_Function_glGetLightxvOES;
+  static const Function glGetMaterialfv = GLMessage_Function_glGetMaterialfv;
+  static const Function glGetMaterialxv = GLMessage_Function_glGetMaterialxv;
+  static const Function glGetMaterialxvOES = GLMessage_Function_glGetMaterialxvOES;
+  static const Function glGetPerfMonitorCounterDataAMD = GLMessage_Function_glGetPerfMonitorCounterDataAMD;
+  static const Function glGetPerfMonitorCounterInfoAMD = GLMessage_Function_glGetPerfMonitorCounterInfoAMD;
+  static const Function glGetPerfMonitorCountersAMD = GLMessage_Function_glGetPerfMonitorCountersAMD;
+  static const Function glGetPerfMonitorCounterStringAMD = GLMessage_Function_glGetPerfMonitorCounterStringAMD;
+  static const Function glGetPerfMonitorGroupsAMD = GLMessage_Function_glGetPerfMonitorGroupsAMD;
+  static const Function glGetPerfMonitorGroupStringAMD = GLMessage_Function_glGetPerfMonitorGroupStringAMD;
+  static const Function glGetPointerv = GLMessage_Function_glGetPointerv;
+  static const Function glGetProgramBinaryOES = GLMessage_Function_glGetProgramBinaryOES;
+  static const Function glGetProgramInfoLog = GLMessage_Function_glGetProgramInfoLog;
+  static const Function glGetProgramiv = GLMessage_Function_glGetProgramiv;
+  static const Function glGetRenderbufferParameteriv = GLMessage_Function_glGetRenderbufferParameteriv;
+  static const Function glGetRenderbufferParameterivOES = GLMessage_Function_glGetRenderbufferParameterivOES;
+  static const Function glGetShaderInfoLog = GLMessage_Function_glGetShaderInfoLog;
+  static const Function glGetShaderiv = GLMessage_Function_glGetShaderiv;
+  static const Function glGetShaderPrecisionFormat = GLMessage_Function_glGetShaderPrecisionFormat;
+  static const Function glGetShaderSource = GLMessage_Function_glGetShaderSource;
+  static const Function glGetString = GLMessage_Function_glGetString;
+  static const Function glGetTexEnvfv = GLMessage_Function_glGetTexEnvfv;
+  static const Function glGetTexEnviv = GLMessage_Function_glGetTexEnviv;
+  static const Function glGetTexEnvxv = GLMessage_Function_glGetTexEnvxv;
+  static const Function glGetTexEnvxvOES = GLMessage_Function_glGetTexEnvxvOES;
+  static const Function glGetTexGenfvOES = GLMessage_Function_glGetTexGenfvOES;
+  static const Function glGetTexGenivOES = GLMessage_Function_glGetTexGenivOES;
+  static const Function glGetTexGenxvOES = GLMessage_Function_glGetTexGenxvOES;
+  static const Function glGetTexParameterfv = GLMessage_Function_glGetTexParameterfv;
+  static const Function glGetTexParameteriv = GLMessage_Function_glGetTexParameteriv;
+  static const Function glGetTexParameterxv = GLMessage_Function_glGetTexParameterxv;
+  static const Function glGetTexParameterxvOES = GLMessage_Function_glGetTexParameterxvOES;
+  static const Function glGetUniformfv = GLMessage_Function_glGetUniformfv;
+  static const Function glGetUniformiv = GLMessage_Function_glGetUniformiv;
+  static const Function glGetUniformLocation = GLMessage_Function_glGetUniformLocation;
+  static const Function glGetVertexAttribfv = GLMessage_Function_glGetVertexAttribfv;
+  static const Function glGetVertexAttribiv = GLMessage_Function_glGetVertexAttribiv;
+  static const Function glGetVertexAttribPointerv = GLMessage_Function_glGetVertexAttribPointerv;
+  static const Function glHint = GLMessage_Function_glHint;
+  static const Function glIsBuffer = GLMessage_Function_glIsBuffer;
+  static const Function glIsEnabled = GLMessage_Function_glIsEnabled;
+  static const Function glIsFenceNV = GLMessage_Function_glIsFenceNV;
+  static const Function glIsFramebuffer = GLMessage_Function_glIsFramebuffer;
+  static const Function glIsFramebufferOES = GLMessage_Function_glIsFramebufferOES;
+  static const Function glIsProgram = GLMessage_Function_glIsProgram;
+  static const Function glIsRenderbuffer = GLMessage_Function_glIsRenderbuffer;
+  static const Function glIsRenderbufferOES = GLMessage_Function_glIsRenderbufferOES;
+  static const Function glIsShader = GLMessage_Function_glIsShader;
+  static const Function glIsTexture = GLMessage_Function_glIsTexture;
+  static const Function glIsVertexArrayOES = GLMessage_Function_glIsVertexArrayOES;
+  static const Function glLightf = GLMessage_Function_glLightf;
+  static const Function glLightfv = GLMessage_Function_glLightfv;
+  static const Function glLightModelf = GLMessage_Function_glLightModelf;
+  static const Function glLightModelfv = GLMessage_Function_glLightModelfv;
+  static const Function glLightModelx = GLMessage_Function_glLightModelx;
+  static const Function glLightModelxOES = GLMessage_Function_glLightModelxOES;
+  static const Function glLightModelxv = GLMessage_Function_glLightModelxv;
+  static const Function glLightModelxvOES = GLMessage_Function_glLightModelxvOES;
+  static const Function glLightx = GLMessage_Function_glLightx;
+  static const Function glLightxOES = GLMessage_Function_glLightxOES;
+  static const Function glLightxv = GLMessage_Function_glLightxv;
+  static const Function glLightxvOES = GLMessage_Function_glLightxvOES;
+  static const Function glLineWidth = GLMessage_Function_glLineWidth;
+  static const Function glLineWidthx = GLMessage_Function_glLineWidthx;
+  static const Function glLineWidthxOES = GLMessage_Function_glLineWidthxOES;
+  static const Function glLinkProgram = GLMessage_Function_glLinkProgram;
+  static const Function glLoadIdentity = GLMessage_Function_glLoadIdentity;
+  static const Function glLoadMatrixf = GLMessage_Function_glLoadMatrixf;
+  static const Function glLoadMatrixx = GLMessage_Function_glLoadMatrixx;
+  static const Function glLoadMatrixxOES = GLMessage_Function_glLoadMatrixxOES;
+  static const Function glLoadPaletteFromModelViewMatrixOES = GLMessage_Function_glLoadPaletteFromModelViewMatrixOES;
+  static const Function glLogicOp = GLMessage_Function_glLogicOp;
+  static const Function glMapBufferOES = GLMessage_Function_glMapBufferOES;
+  static const Function glMaterialf = GLMessage_Function_glMaterialf;
+  static const Function glMaterialfv = GLMessage_Function_glMaterialfv;
+  static const Function glMaterialx = GLMessage_Function_glMaterialx;
+  static const Function glMaterialxOES = GLMessage_Function_glMaterialxOES;
+  static const Function glMaterialxv = GLMessage_Function_glMaterialxv;
+  static const Function glMaterialxvOES = GLMessage_Function_glMaterialxvOES;
+  static const Function glMatrixIndexPointerOES = GLMessage_Function_glMatrixIndexPointerOES;
+  static const Function glMatrixMode = GLMessage_Function_glMatrixMode;
+  static const Function glMultiDrawArraysEXT = GLMessage_Function_glMultiDrawArraysEXT;
+  static const Function glMultiDrawElementsEXT = GLMessage_Function_glMultiDrawElementsEXT;
+  static const Function glMultiTexCoord4f = GLMessage_Function_glMultiTexCoord4f;
+  static const Function glMultiTexCoord4x = GLMessage_Function_glMultiTexCoord4x;
+  static const Function glMultiTexCoord4xOES = GLMessage_Function_glMultiTexCoord4xOES;
+  static const Function glMultMatrixf = GLMessage_Function_glMultMatrixf;
+  static const Function glMultMatrixx = GLMessage_Function_glMultMatrixx;
+  static const Function glMultMatrixxOES = GLMessage_Function_glMultMatrixxOES;
+  static const Function glNormal3f = GLMessage_Function_glNormal3f;
+  static const Function glNormal3x = GLMessage_Function_glNormal3x;
+  static const Function glNormal3xOES = GLMessage_Function_glNormal3xOES;
+  static const Function glNormalPointer = GLMessage_Function_glNormalPointer;
+  static const Function glOrthof = GLMessage_Function_glOrthof;
+  static const Function glOrthofOES = GLMessage_Function_glOrthofOES;
+  static const Function glOrthox = GLMessage_Function_glOrthox;
+  static const Function glOrthoxOES = GLMessage_Function_glOrthoxOES;
+  static const Function glPixelStorei = GLMessage_Function_glPixelStorei;
+  static const Function glPointParameterf = GLMessage_Function_glPointParameterf;
+  static const Function glPointParameterfv = GLMessage_Function_glPointParameterfv;
+  static const Function glPointParameterx = GLMessage_Function_glPointParameterx;
+  static const Function glPointParameterxOES = GLMessage_Function_glPointParameterxOES;
+  static const Function glPointParameterxv = GLMessage_Function_glPointParameterxv;
+  static const Function glPointParameterxvOES = GLMessage_Function_glPointParameterxvOES;
+  static const Function glPointSize = GLMessage_Function_glPointSize;
+  static const Function glPointSizePointerOES = GLMessage_Function_glPointSizePointerOES;
+  static const Function glPointSizex = GLMessage_Function_glPointSizex;
+  static const Function glPointSizexOES = GLMessage_Function_glPointSizexOES;
+  static const Function glPolygonOffset = GLMessage_Function_glPolygonOffset;
+  static const Function glPolygonOffsetx = GLMessage_Function_glPolygonOffsetx;
+  static const Function glPolygonOffsetxOES = GLMessage_Function_glPolygonOffsetxOES;
+  static const Function glPopMatrix = GLMessage_Function_glPopMatrix;
+  static const Function glProgramBinaryOES = GLMessage_Function_glProgramBinaryOES;
+  static const Function glPushMatrix = GLMessage_Function_glPushMatrix;
+  static const Function glQueryMatrixxOES = GLMessage_Function_glQueryMatrixxOES;
+  static const Function glReadPixels = GLMessage_Function_glReadPixels;
+  static const Function glReleaseShaderCompiler = GLMessage_Function_glReleaseShaderCompiler;
+  static const Function glRenderbufferStorage = GLMessage_Function_glRenderbufferStorage;
+  static const Function glRenderbufferStorageMultisampleIMG = GLMessage_Function_glRenderbufferStorageMultisampleIMG;
+  static const Function glRenderbufferStorageOES = GLMessage_Function_glRenderbufferStorageOES;
+  static const Function glRotatef = GLMessage_Function_glRotatef;
+  static const Function glRotatex = GLMessage_Function_glRotatex;
+  static const Function glRotatexOES = GLMessage_Function_glRotatexOES;
+  static const Function glSampleCoverage = GLMessage_Function_glSampleCoverage;
+  static const Function glSampleCoveragex = GLMessage_Function_glSampleCoveragex;
+  static const Function glSampleCoveragexOES = GLMessage_Function_glSampleCoveragexOES;
+  static const Function glScalef = GLMessage_Function_glScalef;
+  static const Function glScalex = GLMessage_Function_glScalex;
+  static const Function glScalexOES = GLMessage_Function_glScalexOES;
+  static const Function glScissor = GLMessage_Function_glScissor;
+  static const Function glSelectPerfMonitorCountersAMD = GLMessage_Function_glSelectPerfMonitorCountersAMD;
+  static const Function glSetFenceNV = GLMessage_Function_glSetFenceNV;
+  static const Function glShadeModel = GLMessage_Function_glShadeModel;
+  static const Function glShaderBinary = GLMessage_Function_glShaderBinary;
+  static const Function glShaderSource = GLMessage_Function_glShaderSource;
+  static const Function glStartTilingQCOM = GLMessage_Function_glStartTilingQCOM;
+  static const Function glStencilFunc = GLMessage_Function_glStencilFunc;
+  static const Function glStencilFuncSeparate = GLMessage_Function_glStencilFuncSeparate;
+  static const Function glStencilMask = GLMessage_Function_glStencilMask;
+  static const Function glStencilMaskSeparate = GLMessage_Function_glStencilMaskSeparate;
+  static const Function glStencilOp = GLMessage_Function_glStencilOp;
+  static const Function glStencilOpSeparate = GLMessage_Function_glStencilOpSeparate;
+  static const Function glTestFenceNV = GLMessage_Function_glTestFenceNV;
+  static const Function glTexCoordPointer = GLMessage_Function_glTexCoordPointer;
+  static const Function glTexEnvf = GLMessage_Function_glTexEnvf;
+  static const Function glTexEnvfv = GLMessage_Function_glTexEnvfv;
+  static const Function glTexEnvi = GLMessage_Function_glTexEnvi;
+  static const Function glTexEnviv = GLMessage_Function_glTexEnviv;
+  static const Function glTexEnvx = GLMessage_Function_glTexEnvx;
+  static const Function glTexEnvxOES = GLMessage_Function_glTexEnvxOES;
+  static const Function glTexEnvxv = GLMessage_Function_glTexEnvxv;
+  static const Function glTexEnvxvOES = GLMessage_Function_glTexEnvxvOES;
+  static const Function glTexGenfOES = GLMessage_Function_glTexGenfOES;
+  static const Function glTexGenfvOES = GLMessage_Function_glTexGenfvOES;
+  static const Function glTexGeniOES = GLMessage_Function_glTexGeniOES;
+  static const Function glTexGenivOES = GLMessage_Function_glTexGenivOES;
+  static const Function glTexGenxOES = GLMessage_Function_glTexGenxOES;
+  static const Function glTexGenxvOES = GLMessage_Function_glTexGenxvOES;
+  static const Function glTexImage2D = GLMessage_Function_glTexImage2D;
+  static const Function glTexImage3DOES = GLMessage_Function_glTexImage3DOES;
+  static const Function glTexParameterf = GLMessage_Function_glTexParameterf;
+  static const Function glTexParameterfv = GLMessage_Function_glTexParameterfv;
+  static const Function glTexParameteri = GLMessage_Function_glTexParameteri;
+  static const Function glTexParameteriv = GLMessage_Function_glTexParameteriv;
+  static const Function glTexParameterx = GLMessage_Function_glTexParameterx;
+  static const Function glTexParameterxOES = GLMessage_Function_glTexParameterxOES;
+  static const Function glTexParameterxv = GLMessage_Function_glTexParameterxv;
+  static const Function glTexParameterxvOES = GLMessage_Function_glTexParameterxvOES;
+  static const Function glTexSubImage2D = GLMessage_Function_glTexSubImage2D;
+  static const Function glTexSubImage3DOES = GLMessage_Function_glTexSubImage3DOES;
+  static const Function glTranslatef = GLMessage_Function_glTranslatef;
+  static const Function glTranslatex = GLMessage_Function_glTranslatex;
+  static const Function glTranslatexOES = GLMessage_Function_glTranslatexOES;
+  static const Function glUniform1f = GLMessage_Function_glUniform1f;
+  static const Function glUniform1fv = GLMessage_Function_glUniform1fv;
+  static const Function glUniform1i = GLMessage_Function_glUniform1i;
+  static const Function glUniform1iv = GLMessage_Function_glUniform1iv;
+  static const Function glUniform2f = GLMessage_Function_glUniform2f;
+  static const Function glUniform2fv = GLMessage_Function_glUniform2fv;
+  static const Function glUniform2i = GLMessage_Function_glUniform2i;
+  static const Function glUniform2iv = GLMessage_Function_glUniform2iv;
+  static const Function glUniform3f = GLMessage_Function_glUniform3f;
+  static const Function glUniform3fv = GLMessage_Function_glUniform3fv;
+  static const Function glUniform3i = GLMessage_Function_glUniform3i;
+  static const Function glUniform3iv = GLMessage_Function_glUniform3iv;
+  static const Function glUniform4f = GLMessage_Function_glUniform4f;
+  static const Function glUniform4fv = GLMessage_Function_glUniform4fv;
+  static const Function glUniform4i = GLMessage_Function_glUniform4i;
+  static const Function glUniform4iv = GLMessage_Function_glUniform4iv;
+  static const Function glUniformMatrix2fv = GLMessage_Function_glUniformMatrix2fv;
+  static const Function glUniformMatrix3fv = GLMessage_Function_glUniformMatrix3fv;
+  static const Function glUniformMatrix4fv = GLMessage_Function_glUniformMatrix4fv;
+  static const Function glUnmapBufferOES = GLMessage_Function_glUnmapBufferOES;
+  static const Function glUseProgram = GLMessage_Function_glUseProgram;
+  static const Function glValidateProgram = GLMessage_Function_glValidateProgram;
+  static const Function glVertexAttrib1f = GLMessage_Function_glVertexAttrib1f;
+  static const Function glVertexAttrib1fv = GLMessage_Function_glVertexAttrib1fv;
+  static const Function glVertexAttrib2f = GLMessage_Function_glVertexAttrib2f;
+  static const Function glVertexAttrib2fv = GLMessage_Function_glVertexAttrib2fv;
+  static const Function glVertexAttrib3f = GLMessage_Function_glVertexAttrib3f;
+  static const Function glVertexAttrib3fv = GLMessage_Function_glVertexAttrib3fv;
+  static const Function glVertexAttrib4f = GLMessage_Function_glVertexAttrib4f;
+  static const Function glVertexAttrib4fv = GLMessage_Function_glVertexAttrib4fv;
+  static const Function glVertexAttribPointer = GLMessage_Function_glVertexAttribPointer;
+  static const Function glVertexPointer = GLMessage_Function_glVertexPointer;
+  static const Function glViewport = GLMessage_Function_glViewport;
+  static const Function glWeightPointerOES = GLMessage_Function_glWeightPointerOES;
+  static const Function glReadBuffer = GLMessage_Function_glReadBuffer;
+  static const Function glDrawRangeElements = GLMessage_Function_glDrawRangeElements;
+  static const Function glTexImage3D = GLMessage_Function_glTexImage3D;
+  static const Function glTexSubImage3D = GLMessage_Function_glTexSubImage3D;
+  static const Function glCopyTexSubImage3D = GLMessage_Function_glCopyTexSubImage3D;
+  static const Function glCompressedTexImage3D = GLMessage_Function_glCompressedTexImage3D;
+  static const Function glCompressedTexSubImage3D = GLMessage_Function_glCompressedTexSubImage3D;
+  static const Function glGenQueries = GLMessage_Function_glGenQueries;
+  static const Function glDeleteQueries = GLMessage_Function_glDeleteQueries;
+  static const Function glIsQuery = GLMessage_Function_glIsQuery;
+  static const Function glBeginQuery = GLMessage_Function_glBeginQuery;
+  static const Function glEndQuery = GLMessage_Function_glEndQuery;
+  static const Function glGetQueryiv = GLMessage_Function_glGetQueryiv;
+  static const Function glGetQueryObjectuiv = GLMessage_Function_glGetQueryObjectuiv;
+  static const Function glUnmapBuffer = GLMessage_Function_glUnmapBuffer;
+  static const Function glGetBufferPointerv = GLMessage_Function_glGetBufferPointerv;
+  static const Function glDrawBuffers = GLMessage_Function_glDrawBuffers;
+  static const Function glUniformMatrix2x3fv = GLMessage_Function_glUniformMatrix2x3fv;
+  static const Function glUniformMatrix3x2fv = GLMessage_Function_glUniformMatrix3x2fv;
+  static const Function glUniformMatrix2x4fv = GLMessage_Function_glUniformMatrix2x4fv;
+  static const Function glUniformMatrix4x2fv = GLMessage_Function_glUniformMatrix4x2fv;
+  static const Function glUniformMatrix3x4fv = GLMessage_Function_glUniformMatrix3x4fv;
+  static const Function glUniformMatrix4x3fv = GLMessage_Function_glUniformMatrix4x3fv;
+  static const Function glBlitFramebuffer = GLMessage_Function_glBlitFramebuffer;
+  static const Function glRenderbufferStorageMultisample = GLMessage_Function_glRenderbufferStorageMultisample;
+  static const Function glFramebufferTextureLayer = GLMessage_Function_glFramebufferTextureLayer;
+  static const Function glMapBufferRange = GLMessage_Function_glMapBufferRange;
+  static const Function glFlushMappedBufferRange = GLMessage_Function_glFlushMappedBufferRange;
+  static const Function glBindVertexArray = GLMessage_Function_glBindVertexArray;
+  static const Function glDeleteVertexArrays = GLMessage_Function_glDeleteVertexArrays;
+  static const Function glGenVertexArrays = GLMessage_Function_glGenVertexArrays;
+  static const Function glIsVertexArray = GLMessage_Function_glIsVertexArray;
+  static const Function glGetIntegeri_v = GLMessage_Function_glGetIntegeri_v;
+  static const Function glBeginTransformFeedback = GLMessage_Function_glBeginTransformFeedback;
+  static const Function glEndTransformFeedback = GLMessage_Function_glEndTransformFeedback;
+  static const Function glBindBufferRange = GLMessage_Function_glBindBufferRange;
+  static const Function glBindBufferBase = GLMessage_Function_glBindBufferBase;
+  static const Function glTransformFeedbackVaryings = GLMessage_Function_glTransformFeedbackVaryings;
+  static const Function glGetTransformFeedbackVarying = GLMessage_Function_glGetTransformFeedbackVarying;
+  static const Function glVertexAttribIPointer = GLMessage_Function_glVertexAttribIPointer;
+  static const Function glGetVertexAttribIiv = GLMessage_Function_glGetVertexAttribIiv;
+  static const Function glGetVertexAttribIuiv = GLMessage_Function_glGetVertexAttribIuiv;
+  static const Function glVertexAttribI4i = GLMessage_Function_glVertexAttribI4i;
+  static const Function glVertexAttribI4ui = GLMessage_Function_glVertexAttribI4ui;
+  static const Function glVertexAttribI4iv = GLMessage_Function_glVertexAttribI4iv;
+  static const Function glVertexAttribI4uiv = GLMessage_Function_glVertexAttribI4uiv;
+  static const Function glGetUniformuiv = GLMessage_Function_glGetUniformuiv;
+  static const Function glGetFragDataLocation = GLMessage_Function_glGetFragDataLocation;
+  static const Function glUniform1ui = GLMessage_Function_glUniform1ui;
+  static const Function glUniform2ui = GLMessage_Function_glUniform2ui;
+  static const Function glUniform3ui = GLMessage_Function_glUniform3ui;
+  static const Function glUniform4ui = GLMessage_Function_glUniform4ui;
+  static const Function glUniform1uiv = GLMessage_Function_glUniform1uiv;
+  static const Function glUniform2uiv = GLMessage_Function_glUniform2uiv;
+  static const Function glUniform3uiv = GLMessage_Function_glUniform3uiv;
+  static const Function glUniform4uiv = GLMessage_Function_glUniform4uiv;
+  static const Function glClearBufferiv = GLMessage_Function_glClearBufferiv;
+  static const Function glClearBufferuiv = GLMessage_Function_glClearBufferuiv;
+  static const Function glClearBufferfv = GLMessage_Function_glClearBufferfv;
+  static const Function glClearBufferfi = GLMessage_Function_glClearBufferfi;
+  static const Function glGetStringi = GLMessage_Function_glGetStringi;
+  static const Function glCopyBufferSubData = GLMessage_Function_glCopyBufferSubData;
+  static const Function glGetUniformIndices = GLMessage_Function_glGetUniformIndices;
+  static const Function glGetActiveUniformsiv = GLMessage_Function_glGetActiveUniformsiv;
+  static const Function glGetUniformBlockIndex = GLMessage_Function_glGetUniformBlockIndex;
+  static const Function glGetActiveUniformBlockiv = GLMessage_Function_glGetActiveUniformBlockiv;
+  static const Function glGetActiveUniformBlockName = GLMessage_Function_glGetActiveUniformBlockName;
+  static const Function glUniformBlockBinding = GLMessage_Function_glUniformBlockBinding;
+  static const Function glDrawArraysInstanced = GLMessage_Function_glDrawArraysInstanced;
+  static const Function glDrawElementsInstanced = GLMessage_Function_glDrawElementsInstanced;
+  static const Function glFenceSync = GLMessage_Function_glFenceSync;
+  static const Function glIsSync = GLMessage_Function_glIsSync;
+  static const Function glDeleteSync = GLMessage_Function_glDeleteSync;
+  static const Function glClientWaitSync = GLMessage_Function_glClientWaitSync;
+  static const Function glWaitSync = GLMessage_Function_glWaitSync;
+  static const Function glGetInteger64v = GLMessage_Function_glGetInteger64v;
+  static const Function glGetSynciv = GLMessage_Function_glGetSynciv;
+  static const Function glGetInteger64i_v = GLMessage_Function_glGetInteger64i_v;
+  static const Function glGetBufferParameteri64v = GLMessage_Function_glGetBufferParameteri64v;
+  static const Function glGenSamplers = GLMessage_Function_glGenSamplers;
+  static const Function glDeleteSamplers = GLMessage_Function_glDeleteSamplers;
+  static const Function glIsSampler = GLMessage_Function_glIsSampler;
+  static const Function glBindSampler = GLMessage_Function_glBindSampler;
+  static const Function glSamplerParameteri = GLMessage_Function_glSamplerParameteri;
+  static const Function glSamplerParameteriv = GLMessage_Function_glSamplerParameteriv;
+  static const Function glSamplerParameterf = GLMessage_Function_glSamplerParameterf;
+  static const Function glSamplerParameterfv = GLMessage_Function_glSamplerParameterfv;
+  static const Function glGetSamplerParameteriv = GLMessage_Function_glGetSamplerParameteriv;
+  static const Function glGetSamplerParameterfv = GLMessage_Function_glGetSamplerParameterfv;
+  static const Function glVertexAttribDivisor = GLMessage_Function_glVertexAttribDivisor;
+  static const Function glBindTransformFeedback = GLMessage_Function_glBindTransformFeedback;
+  static const Function glDeleteTransformFeedbacks = GLMessage_Function_glDeleteTransformFeedbacks;
+  static const Function glGenTransformFeedbacks = GLMessage_Function_glGenTransformFeedbacks;
+  static const Function glIsTransformFeedback = GLMessage_Function_glIsTransformFeedback;
+  static const Function glPauseTransformFeedback = GLMessage_Function_glPauseTransformFeedback;
+  static const Function glResumeTransformFeedback = GLMessage_Function_glResumeTransformFeedback;
+  static const Function glGetProgramBinary = GLMessage_Function_glGetProgramBinary;
+  static const Function glProgramBinary = GLMessage_Function_glProgramBinary;
+  static const Function glProgramParameteri = GLMessage_Function_glProgramParameteri;
+  static const Function glInvalidateFramebuffer = GLMessage_Function_glInvalidateFramebuffer;
+  static const Function glInvalidateSubFramebuffer = GLMessage_Function_glInvalidateSubFramebuffer;
+  static const Function glTexStorage2D = GLMessage_Function_glTexStorage2D;
+  static const Function glTexStorage3D = GLMessage_Function_glTexStorage3D;
+  static const Function glGetInternalformativ = GLMessage_Function_glGetInternalformativ;
+  static const Function glBeginPerfQueryINTEL = GLMessage_Function_glBeginPerfQueryINTEL;
+  static const Function glCreatePerfQueryINTEL = GLMessage_Function_glCreatePerfQueryINTEL;
+  static const Function glDeletePerfQueryINTEL = GLMessage_Function_glDeletePerfQueryINTEL;
+  static const Function glEndPerfQueryINTEL = GLMessage_Function_glEndPerfQueryINTEL;
+  static const Function glGetFirstPerfQueryIdINTEL = GLMessage_Function_glGetFirstPerfQueryIdINTEL;
+  static const Function glGetNextPerfQueryIdINTEL = GLMessage_Function_glGetNextPerfQueryIdINTEL;
+  static const Function glGetPerfCounterInfoINTEL = GLMessage_Function_glGetPerfCounterInfoINTEL;
+  static const Function glGetPerfQueryDataINTEL = GLMessage_Function_glGetPerfQueryDataINTEL;
+  static const Function glGetPerfQueryIdByNameINTEL = GLMessage_Function_glGetPerfQueryIdByNameINTEL;
+  static const Function glGetPerfQueryInfoINTEL = GLMessage_Function_glGetPerfQueryInfoINTEL;
+  static const Function glBlendBarrierKHR = GLMessage_Function_glBlendBarrierKHR;
+  static const Function glBlendBarrierNV = GLMessage_Function_glBlendBarrierNV;
+  static const Function glBlendParameteriNV = GLMessage_Function_glBlendParameteriNV;
+  static const Function glBlitFramebufferNV = GLMessage_Function_glBlitFramebufferNV;
+  static const Function glFenceSyncAPPLE = GLMessage_Function_glFenceSyncAPPLE;
+  static const Function glIsSyncAPPLE = GLMessage_Function_glIsSyncAPPLE;
+  static const Function glDeleteSyncAPPLE = GLMessage_Function_glDeleteSyncAPPLE;
+  static const Function glClientWaitSyncAPPLE = GLMessage_Function_glClientWaitSyncAPPLE;
+  static const Function glWaitSyncAPPLE = GLMessage_Function_glWaitSyncAPPLE;
+  static const Function glGetInteger64vAPPLE = GLMessage_Function_glGetInteger64vAPPLE;
+  static const Function glGetSyncivAPPLE = GLMessage_Function_glGetSyncivAPPLE;
+  static const Function glCopyBufferSubDataNV = GLMessage_Function_glCopyBufferSubDataNV;
+  static const Function glActiveShaderProgramEXT = GLMessage_Function_glActiveShaderProgramEXT;
+  static const Function glAlphaFuncQCOM = GLMessage_Function_glAlphaFuncQCOM;
+  static const Function glBeginQueryEXT = GLMessage_Function_glBeginQueryEXT;
+  static const Function glBindProgramPipelineEXT = GLMessage_Function_glBindProgramPipelineEXT;
+  static const Function glBlitFramebufferANGLE = GLMessage_Function_glBlitFramebufferANGLE;
+  static const Function glCreateShaderProgramvEXT = GLMessage_Function_glCreateShaderProgramvEXT;
+  static const Function glDeleteProgramPipelinesEXT = GLMessage_Function_glDeleteProgramPipelinesEXT;
+  static const Function glDeleteQueriesEXT = GLMessage_Function_glDeleteQueriesEXT;
+  static const Function glDrawBuffersNV = GLMessage_Function_glDrawBuffersNV;
+  static const Function glEndQueryEXT = GLMessage_Function_glEndQueryEXT;
+  static const Function glFramebufferTexture2DMultisampleEXT = GLMessage_Function_glFramebufferTexture2DMultisampleEXT;
+  static const Function glGenProgramPipelinesEXT = GLMessage_Function_glGenProgramPipelinesEXT;
+  static const Function glGenQueriesEXT = GLMessage_Function_glGenQueriesEXT;
+  static const Function glGetGraphicsResetStatusEXT = GLMessage_Function_glGetGraphicsResetStatusEXT;
+  static const Function glGetObjectLabelEXT = GLMessage_Function_glGetObjectLabelEXT;
+  static const Function glGetProgramPipelineInfoLogEXT = GLMessage_Function_glGetProgramPipelineInfoLogEXT;
+  static const Function glGetProgramPipelineivEXT = GLMessage_Function_glGetProgramPipelineivEXT;
+  static const Function glGetQueryObjectuivEXT = GLMessage_Function_glGetQueryObjectuivEXT;
+  static const Function glGetQueryivEXT = GLMessage_Function_glGetQueryivEXT;
+  static const Function glGetnUniformfvEXT = GLMessage_Function_glGetnUniformfvEXT;
+  static const Function glGetnUniformivEXT = GLMessage_Function_glGetnUniformivEXT;
+  static const Function glInsertEventMarkerEXT = GLMessage_Function_glInsertEventMarkerEXT;
+  static const Function glIsProgramPipelineEXT = GLMessage_Function_glIsProgramPipelineEXT;
+  static const Function glIsQueryEXT = GLMessage_Function_glIsQueryEXT;
+  static const Function glLabelObjectEXT = GLMessage_Function_glLabelObjectEXT;
+  static const Function glPopGroupMarkerEXT = GLMessage_Function_glPopGroupMarkerEXT;
+  static const Function glProgramParameteriEXT = GLMessage_Function_glProgramParameteriEXT;
+  static const Function glProgramUniform1fEXT = GLMessage_Function_glProgramUniform1fEXT;
+  static const Function glProgramUniform1fvEXT = GLMessage_Function_glProgramUniform1fvEXT;
+  static const Function glProgramUniform1iEXT = GLMessage_Function_glProgramUniform1iEXT;
+  static const Function glProgramUniform1ivEXT = GLMessage_Function_glProgramUniform1ivEXT;
+  static const Function glProgramUniform2fEXT = GLMessage_Function_glProgramUniform2fEXT;
+  static const Function glProgramUniform2fvEXT = GLMessage_Function_glProgramUniform2fvEXT;
+  static const Function glProgramUniform2iEXT = GLMessage_Function_glProgramUniform2iEXT;
+  static const Function glProgramUniform2ivEXT = GLMessage_Function_glProgramUniform2ivEXT;
+  static const Function glProgramUniform3fEXT = GLMessage_Function_glProgramUniform3fEXT;
+  static const Function glProgramUniform3fvEXT = GLMessage_Function_glProgramUniform3fvEXT;
+  static const Function glProgramUniform3iEXT = GLMessage_Function_glProgramUniform3iEXT;
+  static const Function glProgramUniform3ivEXT = GLMessage_Function_glProgramUniform3ivEXT;
+  static const Function glProgramUniform4fEXT = GLMessage_Function_glProgramUniform4fEXT;
+  static const Function glProgramUniform4fvEXT = GLMessage_Function_glProgramUniform4fvEXT;
+  static const Function glProgramUniform4iEXT = GLMessage_Function_glProgramUniform4iEXT;
+  static const Function glProgramUniform4ivEXT = GLMessage_Function_glProgramUniform4ivEXT;
+  static const Function glProgramUniformMatrix2fvEXT = GLMessage_Function_glProgramUniformMatrix2fvEXT;
+  static const Function glProgramUniformMatrix3fvEXT = GLMessage_Function_glProgramUniformMatrix3fvEXT;
+  static const Function glProgramUniformMatrix4fvEXT = GLMessage_Function_glProgramUniformMatrix4fvEXT;
+  static const Function glPushGroupMarkerEXT = GLMessage_Function_glPushGroupMarkerEXT;
+  static const Function glReadBufferNV = GLMessage_Function_glReadBufferNV;
+  static const Function glReadnPixelsEXT = GLMessage_Function_glReadnPixelsEXT;
+  static const Function glRenderbufferStorageMultisampleANGLE = GLMessage_Function_glRenderbufferStorageMultisampleANGLE;
+  static const Function glRenderbufferStorageMultisampleAPPLE = GLMessage_Function_glRenderbufferStorageMultisampleAPPLE;
+  static const Function glRenderbufferStorageMultisampleEXT = GLMessage_Function_glRenderbufferStorageMultisampleEXT;
+  static const Function glResolveMultisampleFramebufferAPPLE = GLMessage_Function_glResolveMultisampleFramebufferAPPLE;
+  static const Function glTexStorage1DEXT = GLMessage_Function_glTexStorage1DEXT;
+  static const Function glTexStorage2DEXT = GLMessage_Function_glTexStorage2DEXT;
+  static const Function glTexStorage3DEXT = GLMessage_Function_glTexStorage3DEXT;
+  static const Function glTextureStorage1DEXT = GLMessage_Function_glTextureStorage1DEXT;
+  static const Function glTextureStorage2DEXT = GLMessage_Function_glTextureStorage2DEXT;
+  static const Function glTextureStorage3DEXT = GLMessage_Function_glTextureStorage3DEXT;
+  static const Function glUseProgramStagesEXT = GLMessage_Function_glUseProgramStagesEXT;
+  static const Function glValidateProgramPipelineEXT = GLMessage_Function_glValidateProgramPipelineEXT;
+  static const Function glCopyTextureLevelsAPPLE = GLMessage_Function_glCopyTextureLevelsAPPLE;
+  static const Function glDebugMessageControlKHR = GLMessage_Function_glDebugMessageControlKHR;
+  static const Function glDebugMessageInsertKHR = GLMessage_Function_glDebugMessageInsertKHR;
+  static const Function glDebugMessageCallbackKHR = GLMessage_Function_glDebugMessageCallbackKHR;
+  static const Function glGetDebugMessageLogKHR = GLMessage_Function_glGetDebugMessageLogKHR;
+  static const Function glPushDebugGroupKHR = GLMessage_Function_glPushDebugGroupKHR;
+  static const Function glPopDebugGroupKHR = GLMessage_Function_glPopDebugGroupKHR;
+  static const Function glObjectLabelKHR = GLMessage_Function_glObjectLabelKHR;
+  static const Function glGetObjectLabelKHR = GLMessage_Function_glGetObjectLabelKHR;
+  static const Function glObjectPtrLabelKHR = GLMessage_Function_glObjectPtrLabelKHR;
+  static const Function glGetObjectPtrLabelKHR = GLMessage_Function_glGetObjectPtrLabelKHR;
+  static const Function glGetPointervKHR = GLMessage_Function_glGetPointervKHR;
+  static const Function glDrawArraysInstancedANGLE = GLMessage_Function_glDrawArraysInstancedANGLE;
+  static const Function glDrawElementsInstancedANGLE = GLMessage_Function_glDrawElementsInstancedANGLE;
+  static const Function glVertexAttribDivisorANGLE = GLMessage_Function_glVertexAttribDivisorANGLE;
+  static const Function glDrawArraysInstancedEXT = GLMessage_Function_glDrawArraysInstancedEXT;
+  static const Function glDrawElementsInstancedEXT = GLMessage_Function_glDrawElementsInstancedEXT;
+  static const Function glVertexAttribDivisorEXT = GLMessage_Function_glVertexAttribDivisorEXT;
+  static const Function glDrawArraysInstancedNV = GLMessage_Function_glDrawArraysInstancedNV;
+  static const Function glDrawElementsInstancedNV = GLMessage_Function_glDrawElementsInstancedNV;
+  static const Function glVertexAttribDivisorNV = GLMessage_Function_glVertexAttribDivisorNV;
+  static const Function glDrawBuffersEXT = GLMessage_Function_glDrawBuffersEXT;
+  static const Function glReadBufferIndexedEXT = GLMessage_Function_glReadBufferIndexedEXT;
+  static const Function glDrawBuffersIndexedEXT = GLMessage_Function_glDrawBuffersIndexedEXT;
+  static const Function glGetIntegeri_vEXT = GLMessage_Function_glGetIntegeri_vEXT;
+  static const Function glMapBufferRangeEXT = GLMessage_Function_glMapBufferRangeEXT;
+  static const Function glFlushMappedBufferRangeEXT = GLMessage_Function_glFlushMappedBufferRangeEXT;
+  static const Function glQueryCounterEXT = GLMessage_Function_glQueryCounterEXT;
+  static const Function glGetQueryObjecti64vEXT = GLMessage_Function_glGetQueryObjecti64vEXT;
+  static const Function glGetQueryObjectivEXT = GLMessage_Function_glGetQueryObjectivEXT;
+  static const Function glGetQueryObjectui64vEXT = GLMessage_Function_glGetQueryObjectui64vEXT;
+  static const Function glGetTranslatedShaderSourceANGLE = GLMessage_Function_glGetTranslatedShaderSourceANGLE;
+  static const Function glMinSampleShadingOES = GLMessage_Function_glMinSampleShadingOES;
+  static const Function glMultiTexCoord1bOES = GLMessage_Function_glMultiTexCoord1bOES;
+  static const Function glMultiTexCoord1bvOES = GLMessage_Function_glMultiTexCoord1bvOES;
+  static const Function glMultiTexCoord2bOES = GLMessage_Function_glMultiTexCoord2bOES;
+  static const Function glMultiTexCoord2bvOES = GLMessage_Function_glMultiTexCoord2bvOES;
+  static const Function glMultiTexCoord3bOES = GLMessage_Function_glMultiTexCoord3bOES;
+  static const Function glMultiTexCoord3bvOES = GLMessage_Function_glMultiTexCoord3bvOES;
+  static const Function glMultiTexCoord4bOES = GLMessage_Function_glMultiTexCoord4bOES;
+  static const Function glMultiTexCoord4bvOES = GLMessage_Function_glMultiTexCoord4bvOES;
+  static const Function glTexCoord1bOES = GLMessage_Function_glTexCoord1bOES;
+  static const Function glTexCoord1bvOES = GLMessage_Function_glTexCoord1bvOES;
+  static const Function glTexCoord2bOES = GLMessage_Function_glTexCoord2bOES;
+  static const Function glTexCoord2bvOES = GLMessage_Function_glTexCoord2bvOES;
+  static const Function glTexCoord3bOES = GLMessage_Function_glTexCoord3bOES;
+  static const Function glTexCoord3bvOES = GLMessage_Function_glTexCoord3bvOES;
+  static const Function glTexCoord4bOES = GLMessage_Function_glTexCoord4bOES;
+  static const Function glTexCoord4bvOES = GLMessage_Function_glTexCoord4bvOES;
+  static const Function glVertex2bOES = GLMessage_Function_glVertex2bOES;
+  static const Function glVertex2bvOES = GLMessage_Function_glVertex2bvOES;
+  static const Function glVertex3bOES = GLMessage_Function_glVertex3bOES;
+  static const Function glVertex3bvOES = GLMessage_Function_glVertex3bvOES;
+  static const Function glVertex4bOES = GLMessage_Function_glVertex4bOES;
+  static const Function glVertex4bvOES = GLMessage_Function_glVertex4bvOES;
+  static const Function glProgramUniform1uiEXT = GLMessage_Function_glProgramUniform1uiEXT;
+  static const Function glProgramUniform2uiEXT = GLMessage_Function_glProgramUniform2uiEXT;
+  static const Function glProgramUniform3uiEXT = GLMessage_Function_glProgramUniform3uiEXT;
+  static const Function glProgramUniform4uiEXT = GLMessage_Function_glProgramUniform4uiEXT;
+  static const Function glProgramUniform1uivEXT = GLMessage_Function_glProgramUniform1uivEXT;
+  static const Function glProgramUniform2uivEXT = GLMessage_Function_glProgramUniform2uivEXT;
+  static const Function glProgramUniform3uivEXT = GLMessage_Function_glProgramUniform3uivEXT;
+  static const Function glProgramUniform4uivEXT = GLMessage_Function_glProgramUniform4uivEXT;
+  static const Function glProgramUniformMatrix2x3fvEXT = GLMessage_Function_glProgramUniformMatrix2x3fvEXT;
+  static const Function glProgramUniformMatrix3x2fvEXT = GLMessage_Function_glProgramUniformMatrix3x2fvEXT;
+  static const Function glProgramUniformMatrix2x4fvEXT = GLMessage_Function_glProgramUniformMatrix2x4fvEXT;
+  static const Function glProgramUniformMatrix4x2fvEXT = GLMessage_Function_glProgramUniformMatrix4x2fvEXT;
+  static const Function glProgramUniformMatrix3x4fvEXT = GLMessage_Function_glProgramUniformMatrix3x4fvEXT;
+  static const Function glProgramUniformMatrix4x3fvEXT = GLMessage_Function_glProgramUniformMatrix4x3fvEXT;
+  static const Function glRenderbufferStorageMultisampleNV = GLMessage_Function_glRenderbufferStorageMultisampleNV;
+  static const Function glSampleCoverageOES = GLMessage_Function_glSampleCoverageOES;
+  static const Function glTexStorage3DMultisampleOES = GLMessage_Function_glTexStorage3DMultisampleOES;
+  static const Function glUniformMatrix2x3fvNV = GLMessage_Function_glUniformMatrix2x3fvNV;
+  static const Function glUniformMatrix3x2fvNV = GLMessage_Function_glUniformMatrix3x2fvNV;
+  static const Function glUniformMatrix2x4fvNV = GLMessage_Function_glUniformMatrix2x4fvNV;
+  static const Function glUniformMatrix4x2fvNV = GLMessage_Function_glUniformMatrix4x2fvNV;
+  static const Function glUniformMatrix3x4fvNV = GLMessage_Function_glUniformMatrix3x4fvNV;
+  static const Function glUniformMatrix4x3fvNV = GLMessage_Function_glUniformMatrix4x3fvNV;
+  static const Function glActiveShaderProgram = GLMessage_Function_glActiveShaderProgram;
+  static const Function glBindImageTexture = GLMessage_Function_glBindImageTexture;
+  static const Function glBindProgramPipeline = GLMessage_Function_glBindProgramPipeline;
+  static const Function glBindVertexBuffer = GLMessage_Function_glBindVertexBuffer;
+  static const Function glCreateShaderProgramv = GLMessage_Function_glCreateShaderProgramv;
+  static const Function glDeleteProgramPipelines = GLMessage_Function_glDeleteProgramPipelines;
+  static const Function glDispatchCompute = GLMessage_Function_glDispatchCompute;
+  static const Function glDispatchComputeIndirect = GLMessage_Function_glDispatchComputeIndirect;
+  static const Function glDrawArraysIndirect = GLMessage_Function_glDrawArraysIndirect;
+  static const Function glDrawElementsIndirect = GLMessage_Function_glDrawElementsIndirect;
+  static const Function glFramebufferParameteri = GLMessage_Function_glFramebufferParameteri;
+  static const Function glGenProgramPipelines = GLMessage_Function_glGenProgramPipelines;
+  static const Function glGetBooleani_v = GLMessage_Function_glGetBooleani_v;
+  static const Function glGetFramebufferParameteriv = GLMessage_Function_glGetFramebufferParameteriv;
+  static const Function glGetMultisamplefv = GLMessage_Function_glGetMultisamplefv;
+  static const Function glGetProgramInterfaceiv = GLMessage_Function_glGetProgramInterfaceiv;
+  static const Function glGetProgramPipelineInfoLog = GLMessage_Function_glGetProgramPipelineInfoLog;
+  static const Function glGetProgramPipelineiv = GLMessage_Function_glGetProgramPipelineiv;
+  static const Function glGetProgramResourceIndex = GLMessage_Function_glGetProgramResourceIndex;
+  static const Function glGetProgramResourceLocation = GLMessage_Function_glGetProgramResourceLocation;
+  static const Function glGetProgramResourceName = GLMessage_Function_glGetProgramResourceName;
+  static const Function glGetProgramResourceiv = GLMessage_Function_glGetProgramResourceiv;
+  static const Function glGetTexLevelParameterfv = GLMessage_Function_glGetTexLevelParameterfv;
+  static const Function glGetTexLevelParameteriv = GLMessage_Function_glGetTexLevelParameteriv;
+  static const Function glIsProgramPipeline = GLMessage_Function_glIsProgramPipeline;
+  static const Function glMemoryBarrier = GLMessage_Function_glMemoryBarrier;
+  static const Function glMemoryBarrierByRegion = GLMessage_Function_glMemoryBarrierByRegion;
+  static const Function glProgramUniform1f = GLMessage_Function_glProgramUniform1f;
+  static const Function glProgramUniform1fv = GLMessage_Function_glProgramUniform1fv;
+  static const Function glProgramUniform1i = GLMessage_Function_glProgramUniform1i;
+  static const Function glProgramUniform1iv = GLMessage_Function_glProgramUniform1iv;
+  static const Function glProgramUniform1ui = GLMessage_Function_glProgramUniform1ui;
+  static const Function glProgramUniform1uiv = GLMessage_Function_glProgramUniform1uiv;
+  static const Function glProgramUniform2f = GLMessage_Function_glProgramUniform2f;
+  static const Function glProgramUniform2fv = GLMessage_Function_glProgramUniform2fv;
+  static const Function glProgramUniform2i = GLMessage_Function_glProgramUniform2i;
+  static const Function glProgramUniform2iv = GLMessage_Function_glProgramUniform2iv;
+  static const Function glProgramUniform2ui = GLMessage_Function_glProgramUniform2ui;
+  static const Function glProgramUniform2uiv = GLMessage_Function_glProgramUniform2uiv;
+  static const Function glProgramUniform3f = GLMessage_Function_glProgramUniform3f;
+  static const Function glProgramUniform3fv = GLMessage_Function_glProgramUniform3fv;
+  static const Function glProgramUniform3i = GLMessage_Function_glProgramUniform3i;
+  static const Function glProgramUniform3iv = GLMessage_Function_glProgramUniform3iv;
+  static const Function glProgramUniform3ui = GLMessage_Function_glProgramUniform3ui;
+  static const Function glProgramUniform3uiv = GLMessage_Function_glProgramUniform3uiv;
+  static const Function glProgramUniform4f = GLMessage_Function_glProgramUniform4f;
+  static const Function glProgramUniform4fv = GLMessage_Function_glProgramUniform4fv;
+  static const Function glProgramUniform4i = GLMessage_Function_glProgramUniform4i;
+  static const Function glProgramUniform4iv = GLMessage_Function_glProgramUniform4iv;
+  static const Function glProgramUniform4ui = GLMessage_Function_glProgramUniform4ui;
+  static const Function glProgramUniform4uiv = GLMessage_Function_glProgramUniform4uiv;
+  static const Function glProgramUniformMatrix2fv = GLMessage_Function_glProgramUniformMatrix2fv;
+  static const Function glProgramUniformMatrix2x3fv = GLMessage_Function_glProgramUniformMatrix2x3fv;
+  static const Function glProgramUniformMatrix2x4fv = GLMessage_Function_glProgramUniformMatrix2x4fv;
+  static const Function glProgramUniformMatrix3fv = GLMessage_Function_glProgramUniformMatrix3fv;
+  static const Function glProgramUniformMatrix3x2fv = GLMessage_Function_glProgramUniformMatrix3x2fv;
+  static const Function glProgramUniformMatrix3x4fv = GLMessage_Function_glProgramUniformMatrix3x4fv;
+  static const Function glProgramUniformMatrix4fv = GLMessage_Function_glProgramUniformMatrix4fv;
+  static const Function glProgramUniformMatrix4x2fv = GLMessage_Function_glProgramUniformMatrix4x2fv;
+  static const Function glProgramUniformMatrix4x3fv = GLMessage_Function_glProgramUniformMatrix4x3fv;
+  static const Function glSampleMaski = GLMessage_Function_glSampleMaski;
+  static const Function glTexStorage2DMultisample = GLMessage_Function_glTexStorage2DMultisample;
+  static const Function glUseProgramStages = GLMessage_Function_glUseProgramStages;
+  static const Function glValidateProgramPipeline = GLMessage_Function_glValidateProgramPipeline;
+  static const Function glVertexAttribBinding = GLMessage_Function_glVertexAttribBinding;
+  static const Function glVertexAttribFormat = GLMessage_Function_glVertexAttribFormat;
+  static const Function glVertexAttribIFormat = GLMessage_Function_glVertexAttribIFormat;
+  static const Function glVertexBindingDivisor = GLMessage_Function_glVertexBindingDivisor;
+  static const Function glBlendEquationSeparateiEXT = GLMessage_Function_glBlendEquationSeparateiEXT;
+  static const Function glBlendEquationiEXT = GLMessage_Function_glBlendEquationiEXT;
+  static const Function glBlendFuncSeparateiEXT = GLMessage_Function_glBlendFuncSeparateiEXT;
+  static const Function glBlendFunciEXT = GLMessage_Function_glBlendFunciEXT;
+  static const Function glColorMaskiEXT = GLMessage_Function_glColorMaskiEXT;
+  static const Function glCopyImageSubDataEXT = GLMessage_Function_glCopyImageSubDataEXT;
+  static const Function glDisableiEXT = GLMessage_Function_glDisableiEXT;
+  static const Function glEnableiEXT = GLMessage_Function_glEnableiEXT;
+  static const Function glFramebufferTextureEXT = GLMessage_Function_glFramebufferTextureEXT;
+  static const Function glGetSamplerParameterIivEXT = GLMessage_Function_glGetSamplerParameterIivEXT;
+  static const Function glGetSamplerParameterIuivEXT = GLMessage_Function_glGetSamplerParameterIuivEXT;
+  static const Function glGetTexParameterIivEXT = GLMessage_Function_glGetTexParameterIivEXT;
+  static const Function glGetTexParameterIuivEXT = GLMessage_Function_glGetTexParameterIuivEXT;
+  static const Function glIsEnablediEXT = GLMessage_Function_glIsEnablediEXT;
+  static const Function glPatchParameteriEXT = GLMessage_Function_glPatchParameteriEXT;
+  static const Function glPrimitiveBoundingBoxEXT = GLMessage_Function_glPrimitiveBoundingBoxEXT;
+  static const Function glSamplerParameterIivEXT = GLMessage_Function_glSamplerParameterIivEXT;
+  static const Function glSamplerParameterIuivEXT = GLMessage_Function_glSamplerParameterIuivEXT;
+  static const Function glTexBufferEXT = GLMessage_Function_glTexBufferEXT;
+  static const Function glTexBufferRangeEXT = GLMessage_Function_glTexBufferRangeEXT;
+  static const Function glTexParameterIivEXT = GLMessage_Function_glTexParameterIivEXT;
+  static const Function glTexParameterIuivEXT = GLMessage_Function_glTexParameterIuivEXT;
+  static const Function glTextureViewEXT = GLMessage_Function_glTextureViewEXT;
+  static const Function eglGetDisplay = GLMessage_Function_eglGetDisplay;
+  static const Function eglInitialize = GLMessage_Function_eglInitialize;
+  static const Function eglTerminate = GLMessage_Function_eglTerminate;
+  static const Function eglGetConfigs = GLMessage_Function_eglGetConfigs;
+  static const Function eglChooseConfig = GLMessage_Function_eglChooseConfig;
+  static const Function eglGetConfigAttrib = GLMessage_Function_eglGetConfigAttrib;
+  static const Function eglCreateWindowSurface = GLMessage_Function_eglCreateWindowSurface;
+  static const Function eglCreatePixmapSurface = GLMessage_Function_eglCreatePixmapSurface;
+  static const Function eglCreatePbufferSurface = GLMessage_Function_eglCreatePbufferSurface;
+  static const Function eglDestroySurface = GLMessage_Function_eglDestroySurface;
+  static const Function eglQuerySurface = GLMessage_Function_eglQuerySurface;
+  static const Function eglCreateContext = GLMessage_Function_eglCreateContext;
+  static const Function eglDestroyContext = GLMessage_Function_eglDestroyContext;
+  static const Function eglMakeCurrent = GLMessage_Function_eglMakeCurrent;
+  static const Function eglGetCurrentContext = GLMessage_Function_eglGetCurrentContext;
+  static const Function eglGetCurrentSurface = GLMessage_Function_eglGetCurrentSurface;
+  static const Function eglGetCurrentDisplay = GLMessage_Function_eglGetCurrentDisplay;
+  static const Function eglQueryContext = GLMessage_Function_eglQueryContext;
+  static const Function eglWaitGL = GLMessage_Function_eglWaitGL;
+  static const Function eglWaitNative = GLMessage_Function_eglWaitNative;
+  static const Function eglSwapBuffers = GLMessage_Function_eglSwapBuffers;
+  static const Function eglCopyBuffers = GLMessage_Function_eglCopyBuffers;
+  static const Function eglGetError = GLMessage_Function_eglGetError;
+  static const Function eglQueryString = GLMessage_Function_eglQueryString;
+  static const Function eglGetProcAddress = GLMessage_Function_eglGetProcAddress;
+  static const Function eglSurfaceAttrib = GLMessage_Function_eglSurfaceAttrib;
+  static const Function eglBindTexImage = GLMessage_Function_eglBindTexImage;
+  static const Function eglReleaseTexImage = GLMessage_Function_eglReleaseTexImage;
+  static const Function eglSwapInterval = GLMessage_Function_eglSwapInterval;
+  static const Function eglBindAPI = GLMessage_Function_eglBindAPI;
+  static const Function eglQueryAPI = GLMessage_Function_eglQueryAPI;
+  static const Function eglWaitClient = GLMessage_Function_eglWaitClient;
+  static const Function eglReleaseThread = GLMessage_Function_eglReleaseThread;
+  static const Function eglCreatePbufferFromClientBuffer = GLMessage_Function_eglCreatePbufferFromClientBuffer;
+  static const Function eglLockSurfaceKHR = GLMessage_Function_eglLockSurfaceKHR;
+  static const Function eglUnlockSurfaceKHR = GLMessage_Function_eglUnlockSurfaceKHR;
+  static const Function eglCreateImageKHR = GLMessage_Function_eglCreateImageKHR;
+  static const Function eglDestroyImageKHR = GLMessage_Function_eglDestroyImageKHR;
+  static const Function eglCreateSyncKHR = GLMessage_Function_eglCreateSyncKHR;
+  static const Function eglDestroySyncKHR = GLMessage_Function_eglDestroySyncKHR;
+  static const Function eglClientWaitSyncKHR = GLMessage_Function_eglClientWaitSyncKHR;
+  static const Function eglGetSyncAttribKHR = GLMessage_Function_eglGetSyncAttribKHR;
+  static const Function eglSetSwapRectangleANDROID = GLMessage_Function_eglSetSwapRectangleANDROID;
+  static const Function eglGetRenderBufferANDROID = GLMessage_Function_eglGetRenderBufferANDROID;
+  static const Function eglGetSystemTimeFrequencyNV = GLMessage_Function_eglGetSystemTimeFrequencyNV;
+  static const Function eglGetSystemTimeNV = GLMessage_Function_eglGetSystemTimeNV;
+  static const Function invalid = GLMessage_Function_invalid;
+  static const Function glVertexAttribPointerData = GLMessage_Function_glVertexAttribPointerData;
+  static inline bool Function_IsValid(int value) {
+    return GLMessage_Function_IsValid(value);
+  }
+  static const Function Function_MIN =
+    GLMessage_Function_Function_MIN;
+  static const Function Function_MAX =
+    GLMessage_Function_Function_MAX;
+  static const int Function_ARRAYSIZE =
+    GLMessage_Function_Function_ARRAYSIZE;
+  
+  // accessors -------------------------------------------------------
+  
+  // required int32 context_id = 1;
+  inline bool has_context_id() const;
+  inline void clear_context_id();
+  static const int kContextIdFieldNumber = 1;
+  inline ::google::protobuf::int32 context_id() const;
+  inline void set_context_id(::google::protobuf::int32 value);
+  
+  // required int64 start_time = 2;
+  inline bool has_start_time() const;
+  inline void clear_start_time();
+  static const int kStartTimeFieldNumber = 2;
+  inline ::google::protobuf::int64 start_time() const;
+  inline void set_start_time(::google::protobuf::int64 value);
+  
+  // required int32 duration = 3;
+  inline bool has_duration() const;
+  inline void clear_duration();
+  static const int kDurationFieldNumber = 3;
+  inline ::google::protobuf::int32 duration() const;
+  inline void set_duration(::google::protobuf::int32 value);
+  
+  // required .android.gltrace.GLMessage.Function function = 4 [default = invalid];
+  inline bool has_function() const;
+  inline void clear_function();
+  static const int kFunctionFieldNumber = 4;
+  inline ::android::gltrace::GLMessage_Function function() const;
+  inline void set_function(::android::gltrace::GLMessage_Function value);
+  
+  // repeated .android.gltrace.GLMessage.DataType args = 5;
+  inline int args_size() const;
+  inline void clear_args();
+  static const int kArgsFieldNumber = 5;
+  inline const ::android::gltrace::GLMessage_DataType& args(int index) const;
+  inline ::android::gltrace::GLMessage_DataType* mutable_args(int index);
+  inline ::android::gltrace::GLMessage_DataType* add_args();
+  inline const ::google::protobuf::RepeatedPtrField< ::android::gltrace::GLMessage_DataType >&
+      args() const;
+  inline ::google::protobuf::RepeatedPtrField< ::android::gltrace::GLMessage_DataType >*
+      mutable_args();
+  
+  // optional .android.gltrace.GLMessage.DataType returnValue = 6;
+  inline bool has_returnvalue() const;
+  inline void clear_returnvalue();
+  static const int kReturnValueFieldNumber = 6;
+  inline const ::android::gltrace::GLMessage_DataType& returnvalue() const;
+  inline ::android::gltrace::GLMessage_DataType* mutable_returnvalue();
+  
+  // optional .android.gltrace.GLMessage.FrameBuffer fb = 7;
+  inline bool has_fb() const;
+  inline void clear_fb();
+  static const int kFbFieldNumber = 7;
+  inline const ::android::gltrace::GLMessage_FrameBuffer& fb() const;
+  inline ::android::gltrace::GLMessage_FrameBuffer* mutable_fb();
+  
+  // optional int32 threadtime = 8;
+  inline bool has_threadtime() const;
+  inline void clear_threadtime();
+  static const int kThreadtimeFieldNumber = 8;
+  inline ::google::protobuf::int32 threadtime() const;
+  inline void set_threadtime(::google::protobuf::int32 value);
+  
+  // @@protoc_insertion_point(class_scope:android.gltrace.GLMessage)
+ private:
+  mutable int _cached_size_;
+  
+  ::google::protobuf::int32 context_id_;
+  ::google::protobuf::int64 start_time_;
+  ::google::protobuf::int32 duration_;
+  int function_;
+  ::google::protobuf::RepeatedPtrField< ::android::gltrace::GLMessage_DataType > args_;
+  ::android::gltrace::GLMessage_DataType* returnvalue_;
+  ::android::gltrace::GLMessage_FrameBuffer* fb_;
+  ::google::protobuf::int32 threadtime_;
+  friend void  protobuf_AddDesc_gltrace_2eproto();
+  friend void protobuf_AssignDesc_gltrace_2eproto();
+  friend void protobuf_ShutdownFile_gltrace_2eproto();
+  
+  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
+  
+  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
+  inline bool _has_bit(int index) const {
+    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
+  }
+  inline void _set_bit(int index) {
+    _has_bits_[index / 32] |= (1u << (index % 32));
+  }
+  inline void _clear_bit(int index) {
+    _has_bits_[index / 32] &= ~(1u << (index % 32));
+  }
+  
+  void InitAsDefaultInstance();
+  static GLMessage* default_instance_;
+};
+// ===================================================================
+
+
+// ===================================================================
+
+// GLMessage_DataType
+
+// required .android.gltrace.GLMessage.DataType.Type type = 1 [default = VOID];
+inline bool GLMessage_DataType::has_type() const {
+  return _has_bit(0);
+}
+inline void GLMessage_DataType::clear_type() {
+  type_ = 1;
+  _clear_bit(0);
+}
+inline ::android::gltrace::GLMessage_DataType_Type GLMessage_DataType::type() const {
+  return static_cast< ::android::gltrace::GLMessage_DataType_Type >(type_);
+}
+inline void GLMessage_DataType::set_type(::android::gltrace::GLMessage_DataType_Type value) {
+  GOOGLE_DCHECK(::android::gltrace::GLMessage_DataType_Type_IsValid(value));
+  _set_bit(0);
+  type_ = value;
+}
+
+// required bool isArray = 2 [default = false];
+inline bool GLMessage_DataType::has_isarray() const {
+  return _has_bit(1);
+}
+inline void GLMessage_DataType::clear_isarray() {
+  isarray_ = false;
+  _clear_bit(1);
+}
+inline bool GLMessage_DataType::isarray() const {
+  return isarray_;
+}
+inline void GLMessage_DataType::set_isarray(bool value) {
+  _set_bit(1);
+  isarray_ = value;
+}
+
+// repeated int32 intValue = 3;
+inline int GLMessage_DataType::intvalue_size() const {
+  return intvalue_.size();
+}
+inline void GLMessage_DataType::clear_intvalue() {
+  intvalue_.Clear();
+}
+inline ::google::protobuf::int32 GLMessage_DataType::intvalue(int index) const {
+  return intvalue_.Get(index);
+}
+inline void GLMessage_DataType::set_intvalue(int index, ::google::protobuf::int32 value) {
+  intvalue_.Set(index, value);
+}
+inline void GLMessage_DataType::add_intvalue(::google::protobuf::int32 value) {
+  intvalue_.Add(value);
+}
+inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
+GLMessage_DataType::intvalue() const {
+  return intvalue_;
+}
+inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
+GLMessage_DataType::mutable_intvalue() {
+  return &intvalue_;
+}
+
+// repeated float floatValue = 4;
+inline int GLMessage_DataType::floatvalue_size() const {
+  return floatvalue_.size();
+}
+inline void GLMessage_DataType::clear_floatvalue() {
+  floatvalue_.Clear();
+}
+inline float GLMessage_DataType::floatvalue(int index) const {
+  return floatvalue_.Get(index);
+}
+inline void GLMessage_DataType::set_floatvalue(int index, float value) {
+  floatvalue_.Set(index, value);
+}
+inline void GLMessage_DataType::add_floatvalue(float value) {
+  floatvalue_.Add(value);
+}
+inline const ::google::protobuf::RepeatedField< float >&
+GLMessage_DataType::floatvalue() const {
+  return floatvalue_;
+}
+inline ::google::protobuf::RepeatedField< float >*
+GLMessage_DataType::mutable_floatvalue() {
+  return &floatvalue_;
+}
+
+// repeated bytes charValue = 5;
+inline int GLMessage_DataType::charvalue_size() const {
+  return charvalue_.size();
+}
+inline void GLMessage_DataType::clear_charvalue() {
+  charvalue_.Clear();
+}
+inline const ::std::string& GLMessage_DataType::charvalue(int index) const {
+  return charvalue_.Get(index);
+}
+inline ::std::string* GLMessage_DataType::mutable_charvalue(int index) {
+  return charvalue_.Mutable(index);
+}
+inline void GLMessage_DataType::set_charvalue(int index, const ::std::string& value) {
+  charvalue_.Mutable(index)->assign(value);
+}
+inline void GLMessage_DataType::set_charvalue(int index, const char* value) {
+  charvalue_.Mutable(index)->assign(value);
+}
+inline void GLMessage_DataType::set_charvalue(int index, const void* value, size_t size) {
+  charvalue_.Mutable(index)->assign(
+    reinterpret_cast<const char*>(value), size);
+}
+inline ::std::string* GLMessage_DataType::add_charvalue() {
+  return charvalue_.Add();
+}
+inline void GLMessage_DataType::add_charvalue(const ::std::string& value) {
+  charvalue_.Add()->assign(value);
+}
+inline void GLMessage_DataType::add_charvalue(const char* value) {
+  charvalue_.Add()->assign(value);
+}
+inline void GLMessage_DataType::add_charvalue(const void* value, size_t size) {
+  charvalue_.Add()->assign(reinterpret_cast<const char*>(value), size);
+}
+inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
+GLMessage_DataType::charvalue() const {
+  return charvalue_;
+}
+inline ::google::protobuf::RepeatedPtrField< ::std::string>*
+GLMessage_DataType::mutable_charvalue() {
+  return &charvalue_;
+}
+
+// repeated bytes rawBytes = 6;
+inline int GLMessage_DataType::rawbytes_size() const {
+  return rawbytes_.size();
+}
+inline void GLMessage_DataType::clear_rawbytes() {
+  rawbytes_.Clear();
+}
+inline const ::std::string& GLMessage_DataType::rawbytes(int index) const {
+  return rawbytes_.Get(index);
+}
+inline ::std::string* GLMessage_DataType::mutable_rawbytes(int index) {
+  return rawbytes_.Mutable(index);
+}
+inline void GLMessage_DataType::set_rawbytes(int index, const ::std::string& value) {
+  rawbytes_.Mutable(index)->assign(value);
+}
+inline void GLMessage_DataType::set_rawbytes(int index, const char* value) {
+  rawbytes_.Mutable(index)->assign(value);
+}
+inline void GLMessage_DataType::set_rawbytes(int index, const void* value, size_t size) {
+  rawbytes_.Mutable(index)->assign(
+    reinterpret_cast<const char*>(value), size);
+}
+inline ::std::string* GLMessage_DataType::add_rawbytes() {
+  return rawbytes_.Add();
+}
+inline void GLMessage_DataType::add_rawbytes(const ::std::string& value) {
+  rawbytes_.Add()->assign(value);
+}
+inline void GLMessage_DataType::add_rawbytes(const char* value) {
+  rawbytes_.Add()->assign(value);
+}
+inline void GLMessage_DataType::add_rawbytes(const void* value, size_t size) {
+  rawbytes_.Add()->assign(reinterpret_cast<const char*>(value), size);
+}
+inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
+GLMessage_DataType::rawbytes() const {
+  return rawbytes_;
+}
+inline ::google::protobuf::RepeatedPtrField< ::std::string>*
+GLMessage_DataType::mutable_rawbytes() {
+  return &rawbytes_;
+}
+
+// repeated bool boolValue = 7;
+inline int GLMessage_DataType::boolvalue_size() const {
+  return boolvalue_.size();
+}
+inline void GLMessage_DataType::clear_boolvalue() {
+  boolvalue_.Clear();
+}
+inline bool GLMessage_DataType::boolvalue(int index) const {
+  return boolvalue_.Get(index);
+}
+inline void GLMessage_DataType::set_boolvalue(int index, bool value) {
+  boolvalue_.Set(index, value);
+}
+inline void GLMessage_DataType::add_boolvalue(bool value) {
+  boolvalue_.Add(value);
+}
+inline const ::google::protobuf::RepeatedField< bool >&
+GLMessage_DataType::boolvalue() const {
+  return boolvalue_;
+}
+inline ::google::protobuf::RepeatedField< bool >*
+GLMessage_DataType::mutable_boolvalue() {
+  return &boolvalue_;
+}
+
+// repeated int64 int64Value = 8;
+inline int GLMessage_DataType::int64value_size() const {
+  return int64value_.size();
+}
+inline void GLMessage_DataType::clear_int64value() {
+  int64value_.Clear();
+}
+inline ::google::protobuf::int64 GLMessage_DataType::int64value(int index) const {
+  return int64value_.Get(index);
+}
+inline void GLMessage_DataType::set_int64value(int index, ::google::protobuf::int64 value) {
+  int64value_.Set(index, value);
+}
+inline void GLMessage_DataType::add_int64value(::google::protobuf::int64 value) {
+  int64value_.Add(value);
+}
+inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
+GLMessage_DataType::int64value() const {
+  return int64value_;
+}
+inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
+GLMessage_DataType::mutable_int64value() {
+  return &int64value_;
+}
+
+// -------------------------------------------------------------------
+
+// GLMessage_FrameBuffer
+
+// required int32 width = 1;
+inline bool GLMessage_FrameBuffer::has_width() const {
+  return _has_bit(0);
+}
+inline void GLMessage_FrameBuffer::clear_width() {
+  width_ = 0;
+  _clear_bit(0);
+}
+inline ::google::protobuf::int32 GLMessage_FrameBuffer::width() const {
+  return width_;
+}
+inline void GLMessage_FrameBuffer::set_width(::google::protobuf::int32 value) {
+  _set_bit(0);
+  width_ = value;
+}
+
+// required int32 height = 2;
+inline bool GLMessage_FrameBuffer::has_height() const {
+  return _has_bit(1);
+}
+inline void GLMessage_FrameBuffer::clear_height() {
+  height_ = 0;
+  _clear_bit(1);
+}
+inline ::google::protobuf::int32 GLMessage_FrameBuffer::height() const {
+  return height_;
+}
+inline void GLMessage_FrameBuffer::set_height(::google::protobuf::int32 value) {
+  _set_bit(1);
+  height_ = value;
+}
+
+// repeated bytes contents = 3;
+inline int GLMessage_FrameBuffer::contents_size() const {
+  return contents_.size();
+}
+inline void GLMessage_FrameBuffer::clear_contents() {
+  contents_.Clear();
+}
+inline const ::std::string& GLMessage_FrameBuffer::contents(int index) const {
+  return contents_.Get(index);
+}
+inline ::std::string* GLMessage_FrameBuffer::mutable_contents(int index) {
+  return contents_.Mutable(index);
+}
+inline void GLMessage_FrameBuffer::set_contents(int index, const ::std::string& value) {
+  contents_.Mutable(index)->assign(value);
+}
+inline void GLMessage_FrameBuffer::set_contents(int index, const char* value) {
+  contents_.Mutable(index)->assign(value);
+}
+inline void GLMessage_FrameBuffer::set_contents(int index, const void* value, size_t size) {
+  contents_.Mutable(index)->assign(
+    reinterpret_cast<const char*>(value), size);
+}
+inline ::std::string* GLMessage_FrameBuffer::add_contents() {
+  return contents_.Add();
+}
+inline void GLMessage_FrameBuffer::add_contents(const ::std::string& value) {
+  contents_.Add()->assign(value);
+}
+inline void GLMessage_FrameBuffer::add_contents(const char* value) {
+  contents_.Add()->assign(value);
+}
+inline void GLMessage_FrameBuffer::add_contents(const void* value, size_t size) {
+  contents_.Add()->assign(reinterpret_cast<const char*>(value), size);
+}
+inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
+GLMessage_FrameBuffer::contents() const {
+  return contents_;
+}
+inline ::google::protobuf::RepeatedPtrField< ::std::string>*
+GLMessage_FrameBuffer::mutable_contents() {
+  return &contents_;
+}
+
+// -------------------------------------------------------------------
+
+// GLMessage
+
+// required int32 context_id = 1;
+inline bool GLMessage::has_context_id() const {
+  return _has_bit(0);
+}
+inline void GLMessage::clear_context_id() {
+  context_id_ = 0;
+  _clear_bit(0);
+}
+inline ::google::protobuf::int32 GLMessage::context_id() const {
+  return context_id_;
+}
+inline void GLMessage::set_context_id(::google::protobuf::int32 value) {
+  _set_bit(0);
+  context_id_ = value;
+}
+
+// required int64 start_time = 2;
+inline bool GLMessage::has_start_time() const {
+  return _has_bit(1);
+}
+inline void GLMessage::clear_start_time() {
+  start_time_ = GOOGLE_LONGLONG(0);
+  _clear_bit(1);
+}
+inline ::google::protobuf::int64 GLMessage::start_time() const {
+  return start_time_;
+}
+inline void GLMessage::set_start_time(::google::protobuf::int64 value) {
+  _set_bit(1);
+  start_time_ = value;
+}
+
+// required int32 duration = 3;
+inline bool GLMessage::has_duration() const {
+  return _has_bit(2);
+}
+inline void GLMessage::clear_duration() {
+  duration_ = 0;
+  _clear_bit(2);
+}
+inline ::google::protobuf::int32 GLMessage::duration() const {
+  return duration_;
+}
+inline void GLMessage::set_duration(::google::protobuf::int32 value) {
+  _set_bit(2);
+  duration_ = value;
+}
+
+// required .android.gltrace.GLMessage.Function function = 4 [default = invalid];
+inline bool GLMessage::has_function() const {
+  return _has_bit(3);
+}
+inline void GLMessage::clear_function() {
+  function_ = 3000;
+  _clear_bit(3);
+}
+inline ::android::gltrace::GLMessage_Function GLMessage::function() const {
+  return static_cast< ::android::gltrace::GLMessage_Function >(function_);
+}
+inline void GLMessage::set_function(::android::gltrace::GLMessage_Function value) {
+  GOOGLE_DCHECK(::android::gltrace::GLMessage_Function_IsValid(value));
+  _set_bit(3);
+  function_ = value;
+}
+
+// repeated .android.gltrace.GLMessage.DataType args = 5;
+inline int GLMessage::args_size() const {
+  return args_.size();
+}
+inline void GLMessage::clear_args() {
+  args_.Clear();
+}
+inline const ::android::gltrace::GLMessage_DataType& GLMessage::args(int index) const {
+  return args_.Get(index);
+}
+inline ::android::gltrace::GLMessage_DataType* GLMessage::mutable_args(int index) {
+  return args_.Mutable(index);
+}
+inline ::android::gltrace::GLMessage_DataType* GLMessage::add_args() {
+  return args_.Add();
+}
+inline const ::google::protobuf::RepeatedPtrField< ::android::gltrace::GLMessage_DataType >&
+GLMessage::args() const {
+  return args_;
+}
+inline ::google::protobuf::RepeatedPtrField< ::android::gltrace::GLMessage_DataType >*
+GLMessage::mutable_args() {
+  return &args_;
+}
+
+// optional .android.gltrace.GLMessage.DataType returnValue = 6;
+inline bool GLMessage::has_returnvalue() const {
+  return _has_bit(5);
+}
+inline void GLMessage::clear_returnvalue() {
+  if (returnvalue_ != NULL) returnvalue_->::android::gltrace::GLMessage_DataType::Clear();
+  _clear_bit(5);
+}
+inline const ::android::gltrace::GLMessage_DataType& GLMessage::returnvalue() const {
+  return returnvalue_ != NULL ? *returnvalue_ : *default_instance_->returnvalue_;
+}
+inline ::android::gltrace::GLMessage_DataType* GLMessage::mutable_returnvalue() {
+  _set_bit(5);
+  if (returnvalue_ == NULL) returnvalue_ = new ::android::gltrace::GLMessage_DataType;
+  return returnvalue_;
+}
+
+// optional .android.gltrace.GLMessage.FrameBuffer fb = 7;
+inline bool GLMessage::has_fb() const {
+  return _has_bit(6);
+}
+inline void GLMessage::clear_fb() {
+  if (fb_ != NULL) fb_->::android::gltrace::GLMessage_FrameBuffer::Clear();
+  _clear_bit(6);
+}
+inline const ::android::gltrace::GLMessage_FrameBuffer& GLMessage::fb() const {
+  return fb_ != NULL ? *fb_ : *default_instance_->fb_;
+}
+inline ::android::gltrace::GLMessage_FrameBuffer* GLMessage::mutable_fb() {
+  _set_bit(6);
+  if (fb_ == NULL) fb_ = new ::android::gltrace::GLMessage_FrameBuffer;
+  return fb_;
+}
+
+// optional int32 threadtime = 8;
+inline bool GLMessage::has_threadtime() const {
+  return _has_bit(7);
+}
+inline void GLMessage::clear_threadtime() {
+  threadtime_ = 0;
+  _clear_bit(7);
+}
+inline ::google::protobuf::int32 GLMessage::threadtime() const {
+  return threadtime_;
+}
+inline void GLMessage::set_threadtime(::google::protobuf::int32 value) {
+  _set_bit(7);
+  threadtime_ = value;
+}
+
+
+// @@protoc_insertion_point(namespace_scope)
+
+}  // namespace gltrace
+}  // namespace android
+
+// @@protoc_insertion_point(global_scope)
+
+#endif  // PROTOBUF_gltrace_2eproto__INCLUDED
diff --git a/opengl/libs/GLES_trace/src/gltrace_api.cpp b/opengl/libs/GLES_trace/src/gltrace_api.cpp
index d83b9b4..eed3ccf 100644
--- a/opengl/libs/GLES_trace/src/gltrace_api.cpp
+++ b/opengl/libs/GLES_trace/src/gltrace_api.cpp
@@ -19,7 +19,7 @@
 #include <cutils/log.h>
 #include <utils/Timers.h>
 
-#include "frameworks/native/opengl/libs/GLES_trace/proto/gltrace.pb.h"
+#include "gltrace.pb.h"
 #include "gltrace_context.h"
 #include "gltrace_fixup.h"
 #include "gltrace_transport.h"
diff --git a/opengl/libs/GLES_trace/src/gltrace_egl.cpp b/opengl/libs/GLES_trace/src/gltrace_egl.cpp
index a7878f2..4f9b006 100644
--- a/opengl/libs/GLES_trace/src/gltrace_egl.cpp
+++ b/opengl/libs/GLES_trace/src/gltrace_egl.cpp
@@ -17,7 +17,7 @@
 #include <cutils/log.h>
 #include <utils/Timers.h>
 
-#include "frameworks/native/opengl/libs/GLES_trace/proto/gltrace.pb.h"
+#include "gltrace.pb.h"
 #include "gltrace_context.h"
 #include "gltrace_fixup.h"
 #include "gltrace_transport.h"
diff --git a/opengl/libs/GLES_trace/src/gltrace_fixup.cpp b/opengl/libs/GLES_trace/src/gltrace_fixup.cpp
index a4a187a..be729c7 100644
--- a/opengl/libs/GLES_trace/src/gltrace_fixup.cpp
+++ b/opengl/libs/GLES_trace/src/gltrace_fixup.cpp
@@ -21,7 +21,7 @@
 #include <GLES2/gl2.h>
 #include <GLES2/gl2ext.h>
 
-#include "frameworks/native/opengl/libs/GLES_trace/proto/gltrace.pb.h"
+#include "gltrace.pb.h"
 #include "gltrace_api.h"
 #include "gltrace_context.h"
 #include "gltrace_fixup.h"
diff --git a/opengl/libs/GLES_trace/src/gltrace_fixup.h b/opengl/libs/GLES_trace/src/gltrace_fixup.h
index c90dbeb..fe30125 100644
--- a/opengl/libs/GLES_trace/src/gltrace_fixup.h
+++ b/opengl/libs/GLES_trace/src/gltrace_fixup.h
@@ -19,7 +19,7 @@
 
 #include <utils/Timers.h>
 
-#include "frameworks/native/opengl/libs/GLES_trace/proto/gltrace.pb.h"
+#include "gltrace.pb.h"
 #include "gltrace_context.h"
 
 namespace android {
diff --git a/opengl/libs/GLES_trace/src/gltrace_transport.h b/opengl/libs/GLES_trace/src/gltrace_transport.h
index fd6cb8c..9cf5b45 100644
--- a/opengl/libs/GLES_trace/src/gltrace_transport.h
+++ b/opengl/libs/GLES_trace/src/gltrace_transport.h
@@ -19,7 +19,7 @@
 
 #include <pthread.h>
 
-#include "frameworks/native/opengl/libs/GLES_trace/proto/gltrace.pb.h"
+#include "gltrace.pb.h"
 
 namespace android {
 namespace gltrace {
diff --git a/opengl/libs/egl_impl.h b/opengl/libs/egl_impl.h
index c0990ec..cb0e908 100644
--- a/opengl/libs/egl_impl.h
+++ b/opengl/libs/egl_impl.h
@@ -30,9 +30,6 @@ namespace android {
 // ----------------------------------------------------------------------------
 
 EGLAPI const GLubyte * egl_get_string_for_current_context(GLenum name);
-EGLAPI const GLubyte * egl_get_string_for_current_context(GLenum name,
-                                                          GLuint index);
-EGLAPI GLint egl_get_num_extensions_for_current_context();
 
 // ----------------------------------------------------------------------------
 }; // namespace android
-- 
1.9.1

