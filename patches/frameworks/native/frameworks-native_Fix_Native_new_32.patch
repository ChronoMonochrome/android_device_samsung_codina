  Eliminate benign overflow condition triggered upon loop termination iâ€¦

In readFromParcel, a while loop is terminated when sampleCount = 0. The
decrement operation that was here would decrease sampleCount, an unsigned value,
below 0, triggering an unsigned integer overflow. The while loop was refactored
to eliminate this condition.
Bug: 24171356
 Eliminate multiple benign overflow conditions.

In InputTransport.cpp, there are multiple loops in which loop
termination occurs when the value becomes zero. These termination
conditions are all written value-- > 0, which, since value is
unsigned, result in an unsigned integer overflow when value is 0.
These loops were refactored to eliminate these conditions.
Bug: 24171356

diff --git a/libs/input/Input.cpp b/libs/input/Input.cpp
index 5cd8508..34def01 100644
--- a/libs/input/Input.cpp
+++ b/libs/input/Input.cpp
@@ -452,7 +452,8 @@ status_t MotionEvent::readFromParcel(Parcel* parcel) {
         properties.toolType = parcel->readInt32();
     }
 
-    while (sampleCount-- > 0) {
+    while (sampleCount > 0) {
+        sampleCount--;
         mSampleEventTimes.push(parcel->readInt64());
         for (size_t i = 0; i < pointerCount; i++) {
             mSamplePointerCoords.push();
diff --git a/libs/input/InputTransport.cpp b/libs/input/InputTransport.cpp
index 5cd8508..44def01 100644
--- a/libs/input/InputTransport.cpp
+++ b/libs/input/InputTransport.cpp
@@ -510,7 +510,8 @@ status_t InputConsumer::consume(InputEventFactoryInterface* factory,
 status_t InputConsumer::consumeBatch(InputEventFactoryInterface* factory,
         nsecs_t frameTime, uint32_t* outSeq, InputEvent** outEvent) {
     status_t result;
-    for (size_t i = mBatches.size(); i-- > 0; ) {
+    for (size_t i = mBatches.size(); i > 0; ) {
+        i--;
         Batch& batch = mBatches.editItemAt(i);
         if (frameTime < 0) {
             result = consumeSamples(factory, batch, batch.samples.size(),
@@ -815,7 +816,8 @@ status_t InputConsumer::sendFinishedSignal(uint32_t seq, bool handled) {
         uint32_t currentSeq = seq;
         uint32_t chainSeqs[seqChainCount];
         size_t chainIndex = 0;
-        for (size_t i = seqChainCount; i-- > 0; ) {
+        for (size_t i = seqChainCount; i > 0; ) {
+             i--;
              const SeqChain& seqChain = mSeqChains.itemAt(i);
              if (seqChain.seq == currentSeq) {
                  currentSeq = seqChain.chain;
@@ -824,7 +826,8 @@ status_t InputConsumer::sendFinishedSignal(uint32_t seq, bool handled) {
              }
         }
         status_t status = OK;
-        while (!status && chainIndex-- > 0) {
+        while (!status && chainIndex > 0) {
+            chainIndex--;
             status = sendUnchainedFinishedSignal(chainSeqs[chainIndex], handled);
         }
         if (status) {
@@ -834,7 +837,10 @@ status_t InputConsumer::sendFinishedSignal(uint32_t seq, bool handled) {
                 seqChain.seq = chainIndex != 0 ? chainSeqs[chainIndex - 1] : seq;
                 seqChain.chain = chainSeqs[chainIndex];
                 mSeqChains.push(seqChain);
-            } while (chainIndex-- > 0);
+                if (chainIndex != 0) {
+                    chainIndex--;
+                }
+            } while (chainIndex > 0);
             return status;
         }
     }
