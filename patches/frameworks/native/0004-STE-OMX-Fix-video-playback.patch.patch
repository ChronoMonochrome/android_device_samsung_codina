From fa7e601fb5286fe6d869748b9100c1c9b03bf9bb Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Mon, 11 May 2015 20:16:18 +0300
Subject: [PATCH 4/4] 0004-STE-OMX-Fix-video-playback.patch

Change-Id: I2748c4bcdad0f765423839d9b702b4d7d0a4cf6f
---
 include/gui/GLConsumer.h |  5 +++++
 libs/gui/GLConsumer.cpp  | 48 +++++++++++++++++++++++++-----------------------
 2 files changed, 30 insertions(+), 23 deletions(-)

diff --git a/include/gui/GLConsumer.h b/include/gui/GLConsumer.h
index 9ec530d..29f2580 100644
--- a/include/gui/GLConsumer.h
+++ b/include/gui/GLConsumer.h
@@ -316,6 +316,11 @@ private:
         const native_handle* graphicBufferHandle() {
             return mGraphicBuffer == NULL ? NULL : mGraphicBuffer->handle;
         }
+#ifdef STE_HARDWARE
+        void setGraphicBuffer(sp<GraphicBuffer> graphicBuffer) {
+            mGraphicBuffer = graphicBuffer;
+        }
+#endif
 
     private:
         // Only allow instantiation using ref counting.
diff --git a/libs/gui/GLConsumer.cpp b/libs/gui/GLConsumer.cpp
index db19de3..3b224c8 100644
--- a/libs/gui/GLConsumer.cpp
+++ b/libs/gui/GLConsumer.cpp
@@ -448,21 +448,11 @@ status_t GLConsumer::updateAndReleaseLocked(const BufferQueue::BufferItem& item)
         return err;
     }
 
-    // Ensure we have a valid EglImageKHR for the slot, creating an EglImage
-    // if nessessary, for the gralloc buffer currently in the slot in
-    // ConsumerBase.
-    // We may have to do this even when item.mGraphicBuffer == NULL (which
-    // means the buffer was previously acquired).
 
 #ifdef STE_HARDWARE
     sp<GraphicBuffer> textureBuffer;
     if (mSlots[buf].mGraphicBuffer->getPixelFormat() == HAL_PIXEL_FORMAT_YCBCR42XMBN
      || mSlots[buf].mGraphicBuffer->getPixelFormat() == HAL_PIXEL_FORMAT_YCbCr_420_P) {
-        /* deallocate image each time .... */
-        /*if (&mEglSlots[buf].mEglImage != EGL_NO_IMAGE_KHR) {
-            eglDestroyImageKHR(mEglDisplay, &mEglSlots[buf].mEglImage);
-            mEglSlots[buf].mEglImage = (android::GLConsumer::EglImage*)EGL_NO_IMAGE_KHR;
-        }*/
         /* test if source and convert buffer size are ok */
         if (mSlots[buf].mGraphicBuffer != NULL && mBlitSlots[mNextBlitSlot] != NULL) {
             sp<GraphicBuffer> srcBuf = mSlots[buf].mGraphicBuffer;
@@ -503,28 +493,40 @@ status_t GLConsumer::updateAndReleaseLocked(const BufferQueue::BufferItem& item)
             return UNKNOWN_ERROR;
         }
         textureBuffer = mBlitSlots[mNextBlitSlot];
-        mEglSlots[buf].mEglImage = new EglImage(textureBuffer);
         mNextBlitSlot = (mNextBlitSlot + 1) % BufferQueue::NUM_BLIT_BUFFER_SLOTS;
-    } 
+    } else {
+         textureBuffer = mSlots[buf].mGraphicBuffer;
+    }
+ 
+     // Set EglImage to use the new textureBuffer
+     mEglSlots[buf].mEglImage->setGraphicBuffer(textureBuffer);
+#endif
+    // Ensure we have a valid EglImageKHR for the slot, creating an EglImage
+    // if nessessary, for the gralloc buffer currently in the slot in
+    // ConsumerBase.
+    // We may have to do this even when item.mGraphicBuffer == NULL (which
+    // means the buffer was previously acquired).
+
+#ifdef STE_HARDWARE
+    // Force EglImage to destroy old eglImage and create a new one
+    // using textureBuffer.
+    err = mEglSlots[buf].mEglImage->createIfNeeded(mEglDisplay, item.mCrop, true);
+#else
+     err = mEglSlots[buf].mEglImage->createIfNeeded(mEglDisplay, item.mCrop);
 #endif
 
-    err = mEglSlots[buf].mEglImage->createIfNeeded(mEglDisplay, item.mCrop);
-    if (err != NO_ERROR) {
-        ST_LOGW("updateAndRelease: unable to createImage on display=%p slot=%d",
-                mEglDisplay, buf);
-        releaseBufferLocked(buf, mSlots[buf].mGraphicBuffer,
-                mEglDisplay, EGL_NO_SYNC_KHR);
-        return UNKNOWN_ERROR;
-    }
 
-    // Do whatever sync ops we need to do before releasing the old slot.
-    err = syncForReleaseLocked(mEglDisplay);
     if (err != NO_ERROR) {
         // Release the buffer we just acquired.  It's not safe to
         // release the old buffer, so instead we just drop the new frame.
         // As we are still under lock since acquireBuffer, it is safe to
         // release by slot.
-        releaseBufferLocked(buf, mSlots[buf].mGraphicBuffer, mEglDisplay, EGL_NO_SYNC_KHR);
+#ifdef STE_HARDWARE
+        releaseBufferLocked(buf, textureBuffer,
+#else        
+        releaseBufferLocked(buf, mSlots[buf].mGraphicBuffer,
+#endif
+                mEglDisplay, EGL_NO_SYNC_KHR);
         return err;
     }
 
-- 
1.9.1

