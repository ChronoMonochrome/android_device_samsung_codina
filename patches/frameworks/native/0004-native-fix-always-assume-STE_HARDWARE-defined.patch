From ce6dcb1c572bb6cdea68109b58bff75127fced42 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Sun, 4 Sep 2016 20:41:04 +0700
Subject: [PATCH 4/7] native fix: always assume STE_HARDWARE defined

Change-Id: I0a3d198876f2a72ffa0bd8e3d51d63eed05a21bf
---
 include/binder/MemoryBase.h               |  2 --
 include/binder/Parcel.h                   | 42 ---------------------------
 include/gui/BufferQueue.h                 |  2 --
 include/gui/ConsumerBase.h                |  2 --
 include/gui/GLConsumer.h                  | 10 -------
 include/gui/IGraphicBufferProducer.h      |  5 ----
 include/media/openmax/OMX_IVCommon.h      |  2 --
 include/ui/Fence.h                        |  4 ---
 include/ui/GraphicBuffer.h                |  8 ------
 include/ui/PixelFormat.h                  |  2 --
 include/ui/Region.h                       |  4 ---
 libs/binder/MemoryBase.cpp                |  4 ---
 libs/binder/Parcel.cpp                    |  4 ---
 libs/gui/GLConsumer.cpp                   | 16 -----------
 opengl/include/EGL/eglext.h               | 15 ----------
 opengl/libs/EGL/eglApi.cpp                | 48 -------------------------------
 opengl/libs/EGL/egl_entries.in            |  7 -----
 services/surfaceflinger/DisplayDevice.cpp | 19 ------------
 services/surfaceflinger/DisplayDevice.h   |  3 --
 19 files changed, 199 deletions(-)

diff --git a/include/binder/MemoryBase.h b/include/binder/MemoryBase.h
index 5bf104b..f55f7a9 100644
--- a/include/binder/MemoryBase.h
+++ b/include/binder/MemoryBase.h
@@ -38,9 +38,7 @@ protected:
     size_t getSize() const { return mSize; }
     ssize_t getOffset() const { return mOffset; }
     const sp<IMemoryHeap>& getHeap() const { return mHeap; }
-#ifdef STE_HARDWARE
     virtual sp<IMemoryHeap> getMemory(long* offset, unsigned int* size) const;
-#endif
 
 private:
     size_t          mSize;
diff --git a/include/binder/Parcel.h b/include/binder/Parcel.h
index 20d4974..fce5da2 100644
--- a/include/binder/Parcel.h
+++ b/include/binder/Parcel.h
@@ -36,11 +36,7 @@
 namespace android {
 
 template <typename T> class LightFlattenable;
-#ifdef STE_HARDWARE
 class Flattenable;
-#else
-template <typename T> class Flattenable;
-#endif
 class IBinder;
 class IPCThreadState;
 class ProcessState;
@@ -164,12 +160,7 @@ public:
 
     status_t            writeParcelable(const Parcelable& parcelable);
 
-#ifdef STE_HARDWARE
     status_t            write(const Flattenable& val);
-#else
-    template<typename T>
-    status_t            write(const Flattenable<T>& val);
-#endif
 
     template<typename T>
     status_t            write(const LightFlattenable<T>& val);
@@ -302,12 +293,7 @@ public:
                             std::unique_ptr<std::vector<std::unique_ptr<std::string>>>* val) const;
     status_t            readUtf8VectorFromUtf16Vector(std::vector<std::string>* val) const;
 
-#ifdef STE_HARDWARE
     status_t            read(Flattenable& val) const;
-#else
-    template<typename T>
-    status_t            read(Flattenable<T>& val) const;
-#endif
 
     template<typename T>
     status_t            read(LightFlattenable<T>& val) const;
@@ -471,18 +457,10 @@ private:
         virtual status_t unflatten(void const* buffer, size_t size, int const* fds, size_t count) = 0;
     };
 
-#ifndef STE_HARDWARE
-    template<typename T>
-#endif
     class FlattenableHelper : public FlattenableHelperInterface {
         friend class Parcel;
-#ifdef STE_HARDWARE
         const Flattenable& val;
         explicit FlattenableHelper(const Flattenable& val) : val(val) { }
-#else
-        const Flattenable<T>& val;
-        explicit FlattenableHelper(const Flattenable<T>& val) : val(val) { }
-#endif
 
     public:
         virtual size_t getFlattenedSize() const {
@@ -495,11 +473,7 @@ private:
             return val.flatten(buffer, size, fds, count);
         }
         virtual status_t unflatten(void const* buffer, size_t size, int const* fds, size_t count) {
-#ifdef STE_HARDWARE
             return const_cast<Flattenable&>(val).unflatten(buffer, size, fds, count);
-#else
-            return const_cast<Flattenable<T>&>(val).unflatten(buffer, size, fds, count);
-#endif
         }
     };
     status_t write(const FlattenableHelperInterface& val);
@@ -532,14 +506,6 @@ public:
 
 // ---------------------------------------------------------------------------
 
-#ifndef STE_HARDWARE
-template<typename T>
-status_t Parcel::write(const Flattenable<T>& val) {
-    const FlattenableHelper<T> helper(val);
-    return write(helper);
-}
-#endif
-
 template<typename T>
 status_t Parcel::write(const LightFlattenable<T>& val) {
     size_t size(val.getFlattenedSize());
@@ -558,14 +524,6 @@ status_t Parcel::write(const LightFlattenable<T>& val) {
     return NO_ERROR;
 }
 
-#ifndef STE_HARDWARE
-template<typename T>
-status_t Parcel::read(Flattenable<T>& val) const {
-    FlattenableHelper<T> helper(val);
-    return read(helper);
-}
-#endif
-
 template<typename T>
 status_t Parcel::read(LightFlattenable<T>& val) const {
     size_t size;
diff --git a/include/gui/BufferQueue.h b/include/gui/BufferQueue.h
index dacdf9e..3f8c0e6 100644
--- a/include/gui/BufferQueue.h
+++ b/include/gui/BufferQueue.h
@@ -42,9 +42,7 @@ public:
         PRESENT_LATER = IGraphicBufferConsumer::PRESENT_LATER,
     };
 
-#ifdef STE_HARDWARE
     enum { NUM_BLIT_BUFFER_SLOTS = 2 };
-#endif
 
     // When in async mode we reserve two slots in order to guarantee that the
     // producer and consumer can run asynchronously.
diff --git a/include/gui/ConsumerBase.h b/include/gui/ConsumerBase.h
index 19158ac..9e4086a 100644
--- a/include/gui/ConsumerBase.h
+++ b/include/gui/ConsumerBase.h
@@ -179,9 +179,7 @@ protected:
             EGLDisplay display, EGLSyncKHR eglFence);
 
     // returns true if the slot still has the graphicBuffer in it.
-#ifdef STE_HARDWARE
     virtual
-#endif
     bool stillTracking(int slot, const sp<GraphicBuffer> graphicBuffer);
 
     // addReleaseFence* adds the sync points associated with a fence to the set
diff --git a/include/gui/GLConsumer.h b/include/gui/GLConsumer.h
index 6d82d55..29092ab 100644
--- a/include/gui/GLConsumer.h
+++ b/include/gui/GLConsumer.h
@@ -30,10 +30,8 @@
 #include <utils/Vector.h>
 #include <utils/threads.h>
 
-#ifdef STE_HARDWARE
 #include <hardware/copybit.h>
 #include <gui/IGraphicBufferAlloc.h>
-#endif
 
 namespace android {
 // ----------------------------------------------------------------------------
@@ -94,10 +92,8 @@ public:
     GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t texureTarget,
             bool useFenceSync, bool isControlledByApp);
 
-#ifdef STE_HARDWARE
     // Method for closing copybit device while abandoning the surface 
     virtual ~GLConsumer();
-#endif
 
     // updateTexImage acquires the most recently queued buffer, and sets the
     // image contents of the target texture to it.
@@ -264,10 +260,8 @@ protected:
             const sp<GraphicBuffer> graphicBuffer,
             EGLDisplay display, EGLSyncKHR eglFence);
 
-#ifdef STE_HARDWARE
     // returns true if the slot still has the graphicBuffer in it.
     virtual bool stillTracking(int slot, const sp<GraphicBuffer> graphicBuffer);
-#endif
 
     status_t releaseBufferLocked(int slot,
             const sp<GraphicBuffer> graphicBuffer, EGLSyncKHR eglFence) {
@@ -344,10 +338,8 @@ private:
         EGLImageKHR createImage(EGLDisplay dpy,
                 const sp<GraphicBuffer>& graphicBuffer, const Rect& crop);
 
-#ifdef STE_HARDWARE
     // converts buffer to a suitable color format
     status_t convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf);
-#endif
 
         // Disallow copying
         EglImage(const EglImage& rhs);
@@ -504,7 +496,6 @@ private:
     // reset mCurrentTexture to INVALID_BUFFER_SLOT.
     int mCurrentTexture;
 
-#ifdef STE_HARDWARE
     // mBlitEngine is the handle to the copybit device which will be used in
     // case color transform is needed before the EGL image is created.
     copybit_device_t* mBlitEngine;
@@ -518,7 +509,6 @@ private:
     // filled in with the result of GLConsumer::updateAndReleaseLocked
     sp<GraphicBuffer> mBlitSlots[BufferQueue::NUM_BLIT_BUFFER_SLOTS];
     int mNextBlitSlot;
-#endif
 
     // mAttached indicates whether the ConsumerBase is currently attached to
     // an OpenGL ES context.  For legacy reasons, this is initialized to true,
diff --git a/include/gui/IGraphicBufferProducer.h b/include/gui/IGraphicBufferProducer.h
index 68137f7..7439c11 100644
--- a/include/gui/IGraphicBufferProducer.h
+++ b/include/gui/IGraphicBufferProducer.h
@@ -290,12 +290,7 @@ public:
     //              * the slot was enqueued without requesting a buffer
     //              * crop rect is out of bounds of the buffer dimensions
 
-#ifdef STE_HARDWARE
     struct QueueBufferInput : public Flattenable {
-#else
-    struct QueueBufferInput : public Flattenable<QueueBufferInput> {
-        friend class Flattenable<QueueBufferInput>;
-#endif
         inline QueueBufferInput(const Parcel& parcel);
         // timestamp - a monotonically increasing value in nanoseconds
         // isAutoTimestamp - if the timestamp was synthesized at queue time
diff --git a/include/media/openmax/OMX_IVCommon.h b/include/media/openmax/OMX_IVCommon.h
index 7ce89ab..a2f5418 100644
--- a/include/media/openmax/OMX_IVCommon.h
+++ b/include/media/openmax/OMX_IVCommon.h
@@ -166,9 +166,7 @@ typedef enum OMX_COLOR_FORMATTYPE {
     OMX_COLOR_FormatYUV420Flexible = 0x7F420888,
 
     OMX_TI_COLOR_FormatYUV420PackedSemiPlanar = 0x7F000100,
-#ifdef STE_HARDWARE
     OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB = 0x7FA00000,
-#endif
     OMX_QCOM_COLOR_FormatYVU420SemiPlanar = 0x7FA30C00,
     OMX_QCOM_COLOR_FormatYUV420PackedSemiPlanar64x32Tile2m8ka = 0x7FA30C03,
     OMX_SEC_COLOR_FormatNV12Tiled = 0x7FC00002,
diff --git a/include/ui/Fence.h b/include/ui/Fence.h
index 69a8061..095745d 100644
--- a/include/ui/Fence.h
+++ b/include/ui/Fence.h
@@ -36,11 +36,7 @@ namespace android {
 // ===========================================================================
 
 class Fence
-#ifdef STE_HARDWARE
     : public LightRefBase<Fence>, public Flattenable
-#else
-    : public LightRefBase<Fence>, public Flattenable<Fence>
-#endif
 {
 public:
     static const sp<Fence> NO_FENCE;
diff --git a/include/ui/GraphicBuffer.h b/include/ui/GraphicBuffer.h
index ae8bac5..74a5ba4 100644
--- a/include/ui/GraphicBuffer.h
+++ b/include/ui/GraphicBuffer.h
@@ -39,17 +39,9 @@ class GraphicBufferMapper;
 
 class GraphicBuffer
     : public ANativeObjectBase< ANativeWindowBuffer, GraphicBuffer,
-#ifdef STE_HARDWARE
     LightRefBase<GraphicBuffer> >,
       public Flattenable
-#else
-    RefBase >,
-      public Flattenable<GraphicBuffer>
-#endif
 {
-#ifndef STE_HARDWARE
-    friend class Flattenable<GraphicBuffer>;
-#endif
 public:
 
     enum {
diff --git a/include/ui/PixelFormat.h b/include/ui/PixelFormat.h
index 90f57cd..138f023 100644
--- a/include/ui/PixelFormat.h
+++ b/include/ui/PixelFormat.h
@@ -61,13 +61,11 @@ enum {
     PIXEL_FORMAT_RGBA_5551   = 6,                            // 16-bit ARGB
     PIXEL_FORMAT_RGBA_4444   = 7,                            // 16-bit ARGB
 
-#ifdef STE_HARDWARE
     // Added Support for YUV42XMBN,
     // Required for Copybit CC acceleration
     PIXEL_FORMAT_YCBCR42XMBN = HAL_PIXEL_FORMAT_YCBCR42XMBN,
     PIXEL_FORMAT_YCbCr_420_SP = HAL_PIXEL_FORMAT_YCbCr_420_SP,
     PIXEL_FORMAT_YCbCr_420_P = HAL_PIXEL_FORMAT_YCbCr_420_P,
-#endif
 
 };
 
diff --git a/include/ui/Region.h b/include/ui/Region.h
index 383e8ed..6f07f0a 100644
--- a/include/ui/Region.h
+++ b/include/ui/Region.h
@@ -25,9 +25,7 @@
 #include <ui/Rect.h>
 #include <utils/Flattenable.h>
 
-#ifdef STE_HARDWARE
 #include <hardware/copybit.h>
-#endif
 
 namespace android {
 // ---------------------------------------------------------------------------
@@ -215,7 +213,6 @@ Region& Region::operator += (const Point& pt) {
     return translateSelf(pt.x, pt.y);
 }
 // ---------------------------------------------------------------------------
-#ifdef STE_HARDWARE
 struct region_iterator : public copybit_region_t {
     region_iterator(const Region& region)
         : b(region.begin()), e(region.end()) {
@@ -233,7 +230,6 @@ private:
     mutable Region::const_iterator b;
     Region::const_iterator const e;
 };
-#endif
 // ---------------------------------------------------------------------------
 }; // namespace android
 
diff --git a/libs/binder/MemoryBase.cpp b/libs/binder/MemoryBase.cpp
index e6d6401..f9e7285 100644
--- a/libs/binder/MemoryBase.cpp
+++ b/libs/binder/MemoryBase.cpp
@@ -25,9 +25,7 @@ namespace android {
 
 // ---------------------------------------------------------------------------
 
-#ifdef STE_HARDWARE
 extern "C" void _ZN7android10MemoryBaseC2ERKNS_2spINS_11IMemoryHeapEEElj() __attribute__((alias("_ZN7android10MemoryBaseC1ERKNS_2spINS_11IMemoryHeapEEElj")));
-#endif
 
 MemoryBase::MemoryBase(const sp<IMemoryHeap>& heap,
         ssize_t offset, size_t size)
@@ -46,7 +44,6 @@ MemoryBase::~MemoryBase()
 {
 }
 
-#ifdef STE_HARDWARE
 sp<IMemoryHeap> android::MemoryBase::getMemory(long* offset, unsigned int* size) const
 {
     ssize_t offset_o;
@@ -59,7 +56,6 @@ sp<IMemoryHeap> android::MemoryBase::getMemory(long* offset, unsigned int* size)
 
     return res;
 }
-#endif
 
 // ---------------------------------------------------------------------------
 }; // namespace android
diff --git a/libs/binder/Parcel.cpp b/libs/binder/Parcel.cpp
index 0b7348b..886b6b6 100644
--- a/libs/binder/Parcel.cpp
+++ b/libs/binder/Parcel.cpp
@@ -1267,12 +1267,10 @@ status_t Parcel::writeDupImmutableBlobFileDescriptor(int fd)
     return writeDupFileDescriptor(fd);
 }
 
-#ifdef STE_HARDWARE
 status_t Parcel::write(const Flattenable& val) {
     const FlattenableHelper helper(val);
     return write(helper);
 }
-#endif
 
 status_t Parcel::write(const FlattenableHelperInterface& val)
 {
@@ -2062,12 +2060,10 @@ status_t Parcel::readBlob(size_t len, ReadableBlob* outBlob) const
     return NO_ERROR;
 }
 
-#ifdef STE_HARDWARE
 status_t Parcel::read(Flattenable& val) const {
     FlattenableHelper helper(val);
     return read(helper);
 }
-#endif
 
 status_t Parcel::read(FlattenableHelperInterface& val) const
 {
diff --git a/libs/gui/GLConsumer.cpp b/libs/gui/GLConsumer.cpp
index bb2f344..a5b827f 100644
--- a/libs/gui/GLConsumer.cpp
+++ b/libs/gui/GLConsumer.cpp
@@ -167,9 +167,7 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex,
     mEglDisplay(EGL_NO_DISPLAY),
     mEglContext(EGL_NO_CONTEXT),
     mCurrentTexture(BufferQueue::INVALID_BUFFER_SLOT),
-#ifdef STE_HARDWARE
     mNextBlitSlot(0),
-#endif
     mAttached(true)
 {
     GLC_LOGV("GLConsumer");
@@ -177,7 +175,6 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex,
     memcpy(mCurrentTransformMatrix, mtxIdentity,
             sizeof(mCurrentTransformMatrix));
 
-#ifdef STE_HARDWARE
     hw_module_t const* module;
     mBlitEngine = 0;
     if (hw_get_module(COPYBIT_HARDWARE_MODULE_ID, &module) == 0) {
@@ -190,7 +187,6 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t tex,
     if (mGraphicBufferAlloc == 0) {
         GLC_LOGE("createGraphicBufferAlloc() failed in SurfaceTexture()");
     }
-#endif
 
     mConsumer->setConsumerUsageBits(DEFAULT_USAGE_FLAGS);
 }
@@ -213,9 +209,7 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t texTarget,
     mEglDisplay(EGL_NO_DISPLAY),
     mEglContext(EGL_NO_CONTEXT),
     mCurrentTexture(BufferQueue::INVALID_BUFFER_SLOT),
-#ifdef STE_HARDWARE
     mNextBlitSlot(0),
-#endif
     mAttached(false)
 {
     GLC_LOGV("GLConsumer");
@@ -223,7 +217,6 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t texTarget,
     memcpy(mCurrentTransformMatrix, mtxIdentity,
             sizeof(mCurrentTransformMatrix));
 
-#ifdef STE_HARDWARE
     hw_module_t const* module;
     mBlitEngine = 0;
     if (hw_get_module(COPYBIT_HARDWARE_MODULE_ID, &module) == 0) {
@@ -236,12 +229,10 @@ GLConsumer::GLConsumer(const sp<IGraphicBufferConsumer>& bq, uint32_t texTarget,
     if (mGraphicBufferAlloc == 0) {
         GLC_LOGE("createGraphicBufferAlloc() failed in SurfaceTexture()");
     }
-#endif
 
     mConsumer->setConsumerUsageBits(DEFAULT_USAGE_FLAGS);
 }
 
-#ifdef STE_HARDWARE
 GLConsumer::~GLConsumer() {
     GLC_LOGV("~GLConsumer");
     abandon();
@@ -250,7 +241,6 @@ GLConsumer::~GLConsumer() {
         copybit_close(mBlitEngine);
     }
 }
-#endif
 
 status_t GLConsumer::setDefaultBufferSize(uint32_t w, uint32_t h)
 {
@@ -443,7 +433,6 @@ status_t GLConsumer::releaseBufferLocked(int buf,
     return err;
 }
 
-#ifdef STE_HARDWARE
 bool GLConsumer::stillTracking(int slot,
         const sp<GraphicBuffer> graphicBuffer) {
     if (slot < 0 || slot >= BufferQueue::NUM_BUFFER_SLOTS) {
@@ -459,7 +448,6 @@ bool GLConsumer::stillTracking(int slot,
             (mBlitSlots[0] != NULL && mBlitSlots[0]->handle == graphicBuffer->handle) ||
             (mBlitSlots[1] != NULL && mBlitSlots[1]->handle == graphicBuffer->handle));
 }
-#endif
 
 status_t GLConsumer::updateAndReleaseLocked(const BufferItem& item,
         PendingRelease* pendingRelease)
@@ -484,7 +472,6 @@ status_t GLConsumer::updateAndReleaseLocked(const BufferItem& item,
         return err;
     }
 
-#ifdef STE_HARDWARE
     sp<GraphicBuffer> textureBuffer;
     if (mSlots[slot].mGraphicBuffer->getPixelFormat() == HAL_PIXEL_FORMAT_YCBCR42XMBN
      || mSlots[slot].mGraphicBuffer->getPixelFormat() == HAL_PIXEL_FORMAT_YCbCr_420_P) {
@@ -536,7 +523,6 @@ status_t GLConsumer::updateAndReleaseLocked(const BufferItem& item,
         mEglSlots[slot].mEglImage = new EglImage(textureBuffer);
         mNextBlitSlot = (mNextBlitSlot + 1) % BufferQueue::NUM_BLIT_BUFFER_SLOTS;
     } 
-#endif
 
     // Ensure we have a valid EglImageKHR for the slot, creating an EglImage
     // if nessessary, for the gralloc buffer currently in the slot in
@@ -1248,7 +1234,6 @@ void GLConsumer::dumpLocked(String8& result, const char* prefix) const
     ConsumerBase::dumpLocked(result, prefix);
 }
 
-#ifdef STE_HARDWARE
 status_t GLConsumer::convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBuf) {
 
     /* For some reason mBlitEngine is not being initialized in
@@ -1299,7 +1284,6 @@ status_t GLConsumer::convert(sp<GraphicBuffer> &srcBuf, sp<GraphicBuffer> &dstBu
     }
     return OK;
 }
-#endif
 
 static void mtxMul(float out[16], const float a[16], const float b[16]) {
     out[0] = a[0]*b[0] + a[4]*b[1] + a[8]*b[2] + a[12]*b[3];
diff --git a/opengl/include/EGL/eglext.h b/opengl/include/EGL/eglext.h
index 4ccdbb7..f8d3830 100644
--- a/opengl/include/EGL/eglext.h
+++ b/opengl/include/EGL/eglext.h
@@ -321,21 +321,6 @@ typedef EGLBoolean (EGLAPIENTRYP PFNEGLQUERYSURFACEPOINTERANGLEPROC) (EGLDisplay
 #define EGL_COVERAGE_SAMPLE_RESOLVE_NONE_NV	0x3133
 #endif
 
-#if KHRONOS_SUPPORT_INT64   /* EGLuint64NV requires 64-bit uint support */
-#ifndef STE_HARDWARE
-#ifndef EGL_NV_system_time
-#define EGL_NV_system_time 1
-typedef khronos_utime_nanoseconds_t EGLuint64NV;
-#ifdef EGL_EGLEXT_PROTOTYPES
-EGLAPI EGLuint64NV EGLAPIENTRY eglGetSystemTimeFrequencyNV(void);
-EGLAPI EGLuint64NV EGLAPIENTRY eglGetSystemTimeNV(void);
-#endif /* EGL_EGLEXT_PROTOTYPES */
-typedef EGLuint64NV (EGLAPIENTRYP PFNEGLGETSYSTEMTIMEFREQUENCYNVPROC) (void);
-typedef EGLuint64NV (EGLAPIENTRYP PFNEGLGETSYSTEMTIMENVPROC) (void);
-#endif
-#endif
-#endif
-
 #if KHRONOS_SUPPORT_INT64 /* EGLuint64KHR requires 64-bit uint support */
 #ifndef EGL_KHR_stream
 #define EGL_KHR_stream 1
diff --git a/opengl/libs/EGL/eglApi.cpp b/opengl/libs/EGL/eglApi.cpp
index 31efc11..3593d8e 100644
--- a/opengl/libs/EGL/eglApi.cpp
+++ b/opengl/libs/EGL/eglApi.cpp
@@ -157,13 +157,6 @@ static const extention_map_t sExtensionMap[] = {
     { "eglGetSyncAttribKHR",
             (__eglMustCastToProperFunctionPointerType)&eglGetSyncAttribKHR },
 
-#ifndef STE_HARDWARE
-    // EGL_NV_system_time
-    { "eglGetSystemTimeFrequencyNV",
-            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeFrequencyNV },
-    { "eglGetSystemTimeNV",
-            (__eglMustCastToProperFunctionPointerType)&eglGetSystemTimeNV },
-#endif
 
     // EGL_KHR_wait_sync
     { "eglWaitSyncKHR",
@@ -1880,47 +1873,6 @@ EGLClientBuffer eglCreateNativeClientBufferANDROID(const EGLint *attrib_list)
 }
 
 // ----------------------------------------------------------------------------
-// NVIDIA extensions
-// ----------------------------------------------------------------------------
-#ifndef STE_HARDWARE
-EGLuint64NV eglGetSystemTimeFrequencyNV()
-{
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    EGLuint64NV ret = 0;
-    egl_connection_t* const cnx = &gEGLImpl;
-
-    if (cnx->dso && cnx->egl.eglGetSystemTimeFrequencyNV) {
-        return cnx->egl.eglGetSystemTimeFrequencyNV();
-    }
-
-    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-}
-
-EGLuint64NV eglGetSystemTimeNV()
-{
-    clearError();
-
-    if (egl_init_drivers() == EGL_FALSE) {
-        return setError(EGL_BAD_PARAMETER, EGL_FALSE);
-    }
-
-    EGLuint64NV ret = 0;
-    egl_connection_t* const cnx = &gEGLImpl;
-
-    if (cnx->dso && cnx->egl.eglGetSystemTimeNV) {
-        return cnx->egl.eglGetSystemTimeNV();
-    }
-
-    return setErrorQuiet(EGL_BAD_DISPLAY, 0);
-}
-#endif
-
-// ----------------------------------------------------------------------------
 // Partial update extension
 // ----------------------------------------------------------------------------
 EGLBoolean eglSetDamageRegionKHR(EGLDisplay dpy, EGLSurface surface,
diff --git a/opengl/libs/EGL/egl_entries.in b/opengl/libs/EGL/egl_entries.in
index 5351154..eda5645 100644
--- a/opengl/libs/EGL/egl_entries.in
+++ b/opengl/libs/EGL/egl_entries.in
@@ -82,13 +82,6 @@ EGL_ENTRY(EGLClientBuffer, eglGetRenderBufferANDROID, EGLDisplay, EGLSurface)
 EGL_ENTRY(EGLint, eglDupNativeFenceFDANDROID, EGLDisplay, EGLSyncKHR)
 EGL_ENTRY(EGLClientBuffer, eglCreateNativeClientBufferANDROID, const EGLint *)
 
-/* NVIDIA extensions */
-
-#ifndef STE_HARDWARE
-EGL_ENTRY(EGLuint64NV, eglGetSystemTimeFrequencyNV, void)
-EGL_ENTRY(EGLuint64NV, eglGetSystemTimeNV, void)
-#endif
-
 /* IMG extensions */
 
 EGL_ENTRY(EGLBoolean, eglHibernateProcessIMG, void)
diff --git a/services/surfaceflinger/DisplayDevice.cpp b/services/surfaceflinger/DisplayDevice.cpp
index ec275b4..49d1063 100755
--- a/services/surfaceflinger/DisplayDevice.cpp
+++ b/services/surfaceflinger/DisplayDevice.cpp
@@ -30,9 +30,7 @@
 
 #include <ui/DisplayInfo.h>
 #include <ui/PixelFormat.h>
-#ifdef STE_HARDWARE
 #include <ui/FramebufferNativeWindow.h>
-#endif
 
 #include <gui/Surface.h>
 
@@ -106,13 +104,7 @@ DisplayDevice::DisplayDevice(
       mPowerMode(HWC_POWER_MODE_OFF),
       mActiveConfig(0)
 {
-#ifdef STE_HARDWARE
     ANativeWindow* const window = new FramebufferNativeWindow();
-#else
-    Surface* surface;
-    mNativeWindow = surface = new Surface(producer, false);
-    ANativeWindow* const window = mNativeWindow.get();
-#endif
     char property[PROPERTY_VALUE_MAX];
 
     /*
@@ -508,12 +500,7 @@ void DisplayDevice::setDisplaySize(const int newWidth, const int newHeight) {
 
     mDisplaySurface->resizeBuffers(newWidth, newHeight);
 
-#ifdef STE_HARDWARE
     ANativeWindow* const window = new FramebufferNativeWindow();
-#else
-    mNativeWindow = new Surface(producer, false);
-    ANativeWindow* const window = mNativeWindow.get();
-#endif
     mSurface = eglCreateWindowSurface(mDisplay, mConfig, window, NULL);
     eglQuerySurface(mDisplay, mSurface, EGL_WIDTH,  &mDisplayWidth);
     eglQuerySurface(mDisplay, mSurface, EGL_HEIGHT, &mDisplayHeight);
@@ -628,18 +615,12 @@ void DisplayDevice::dump(String8& result) const {
     result.appendFormat(
         "+ DisplayDevice: %s\n"
         "   type=%x, hwcId=%d, layerStack=%u, (%4dx%4d),"
-#ifndef STE_HARDWARE
-	" ANativeWindow=%p,"
-#endif
 	" orient=%2d (type=%08x),\n"
         "flips=%u, isSecure=%d, powerMode=%d, activeConfig=%d, numLayers=%zu\n"
         "   v:[%d,%d,%d,%d], f:[%d,%d,%d,%d], s:[%d,%d,%d,%d],"
         "transform:[[%0.3f,%0.3f,%0.3f][%0.3f,%0.3f,%0.3f][%0.3f,%0.3f,%0.3f]]\n",
         mDisplayName.string(), mType, mHwcDisplayId,
         mLayerStack, mDisplayWidth, mDisplayHeight, 
-#ifndef STE_HARDWARE
-	mNativeWindow.get(),
-#endif
         mOrientation, tr.getType(), getPageFlipCount(),
         mIsSecure, mPowerMode, mActiveConfig,
         mVisibleLayersSortedByZ.size(),
diff --git a/services/surfaceflinger/DisplayDevice.h b/services/surfaceflinger/DisplayDevice.h
index 2e60aa0..2a6d838 100644
--- a/services/surfaceflinger/DisplayDevice.h
+++ b/services/surfaceflinger/DisplayDevice.h
@@ -211,9 +211,6 @@ private:
     wp<IBinder> mDisplayToken;
 
     // ANativeWindow this display is rendering into
-#ifndef STE_HARDWARE
-    sp<ANativeWindow> mNativeWindow;
-#endif
     sp<DisplaySurface> mDisplaySurface;
 
     EGLConfig       mConfig;
-- 
2.5.0

