From 7a00f5f9b401b2f8a88bf8ab90b0f5932981a6b1 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Sat, 5 Sep 2015 17:53:34 +0300
Subject: [PATCH] Add headers from device

Change-Id: I100abf33ddc4857b050b7fa73279168bf8c80730
---
 include/hardware/audio.h | 320 +++++++++++++++++++++++++++++++++---------
 include/hardware/fb.h    |  16 +--
 include/hardware/gps.h   | 355 +++++++++++++++++++++--------------------------
 3 files changed, 420 insertions(+), 271 deletions(-)

diff --git a/include/hardware/audio.h b/include/hardware/audio.h
index 5ad4751..6575572 100644
--- a/include/hardware/audio.h
+++ b/include/hardware/audio.h
@@ -1,5 +1,7 @@
 /*
  * Copyright (C) 2011 The Android Open Source Project
+ * Copyright (c) 2011-2014, The Linux Foundation. All rights reserved.
+ * Not a Contribution.
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -28,6 +30,9 @@
 #include <hardware/hardware.h>
 #include <system/audio.h>
 #include <hardware/audio_effect.h>
+#ifdef AUDIO_LISTEN_ENABLED
+#include <listen_types.h>
+#endif
 
 __BEGIN_DECLS
 
@@ -55,9 +60,14 @@ __BEGIN_DECLS
 #define AUDIO_DEVICE_API_VERSION_1_0 HARDWARE_DEVICE_API_VERSION(1, 0)
 #define AUDIO_DEVICE_API_VERSION_2_0 HARDWARE_DEVICE_API_VERSION(2, 0)
 #define AUDIO_DEVICE_API_VERSION_3_0 HARDWARE_DEVICE_API_VERSION(3, 0)
-#define AUDIO_DEVICE_API_VERSION_CURRENT AUDIO_DEVICE_API_VERSION_3_0
+#ifndef ICS_AUDIO_BLOB
+#define AUDIO_DEVICE_API_VERSION_CURRENT AUDIO_DEVICE_API_VERSION_2_0
 /* Minimal audio HAL version supported by the audio framework */
-#define AUDIO_DEVICE_API_VERSION_MIN AUDIO_DEVICE_API_VERSION_2_0
+#define AUDIO_DEVICE_API_VERSION_MIN AUDIO_DEVICE_API_VERSION_1_0
+#else
+#define AUDIO_DEVICE_API_VERSION_CURRENT AUDIO_DEVICE_API_VERSION_1_0
+#define AUDIO_DEVICE_API_VERSION_MIN AUDIO_DEVICE_API_VERSION_1_0
+#endif
 
 /**
  * List of known audio HAL modules. This is the base name of the audio HAL
@@ -112,23 +122,17 @@ __BEGIN_DECLS
 /* Bluetooth SCO wideband */
 #define AUDIO_PARAMETER_KEY_BT_SCO_WB "bt_wbs"
 
-/* Get a new HW synchronization source identifier.
- * Return a valid source (positive integer) or AUDIO_HW_SYNC_INVALID if an error occurs
- * or no HW sync is available. */
-#define AUDIO_PARAMETER_HW_AV_SYNC "hw_av_sync"
-
 /**
  *  audio stream parameters
  */
 
-#define AUDIO_PARAMETER_STREAM_ROUTING "routing"             /* audio_devices_t */
-#define AUDIO_PARAMETER_STREAM_FORMAT "format"               /* audio_format_t */
-#define AUDIO_PARAMETER_STREAM_CHANNELS "channels"           /* audio_channel_mask_t */
-#define AUDIO_PARAMETER_STREAM_FRAME_COUNT "frame_count"     /* size_t */
-#define AUDIO_PARAMETER_STREAM_INPUT_SOURCE "input_source"   /* audio_source_t */
+#define AUDIO_PARAMETER_STREAM_ROUTING "routing"            /* audio_devices_t */
+#define AUDIO_PARAMETER_STREAM_FORMAT "format"              /* audio_format_t */
+#define AUDIO_PARAMETER_STREAM_CHANNELS "channels"          /* audio_channel_mask_t */
+#define AUDIO_PARAMETER_STREAM_FRAME_COUNT "frame_count"    /* size_t */
+#define AUDIO_PARAMETER_STREAM_INPUT_SOURCE "input_source"  /* audio_source_t */
 #define AUDIO_PARAMETER_STREAM_SAMPLING_RATE "sampling_rate" /* uint32_t */
 
-#define AUDIO_PARAMETER_DEVICE_CONNECT "connect"            /* audio_devices_t */
 #define AUDIO_PARAMETER_DEVICE_DISCONNECT "disconnect"      /* audio_devices_t */
 
 /* Query supported formats. The response is a '|' separated list of strings from
@@ -141,8 +145,11 @@ __BEGIN_DECLS
  * "sup_sampling_rates=44100|48000" */
 #define AUDIO_PARAMETER_STREAM_SUP_SAMPLING_RATES "sup_sampling_rates"
 
-/* Set the HW synchronization source for an output stream. */
+/* Get the HW synchronization source used for an output stream.
+ * Return a valid source (positive integer) or AUDIO_HW_SYNC_INVALID if an error occurs
+ * or no HW sync source is used. */
 #define AUDIO_PARAMETER_STREAM_HW_AV_SYNC "hw_av_sync"
+#define AUDIO_PARAMETER_HW_AV_SYNC "hw_av_sync"
 
 /**
  * audio codec parameters
@@ -160,9 +167,59 @@ __BEGIN_DECLS
 #define AUDIO_OFFLOAD_CODEC_DOWN_SAMPLING  "music_offload_down_sampling"
 #define AUDIO_OFFLOAD_CODEC_DELAY_SAMPLES  "delay_samples"
 #define AUDIO_OFFLOAD_CODEC_PADDING_SAMPLES  "padding_samples"
+#define AUDIO_OFFLOAD_CODEC_WMA_FORMAT_TAG "music_offload_wma_format_tag"
+#define AUDIO_OFFLOAD_CODEC_WMA_BLOCK_ALIGN "music_offload_wma_block_align"
+#define AUDIO_OFFLOAD_CODEC_WMA_BIT_PER_SAMPLE "music_offload_wma_bit_per_sample"
+#define AUDIO_OFFLOAD_CODEC_WMA_CHANNEL_MASK "music_offload_wma_channel_mask"
+#define AUDIO_OFFLOAD_CODEC_WMA_ENCODE_OPTION "music_offload_wma_encode_option"
+#define AUDIO_OFFLOAD_CODEC_WMA_ENCODE_OPTION1 "music_offload_wma_encode_option1"
+#define AUDIO_OFFLOAD_CODEC_WMA_ENCODE_OPTION2 "music_offload_wma_encode_option2"
+#define AUDIO_OFFLOAD_CODEC_FORMAT  "music_offload_codec_format"
+
+/* Query handle fm parameter*/
+#define AUDIO_PARAMETER_KEY_HANDLE_FM "handle_fm"
+
+/* Query voip flag */
+#define AUDIO_PARAMETER_KEY_VOIP_CHECK "voip_flag"
+
+/* Query Fluence type */
+#define AUDIO_PARAMETER_KEY_FLUENCE_TYPE "fluence"
+
+/* Query if surround sound recording is supported */
+#define AUDIO_PARAMETER_KEY_SSR "ssr"
+
+/* Query if a2dp  is supported */
+#define AUDIO_PARAMETER_KEY_HANDLE_A2DP_DEVICE "isA2dpDeviceSupported"
+
+/* Query ADSP Status */
+#define AUDIO_PARAMETER_KEY_ADSP_STATUS "ADSP_STATUS"
+
+/* Query Sound Card Status */
+#define AUDIO_PARAMETER_KEY_SND_CARD_STATUS "SND_CARD_STATUS"
+
+/* Query if Proxy can be Opend */
+#define AUDIO_CAN_OPEN_PROXY "can_open_proxy"
+
+/* Query fm volume */
+#define AUDIO_PARAMETER_KEY_FM_VOLUME "fm_volume"
 
 /**************************************/
 
+/* common audio stream configuration parameters
+ * You should memset() the entire structure to zero before use to
+ * ensure forward compatibility
+ */
+
+#ifdef QCOM_DIRECTTRACK
+/** Structure to save buffer information for applying effects for
+ *  LPA buffers */
+struct buf_info {
+    int bufsize;
+    int nBufs;
+    int **buffers;
+};
+#endif
+
 /* common audio stream parameters and operations */
 struct audio_stream {
 
@@ -271,11 +328,6 @@ typedef enum {
  */
 
 struct audio_stream_out {
-    /**
-     * Common methods of the audio stream out.  This *must* be the first member of audio_stream_out
-     * as users of this structure will cast a audio_stream to audio_stream_out pointer in contexts
-     * where it's known the audio_stream references an audio_stream_out.
-     */
     struct audio_stream common;
 
     /**
@@ -314,6 +366,19 @@ struct audio_stream_out {
     int (*get_render_position)(const struct audio_stream_out *stream,
                                uint32_t *dsp_frames);
 
+#ifndef ICS_AUDIO_BLOB
+#ifdef QCOM_DIRECTTRACK
+    /**
+     * start audio data rendering
+     */
+    int (*start)(struct audio_stream_out *stream);
+
+    /**
+     * stop audio data rendering
+     */
+    int (*stop)(struct audio_stream_out *stream);
+#endif
+
     /**
      * get the local time at which the next write to the audio driver will be presented.
      * The units are microseconds, where the epoch is decided by the local audio HAL.
@@ -394,16 +459,35 @@ struct audio_stream_out {
      */
     int (*get_presentation_position)(const struct audio_stream_out *stream,
                                uint64_t *frames, struct timespec *timestamp);
-
+#endif
+#ifdef QCOM_DIRECTTRACK
+    /**
+    * return the current timestamp after quering to the driver
+     */
+    int (*get_time_stamp)(const struct audio_stream_out *stream,
+                               uint64_t *time_stamp);
+    /**
+    * EOS notification from HAL to Player
+     */
+    int (*set_observer)(const struct audio_stream_out *stream,
+                               void *observer);
+    /**
+     * Get the physical address of the buffer allocated in the
+     * driver
+     */
+    int (*get_buffer_info) (const struct audio_stream_out *stream,
+                                struct buf_info **buf);
+    /**
+     * Check if next buffer is available. Waits until next buffer is
+     * available
+     */
+    int (*is_buffer_available) (const struct audio_stream_out *stream,
+                                     int *isAvail);
+#endif
 };
 typedef struct audio_stream_out audio_stream_out_t;
 
 struct audio_stream_in {
-    /**
-     * Common methods of the audio stream in.  This *must* be the first member of audio_stream_in
-     * as users of this structure will cast a audio_stream to audio_stream_in pointer in contexts
-     * where it's known the audio_stream references an audio_stream_in.
-     */
     struct audio_stream common;
 
     /** set the input gain for the audio driver. This method is for
@@ -433,21 +517,76 @@ typedef struct audio_stream_in audio_stream_in_t;
 
 /**
  * return the frame size (number of bytes per sample).
- *
- * Deprecated: use audio_stream_out_frame_size() or audio_stream_in_frame_size() instead.
  */
-__attribute__((__deprecated__))
 static inline size_t audio_stream_frame_size(const struct audio_stream *s)
 {
     size_t chan_samp_sz;
+#ifdef QCOM_HARDWARE
+    audio_format_t format = s->get_format(s);
+    uint32_t chan_mask = s->get_channels(s);
+    if(audio_is_output_channel(chan_mask)) {
+        if (audio_is_linear_pcm(format) &&
+                format != AUDIO_FORMAT_PCM_8_24_BIT) {
+            chan_samp_sz = audio_bytes_per_sample(format);
+            return popcount(s->get_channels(s)) * chan_samp_sz;
+        }
+        return sizeof(int8_t);
+    } else if (audio_is_input_channel(chan_mask)) {
+        char *tmpparam;
+        int isParamEqual;
+
+        if(!s)
+            return 0;
+
+        chan_mask &= (AUDIO_CHANNEL_IN_STEREO | \
+                      AUDIO_CHANNEL_IN_MONO | \
+                      AUDIO_CHANNEL_IN_5POINT1);
+
+        tmpparam = s->get_parameters(s, "voip_flag");
+        isParamEqual = !strncmp(tmpparam,"voip_flag=1", sizeof("voip_flag=1"));
+        free(tmpparam);
+        if(isParamEqual) {
+            if(format != AUDIO_FORMAT_PCM_8_BIT)
+                return popcount(chan_mask) * sizeof(int16_t);
+            else
+                return popcount(chan_mask) * sizeof(int8_t);
+        }
+
+        switch (format) {
+
+        case AUDIO_FORMAT_AMR_NB:
+            chan_samp_sz = 32;
+            break;
+        case AUDIO_FORMAT_EVRC:
+            chan_samp_sz = 23;
+            break;
+        case AUDIO_FORMAT_QCELP:
+            chan_samp_sz = 35;
+            break;
+        case AUDIO_FORMAT_AMR_WB:
+            chan_samp_sz = 61;
+            break;
+        case AUDIO_FORMAT_PCM_16_BIT:
+            chan_samp_sz = sizeof(int16_t);
+            break;
+        case AUDIO_FORMAT_PCM_8_BIT:
+        default:
+            chan_samp_sz = sizeof(int8_t);
+            break;
+        }
+        return popcount(chan_mask) * chan_samp_sz;
+    }
+#else
     audio_format_t format = s->get_format(s);
 
-    if (audio_is_linear_pcm(format)) {
+    if (audio_is_linear_pcm(format) &&
+            format != AUDIO_FORMAT_PCM_8_24_BIT) {
         chan_samp_sz = audio_bytes_per_sample(format);
         return popcount(s->get_channels(s)) * chan_samp_sz;
     }
 
     return sizeof(int8_t);
+#endif
 }
 
 /**
@@ -494,11 +633,6 @@ struct audio_module {
 };
 
 struct audio_hw_device {
-    /**
-     * Common methods of the audio device.  This *must* be the first member of audio_hw_device
-     * as users of this structure will cast a hw_device_t to audio_hw_device pointer in contexts
-     * where it's known the hw_device_t references an audio_hw_device.
-     */
     struct hw_device_t common;
 
     /**
@@ -531,6 +665,7 @@ struct audio_hw_device {
      */
     int (*set_master_volume)(struct audio_hw_device *dev, float volume);
 
+#ifndef ICS_AUDIO_BLOB
     /**
      * Get the current master volume value for the HAL, if the HAL supports
      * master volume control.  AudioFlinger will query this value from the
@@ -539,6 +674,7 @@ struct audio_hw_device {
      * this method may leave it set to NULL.
      */
     int (*get_master_volume)(struct audio_hw_device *dev, float *volume);
+#endif
 
     /**
      * set_mode is called when the audio mode changes. AUDIO_MODE_NORMAL mode
@@ -566,16 +702,22 @@ struct audio_hw_device {
      * See also get_buffer_size which is for a particular stream.
      */
     size_t (*get_input_buffer_size)(const struct audio_hw_device *dev,
+#ifndef ICS_AUDIO_BLOB
                                     const struct audio_config *config);
+#else
+                                    uint32_t sample_rate, int format,
+                                    int channel_count);
+#endif
 
-    /** This method creates and opens the audio hardware output stream.
-     * The "address" parameter qualifies the "devices" audio device type if needed.
-     * The format format depends on the device type:
-     * - Bluetooth devices use the MAC address of the device in the form "00:11:22:AA:BB:CC"
-     * - USB devices use the ALSA card and device numbers in the form  "card=X;device=Y"
-     * - Other devices may use a number or any other string.
-     */
+/** This method creates and opens the audio hardware output stream
+ * The "address" parameter qualifies the "devices" audio device type if needed.
+ * The format format depends on the device type:
+ * - Bluetooth devices use the MAC address of the device in the form "00:11:22:AA:BB:CC"
+ * - USB devices use the ALSA card and device numbers in the form "card=X;device=Y"
+ * - Other devices may use a number or any other string.
+ */
 
+#ifndef ICS_AUDIO_BLOB
     int (*open_output_stream)(struct audio_hw_device *dev,
                               audio_io_handle_t handle,
                               audio_devices_t devices,
@@ -583,11 +725,17 @@ struct audio_hw_device {
                               struct audio_config *config,
                               struct audio_stream_out **stream_out,
                               const char *address);
+#else
+    int (*open_output_stream)(struct audio_hw_device *dev, uint32_t devices,
+                              int *format, uint32_t *channels,
+                              uint32_t *sample_rate,
+                              struct audio_stream_out **out);
+#endif
 
     void (*close_output_stream)(struct audio_hw_device *dev,
                                 struct audio_stream_out* stream_out);
 
-#ifdef STE_SAMSUNG_HARDWARE
+#if defined (QCOM_HARDWARE)
     /** This method creates and opens the audio hardware output
      *  for broadcast stream */
     int (*open_broadcast_stream)(struct audio_hw_device *dev, uint32_t devices,
@@ -601,6 +749,7 @@ struct audio_hw_device {
 #endif
 
     /** This method creates and opens the audio hardware input stream */
+#ifndef ICS_AUDIO_BLOB
     int (*open_input_stream)(struct audio_hw_device *dev,
                              audio_io_handle_t handle,
                              audio_devices_t devices,
@@ -609,6 +758,13 @@ struct audio_hw_device {
                              audio_input_flags_t flags,
                              const char *address,
                              audio_source_t source);
+#else
+    int (*open_input_stream)(struct audio_hw_device *dev, uint32_t devices,
+                             int *format, uint32_t *channels,
+                             uint32_t *sample_rate,
+                             audio_in_acoustics_t acoustics,
+                             struct audio_stream_in **stream_in);
+#endif
 
     void (*close_input_stream)(struct audio_hw_device *dev,
                                struct audio_stream_in *stream_in);
@@ -616,6 +772,7 @@ struct audio_hw_device {
     /** This method dumps the state of the audio hardware */
     int (*dump)(const struct audio_hw_device *dev, int fd);
 
+#ifndef ICS_AUDIO_BLOB
     /**
      * set the audio mute status for all audio activities.  If any value other
      * than 0 is returned, the software mixer will emulate this capability.
@@ -630,37 +787,61 @@ struct audio_hw_device {
      * method may leave it set to NULL.
      */
     int (*get_master_mute)(struct audio_hw_device *dev, bool *mute);
+#endif
 
-    /**
-     * Routing control
-     */
+#ifdef AUDIO_LISTEN_ENABLED
+    /** This method creates the listen session and returns handle */
+    int (*open_listen_session)(struct audio_hw_device *dev,
+                              listen_open_params_t *params,
+                              struct listen_session** handle);
 
-    /* Creates an audio patch between several source and sink ports.
-     * The handle is allocated by the HAL and should be unique for this
-     * audio HAL module. */
-    int (*create_audio_patch)(struct audio_hw_device *dev,
-                               unsigned int num_sources,
-                               const struct audio_port_config *sources,
-                               unsigned int num_sinks,
-                               const struct audio_port_config *sinks,
-                               audio_patch_handle_t *handle);
+    /** This method closes the listen session  */
+    int (*close_listen_session)(struct audio_hw_device *dev,
+                                struct listen_session* handle);
 
-    /* Release an audio patch */
-    int (*release_audio_patch)(struct audio_hw_device *dev,
-                               audio_patch_handle_t handle);
+    /** This method sets the mad observer callback  */
+    int (*set_mad_observer)(struct audio_hw_device *dev,
+                            listen_callback_t cb_func);
 
-    /* Fills the list of supported attributes for a given audio port.
+    /**
+     *   This method is used for setting listen hal specfic parameters.
+     *  If multiple paramets are set in one call and setting any one of them
+     *  fails it will return failure.
+     */
+    int (*listen_set_parameters)(struct audio_hw_device *dev,
+                                 const char *kv_pairs);
+#endif
+
+     /**
+      * Routing control
+      */
+
+     /* Creates an audio patch between several source and sink ports.
+      * The handle is allocated by the HAL and should be unique for this
+      * audio HAL module. */
+     int (*create_audio_patch)(struct audio_hw_device *dev,
+                                unsigned int num_sources,
+                                const struct audio_port_config *sources,
+                                unsigned int num_sinks,
+                                const struct audio_port_config *sinks,
+                                audio_patch_handle_t *handle);
+
+     /* Release an audio patch */
+     int (*release_audio_patch)(struct audio_hw_device *dev,
+                                audio_patch_handle_t handle);
+
+     /* Fills the list of supported attributes for a given audio port.
      * As input, "port" contains the information (type, role, address etc...)
      * needed by the HAL to identify the port.
      * As output, "port" contains possible attributes (sampling rates, formats,
      * channel masks, gain controllers...) for this port.
      */
-    int (*get_audio_port)(struct audio_hw_device *dev,
-                          struct audio_port *port);
+     int (*get_audio_port)(struct audio_hw_device *dev,
+                           struct audio_port *port);
 
-    /* Set audio port configuration */
-    int (*set_audio_port_config)(struct audio_hw_device *dev,
-                         const struct audio_port_config *config);
+     /* Set audio port configuration */
+     int (*set_audio_port_config)(struct audio_hw_device *dev,
+                          const struct audio_port_config *config);
 
 };
 typedef struct audio_hw_device audio_hw_device_t;
@@ -679,7 +860,18 @@ static inline int audio_hw_device_close(struct audio_hw_device* device)
     return device->common.close(&device->common);
 }
 
-
+#ifdef QCOM_DIRECTTRACK
+#ifdef __cplusplus
+/**
+ *Observer class to post the Events from HAL to Flinger
+*/
+class AudioEventObserver {
+public:
+    virtual ~AudioEventObserver() {}
+    virtual void postEOS(int64_t delayUs) = 0;
+};
+#endif
+#endif
 __END_DECLS
 
 #endif  // ANDROID_AUDIO_INTERFACE_H
diff --git a/include/hardware/fb.h b/include/hardware/fb.h
index d07a2c4..f6ba0b6 100644
--- a/include/hardware/fb.h
+++ b/include/hardware/fb.h
@@ -36,12 +36,6 @@ __BEGIN_DECLS
 /*****************************************************************************/
 
 typedef struct framebuffer_device_t {
-    /**
-     * Common methods of the framebuffer device.  This *must* be the first member of
-     * framebuffer_device_t as users of this structure will cast a hw_device_t to
-     * framebuffer_device_t pointer in contexts where it's known the hw_device_t references a
-     * framebuffer_device_t.
-     */
     struct hw_device_t common;
 
     /* flags describing some attributes of the framebuffer */
@@ -49,8 +43,8 @@ typedef struct framebuffer_device_t {
 
     /* dimensions of the framebuffer in pixels */
 #ifdef STE_HARDWARE
-    uint32_t        width;
-    uint32_t        height;
+    uint32_t  width;
+    uint32_t  height;
 #else
     const uint32_t  width;
     const uint32_t  height;
@@ -58,7 +52,7 @@ typedef struct framebuffer_device_t {
 
     /* frambuffer stride in pixels */
 #ifdef STE_HARDWARE
-    int             stride;
+    int       stride;
 #else
     const int       stride;
 #endif
@@ -68,8 +62,8 @@ typedef struct framebuffer_device_t {
 
     /* resolution of the framebuffer's display panel in pixel per inch*/
 #ifdef STE_HARDWARE
-    float           xdpi;
-    float           ydpi;
+    float     xdpi;
+    float     ydpi;
 #else
     const float     xdpi;
     const float     ydpi;
diff --git a/include/hardware/gps.h b/include/hardware/gps.h
index 4199db9..bdb639f 100644
--- a/include/hardware/gps.h
+++ b/include/hardware/gps.h
@@ -41,7 +41,7 @@ typedef int64_t GpsUtcTime;
 #define GPS_MAX_SVS 32
 
 /** Maximum number of Measurements in gps_measurement_callback(). */
-#define GPS_MAX_MEASUREMENT   32
+#define GPS_MAX_MEASUREMENT 32
 
 /** Requested operational mode for GPS operation. */
 typedef uint32_t GpsPositionMode;
@@ -220,156 +220,135 @@ typedef uint16_t AGpsStatusValue;
 #define AGPS_RIL_NETWORK_TTYPE_MOBILE_HIPRI 5
 #define AGPS_RIL_NETWORK_TTYPE_WIMAX        6
 
-/**
- * Flags to indicate what fields in GpsClock are valid.
- */
+ /**
+  * Flags to indicate what fields in GpsClock are valid.
+  */
 typedef uint16_t GpsClockFlags;
 /** A valid 'leap second' is stored in the data structure. */
-#define GPS_CLOCK_HAS_LEAP_SECOND               (1<<0)
+#define GPS_CLOCK_HAS_LEAP_SECOND (1<<0)
 /** A valid 'time uncertainty' is stored in the data structure. */
-#define GPS_CLOCK_HAS_TIME_UNCERTAINTY          (1<<1)
+#define GPS_CLOCK_HAS_TIME_UNCERTAINTY (1<<1)
 /** A valid 'full bias' is stored in the data structure. */
-#define GPS_CLOCK_HAS_FULL_BIAS                 (1<<2)
+#define GPS_CLOCK_HAS_FULL_BIAS (1<<2)
 /** A valid 'bias' is stored in the data structure. */
-#define GPS_CLOCK_HAS_BIAS                      (1<<3)
+#define GPS_CLOCK_HAS_BIAS (1<<3)
 /** A valid 'bias uncertainty' is stored in the data structure. */
-#define GPS_CLOCK_HAS_BIAS_UNCERTAINTY          (1<<4)
+#define GPS_CLOCK_HAS_BIAS_UNCERTAINTY (1<<4)
 /** A valid 'drift' is stored in the data structure. */
-#define GPS_CLOCK_HAS_DRIFT                     (1<<5)
+#define GPS_CLOCK_HAS_DRIFT (1<<5)
 /** A valid 'drift uncertainty' is stored in the data structure. */
-#define GPS_CLOCK_HAS_DRIFT_UNCERTAINTY         (1<<6)
+#define GPS_CLOCK_HAS_DRIFT_UNCERTAINTY (1<<6)
 
 /**
  * Enumeration of the available values for the GPS Clock type.
  */
 typedef uint8_t GpsClockType;
 /** The type is not available ot it is unknown. */
-#define GPS_CLOCK_TYPE_UNKNOWN                  0
+#define GPS_CLOCK_TYPE_UNKNOWN 0
 /** The source of the time value reported by GPS clock is the local hardware clock. */
-#define GPS_CLOCK_TYPE_LOCAL_HW_TIME            1
+#define GPS_CLOCK_TYPE_LOCAL_HW_TIME 1
 /**
  * The source of the time value reported by GPS clock is the GPS time derived from satellites
  * (epoch = Jan 6, 1980)
  */
-#define GPS_CLOCK_TYPE_GPS_TIME                 2
+#define GPS_CLOCK_TYPE_GPS_TIME 2
 
 /**
  * Flags to indicate what fields in GpsMeasurement are valid.
  */
 typedef uint32_t GpsMeasurementFlags;
 /** A valid 'snr' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_SNR                               (1<<0)
+#define GPS_MEASUREMENT_HAS_SNR (1<<0)
 /** A valid 'elevation' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_ELEVATION                         (1<<1)
+#define GPS_MEASUREMENT_HAS_ELEVATION (1<<1)
 /** A valid 'elevation uncertainty' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_ELEVATION_UNCERTAINTY             (1<<2)
+#define GPS_MEASUREMENT_HAS_ELEVATION_UNCERTAINTY (1<<2)
 /** A valid 'azimuth' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_AZIMUTH                           (1<<3)
+#define GPS_MEASUREMENT_HAS_AZIMUTH (1<<3)
 /** A valid 'azimuth uncertainty' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_AZIMUTH_UNCERTAINTY               (1<<4)
+#define GPS_MEASUREMENT_HAS_AZIMUTH_UNCERTAINTY (1<<4)
 /** A valid 'pseudorange' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_PSEUDORANGE                       (1<<5)
+#define GPS_MEASUREMENT_HAS_PSEUDORANGE (1<<5)
 /** A valid 'pseudorange uncertainty' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_PSEUDORANGE_UNCERTAINTY           (1<<6)
+#define GPS_MEASUREMENT_HAS_PSEUDORANGE_UNCERTAINTY (1<<6)
 /** A valid 'code phase' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_CODE_PHASE                        (1<<7)
+#define GPS_MEASUREMENT_HAS_CODE_PHASE (1<<7)
 /** A valid 'code phase uncertainty' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_CODE_PHASE_UNCERTAINTY            (1<<8)
+#define GPS_MEASUREMENT_HAS_CODE_PHASE_UNCERTAINTY (1<<8)
 /** A valid 'carrier frequency' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_CARRIER_FREQUENCY                 (1<<9)
+#define GPS_MEASUREMENT_HAS_CARRIER_FREQUENCY (1<<9)
 /** A valid 'carrier cycles' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_CARRIER_CYCLES                    (1<<10)
+#define GPS_MEASUREMENT_HAS_CARRIER_CYCLES (1<<10)
 /** A valid 'carrier phase' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_CARRIER_PHASE                     (1<<11)
+#define GPS_MEASUREMENT_HAS_CARRIER_PHASE (1<<11)
 /** A valid 'carrier phase uncertainty' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_CARRIER_PHASE_UNCERTAINTY         (1<<12)
+#define GPS_MEASUREMENT_HAS_CARRIER_PHASE_UNCERTAINTY (1<<12)
 /** A valid 'bit number' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_BIT_NUMBER                        (1<<13)
+#define GPS_MEASUREMENT_HAS_BIT_NUMBER (1<<13)
 /** A valid 'time from last bit' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_TIME_FROM_LAST_BIT                (1<<14)
+#define GPS_MEASUREMENT_HAS_TIME_FROM_LAST_BIT (1<<14)
 /** A valid 'doppler shift' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_DOPPLER_SHIFT                     (1<<15)
+#define GPS_MEASUREMENT_HAS_DOPPLER_SHIFT (1<<15)
 /** A valid 'doppler shift uncertainty' is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_DOPPLER_SHIFT_UNCERTAINTY         (1<<16)
+#define GPS_MEASUREMENT_HAS_DOPPLER_SHIFT_UNCERTAINTY (1<<16)
 /** A valid 'used in fix' flag is stored in the data structure. */
-#define GPS_MEASUREMENT_HAS_USED_IN_FIX                       (1<<17)
+#define GPS_MEASUREMENT_HAS_USED_IN_FIX (1<<17)
 
 /**
  * Enumeration of the available values for the GPS Measurement's loss of lock.
  */
 typedef uint8_t GpsLossOfLock;
 /** The indicator is not available or it is unknown. */
-#define GPS_LOSS_OF_LOCK_UNKNOWN                            0
+#define GPS_LOSS_OF_LOCK_UNKNOWN 0
 /** The measurement does not present any indication of loss of lock. */
-#define GPS_LOSS_OF_LOCK_OK                                 1
+#define GPS_LOSS_OF_LOCK_OK 1
 /** Loss of lock between previous and current observation: cycle slip possible. */
-#define GPS_LOSS_OF_LOCK_CYCLE_SLIP                         2
+#define GPS_LOSS_OF_LOCK_CYCLE_SLIP 2
 
 /**
  * Enumeration of available values for the GPS Measurement's multipath indicator.
  */
 typedef uint8_t GpsMultipathIndicator;
 /** The indicator is not available or unknown. */
-#define GPS_MULTIPATH_INDICATOR_UNKNOWN                 0
+#define GPS_MULTIPATH_INDICATOR_UNKNOWN 0
 /** The measurement has been indicated to use multipath. */
-#define GPS_MULTIPATH_INDICATOR_DETECTED                1
+#define GPS_MULTIPATH_INDICATOR_DETECTED 1
 /** The measurement has been indicated Not to use multipath. */
-#define GPS_MULTIPATH_INDICATOR_NOT_USED                2
+#define GPS_MULTIPATH_INDICATOR_NOT_USED 2
 
 /**
  * Flags indicating the GPS measurement state.
- * The expected behavior here is for GPS HAL to set all the flags that applies. For
- * example, if the state for a satellite is only C/A code locked and bit synchronized,
- * and there is still millisecond ambiguity, the state should be set as:
- * GPS_MEASUREMENT_STATE_CODE_LOCK|GPS_MEASUREMENT_STATE_BIT_SYNC|GPS_MEASUREMENT_STATE_MSEC_AMBIGUOUS
- * If GPS is still searching for a satellite, the corresponding state should be set to
- * GPS_MEASUREMENT_STATE_UNKNOWN(0).
  */
 typedef uint16_t GpsMeasurementState;
-#define GPS_MEASUREMENT_STATE_UNKNOWN                   0
-#define GPS_MEASUREMENT_STATE_CODE_LOCK             (1<<0)
-#define GPS_MEASUREMENT_STATE_BIT_SYNC              (1<<1)
-#define GPS_MEASUREMENT_STATE_SUBFRAME_SYNC         (1<<2)
-#define GPS_MEASUREMENT_STATE_TOW_DECODED           (1<<3)
-#define GPS_MEASUREMENT_STATE_MSEC_AMBIGUOUS        (1<<4)
+#define GPS_MEASUREMENT_STATE_UNKNOWN 0
+#define GPS_MEASUREMENT_STATE_CODE_LOCK (1<<0)
+#define GPS_MEASUREMENT_STATE_BIT_SYNC (1<<1)
+#define GPS_MEASUREMENT_STATE_SUBFRAME_SYNC (1<<2)
+#define GPS_MEASUREMENT_STATE_TOW_DECODED (1<<3)
 
 /**
  * Flags indicating the Accumulated Delta Range's states.
  */
 typedef uint16_t GpsAccumulatedDeltaRangeState;
-#define GPS_ADR_STATE_UNKNOWN                       0
-#define GPS_ADR_STATE_VALID                     (1<<0)
-#define GPS_ADR_STATE_RESET                     (1<<1)
-#define GPS_ADR_STATE_CYCLE_SLIP                (1<<2)
+#define GPS_ADR_STATE_UNKNOWN 0
+#define GPS_ADR_STATE_VALID (1<<0)
+#define GPS_ADR_STATE_RESET (1<<1)
+#define GPS_ADR_STATE_CYCLE_SLIP (1<<2)
 
 /**
- * Enumeration of available values to indicate the available GPS Navigation message types.
+ * Enumeration of available values to indicate the available GPS Natigation message types.
  */
 typedef uint8_t GpsNavigationMessageType;
 /** The message type is unknown. */
-#define GPS_NAVIGATION_MESSAGE_TYPE_UNKNOWN         0
-/** L1 C/A message contained in the structure.  */
-#define GPS_NAVIGATION_MESSAGE_TYPE_L1CA            1
+#define GPS_NAVIGATION_MESSAGE_TYPE_UNKNOWN 0
+/** L1 C/A message contained in the structure. */
+#define GPS_NAVIGATION_MESSAGE_TYPE_L1CA 1
 /** L2-CNAV message contained in the structure. */
-#define GPS_NAVIGATION_MESSAGE_TYPE_L2CNAV          2
+#define GPS_NAVIGATION_MESSAGE_TYPE_L2CNAV 2
 /** L5-CNAV message contained in the structure. */
-#define GPS_NAVIGATION_MESSAGE_TYPE_L5CNAV          3
+#define GPS_NAVIGATION_MESSAGE_TYPE_L5CNAV 3
 /** CNAV-2 message contained in the structure. */
-#define GPS_NAVIGATION_MESSAGE_TYPE_CNAV2           4
-
-/**
- * Status of Navigation Message
- * When a message is received properly without any parity error in its navigation words, the
- * status should be set to NAV_MESSAGE_STATUS_PARITY_PASSED. But if a message is received
- * with words that failed parity check, but GPS is able to correct those words, the status
- * should be set to NAV_MESSAGE_STATUS_PARITY_REBUILT.
- * No need to send any navigation message that contains words with parity error and cannot be
- * corrected.
- */
-typedef uint16_t NavigationMessageStatus;
-#define NAV_MESSAGE_STATUS_UNKONW              0
-#define NAV_MESSAGE_STATUS_PARITY_PASSED   (1<<0)
-#define NAV_MESSAGE_STATUS_PARITY_REBUILT  (1<<1)
+#define GPS_NAVIGATION_MESSAGE_TYPE_CNAV2 4
 
 /**
  * Name for the GPS XTRA interface.
@@ -387,11 +366,6 @@ typedef uint16_t NavigationMessageStatus;
 #define AGPS_INTERFACE      "agps"
 
 /**
- * Name of the Supl Certificate interface.
- */
-#define SUPL_CERTIFICATE_INTERFACE  "supl-certificate"
-
-/**
  * Name for NI interface
  */
 #define GPS_NI_INTERFACE "gps-ni"
@@ -406,28 +380,25 @@ typedef uint16_t NavigationMessageStatus;
  */
 #define GPS_GEOFENCING_INTERFACE   "gps_geofencing"
 
-#ifdef STE_SAMSUNG_HARDWARE
-/**
- * The GPS chipset can use Psc for AGPS.
- */
-#define AGPS_USE_PSC
-#endif
-
-/**
- * Name of the GPS Measurements interface.
- */
-#define GPS_MEASUREMENT_INTERFACE   "gps_measurement"
+ /**
+  * Name of the GPS Measurements interface.
+  */
+#define GPS_MEASUREMENT_INTERFACE "gps_measurement"
 
 /**
  * Name of the GPS navigation message interface.
  */
-#define GPS_NAVIGATION_MESSAGE_INTERFACE     "gps_navigation_message"
+#define GPS_NAVIGATION_MESSAGE_INTERFACE "gps_navigation_message"
 
 /**
  * Name of the GNSS/GPS configuration interface.
  */
-#define GNSS_CONFIGURATION_INTERFACE     "gnss_configuration"
+#define GNSS_CONFIGURATION_INTERFACE "gnss_configuration"
 
+/**
+ * The GPS chipset can use Psc for AGPS.
+ */
+#define AGPS_USE_PSC
 
 /** Represents a location. */
 typedef struct {
@@ -471,10 +442,13 @@ typedef struct {
     float   elevation;
     /** Azimuth of SV in degrees. */
     float   azimuth;
-#ifdef STE_SAMSUNG_HARDWARE
-    /** Unknown Samsung element. */
-    int     padding;
-#endif
+    /** Unknown field in Samsung I9100 libgps
+        May be an indicator for constellation type
+        (GPS, GLONASS, Galileo)?
+        Used on GT-I9100, likely also present on GT-N7000,
+        SGH-I717, SGH-I727 but this needs confirmation.
+    */
+    int unknown_samsung_field;
 } GpsSvInfo;
 
 /** Represents SV status. */
@@ -505,7 +479,6 @@ typedef struct {
     uint32_t    used_in_fix_mask;
 } GpsSvStatus;
 
-
 /* 2G and 3G */
 /* In 3G lac is discarded */
 typedef struct {
@@ -513,6 +486,9 @@ typedef struct {
     uint16_t mcc;
     uint16_t mnc;
     uint16_t lac;
+#ifdef AGPS_USE_PSC
+    uint16_t psc;
+#endif
     uint32_t cid;
 } AGpsRefLocationCellID;
 
@@ -539,9 +515,8 @@ typedef void (* gps_location_callback)(GpsLocation* location);
  */
 typedef void (* gps_status_callback)(GpsStatus* status);
 
-/**
- * Callback with SV status information.
- * Can only be called from a thread created by create_thread_cb.
+/** Callback with SV status information.
+ *  Can only be called from a thread created by create_thread_cb.
  */
 typedef void (* gps_sv_status_callback)(GpsSvStatus* sv_info);
 
@@ -593,7 +568,7 @@ typedef struct {
     size_t          size;
     /**
      * Opens the interface and provides the callback routines
-     * to the implementation of this interface.
+     * to the implemenation of this interface.
      */
     int   (*init)( GpsCallbacks* callbacks );
 
@@ -654,7 +629,7 @@ typedef struct {
     size_t          size;
     /**
      * Opens the XTRA interface and provides the callback routines
-     * to the implementation of this interface.
+     * to the implemenation of this interface.
      */
     int  (*init)( GpsXtraCallbacks* callbacks );
     /** Injects XTRA data into the GPS. */
@@ -685,35 +660,35 @@ typedef struct {
 /** Represents the status of AGPS augmented with a IPv4 address field. */
 typedef struct {
     /** set to sizeof(AGpsStatus_v2) */
-    size_t          size;
+    size_t size;
 
-    AGpsType        type;
+    AGpsType type;
     AGpsStatusValue status;
-    uint32_t        ipaddr;
+    uint32_t ipaddr;
 } AGpsStatus_v2;
 
 /* Represents the status of AGPS augmented to support IPv4 and IPv6. */
 typedef struct {
     /** set to sizeof(AGpsStatus_v3) */
-    size_t                  size;
+    size_t size;
 
-    AGpsType                type;
-    AGpsStatusValue         status;
+    AGpsType type;
+    AGpsStatusValue status;
 
     /**
      * Must be set to a valid IPv4 address if the field 'addr' contains an IPv4
      * address, or set to INADDR_NONE otherwise.
      */
-    uint32_t                ipaddr;
+    uint32_t ipaddr;
 
     /**
      * Must contain the IPv4 (AF_INET) or IPv6 (AF_INET6) address to report.
      * Any other value of addr.ss_family will be rejected.
      * */
-    struct sockaddr_storage addr;
+     struct sockaddr_storage addr;
 } AGpsStatus_v3;
 
-typedef AGpsStatus_v3     AGpsStatus;
+typedef AGpsStatus_v3 AGpsStatus;
 
 /** Callback with AGPS status information.
  *  Can only be called from a thread created by create_thread_cb.
@@ -729,12 +704,12 @@ typedef struct {
 
 /** Extended interface for AGPS support. */
 typedef struct {
-    /** set to sizeof(AGpsInterface_v1) */
+    /** set to sizeof(AGpsInterface) */
     size_t          size;
 
     /**
      * Opens the AGPS interface and provides the callback routines
-     * to the implementation of this interface.
+     * to the implemenation of this interface.
      */
     void  (*init)( AGpsCallbacks* callbacks );
     /**
@@ -793,20 +768,19 @@ typedef struct {
      * APN, and its IP type, to be used for SUPL connections.
      */
     int (*data_conn_open_with_apn_ip_type)(
-            const char* apn,
-            ApnIpType apnIpType);
+    const char* apn,
+    ApnIpType apnIpType);
 } AGpsInterface_v2;
-
-typedef AGpsInterface_v2    AGpsInterface;
+typedef AGpsInterface_v2 AGpsInterface;
 
 /** Error codes associated with certificate operations */
-#define AGPS_CERTIFICATE_OPERATION_SUCCESS               0
-#define AGPS_CERTIFICATE_ERROR_GENERIC                -100
-#define AGPS_CERTIFICATE_ERROR_TOO_MANY_CERTIFICATES  -101
+#define AGPS_CERTIFICATE_OPERATION_SUCCESS 0
+#define AGPS_CERTIFICATE_ERROR_GENERIC -100
+#define AGPS_CERTIFICATE_ERROR_TOO_MANY_CERTIFICATES -101
 
 /** A data structure that represents an X.509 certificate using DER encoding */
 typedef struct {
-    size_t  length;
+    size_t length;
     u_char* data;
 } DerEncodedCertificate;
 
@@ -833,37 +807,37 @@ typedef struct {
      * to establish a connection with the AGPS Server.
      *
      * Parameters:
-     *      certificates - A pointer to an array of DER encoded certificates that are need to be
-     *                     installed in the HAL.
-     *      length - The number of certificates to install.
+     * certificates - A pointer to an array of DER encoded certificates that are need to be
+     * installed in the HAL.
+     * length - The number of certificates to install.
      * Returns:
-     *      AGPS_CERTIFICATE_OPERATION_SUCCESS if the operation is completed successfully
-     *      AGPS_CERTIFICATE_ERROR_TOO_MANY_CERTIFICATES if the HAL cannot store the number of
-     *          certificates attempted to be installed, the state of the certificates stored should
-     *          remain the same as before on this error case.
+     * AGPS_CERTIFICATE_OPERATION_SUCCESS if the operation is completed successfully
+     * AGPS_CERTIFICATE_ERROR_TOO_MANY_CERTIFICATES if the HAL cannot store the number of
+     * certificates attempted to be installed, the state of the certificates stored should
+     * remain the same as before on this error case.
      *
      * IMPORTANT:
-     *      If needed the HAL should find out internally the set of certificates that need to be
-     *      removed to accommodate the certificates to install.
+     * If needed the HAL should find out internally the set of certificates that need to be
+     * removed to accommodate the certificates to install.
      */
-    int  (*install_certificates) ( const DerEncodedCertificate* certificates, size_t length );
+     int (*install_certificates) ( const DerEncodedCertificate* certificates, size_t length );
 
     /**
      * Notifies the HAL that a list of certificates used for SUPL connections are revoked. It is
      * expected that the given set of certificates is removed from the internal store of the HAL.
      *
      * Parameters:
-     *      fingerprints - A pointer to an array of SHA1 Fingerprints to identify the set of
-     *                     certificates to revoke.
-     *      length - The number of fingerprints provided.
+     * fingerprints - A pointer to an array of SHA1 Fingerprints to identify the set of
+     * certificates to revoke.
+     * length - The number of fingerprints provided.
      * Returns:
-     *      AGPS_CERTIFICATE_OPERATION_SUCCESS if the operation is completed successfully.
+     * AGPS_CERTIFICATE_OPERATION_SUCCESS if the operation is completed successfully.
      *
      * IMPORTANT:
-     *      If any of the certificates provided (through its fingerprint) is not known by the HAL,
-     *      it should be ignored and continue revoking/deleting the rest of them.
+     * If any of the certificates provided (through its fingerprint) is not known by the HAL,
+     * it should be ignored and continue revoking/deleting the rest of them.
      */
-    int  (*revoke_certificates) ( const Sha1CertificateFingerprint* fingerprints, size_t length );
+     int (*revoke_certificates) ( const Sha1CertificateFingerprint* fingerprints, size_t length );
 } SuplCertificateInterface;
 
 /** Represents an NI request */
@@ -990,7 +964,7 @@ typedef struct {
     size_t          size;
     /**
      * Opens the AGPS interface and provides the callback routines
-     * to the implementation of this interface.
+     * to the implemenation of this interface.
      */
     void  (*init)( AGpsRilCallbacks* callbacks );
 
@@ -1129,7 +1103,7 @@ typedef void (*gps_geofence_transition_callback) (int32_t geofence_id,  GpsLocat
         int32_t transition, GpsUtcTime timestamp);
 
 /**
- * The callback associated with the availability of the GPS system for geofencing
+ * The callback associated with the availablity of the GPS system for geofencing
  * monitoring. If the GPS system determines that it cannot monitor geofences
  * because of lack of reliability or unavailability of the GPS signals, it will
  * call this callback with GPS_GEOFENCE_UNAVAILABLE parameter.
@@ -1207,7 +1181,7 @@ typedef struct {
 
    /**
     * Opens the geofence interface and provides the callback routines
-    * to the implementation of this interface.
+    * to the implemenation of this interface.
     */
    void  (*init)( GpsGeofenceCallbacks* callbacks );
 
@@ -1237,12 +1211,14 @@ typedef struct {
     *       sampling the GPS for power-saving reasons; thus the rate of
     *       sampling may be faster or slower than this.
     *    unknown_timer_ms - The time limit after which the UNCERTAIN transition
-    *       should be triggered. This parameter is defined in milliseconds.
+    *       should be triggered. This paramter is defined in milliseconds.
     *       See above for a detailed explanation.
     */
-   void (*add_geofence_area) (int32_t geofence_id, double latitude, double longitude,
-       double radius_meters, int last_transition, int monitor_transitions,
-       int notification_responsiveness_ms, int unknown_timer_ms);
+   void (*add_geofence_area) (int32_t geofence_id, double latitude,
+                                double longitude, double radius_meters,
+                                int last_transition, int monitor_transitions,
+                                int notification_responsiveness_ms,
+                                int unknown_timer_ms);
 
    /**
     * Pause monitoring a particular geofence.
@@ -1286,7 +1262,7 @@ typedef struct {
     /**
      * Leap second data.
      * The sign of the value is defined by the following equation:
-     *      utc_time_ns = time_ns + (full_bias_ns + bias_ns) - leap_second * 1,000,000,000
+     * utc_time_ns = time_ns + (full_bias_ns + bias_ns) - leap_second * 1,000,000,000
      *
      * If the data is available 'flags' must contain GPS_CLOCK_HAS_LEAP_SECOND.
      */
@@ -1334,11 +1310,10 @@ typedef struct {
      * The caller is responsible for using the 'bias uncertainty' field for quality check.
      *
      * The sign of the value is defined by the following equation:
-     *      true time (GPS time) = time_ns + (full_bias_ns + bias_ns)
+     * true time (GPS time) = time_ns + (full_bias_ns + bias_ns)
      *
      * This value contains the 'bias uncertainty' in it.
      * If the data is available 'flags' must contain GPS_CLOCK_HAS_FULL_BIAS.
-
      */
     int64_t full_bias_ns;
 
@@ -1380,7 +1355,7 @@ typedef struct {
  * Represents a GPS Measurement, it contains raw and computed information.
  */
 typedef struct {
-    /** set to sizeof(GpsMeasurement) */
+ /** set to sizeof(GpsMeasurement) */
     size_t size;
 
     /** A set of flags indicating the validity of the fields in this data structure. */
@@ -1398,7 +1373,7 @@ typedef struct {
      * interpreted in the same way as indicated by GpsClock::type.
      *
      * The sign of time_offset_ns is given by the following equation:
-     *      measurement time = GpsClock::time_ns + time_offset_ns
+     * measurement time = GpsClock::time_ns + time_offset_ns
      *
      * It provides an individual time-stamp for the measurement, and allows sub-nanosecond accuracy.
      * This is a Mandatory value.
@@ -1417,16 +1392,12 @@ typedef struct {
      * Received GPS Time-of-Week at the measurement time, in nanoseconds.
      * The value is relative to the beginning of the current GPS week.
      *
-     * Given the highest sync state that can be achieved, per each satellite, valid range for
-     * this field can be:
-     *     Searching       : [ 0       ]   : GPS_MEASUREMENT_STATE_UNKNOWN
-     *     C/A code lock   : [ 0   1ms ]   : GPS_MEASUREMENT_STATE_CODE_LOCK is set
-     *     Bit sync        : [ 0  20ms ]   : GPS_MEASUREMENT_STATE_BIT_SYNC is set
-     *     Subframe sync   : [ 0    6s ]   : GPS_MEASUREMENT_STATE_SUBFRAME_SYNC is set
-     *     TOW decoded     : [ 0 1week ]   : GPS_MEASUREMENT_STATE_TOW_DECODED is set
-     *
-     * However, if there is any ambiguity in integer millisecond,
-     * GPS_MEASUREMENT_STATE_MSEC_AMBIGUOUS should be set accordingly, in the 'state' field.
+     * Given the sync state of GPS receiver, per each satellite, valid range for this field can be:
+     * Searching : [ 0 ] : GPS_MEASUREMENT_STATE_UNKNOWN
+     * Ranging code lock : [ 0 1ms ] : GPS_MEASUREMENT_STATE_CODE_LOCK is set
+     * Bit sync : [ 0 20ms ] : GPS_MEASUREMENT_STATE_BIT_SYNC is set
+     * Subframe sync : [ 0 6ms ] : GPS_MEASUREMENT_STATE_SUBFRAME_SYNC is set
+     * TOW decoded : [ 0 1week ] : GPS_MEASUREMENT_STATE_TOW_DECODED is set
      */
     int64_t received_gps_tow_ns;
 
@@ -1543,7 +1514,7 @@ typedef struct {
      * The value contains the 'carrier-phase uncertainty' in it.
      *
      * If the data is available, 'flags' must contain GPS_MEASUREMENT_HAS_CARRIER_PHASE.
-     */
+    */
     double carrier_phase;
 
     /**
@@ -1616,7 +1587,7 @@ typedef struct {
      * Azimuth in degrees, in the range [0, 360).
      * The value contains the 'azimuth uncertainty' in it.
      * If the data is available, 'flags' must contain GPS_MEASUREMENT_HAS_AZIMUTH.
-     *  */
+     * */
     double azimuth_deg;
 
     /**
@@ -1653,7 +1624,7 @@ typedef struct {
  * The callback for to report measurements from the HAL.
  *
  * Parameters:
- *    data - A data structure containing the measurements.
+ * data - A data structure containing the measurements.
  */
 typedef void (*gps_measurement_callback) (GpsData* data);
 
@@ -1663,9 +1634,9 @@ typedef struct {
     gps_measurement_callback measurement_callback;
 } GpsMeasurementCallbacks;
 
-#define GPS_MEASUREMENT_OPERATION_SUCCESS          0
-#define GPS_MEASUREMENT_ERROR_ALREADY_INIT      -100
-#define GPS_MEASUREMENT_ERROR_GENERIC           -101
+#define GPS_MEASUREMENT_OPERATION_SUCCESS 0
+#define GPS_MEASUREMENT_ERROR_ALREADY_INIT -100
+#define GPS_MEASUREMENT_ERROR_GENERIC -101
 
 /**
  * Extended interface for GPS Measurements support.
@@ -1679,11 +1650,11 @@ typedef struct {
      * After a successful call to 'init' the HAL must begin to provide updates at its own phase.
      *
      * Status:
-     *    GPS_MEASUREMENT_OPERATION_SUCCESS
-     *    GPS_MEASUREMENT_ERROR_ALREADY_INIT - if a callback has already been registered without a
-     *              corresponding call to 'close'
-     *    GPS_MEASUREMENT_ERROR_GENERIC - if any other error occurred, it is expected that the HAL
-     *              will not generate any updates upon returning this error code.
+     * GPS_MEASUREMENT_OPERATION_SUCCESS
+     * GPS_MEASUREMENT_ERROR_ALREADY_INIT - if a callback has already been registered without a
+     * 		corresponding call to 'close'
+     * GPS_MEASUREMENT_ERROR_GENERIC - if any other error occurred, it is expected that the HAL
+     * 		will not generate any updates upon returning this error code.
      */
     int (*init) (GpsMeasurementCallbacks* callbacks);
 
@@ -1716,13 +1687,6 @@ typedef struct {
     GpsNavigationMessageType type;
 
     /**
-     * The status of the received navigation message.
-     * No need to send any navigation message that contains words with parity error and cannot be
-     * corrected.
-     */
-    NavigationMessageStatus status;
-
-    /**
      * Message identifier.
      * It provides an index so the complete Navigation Message can be assembled. i.e. fo L1 C/A
      * subframe 4 and 5, this value corresponds to the 'frame id' of the navigation message.
@@ -1762,7 +1726,7 @@ typedef struct {
  * The callback to report an available fragment of a GPS navigation messages from the HAL.
  *
  * Parameters:
- *      message - The GPS navigation submessage/subframe representation.
+ * message - The GPS navigation submessage/subframe representation.
  */
 typedef void (*gps_navigation_message_callback) (GpsNavigationMessage* message);
 
@@ -1772,9 +1736,9 @@ typedef struct {
     gps_navigation_message_callback navigation_message_callback;
 } GpsNavigationMessageCallbacks;
 
-#define GPS_NAVIGATION_MESSAGE_OPERATION_SUCCESS             0
-#define GPS_NAVIGATION_MESSAGE_ERROR_ALREADY_INIT         -100
-#define GPS_NAVIGATION_MESSAGE_ERROR_GENERIC              -101
+#define GPS_NAVIGATION_MESSAGE_OPERATION_SUCCESS 0
+#define GPS_NAVIGATION_MESSAGE_ERROR_ALREADY_INIT -100
+#define GPS_NAVIGATION_MESSAGE_ERROR_GENERIC -101
 
 /**
  * Extended interface for GPS navigation message reporting support.
@@ -1789,11 +1753,11 @@ typedef struct {
      * available.
      *
      * Status:
-     *      GPS_NAVIGATION_MESSAGE_OPERATION_SUCCESS
-     *      GPS_NAVIGATION_MESSAGE_ERROR_ALREADY_INIT - if a callback has already been registered
-     *              without a corresponding call to 'close'.
-     *      GPS_NAVIGATION_MESSAGE_ERROR_GENERIC - if any other error occurred, it is expected that
-     *              the HAL will not generate any updates upon returning this error code.
+     * GPS_NAVIGATION_MESSAGE_OPERATION_SUCCESS
+     * GPS_NAVIGATION_MESSAGE_ERROR_ALREADY_INIT - if a callback has already been registered
+     * 		without a corresponding call to 'close'.
+     * GPS_NAVIGATION_MESSAGE_ERROR_GENERIC - if any other error occurred, it is expected that
+     * 		the HAL will not generate any updates upon returning this error code.
      */
     int (*init) (GpsNavigationMessageCallbacks* callbacks);
 
@@ -1817,15 +1781,15 @@ typedef struct {
     /**
      * Deliver GNSS configuration contents to HAL.
      * Parameters:
-     *     config_data - a pointer to a char array which holds what usually is expected from
-                         file(/etc/gps.conf), i.e., a sequence of UTF8 strings separated by '\n'.
-     *     length - total number of UTF8 characters in configuraiton data.
+     * config_data - a pointer to a char array which holds what usually is expected from
+     * 		file(/etc/gps.conf), i.e., a sequence of UTF8 strings separated by '\n'.
+     * length - total number of UTF8 characters in configuraiton data.
      *
      * IMPORTANT:
-     *      GPS HAL should expect this function can be called multiple times. And it may be
-     *      called even when GpsLocationProvider is already constructed and enabled. GPS HAL
-     *      should maintain the existing requests for various callback regardless the change
-     *      in configuration data.
+     * GPS HAL should expect this function can be called multiple times. And it may be
+     * called even when GpsLocationProvider is already constructed and enabled. GPS HAL
+     * should maintain the existing requests for various callback regardless the change
+     * in configuration data.
      */
     void (*configuration_update) (const char* config_data, int32_t length);
 } GnssConfigurationInterface;
@@ -1833,4 +1797,3 @@ typedef struct {
 __END_DECLS
 
 #endif /* ANDROID_INCLUDE_HARDWARE_GPS_H */
-
-- 
1.9.1

