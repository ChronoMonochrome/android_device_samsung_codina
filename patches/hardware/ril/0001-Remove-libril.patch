From 89f7706db74748a730ae276c7ed3a0255bae97c1 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Sun, 4 Sep 2016 21:42:27 +0700
Subject: [PATCH] Remove libril

Change-Id: I9fe470a71dbf037fb6e1ac12f297f245111458a1
---
 libril/Android.mk             |   59 -
 libril/MODULE_LICENSE_APACHE2 |    0
 libril/NOTICE                 |  190 --
 libril/RilSapSocket.cpp       |  502 ----
 libril/RilSapSocket.h         |  256 --
 libril/RilSocket.cpp          |  177 --
 libril/RilSocket.h            |  272 --
 libril/ril.cpp                | 5687 -----------------------------------------
 libril/rilSocketQueue.h       |  167 --
 libril/ril_commands.h         |  152 --
 libril/ril_event.cpp          |  384 ---
 libril/ril_event.h            |   52 -
 libril/ril_unsol_commands.h   |   62 -
 13 files changed, 7960 deletions(-)
 delete mode 100644 libril/Android.mk
 delete mode 100644 libril/MODULE_LICENSE_APACHE2
 delete mode 100644 libril/NOTICE
 delete mode 100644 libril/RilSapSocket.cpp
 delete mode 100644 libril/RilSapSocket.h
 delete mode 100644 libril/RilSocket.cpp
 delete mode 100644 libril/RilSocket.h
 delete mode 100755 libril/ril.cpp
 delete mode 100644 libril/rilSocketQueue.h
 delete mode 100644 libril/ril_commands.h
 delete mode 100644 libril/ril_event.cpp
 delete mode 100644 libril/ril_event.h
 delete mode 100755 libril/ril_unsol_commands.h

diff --git a/libril/Android.mk b/libril/Android.mk
deleted file mode 100644
index 5984d9b..0000000
--- a/libril/Android.mk
+++ /dev/null
@@ -1,59 +0,0 @@
-# Copyright 2006 The Android Open Source Project
-
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:= \
-    ril.cpp \
-    ril_event.cpp\
-    RilSocket.cpp \
-    RilSapSocket.cpp \
-
-LOCAL_SHARED_LIBRARIES := \
-    liblog \
-    libutils \
-    libbinder \
-    libcutils \
-    libhardware_legacy \
-    librilutils \
-
-LOCAL_STATIC_LIBRARIES := \
-    libprotobuf-c-nano-enable_malloc \
-
-#LOCAL_CFLAGS := -DANDROID_MULTI_SIM -DDSDA_RILD1
-
-ifeq ($(SIM_COUNT), 2)
-    LOCAL_CFLAGS += -DANDROID_SIM_COUNT_2
-endif
-
-LOCAL_C_INCLUDES += external/nanopb-c
-LOCAL_C_INCLUDES += $(LOCAL_PATH)/../include
-LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/../include
-
-LOCAL_MODULE:= libril
-LOCAL_CLANG := true
-LOCAL_SANITIZE := integer
-
-include $(BUILD_SHARED_LIBRARY)
-
-
-# For RdoServD which needs a static library
-# =========================================
-ifneq ($(ANDROID_BIONIC_TRANSITION),)
-include $(CLEAR_VARS)
-
-LOCAL_SRC_FILES:= \
-    ril.cpp
-
-LOCAL_STATIC_LIBRARIES := \
-    libutils_static \
-    libcutils \
-    librilutils_static \
-    libprotobuf-c-nano-enable_malloc
-
-LOCAL_CFLAGS :=
-
-LOCAL_MODULE:= libril_static
-
-include $(BUILD_STATIC_LIBRARY)
-endif # ANDROID_BIONIC_TRANSITION
diff --git a/libril/MODULE_LICENSE_APACHE2 b/libril/MODULE_LICENSE_APACHE2
deleted file mode 100644
index e69de29..0000000
diff --git a/libril/NOTICE b/libril/NOTICE
deleted file mode 100644
index c5b1efa..0000000
--- a/libril/NOTICE
+++ /dev/null
@@ -1,190 +0,0 @@
-
-   Copyright (c) 2005-2008, The Android Open Source Project
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
-
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
diff --git a/libril/RilSapSocket.cpp b/libril/RilSapSocket.cpp
deleted file mode 100644
index 19457f4..0000000
--- a/libril/RilSapSocket.cpp
+++ /dev/null
@@ -1,502 +0,0 @@
-/*
-* Copyright (C) 2014 The Android Open Source Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*     http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#define __STDC_LIMIT_MACROS
-#include <stdint.h>
-#define RIL_SHLIB
-#include "telephony/ril.h"
-#include "RilSapSocket.h"
-#include "pb_decode.h"
-#include "pb_encode.h"
-#define LOG_TAG "RIL_UIM_SOCKET"
-#include <utils/Log.h>
-#include <arpa/inet.h>
-#include <errno.h>
-
-static RilSapSocket::RilSapSocketList *head = NULL;
-
-void ril_sap_on_request_complete (
-        RIL_Token t, RIL_Errno e,
-        void *response, size_t responselen
-);
-
-void ril_sap_on_unsolicited_response (
-        int unsolResponse, const void *data,
-        size_t datalen
-);
-extern "C" void
-RIL_requestTimedCallback (RIL_TimedCallback callback, void *param,
-        const struct timeval *relativeTime);
-
-struct RIL_Env RilSapSocket::uimRilEnv = {
-        .OnRequestComplete = RilSapSocket::sOnRequestComplete,
-        .OnUnsolicitedResponse = RilSapSocket::sOnUnsolicitedResponse,
-        .RequestTimedCallback = RIL_requestTimedCallback
-};
-
-void RilSapSocket::sOnRequestComplete (RIL_Token t,
-        RIL_Errno e,
-        void *response,
-        size_t responselen) {
-    RilSapSocket *sap_socket;
-    SapSocketRequest *request = (SapSocketRequest*) t;
-
-    RLOGD("Socket id:%d", request->socketId);
-
-    sap_socket = getSocketById(request->socketId);
-
-    if (sap_socket) {
-        sap_socket->onRequestComplete(t,e,response,responselen);
-    } else {
-        RLOGE("Invalid socket id");
-        if (request->curr->payload) {
-            free(request->curr->payload);
-        }
-        free(request->curr);
-        free(request);
-    }
-}
-
-#if defined(ANDROID_MULTI_SIM)
-void RilSapSocket::sOnUnsolicitedResponse(int unsolResponse,
-        const void *data,
-        size_t datalen,
-        RIL_SOCKET_ID socketId) {
-    RilSapSocket *sap_socket = getSocketById(socketId);
-    if (sap_socket) {
-        sap_socket->onUnsolicitedResponse(unsolResponse, (void *)data, datalen);
-    }
-}
-#else
-void RilSapSocket::sOnUnsolicitedResponse(int unsolResponse,
-       const void *data,
-       size_t datalen) {
-    RilSapSocket *sap_socket = getSocketById(RIL_SOCKET_1);
-    sap_socket->onUnsolicitedResponse(unsolResponse, (void *)data, datalen);
-}
-#endif
-
-void RilSapSocket::printList() {
-    RilSapSocketList *current = head;
-    RLOGD("Printing socket list");
-    while(NULL != current) {
-        RLOGD("SocketName:%s",current->socket->name);
-        RLOGD("Socket id:%d",current->socket->id);
-        current = current->next;
-    }
-}
-
-RilSapSocket *RilSapSocket::getSocketById(RIL_SOCKET_ID socketId) {
-    RilSapSocket *sap_socket;
-    RilSapSocketList *current = head;
-
-    RLOGD("Entered getSocketById");
-    printList();
-
-    while(NULL != current) {
-        if(socketId == current->socket->id) {
-            sap_socket = current->socket;
-            return sap_socket;
-        }
-        current = current->next;
-    }
-    return NULL;
-}
-
-void RilSapSocket::initSapSocket(const char *socketName,
-        RIL_RadioFunctions *uimFuncs) {
-
-    if (strcmp(socketName, "sap_uim_socket1") == 0) {
-        if(!SocketExists(socketName)) {
-            addSocketToList(socketName, RIL_SOCKET_1, uimFuncs);
-        }
-    }
-
-#if (SIM_COUNT >= 2)
-    if (strcmp(socketName, "sap_uim_socket2") == 0) {
-        if(!SocketExists(socketName)) {
-            addSocketToList(socketName, RIL_SOCKET_2, uimFuncs);
-        }
-    }
-#endif
-
-#if (SIM_COUNT >= 3)
-    if (strcmp(socketName, "sap_uim_socket3") == 0) {
-        if(!SocketExists(socketName)) {
-            addSocketToList(socketName, RIL_SOCKET_3, uimFuncs);
-        }
-    }
-#endif
-
-#if (SIM_COUNT >= 4)
-    if (strcmp(socketName, "sap_uim_socket4") == 0) {
-        if(!SocketExists(socketName)) {
-            addSocketToList(socketName, RIL_SOCKET_4, uimFuncs);
-        }
-    }
-#endif
-}
-
-void RilSapSocket::addSocketToList(const char *socketName, RIL_SOCKET_ID socketid,
-        RIL_RadioFunctions *uimFuncs) {
-    RilSapSocket* socket = NULL;
-    RilSapSocketList *current;
-
-    if(!SocketExists(socketName)) {
-        socket = new RilSapSocket(socketName, socketid, uimFuncs);
-        RilSapSocketList* listItem = (RilSapSocketList*)malloc(sizeof(RilSapSocketList));
-        if (!listItem) {
-            RLOGE("addSocketToList: OOM");
-            return;
-        }
-        listItem->socket = socket;
-        listItem->next = NULL;
-
-        RLOGD("Adding socket with id: %d", socket->id);
-
-        if(NULL == head) {
-            head = listItem;
-            head->next = NULL;
-        }
-        else {
-            current = head;
-            while(NULL != current->next) {
-                current = current->next;
-            }
-            current->next = listItem;
-        }
-        socket->socketInit();
-    }
-}
-
-bool RilSapSocket::SocketExists(const char *socketName) {
-    RilSapSocketList* current = head;
-
-    while(NULL != current) {
-        if(strcmp(current->socket->name, socketName) == 0) {
-            return true;
-        }
-        current = current->next;
-    }
-    return false;
-}
-
-void* RilSapSocket::processRequestsLoop(void) {
-    RLOGI("UIM_SOCKET:Request loop started");
-
-    while(true) {
-        SapSocketRequest *req = dispatchQueue.dequeue();
-
-        RLOGI("New request from the dispatch Queue");
-
-        if (req != NULL) {
-            dispatchRequest(req->curr);
-            free(req);
-        } else {
-            RLOGE("Fetched null buffer from queue!");
-        }
-    }
-    return NULL;
-}
-
-RilSapSocket::RilSapSocket(const char *socketName,
-        RIL_SOCKET_ID socketId,
-        RIL_RadioFunctions *inputUimFuncs):
-        RilSocket(socketName, socketId) {
-    if (inputUimFuncs) {
-        uimFuncs = inputUimFuncs;
-    }
-}
-
-#define BYTES_PER_LINE 16
-
-#define NIBBLE_TO_HEX(n) ({ \
-  uint8_t __n = (uint8_t) n & 0x0f; \
-  __nibble >= 10 ? 'A' + __n - 10: '0' + __n; \
-})
-
-#define HEX_HIGH(b) ({ \
-  uint8_t __b = (uint8_t) b; \
-  uint8_t __nibble = (__b >> 4) & 0x0f; \
-  NIBBLE_TO_HEX(__nibble); \
-})
-
-#define HEX_LOW(b) ({ \
-  uint8_t __b = (uint8_t) b; \
-  uint8_t __nibble = __b & 0x0f; \
-  NIBBLE_TO_HEX(__nibble); \
-})
-
-void log_hex(const char *who, const uint8_t *buffer, int length) {
-    char out[80];
-    int source = 0;
-    int dest = 0;
-    int dest_len = sizeof(out);
-    int per_line = 0;
-
-    do {
-        dest += sprintf(out, "%8.8s [%8.8x] ", who, source);
-        for(; source < length && dest_len - dest > 3 && per_line < BYTES_PER_LINE; source++,
-        per_line ++) {
-            out[dest++] = HEX_HIGH(buffer[source]);
-            out[dest++] = HEX_LOW(buffer[source]);
-            out[dest++] = ' ';
-        }
-        if (dest < dest_len && (per_line == BYTES_PER_LINE || source >= length)) {
-            out[dest++] = 0;
-            per_line = 0;
-            dest = 0;
-            RLOGD("%s\n", out);
-        }
-    } while(source < length && dest < dest_len);
-}
-
-void RilSapSocket::dispatchRequest(MsgHeader *req) {
-    // SapSocketRequest will be deallocated in onRequestComplete()
-    SapSocketRequest* currRequest=(SapSocketRequest*)malloc(sizeof(SapSocketRequest));
-    if (!currRequest) {
-        RLOGE("dispatchRequest: OOM");
-        // Free MsgHeader allocated in pushRecord()
-        free(req);
-        return;
-    }
-    currRequest->token = req->token;
-    currRequest->curr = req;
-    currRequest->p_next = NULL;
-    currRequest->socketId = id;
-
-    pendingResponseQueue.enqueue(currRequest);
-
-    if (uimFuncs) {
-        RLOGI("[%d] > SAP REQUEST type: %d. id: %d. error: %d",
-        req->token,
-        req->type,
-        req->id,
-        req->error );
-
-#if defined(ANDROID_MULTI_SIM)
-        uimFuncs->onRequest(req->id, req->payload->bytes, req->payload->size, currRequest, id);
-#else
-        uimFuncs->onRequest(req->id, req->payload->bytes, req->payload->size, currRequest);
-#endif
-    }
-}
-
-void RilSapSocket::onRequestComplete(RIL_Token t, RIL_Errno e, void *response,
-        size_t response_len) {
-    SapSocketRequest* request= (SapSocketRequest*)t;
-    MsgHeader *hdr = request->curr;
-
-    MsgHeader rsp;
-    rsp.token = request->curr->token;
-    rsp.type = MsgType_RESPONSE;
-    rsp.id = request->curr->id;
-    rsp.error = (Error)e;
-    rsp.payload = (pb_bytes_array_t *)calloc(1, sizeof(pb_bytes_array_t) + response_len);
-    if (!rsp.payload) {
-        RLOGE("onRequestComplete: OOM");
-    } else {
-        if (response && response_len > 0) {
-            memcpy(rsp.payload->bytes, response, response_len);
-            rsp.payload->size = response_len;
-        } else {
-            rsp.payload->size = 0;
-        }
-
-        RLOGE("Token:%d, MessageId:%d", hdr->token, hdr->id);
-
-        sendResponse(&rsp);
-        free(rsp.payload);
-    }
-
-    // Deallocate SapSocketRequest
-    if(!pendingResponseQueue.checkAndDequeue(hdr->id, hdr->token)) {
-        RLOGE("Token:%d, MessageId:%d", hdr->token, hdr->id);
-        RLOGE ("RilSapSocket::onRequestComplete: invalid Token or Message Id");
-    }
-
-    // Deallocate MsgHeader
-    free(hdr);
-}
-
-void RilSapSocket::sendResponse(MsgHeader* hdr) {
-    size_t encoded_size = 0;
-    uint32_t written_size;
-    size_t buffer_size = 0;
-    pb_ostream_t ostream;
-    bool success = false;
-
-    pthread_mutex_lock(&write_lock);
-
-    if ((success = pb_get_encoded_size(&encoded_size, MsgHeader_fields,
-        hdr)) && encoded_size <= INT32_MAX && commandFd != -1) {
-        buffer_size = encoded_size + sizeof(uint32_t);
-        uint8_t buffer[buffer_size];
-        written_size = htonl((uint32_t) encoded_size);
-        ostream = pb_ostream_from_buffer(buffer, buffer_size);
-        pb_write(&ostream, (uint8_t *)&written_size, sizeof(written_size));
-        success = pb_encode(&ostream, MsgHeader_fields, hdr);
-
-        if (success) {
-            RLOGD("Size: %d (0x%x) Size as written: 0x%x", encoded_size, encoded_size,
-        written_size);
-            log_hex("onRequestComplete", &buffer[sizeof(written_size)], encoded_size);
-            RLOGI("[%d] < SAP RESPONSE type: %d. id: %d. error: %d",
-        hdr->token, hdr->type, hdr->id,hdr->error );
-
-            if ( 0 != blockingWrite_helper(commandFd, buffer, buffer_size)) {
-                RLOGE("Error %d while writing to fd", errno);
-            } else {
-                RLOGD("Write successful");
-            }
-        } else {
-            RLOGE("Error while encoding response of type %d id %d buffer_size: %d: %s.",
-            hdr->type, hdr->id, buffer_size, PB_GET_ERROR(&ostream));
-        }
-    } else {
-    RLOGE("Not sending response type %d: encoded_size: %u. commandFd: %d. encoded size result: %d",
-        hdr->type, encoded_size, commandFd, success);
-    }
-
-    pthread_mutex_unlock(&write_lock);
-}
-
-void RilSapSocket::onUnsolicitedResponse(int unsolResponse, void *data, size_t datalen) {
-    if (data && datalen > 0) {
-        pb_bytes_array_t *payload = (pb_bytes_array_t *)calloc(1,
-                sizeof(pb_bytes_array_t) + datalen);
-        if (!payload) {
-            RLOGE("onUnsolicitedResponse: OOM");
-            return;
-        }
-        memcpy(payload->bytes, data, datalen);
-        payload->size = datalen;
-        MsgHeader rsp;
-        rsp.payload = payload;
-        rsp.type = MsgType_UNSOL_RESPONSE;
-        rsp.id = (MsgId)unsolResponse;
-        rsp.error = Error_RIL_E_SUCCESS;
-        sendResponse(&rsp);
-        free(payload);
-    }
-}
-
-void RilSapSocket::pushRecord(void *p_record, size_t recordlen) {
-    pb_istream_t stream = pb_istream_from_buffer((uint8_t *)p_record, recordlen);
-    // MsgHeader will be deallocated in onRequestComplete()
-    MsgHeader *reqHeader = (MsgHeader *)malloc(sizeof (MsgHeader));
-    if (!reqHeader) {
-        RLOGE("pushRecord: OOM");
-        return;
-    }
-    memset(reqHeader, 0, sizeof(MsgHeader));
-
-    log_hex("BtSapTest-Payload", (const uint8_t*)p_record, recordlen);
-
-    if (!pb_decode(&stream, MsgHeader_fields, reqHeader) ) {
-        RLOGE("Error decoding protobuf buffer : %s", PB_GET_ERROR(&stream));
-        free(reqHeader);
-    } else {
-        // SapSocketRequest will be deallocated in processRequestsLoop()
-        SapSocketRequest *recv = (SapSocketRequest*)malloc(sizeof(SapSocketRequest));
-        if (!recv) {
-            RLOGE("pushRecord: OOM");
-            free(reqHeader);
-            return;
-        }
-        recv->token = reqHeader->token;
-        recv->curr = reqHeader;
-        recv->socketId = id;
-
-        dispatchQueue.enqueue(recv);
-    }
-}
-
-void RilSapSocket::sendDisconnect() {
-    size_t encoded_size = 0;
-    uint32_t written_size;
-    size_t buffer_size = 0;
-    pb_ostream_t ostream;
-    bool success = false;
-
-    RIL_SIM_SAP_DISCONNECT_REQ disconnectReq;
-
-   if ((success = pb_get_encoded_size(&encoded_size, RIL_SIM_SAP_DISCONNECT_REQ_fields,
-        &disconnectReq)) && encoded_size <= INT32_MAX) {
-        buffer_size = encoded_size + sizeof(uint32_t);
-        uint8_t buffer[buffer_size];
-        written_size = htonl((uint32_t) encoded_size);
-        ostream = pb_ostream_from_buffer(buffer, buffer_size);
-        pb_write(&ostream, (uint8_t *)&written_size, sizeof(written_size));
-        success = pb_encode(&ostream, RIL_SIM_SAP_DISCONNECT_REQ_fields, buffer);
-
-        if(success) {
-            // Buffer will be deallocated in sOnRequestComplete()
-            pb_bytes_array_t *payload = (pb_bytes_array_t *)calloc(1,
-                    sizeof(pb_bytes_array_t) + written_size);
-            if (!payload) {
-                RLOGE("sendDisconnect: OOM");
-                return;
-            }
-            memcpy(payload->bytes, buffer, written_size);
-            payload->size = written_size;
-            // MsgHeader will be deallocated in sOnRequestComplete()
-            MsgHeader *hdr = (MsgHeader *)malloc(sizeof(MsgHeader));
-            if (!hdr) {
-                RLOGE("sendDisconnect: OOM");
-                free(payload);
-                return;
-            }
-            hdr->payload = payload;
-            hdr->type = MsgType_REQUEST;
-            hdr->id = MsgId_RIL_SIM_SAP_DISCONNECT;
-            hdr->error = Error_RIL_E_SUCCESS;
-            dispatchDisconnect(hdr);
-        }
-        else {
-            RLOGE("Encode failed in send disconnect!");
-        }
-    }
-}
-
-void RilSapSocket::dispatchDisconnect(MsgHeader *req) {
-    // SapSocketRequest will be deallocated in sOnRequestComplete()
-    SapSocketRequest* currRequest=(SapSocketRequest*)malloc(sizeof(SapSocketRequest));
-    if (!currRequest) {
-        RLOGE("dispatchDisconnect: OOM");
-        // Free memory allocated in sendDisconnect
-        free(req->payload);
-        free(req);
-        return;
-    }
-    currRequest->token = -1;
-    currRequest->curr = req;
-    currRequest->p_next = NULL;
-    currRequest->socketId = (RIL_SOCKET_ID)99;
-
-    RLOGD("Sending disconnect on command close!");
-
-#if defined(ANDROID_MULTI_SIM)
-    uimFuncs->onRequest(req->id, req->payload->bytes, req->payload->size, currRequest, id);
-#else
-    uimFuncs->onRequest(req->id, req->payload->bytes, req->payload->size, currRequest);
-#endif
-}
-
-void RilSapSocket::onCommandsSocketClosed() {
-    sendDisconnect();
-    RLOGE("Socket command closed");
-}
diff --git a/libril/RilSapSocket.h b/libril/RilSapSocket.h
deleted file mode 100644
index 75c3965..0000000
--- a/libril/RilSapSocket.h
+++ /dev/null
@@ -1,256 +0,0 @@
-/*
-* Copyright (C) 2014 The Android Open Source Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*     http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef RIL_UIM_SOCKET_H_INCLUDED
-#define RIL_UIM_SOCKET_H_INCLUDED
-#define RIL_SHLIB
-#include "telephony/ril.h"
-#include "RilSocket.h"
-#include <hardware/ril/librilutils/proto/sap-api.pb.h>
-
-/**
- * RilSapSocket is a derived class, derived from the RilSocket abstract
- * class, representing sockets for communication between bluetooth SAP module and
- * the ril daemon.
- * <p>
- * This class performs the following functions :
- * <ul>
- *     <li>Initialize the socket.
- *     <li>Process the requests coming on the socket.
- *     <li>Provide handlers for Unsolicited and request responses.
- *     <li>Request and pending response queue handling.
- * </ul>
- */
-class RilSapSocket : public RilSocket {
-    /**
-     * Function pointer to the ril initialization funtion.
-     *
-     * @param Ril environment variable with place request and
-     *        response handlers and timeout handler.
-     *
-     * @param Number of arguements for the initialization function.
-     *
-     * @param Arguements to the initialization function used to
-     *        generate instance id of the ril daemon.
-     *
-     * @return Radio functions with handlers for onRequest, onStateRequest,
-     *         supports, onCancel and getVersion.
-     */
-    RIL_RadioFunctions *(*UimInit)(const struct RIL_Env *, int argc, char **argv);
-
-    /**
-     * Place holder for the radio functions returned by the initialization
-     * function. Currenty only onRequest handler is being used.
-     */
-    RIL_RadioFunctions* uimFuncs;
-
-    /**
-     * Wrapper struct for handling the requests in the queue.
-     */
-    typedef struct SapSocketRequest {
-        int token;
-        MsgHeader* curr;
-        struct SapSocketRequest* p_next;
-        RIL_SOCKET_ID socketId;
-    } SapSocketRequest;
-
-    /**
-     * Queue for requests that are pending dispatch.
-     */
-    Ril_queue<SapSocketRequest> dispatchQueue;
-
-    /**
-     * Queue for requests that are dispatched but are pending response
-     */
-    Ril_queue<SapSocketRequest> pendingResponseQueue;
-
-    public:
-        /**
-         * Initialize the socket and add the socket to the list.
-         *
-         * @param Name of the socket.
-         * @param Radio functions to be used by the socket.
-         */
-        static void initSapSocket(const char *socketName,
-        RIL_RadioFunctions *uimFuncs);
-
-        /**
-         * Ril envoronment variable that holds the request and
-         * unsol response handlers.
-         */
-        static struct RIL_Env uimRilEnv;
-
-        /**
-         * Function to print the socket list.
-         */
-        static void printList();
-
-        /**
-         * Clean up method to be called on command close.
-         */
-        void onCommandsSocketClosed(void);
-
-        /**
-         * Datatype to handle the socket list.
-         */
-        typedef struct RilSapSocketList {
-            RilSapSocket* socket;
-            RilSapSocketList *next;
-        } RilSapSocketList;
-
-    protected:
-        /**
-         * Process each record read from the socket and
-         * push a new request created from that record to
-         * the dispatch request queue.
-         *
-         * @param The record data.
-         * @param The record length.
-         */
-        void pushRecord(void *record, size_t recordlen);
-
-        /**
-         * Socket handler to be called when a request has
-         * been completed.
-         *
-         * @param Token associated with the request.
-         * @param Error, if any, while processing the request.
-         * @param The response payload.
-         * @param Response payload length.
-         */
-        void onRequestComplete(RIL_Token t,RIL_Errno e,
-        void *response, size_t response_len);
-
-        /**
-         * Socket handler to be called when there is an
-         * unsolicited response.
-         *
-         * @param Message id.
-         * @param Response data.
-         * @param Response data length.
-         */
-        void onUnsolicitedResponse(int unsolResponse,
-        void *data, size_t datalen);
-
-        /**
-         * Class method to get the socket from the socket list.
-         *
-         * @param Socket id.
-         * @return the sap socket.
-         */
-        static RilSapSocket* getSocketById(RIL_SOCKET_ID socketId);
-
-        /**
-         * Method to send response to SAP. It does an atomic write operation on the
-         * socket.
-         *
-         * @param the response header with the payload.
-         */
-        void sendResponse(MsgHeader *hdr);
-
-        /**
-         * A loop for processing the requests in the request dispatch queue.
-         */
-        void *processRequestsLoop(void);
-
-        /**
-         * Class method to add the sap socket to the list of sockets.
-         * Does nothing if the socket is already present in the list.
-         * Otherwise, calls the constructor of the parent class(To startlistening)
-         * and add socket to the socket list.
-         */
-        static void addSocketToList(const char *socketName, RIL_SOCKET_ID socketid,
-        RIL_RadioFunctions *uimFuncs);
-
-        /**
-         * Check if a socket of the given name exists in the socket list.
-         *
-         * @param Socket name.
-         * @return true if exists, false otherwise.
-         */
-        static bool SocketExists(const char *socketName);
-
-        /**
-         * Send a clean up SAP DISCONNECT if the socket disconnects before doing a SAP
-         * disconnect.
-         */
-        void sendDisconnect(void);
-
-        /**
-         * Dispatch the clean up disconnect request.
-         */
-        void dispatchDisconnect(MsgHeader *req);
-
-
-    private:
-        /**
-         * Constructor.
-         *
-         * @param Socket name.
-         * @param Socket id.
-         * @param Radio functions.
-         */
-        RilSapSocket(const char *socketName,
-        RIL_SOCKET_ID socketId,
-        RIL_RadioFunctions *inputUimFuncs);
-
-        /**
-         * Dispatches the request to the lower layers.
-         * It calls the on request function.
-         *
-         * @param The request message.
-         */
-        void dispatchRequest(MsgHeader *request);
-
-        /**
-         * Class method that selects the socket on which the onRequestComplete
-         * is called.
-         *
-         * @param Token associated with the request.
-         * @param Error, if any, while processing the request.
-         * @param The response payload.
-         * @param Response payload length.
-         */
-        static void sOnRequestComplete(RIL_Token t,
-        RIL_Errno e, void *response, size_t responselen);
-
-#if defined(ANDROID_MULTI_SIM)
-        /**
-         * Class method that selects the socket on which the onUnsolicitedResponse
-         * is called.
-         *
-         * @param Message id.
-         * @param Response data.
-         * @param Response data length.
-         * @param Socket id.
-         */
-        static void sOnUnsolicitedResponse(int unsolResponse, const void *data,
-        size_t datalen, RIL_SOCKET_ID socket_id);
-#else
-        /**
-         * Class method that selects the socket on which the onUnsolicitedResponse
-         * is called.
-         *
-         * @param Message id.
-         * @param Response data.
-         * @param Response data length.
-         */
-        static void sOnUnsolicitedResponse(int unsolResponse, const void *data,
-        size_t datalen);
-#endif
-};
-
-#endif /*RIL_UIM_SOCKET_H_INCLUDED*/
diff --git a/libril/RilSocket.cpp b/libril/RilSocket.cpp
deleted file mode 100644
index a002d94..0000000
--- a/libril/RilSocket.cpp
+++ /dev/null
@@ -1,177 +0,0 @@
-/*
-* Copyright (C) 2014 The Android Open Source Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*     http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-extern "C"
-void *ril_socket_process_requests_loop(void *arg);
-
-#include "RilSocket.h"
-#include <cutils/sockets.h>
-#include <utils/Log.h>
-#include <assert.h>
-#define SOCKET_LISTEN_BACKLOG 0
-
-int RilSocket::socketInit(void) {
-    int ret;
-
-    listenCb = &RilSocket::sSocketListener;
-    commandCb = &RilSocket::sSocketRequestsHandler;
-    listenFd = android_get_control_socket(name);
-
-    //Start listening
-    ret = listen(listenFd, SOCKET_LISTEN_BACKLOG);
-
-    if (ret < 0) {
-        RLOGE("Failed to listen on %s socket '%d': %s",
-        name, listenFd, strerror(errno));
-        return ret;
-    }
-    //Add listen event to the event loop
-    ril_event_set(&listenEvent, listenFd, false, listenCb, this);
-    rilEventAddWakeup_helper(&listenEvent);
-    return ret;
-}
-
-void RilSocket::sSocketListener(int fd, short flags, void *param) {
-    RilSocket *theSocket = (RilSocket *) param;
-    MySocketListenParam listenParam;
-    listenParam.socket = theSocket;
-    listenParam.sListenParam.type = RIL_SAP_SOCKET;
-
-    listenCallback_helper(fd, flags, (void*)&listenParam);
-}
-
-void RilSocket::onNewCommandConnect() {
-    pthread_attr_t attr;
-    PthreadPtr pptr = ril_socket_process_requests_loop;
-    int result;
-
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-
-    //Start socket request processing loop thread
-    result = pthread_create(&socketThreadId, &attr, pptr, this);
-    if(result < 0) {
-        RLOGE("pthread_create failed with result:%d",result);
-    }
-
-    RLOGE("New socket command connected and socket request thread started");
-}
-
-void RilSocket::sSocketRequestsHandler(int fd, short flags, void *param) {
-    socketClient *sc = (socketClient *) param;
-    RilSocket *theSocket = sc->socketPtr;
-    RecordStream *rs = sc->rs;
-
-    theSocket->socketRequestsHandler(fd, flags, rs);
-}
-
-void RilSocket::socketRequestsHandler(int fd, short flags, RecordStream *p_rs) {
-    int ret;
-    assert(fd == commandFd);
-    void *p_record;
-    size_t recordlen;
-
-    for (;;) {
-        /* loop until EAGAIN/EINTR, end of stream, or other error */
-        ret = record_stream_get_next(p_rs, &p_record, &recordlen);
-
-        if (ret == 0 && p_record == NULL) {
-            /* end-of-stream */
-            break;
-        } else if (ret < 0) {
-            break;
-        } else if (ret == 0) {
-            pushRecord(p_record, recordlen);
-        }
-    }
-
-    if (ret == 0 || !(errno == EAGAIN || errno == EINTR)) {
-        /* fatal error or end-of-stream */
-        if (ret != 0) {
-            RLOGE("error on reading command socket errno:%d\n", errno);
-        } else {
-            RLOGW("EOS.  Closing command socket.");
-        }
-
-        close(commandFd);
-        commandFd = -1;
-
-        ril_event_del(&callbackEvent);
-
-        record_stream_free(p_rs);
-
-        /* start listening for new connections again */
-
-        rilEventAddWakeup_helper(&listenEvent);
-
-        onCommandsSocketClosed();
-    }
-}
-
-void RilSocket::setListenFd(int fd) {
-    listenFd = fd;
-}
-
-void RilSocket::setCommandFd(int fd) {
-    commandFd = fd;
-}
-
-int RilSocket::getListenFd(void) {
-    return listenFd;
-}
-
-int RilSocket::getCommandFd(void) {
-    return commandFd;
-}
-
-void RilSocket::setListenCb(ril_event_cb cb) {
-    listenCb = cb;
-}
-
-void RilSocket::setCommandCb(ril_event_cb cb) {
-    commandCb = cb;
-}
-
-ril_event_cb RilSocket::getListenCb(void) {
-    return listenCb;
-}
-
-ril_event_cb RilSocket::getCommandCb(void) {
-    return commandCb;
-}
-
-void RilSocket::setListenEvent(ril_event event) {
-    listenEvent = event;
-}
-
-void RilSocket::setCallbackEvent(ril_event event) {
-    callbackEvent = event;
-}
-
-ril_event* RilSocket::getListenEvent(void)  {
-    return &listenEvent;
-}
-
-ril_event* RilSocket::getCallbackEvent(void) {
-    return &callbackEvent;
-}
-
-extern "C"
-void *ril_socket_process_requests_loop(void *arg) {
-    RilSocket *socket = (RilSocket *)arg;
-    socket->processRequestsLoop();
-    return NULL;
-}
diff --git a/libril/RilSocket.h b/libril/RilSocket.h
deleted file mode 100644
index 619401a..0000000
--- a/libril/RilSocket.h
+++ /dev/null
@@ -1,272 +0,0 @@
-/*
-* Copyright (C) 2014 The Android Open Source Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*     http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#ifndef RIL_SOCKET_H_INCLUDED
-#define RIL_SOCKET_H_INCLUDED
-#include <libril/ril_ex.h>
-#include "rilSocketQueue.h"
-#include <ril_event.h>
-
-using namespace std;
-
-extern "C" void *ril_socket_process_requests_loop(void *arg);
-
-/**
- * Abstract socket class representing sockets in rild.
- * <p>
- * This class performs the following functions :
- * <ul>
- *     <li> Start socket listen.
- *     <li> Handle socket listen and command callbacks.
- * </ul>
- */
-class RilSocket {
-    protected:
-
-        /**
-         * Socket name.
-         */
-        const char* name;
-
-        /**
-         * Socket id.
-         */
-        RIL_SOCKET_ID id;
-
-       /**
-        * Listen socket file descriptor.
-        */
-        int listenFd = -1;
-
-       /**
-        * Commands socket file descriptor.
-        */
-        int commandFd = -1;
-
-       /**
-        * Socket request loop thread id.
-        */
-        pthread_t socketThreadId;
-
-       /**
-        * Listen event callack. Callback called when the other ends does accept.
-        */
-        ril_event_cb listenCb;
-
-       /**
-        * Commands event callack.Callback called when there are requests from the other side.
-        */
-        ril_event_cb commandCb;
-
-        /**
-         * Listen event to be added to eventloop after socket listen.
-         */
-        struct ril_event listenEvent;
-
-        /**
-         * Commands event to be added to eventloop after accept.
-         */
-        struct ril_event callbackEvent;
-
-        /**
-         * Static socket listen handler. Chooses the socket to call the listen callback
-         * from ril.cpp.
-         *
-         * @param Listen fd.
-         * @param flags.
-         * @param Parameter for the listen handler.
-         */
-        static void sSocketListener(int fd, short flags, void *param);
-
-        /**
-         * Static socket request handler. Chooses the socket to call the request handler on.
-         *
-         * @param Commands fd.
-         * @param flags.
-         * @param Parameter for the request handler.
-         */
-        static void sSocketRequestsHandler(int fd, short flags, void *param);
-
-        /**
-         * Process record from the record stream and push the requests onto the queue.
-         *
-         * @param record data.
-         * @param record length.
-         */
-        virtual void pushRecord(void *record, size_t recordlen) = 0;
-
-        /**
-         * Socket lock for writing data on the socket.
-         */
-        pthread_mutex_t write_lock = PTHREAD_MUTEX_INITIALIZER;
-
-        /**
-         * The loop to process the incoming requests.
-         */
-        virtual void *processRequestsLoop(void) = 0;
-
-    private:
-        friend void *::ril_socket_process_requests_loop(void *arg);
-
-    public:
-
-        /**
-         * Constructor.
-         *
-         * @param Socket name.
-         * @param Socket id.
-         */
-        RilSocket(const char* socketName, RIL_SOCKET_ID socketId) {
-            name = socketName;
-            id = socketId;
-        }
-
-        /**
-         * Clean up function on commands socket close.
-         */
-        virtual void onCommandsSocketClosed(void) = 0;
-
-        /**
-         * Function called on new commands socket connect. Request loop thread is started here.
-         */
-        void onNewCommandConnect(void);
-
-        /**
-         * Set listen socket fd.
-         *
-         * @param Input fd.
-         */
-        void setListenFd(int listenFd);
-
-        /**
-         * Set commands socket fd.
-         *
-         * @param Input fd.
-         */
-        void setCommandFd(int commandFd);
-
-        /**
-         * Get listen socket fd.
-         *
-         * @return Listen fd.
-         */
-        int getListenFd(void);
-
-        /**
-         * Get commands socket fd.
-         *
-         * @return Commands fd.
-         */
-        int getCommandFd(void);
-
-        /**
-         * Set listen event callback.
-         *
-         * @param Input event callback.
-         */
-        void setListenCb(ril_event_cb listenCb);
-
-        /**
-         * Set command event callback.
-         *
-         * @param Input event callback.
-         */
-        void setCommandCb(ril_event_cb commandCb);
-
-        /**
-         * Get listen event callback.
-         *
-         * @return Listen event callback.
-         */
-        ril_event_cb getListenCb(void);
-
-        /**
-         * Gey command event callback.
-         *
-         * @return Command event callback.
-         */
-        ril_event_cb getCommandCb(void);
-
-        /**
-         * Set listen event.
-         *
-         * @param Input event.
-         */
-        void setListenEvent(ril_event listenEvent);
-
-        /**
-         * Set command callback event.
-         *
-         * @param Input event.
-         */
-        void setCallbackEvent(ril_event commandEvent);
-
-        /**
-         * Get listen event.
-         *
-         * @return Listen event.
-         */
-        ril_event* getListenEvent(void);
-
-        /**
-         * Get commands callback event.
-         *
-         * @return Commands callback event.
-         */
-        ril_event* getCallbackEvent(void);
-
-        virtual ~RilSocket(){}
-
-    protected:
-
-        /**
-         * Start listening on the socket and add the socket listen callback event.
-         *
-         * @return Result of the socket listen.
-         */
-        int socketInit(void);
-
-        /**
-         * Socket request handler
-         *
-         * @param Commands fd.
-         * @param flags.
-         * @param Record stream.
-         */
-        void socketRequestsHandler(int fd, short flags, RecordStream *rs);
-};
-
-class socketClient {
-    public:
-        RilSocket *socketPtr;
-        RecordStream *rs;
-
-        socketClient(RilSocket *socketPtr, RecordStream *rs) {
-            this->socketPtr = socketPtr;
-            this->rs = rs;
-        }
-};
-
-typedef struct MySocketListenParam {
-    SocketListenParam sListenParam;
-    RilSocket *socket;
-} MySocketListenParam;
-
-typedef void* (RilSocket::*RilSocketFuncPtr)(void);
-typedef void (RilSocket::*RilSocketEventPtr)(int fd,short flags, void *param);
-typedef void* (*PthreadPtr)(void*);
-
-#endif
diff --git a/libril/ril.cpp b/libril/ril.cpp
deleted file mode 100755
index e1d30ea..0000000
--- a/libril/ril.cpp
+++ /dev/null
@@ -1,5687 +0,0 @@
-/* //device/libs/telephony/ril.cpp
-**
-** Copyright 2006, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-#define LOG_TAG "RILC"
-
-#include <hardware_legacy/power.h>
-#include <telephony/ril.h>
-#include <telephony/ril_cdma_sms.h>
-#include <cutils/sockets.h>
-#include <cutils/jstring.h>
-#include <telephony/record_stream.h>
-#include <utils/Log.h>
-#include <utils/SystemClock.h>
-#include <pthread.h>
-#include <binder/Parcel.h>
-#include <cutils/jstring.h>
-#include <sys/types.h>
-#include <sys/limits.h>
-#include <sys/system_properties.h>
-#include <pwd.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <time.h>
-#include <errno.h>
-#include <assert.h>
-#include <ctype.h>
-#include <sys/un.h>
-#include <assert.h>
-#include <netinet/in.h>
-#include <cutils/properties.h>
-#include <RilSapSocket.h>
-
-extern "C" void
-RIL_onRequestComplete(RIL_Token t, RIL_Errno e, void *response, size_t responselen);
-
-extern "C" void
-RIL_onRequestAck(RIL_Token t);
-namespace android {
-
-#define PHONE_PROCESS "radio"
-#define BLUETOOTH_PROCESS "bluetooth"
-
-#define SOCKET_NAME_RIL "rild"
-#define SOCKET2_NAME_RIL "rild2"
-#define SOCKET3_NAME_RIL "rild3"
-#define SOCKET4_NAME_RIL "rild4"
-
-#define SOCKET_NAME_RIL_DEBUG "rild-debug"
-
-#define ANDROID_WAKE_LOCK_NAME "radio-interface"
-
-#define ANDROID_WAKE_LOCK_SECS 0
-#define ANDROID_WAKE_LOCK_USECS 200000
-
-#define PROPERTY_RIL_IMPL "gsm.version.ril-impl"
-
-// match with constant in RIL.java
-#define MAX_COMMAND_BYTES (8 * 1024)
-
-// Basically: memset buffers that the client library
-// shouldn't be using anymore in an attempt to find
-// memory usage issues sooner.
-#define MEMSET_FREED 1
-
-#define NUM_ELEMS(a)     (sizeof (a) / sizeof (a)[0])
-
-#define MIN(a,b) ((a)<(b) ? (a) : (b))
-
-/* Constants for response types */
-#define RESPONSE_SOLICITED 0
-#define RESPONSE_UNSOLICITED 1
-#define RESPONSE_SOLICITED_ACK 2
-#define RESPONSE_SOLICITED_ACK_EXP 3
-#define RESPONSE_UNSOLICITED_ACK_EXP 4
-
-/* Negative values for private RIL errno's */
-#define RIL_ERRNO_INVALID_RESPONSE -1
-#define RIL_ERRNO_NO_MEMORY -12
-
-// request, response, and unsolicited msg print macro
-#define PRINTBUF_SIZE 8096
-
-// Enable verbose logging
-#define VDBG 0
-
-// Enable RILC log
-#define RILC_LOG 0
-
-#if RILC_LOG
-    #define startRequest           sprintf(printBuf, "(")
-    #define closeRequest           sprintf(printBuf, "%s)", printBuf)
-    #define printRequest(token, req)           \
-            RLOGD("[%04d]> %s %s", token, requestToString(req), printBuf)
-
-    #define startResponse           sprintf(printBuf, "%s {", printBuf)
-    #define closeResponse           sprintf(printBuf, "%s}", printBuf)
-    #define printResponse           RLOGD("%s", printBuf)
-
-    #define clearPrintBuf           printBuf[0] = 0
-    #define removeLastChar          printBuf[strlen(printBuf)-1] = 0
-    #define appendPrintBuf(x...)    snprintf(printBuf, PRINTBUF_SIZE, x)
-#else
-    #define startRequest
-    #define closeRequest
-    #define printRequest(token, req)
-    #define startResponse
-    #define closeResponse
-    #define printResponse
-    #define clearPrintBuf
-    #define removeLastChar
-    #define appendPrintBuf(x...)
-#endif
-
-enum WakeType {DONT_WAKE, WAKE_PARTIAL};
-
-typedef struct {
-    int requestNumber;
-    void (*dispatchFunction) (Parcel &p, struct RequestInfo *pRI);
-    int(*responseFunction) (Parcel &p, void *response, size_t responselen);
-} CommandInfo;
-
-typedef struct {
-    int requestNumber;
-    int (*responseFunction) (Parcel &p, void *response, size_t responselen);
-    WakeType wakeType;
-} UnsolResponseInfo;
-
-typedef struct RequestInfo {
-    int32_t token;      //this is not RIL_Token
-    CommandInfo *pCI;
-    struct RequestInfo *p_next;
-    char cancelled;
-    char local;         // responses to local commands do not go back to command process
-    RIL_SOCKET_ID socket_id;
-    int wasAckSent;    // Indicates whether an ack was sent earlier
-} RequestInfo;
-
-typedef struct UserCallbackInfo {
-    RIL_TimedCallback p_callback;
-    void *userParam;
-    struct ril_event event;
-    struct UserCallbackInfo *p_next;
-} UserCallbackInfo;
-
-extern "C" const char * requestToString(int request);
-extern "C" const char * failCauseToString(RIL_Errno);
-extern "C" const char * callStateToString(RIL_CallState);
-extern "C" const char * radioStateToString(RIL_RadioState);
-extern "C" const char * rilSocketIdToString(RIL_SOCKET_ID socket_id);
-
-extern "C"
-char rild[MAX_SOCKET_NAME_LENGTH] = SOCKET_NAME_RIL;
-/*******************************************************************/
-
-RIL_RadioFunctions s_callbacks = {0, NULL, NULL, NULL, NULL, NULL};
-static int s_registerCalled = 0;
-
-static pthread_t s_tid_dispatch;
-static pthread_t s_tid_reader;
-static int s_started = 0;
-
-static int s_fdDebug = -1;
-static int s_fdDebug_socket2 = -1;
-
-static int s_fdWakeupRead;
-static int s_fdWakeupWrite;
-
-int s_wakelock_count = 0;
-
-static struct ril_event s_commands_event;
-static struct ril_event s_wakeupfd_event;
-static struct ril_event s_listen_event;
-static SocketListenParam s_ril_param_socket;
-
-static pthread_mutex_t s_pendingRequestsMutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t s_writeMutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t s_wakeLockCountMutex = PTHREAD_MUTEX_INITIALIZER;
-static RequestInfo *s_pendingRequests = NULL;
-
-#if (SIM_COUNT >= 2)
-static struct ril_event s_commands_event_socket2;
-static struct ril_event s_listen_event_socket2;
-static SocketListenParam s_ril_param_socket2;
-
-static pthread_mutex_t s_pendingRequestsMutex_socket2  = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t s_writeMutex_socket2            = PTHREAD_MUTEX_INITIALIZER;
-static RequestInfo *s_pendingRequests_socket2          = NULL;
-#endif
-
-#if (SIM_COUNT >= 3)
-static struct ril_event s_commands_event_socket3;
-static struct ril_event s_listen_event_socket3;
-static SocketListenParam s_ril_param_socket3;
-
-static pthread_mutex_t s_pendingRequestsMutex_socket3  = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t s_writeMutex_socket3            = PTHREAD_MUTEX_INITIALIZER;
-static RequestInfo *s_pendingRequests_socket3          = NULL;
-#endif
-
-#if (SIM_COUNT >= 4)
-static struct ril_event s_commands_event_socket4;
-static struct ril_event s_listen_event_socket4;
-static SocketListenParam s_ril_param_socket4;
-
-static pthread_mutex_t s_pendingRequestsMutex_socket4  = PTHREAD_MUTEX_INITIALIZER;
-static pthread_mutex_t s_writeMutex_socket4            = PTHREAD_MUTEX_INITIALIZER;
-static RequestInfo *s_pendingRequests_socket4          = NULL;
-#endif
-
-static struct ril_event s_wake_timeout_event;
-static struct ril_event s_debug_event;
-
-
-static const struct timeval TIMEVAL_WAKE_TIMEOUT = {ANDROID_WAKE_LOCK_SECS,ANDROID_WAKE_LOCK_USECS};
-
-
-static pthread_mutex_t s_startupMutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_cond_t s_startupCond = PTHREAD_COND_INITIALIZER;
-
-static pthread_mutex_t s_dispatchMutex = PTHREAD_MUTEX_INITIALIZER;
-static pthread_cond_t s_dispatchCond = PTHREAD_COND_INITIALIZER;
-
-static RequestInfo *s_toDispatchHead = NULL;
-static RequestInfo *s_toDispatchTail = NULL;
-
-static UserCallbackInfo *s_last_wake_timeout_info = NULL;
-
-static void *s_lastNITZTimeData = NULL;
-static size_t s_lastNITZTimeDataSize;
-
-#if RILC_LOG
-    static char printBuf[PRINTBUF_SIZE];
-#endif
-
-/*******************************************************************/
-static int sendResponse (Parcel &p, RIL_SOCKET_ID socket_id);
-
-static void dispatchVoid (Parcel& p, RequestInfo *pRI);
-static void dispatchString (Parcel& p, RequestInfo *pRI);
-static void dispatchStrings (Parcel& p, RequestInfo *pRI);
-static void dispatchInts (Parcel& p, RequestInfo *pRI);
-static void dispatchDial (Parcel& p, RequestInfo *pRI);
-static void dispatchSIM_IO (Parcel& p, RequestInfo *pRI);
-static void dispatchSIM_APDU (Parcel& p, RequestInfo *pRI);
-static void dispatchCallForward(Parcel& p, RequestInfo *pRI);
-static void dispatchRaw(Parcel& p, RequestInfo *pRI);
-static void dispatchSmsWrite (Parcel &p, RequestInfo *pRI);
-static void dispatchDataCall (Parcel& p, RequestInfo *pRI);
-static void dispatchVoiceRadioTech (Parcel& p, RequestInfo *pRI);
-static void dispatchSetInitialAttachApn (Parcel& p, RequestInfo *pRI);
-static void dispatchCdmaSubscriptionSource (Parcel& p, RequestInfo *pRI);
-
-static void dispatchCdmaSms(Parcel &p, RequestInfo *pRI);
-static void dispatchImsSms(Parcel &p, RequestInfo *pRI);
-static void dispatchImsCdmaSms(Parcel &p, RequestInfo *pRI, uint8_t retry, int32_t messageRef);
-static void dispatchImsGsmSms(Parcel &p, RequestInfo *pRI, uint8_t retry, int32_t messageRef);
-static void dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI);
-static void dispatchGsmBrSmsCnf(Parcel &p, RequestInfo *pRI);
-static void dispatchCdmaBrSmsCnf(Parcel &p, RequestInfo *pRI);
-static void dispatchRilCdmaSmsWriteArgs(Parcel &p, RequestInfo *pRI);
-static void dispatchNVReadItem(Parcel &p, RequestInfo *pRI);
-static void dispatchNVWriteItem(Parcel &p, RequestInfo *pRI);
-static void dispatchUiccSubscripton(Parcel &p, RequestInfo *pRI);
-static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI);
-static void dispatchDataProfile(Parcel &p, RequestInfo *pRI);
-static void dispatchRadioCapability(Parcel &p, RequestInfo *pRI);
-static int responseInts(Parcel &p, void *response, size_t responselen);
-static int responseFailCause(Parcel &p, void *response, size_t responselen);
-static int responseStrings(Parcel &p, void *response, size_t responselen);
-static int responseString(Parcel &p, void *response, size_t responselen);
-static int responseVoid(Parcel &p, void *response, size_t responselen);
-static int responseCallList(Parcel &p, void *response, size_t responselen);
-static int responseSMS(Parcel &p, void *response, size_t responselen);
-static int responseSIM_IO(Parcel &p, void *response, size_t responselen);
-static int responseCallForwards(Parcel &p, void *response, size_t responselen);
-static int responseDataCallList(Parcel &p, void *response, size_t responselen);
-static int responseSetupDataCall(Parcel &p, void *response, size_t responselen);
-static int responseRaw(Parcel &p, void *response, size_t responselen);
-static int responseSsn(Parcel &p, void *response, size_t responselen);
-static int responseSimStatus(Parcel &p, void *response, size_t responselen);
-static int responseGsmBrSmsCnf(Parcel &p, void *response, size_t responselen);
-static int responseCdmaBrSmsCnf(Parcel &p, void *response, size_t responselen);
-static int responseCdmaSms(Parcel &p, void *response, size_t responselen);
-static int responseCellList(Parcel &p, void *response, size_t responselen);
-static int responseCdmaInformationRecords(Parcel &p,void *response, size_t responselen);
-static int responseRilSignalStrength(Parcel &p,void *response, size_t responselen);
-static int responseCallRing(Parcel &p, void *response, size_t responselen);
-static int responseCdmaSignalInfoRecord(Parcel &p,void *response, size_t responselen);
-static int responseCdmaCallWaiting(Parcel &p,void *response, size_t responselen);
-static int responseSimRefresh(Parcel &p, void *response, size_t responselen);
-static int responseCellInfoList(Parcel &p, void *response, size_t responselen);
-static int responseHardwareConfig(Parcel &p, void *response, size_t responselen);
-static int responseDcRtInfo(Parcel &p, void *response, size_t responselen);
-static int responseRadioCapability(Parcel &p, void *response, size_t responselen);
-static int responseSSData(Parcel &p, void *response, size_t responselen);
-static int responseLceStatus(Parcel &p, void *response, size_t responselen);
-static int responseLceData(Parcel &p, void *response, size_t responselen);
-static int responseActivityData(Parcel &p, void *response, size_t responselen);
-
-static int decodeVoiceRadioTechnology (RIL_RadioState radioState);
-static int decodeCdmaSubscriptionSource (RIL_RadioState radioState);
-static RIL_RadioState processRadioState(RIL_RadioState newRadioState);
-static void grabPartialWakeLock();
-static void releaseWakeLock();
-static void wakeTimeoutCallback(void *);
-
-static bool isServiceTypeCfQuery(RIL_SsServiceType serType, RIL_SsRequestType reqType);
-
-static bool isDebuggable();
-
-#ifdef RIL_SHLIB
-#if defined(ANDROID_MULTI_SIM)
-extern "C" void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
-                                size_t datalen, RIL_SOCKET_ID socket_id);
-#else
-extern "C" void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
-                                size_t datalen);
-#endif
-#endif
-
-#if defined(ANDROID_MULTI_SIM)
-#define RIL_UNSOL_RESPONSE(a, b, c, d) RIL_onUnsolicitedResponse((a), (b), (c), (d))
-#define CALL_ONREQUEST(a, b, c, d, e) s_callbacks.onRequest((a), (b), (c), (d), (e))
-#define CALL_ONSTATEREQUEST(a) s_callbacks.onStateRequest(a)
-#else
-#define RIL_UNSOL_RESPONSE(a, b, c, d) RIL_onUnsolicitedResponse((a), (b), (c))
-#define CALL_ONREQUEST(a, b, c, d, e) s_callbacks.onRequest((a), (b), (c), (d))
-#define CALL_ONSTATEREQUEST(a) s_callbacks.onStateRequest()
-#endif
-
-static UserCallbackInfo * internalRequestTimedCallback
-    (RIL_TimedCallback callback, void *param,
-        const struct timeval *relativeTime);
-
-/** Index == requestNumber */
-static CommandInfo s_commands[] = {
-#include "ril_commands.h"
-};
-
-static UnsolResponseInfo s_unsolResponses[] = {
-#include "ril_unsol_commands.h"
-};
-
-/* For older RILs that do not support new commands RIL_REQUEST_VOICE_RADIO_TECH and
-   RIL_UNSOL_VOICE_RADIO_TECH_CHANGED messages, decode the voice radio tech from
-   radio state message and store it. Every time there is a change in Radio State
-   check to see if voice radio tech changes and notify telephony
- */
-int voiceRadioTech = -1;
-
-/* For older RILs that do not support new commands RIL_REQUEST_GET_CDMA_SUBSCRIPTION_SOURCE
-   and RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED messages, decode the subscription
-   source from radio state and store it. Every time there is a change in Radio State
-   check to see if subscription source changed and notify telephony
- */
-int cdmaSubscriptionSource = -1;
-
-/* For older RILs that do not send RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, decode the
-   SIM/RUIM state from radio state and store it. Every time there is a change in Radio State,
-   check to see if SIM/RUIM status changed and notify telephony
- */
-int simRuimStatus = -1;
-
-static char * RIL_getRilSocketName() {
-    return rild;
-}
-
-extern "C"
-void RIL_setRilSocketName(const char * s) {
-    strncpy(rild, s, MAX_SOCKET_NAME_LENGTH);
-}
-
-static char *
-strdupReadString(Parcel &p) {
-    size_t stringlen;
-    const char16_t *s16;
-
-    s16 = p.readString16Inplace(&stringlen);
-
-    return strndup16to8(s16, stringlen);
-}
-
-static status_t
-readStringFromParcelInplace(Parcel &p, char *str, size_t maxLen) {
-    size_t s16Len;
-    const char16_t *s16;
-
-    s16 = p.readString16Inplace(&s16Len);
-    if (s16 == NULL) {
-        return NO_MEMORY;
-    }
-    size_t strLen = strnlen16to8(s16, s16Len);
-    if ((strLen + 1) > maxLen) {
-        return NO_MEMORY;
-    }
-    if (strncpy16to8(str, s16, strLen) == NULL) {
-        return NO_MEMORY;
-    } else {
-        return NO_ERROR;
-    }
-}
-
-static void writeStringToParcel(Parcel &p, const char *s) {
-    char16_t *s16;
-    size_t s16_len;
-    s16 = strdup8to16(s, &s16_len);
-    p.writeString16(s16, s16_len);
-    free(s16);
-}
-
-
-static void
-memsetString (char *s) {
-    if (s != NULL) {
-        memset (s, 0, strlen(s));
-    }
-}
-
-void   nullParcelReleaseFunction (const uint8_t* data, size_t dataSize,
-                                    const size_t* objects, size_t objectsSize,
-                                        void* cookie) {
-    // do nothing -- the data reference lives longer than the Parcel object
-}
-
-/**
- * To be called from dispatch thread
- * Issue a single local request, ensuring that the response
- * is not sent back up to the command process
- */
-static void
-issueLocalRequest(int request, void *data, int len, RIL_SOCKET_ID socket_id) {
-    RequestInfo *pRI;
-    int ret;
-    /* Hook for current context */
-    /* pendingRequestsMutextHook refer to &s_pendingRequestsMutex */
-    pthread_mutex_t* pendingRequestsMutexHook = &s_pendingRequestsMutex;
-    /* pendingRequestsHook refer to &s_pendingRequests */
-    RequestInfo**    pendingRequestsHook = &s_pendingRequests;
-
-#if (SIM_COUNT == 2)
-    if (socket_id == RIL_SOCKET_2) {
-        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket2;
-        pendingRequestsHook = &s_pendingRequests_socket2;
-    }
-#endif
-
-    pRI = (RequestInfo *)calloc(1, sizeof(RequestInfo));
-    if (pRI == NULL) {
-        RLOGE("Memory allocation failed for request %s", requestToString(request));
-        return;
-    }
-
-    pRI->local = 1;
-    pRI->token = 0xffffffff;        // token is not used in this context
-    pRI->pCI = &(s_commands[request]);
-    pRI->socket_id = socket_id;
-
-    ret = pthread_mutex_lock(pendingRequestsMutexHook);
-    assert (ret == 0);
-
-    pRI->p_next = *pendingRequestsHook;
-    *pendingRequestsHook = pRI;
-
-    ret = pthread_mutex_unlock(pendingRequestsMutexHook);
-    assert (ret == 0);
-
-    RLOGD("C[locl]> %s", requestToString(request));
-
-    CALL_ONREQUEST(request, data, len, pRI, pRI->socket_id);
-}
-
-
-
-static int
-processCommandBuffer(void *buffer, size_t buflen, RIL_SOCKET_ID socket_id) {
-    Parcel p;
-    status_t status;
-    int32_t request;
-    int32_t token;
-    RequestInfo *pRI;
-    int ret;
-    /* Hook for current context */
-    /* pendingRequestsMutextHook refer to &s_pendingRequestsMutex */
-    pthread_mutex_t* pendingRequestsMutexHook = &s_pendingRequestsMutex;
-    /* pendingRequestsHook refer to &s_pendingRequests */
-    RequestInfo**    pendingRequestsHook = &s_pendingRequests;
-
-    p.setData((uint8_t *) buffer, buflen);
-
-    // status checked at end
-    status = p.readInt32(&request);
-    status = p.readInt32 (&token);
-
-#if (SIM_COUNT >= 2)
-    if (socket_id == RIL_SOCKET_2) {
-        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket2;
-        pendingRequestsHook = &s_pendingRequests_socket2;
-    }
-#if (SIM_COUNT >= 3)
-    else if (socket_id == RIL_SOCKET_3) {
-        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket3;
-        pendingRequestsHook = &s_pendingRequests_socket3;
-    }
-#endif
-#if (SIM_COUNT >= 4)
-    else if (socket_id == RIL_SOCKET_4) {
-        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket4;
-        pendingRequestsHook = &s_pendingRequests_socket4;
-    }
-#endif
-#endif
-
-    if (status != NO_ERROR) {
-        RLOGE("invalid request block");
-        return 0;
-    }
-
-    // Received an Ack for the previous result sent to RIL.java,
-    // so release wakelock and exit
-    if (request == RIL_RESPONSE_ACKNOWLEDGEMENT) {
-        releaseWakeLock();
-        return 0;
-    }
-
-    if (request < 1 || request >= (int32_t)NUM_ELEMS(s_commands)) {
-        Parcel pErr;
-        RLOGE("unsupported request code %d token %d", request, token);
-        // FIXME this should perhaps return a response
-        pErr.writeInt32 (RESPONSE_SOLICITED);
-        pErr.writeInt32 (token);
-        pErr.writeInt32 (RIL_E_GENERIC_FAILURE);
-
-        sendResponse(pErr, socket_id);
-        return 0;
-    }
-
-    pRI = (RequestInfo *)calloc(1, sizeof(RequestInfo));
-    if (pRI == NULL) {
-        RLOGE("Memory allocation failed for request %s", requestToString(request));
-        return 0;
-    }
-
-    pRI->token = token;
-    pRI->pCI = &(s_commands[request]);
-    pRI->socket_id = socket_id;
-
-    ret = pthread_mutex_lock(pendingRequestsMutexHook);
-    assert (ret == 0);
-
-    pRI->p_next = *pendingRequestsHook;
-    *pendingRequestsHook = pRI;
-
-    ret = pthread_mutex_unlock(pendingRequestsMutexHook);
-    assert (ret == 0);
-
-/*    sLastDispatchedToken = token; */
-
-    pRI->pCI->dispatchFunction(p, pRI);
-
-    return 0;
-}
-
-static void
-invalidCommandBlock (RequestInfo *pRI) {
-    RLOGE("invalid command block for token %d request %s",
-                pRI->token, requestToString(pRI->pCI->requestNumber));
-}
-
-/** Callee expects NULL */
-static void
-dispatchVoid (Parcel& p, RequestInfo *pRI) {
-    clearPrintBuf;
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-    CALL_ONREQUEST(pRI->pCI->requestNumber, NULL, 0, pRI, pRI->socket_id);
-}
-
-/** Callee expects const char * */
-static void
-dispatchString (Parcel& p, RequestInfo *pRI) {
-    status_t status;
-    size_t datalen;
-    size_t stringlen;
-    char *string8 = NULL;
-
-    string8 = strdupReadString(p);
-
-    startRequest;
-    appendPrintBuf("%s%s", printBuf, string8);
-    closeRequest;
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, string8,
-                       sizeof(char *), pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memsetString(string8);
-#endif
-
-    free(string8);
-    return;
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-/** Callee expects const char ** */
-static void
-dispatchStrings (Parcel &p, RequestInfo *pRI) {
-    int32_t countStrings;
-    status_t status;
-    size_t datalen;
-    char **pStrings;
-
-    status = p.readInt32 (&countStrings);
-
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    startRequest;
-    if (countStrings == 0) {
-        // just some non-null pointer
-        pStrings = (char **)calloc(1, sizeof(char *));
-        if (pStrings == NULL) {
-            RLOGE("Memory allocation failed for request %s",
-                    requestToString(pRI->pCI->requestNumber));
-            closeRequest;
-            return;
-        }
-
-        datalen = 0;
-    } else if (countStrings < 0) {
-        pStrings = NULL;
-        datalen = 0;
-    } else {
-        datalen = sizeof(char *) * countStrings;
-
-        pStrings = (char **)calloc(countStrings, sizeof(char *));
-        if (pStrings == NULL) {
-            RLOGE("Memory allocation failed for request %s",
-                    requestToString(pRI->pCI->requestNumber));
-            closeRequest;
-            return;
-        }
-
-        for (int i = 0 ; i < countStrings ; i++) {
-            pStrings[i] = strdupReadString(p);
-            appendPrintBuf("%s%s,", printBuf, pStrings[i]);
-        }
-    }
-    removeLastChar;
-    closeRequest;
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, pStrings, datalen, pRI, pRI->socket_id);
-
-    if (pStrings != NULL) {
-        for (int i = 0 ; i < countStrings ; i++) {
-#ifdef MEMSET_FREED
-            memsetString (pStrings[i]);
-#endif
-            free(pStrings[i]);
-        }
-
-#ifdef MEMSET_FREED
-        memset(pStrings, 0, datalen);
-#endif
-        free(pStrings);
-    }
-
-    return;
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-/** Callee expects const int * */
-static void
-dispatchInts (Parcel &p, RequestInfo *pRI) {
-    int32_t count;
-    status_t status;
-    size_t datalen;
-    int *pInts;
-
-    status = p.readInt32 (&count);
-
-    if (status != NO_ERROR || count <= 0) {
-        goto invalid;
-    }
-
-    datalen = sizeof(int) * count;
-    pInts = (int *)calloc(count, sizeof(int));
-    if (pInts == NULL) {
-        RLOGE("Memory allocation failed for request %s", requestToString(pRI->pCI->requestNumber));
-        return;
-    }
-
-    startRequest;
-    for (int i = 0 ; i < count ; i++) {
-        int32_t t;
-
-        status = p.readInt32(&t);
-        pInts[i] = (int)t;
-        appendPrintBuf("%s%d,", printBuf, t);
-
-        if (status != NO_ERROR) {
-            free(pInts);
-            goto invalid;
-        }
-   }
-   removeLastChar;
-   closeRequest;
-   printRequest(pRI->token, pRI->pCI->requestNumber);
-
-   CALL_ONREQUEST(pRI->pCI->requestNumber, const_cast<int *>(pInts),
-                       datalen, pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memset(pInts, 0, datalen);
-#endif
-    free(pInts);
-    return;
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-
-/**
- * Callee expects const RIL_SMS_WriteArgs *
- * Payload is:
- *   int32_t status
- *   String pdu
- */
-static void
-dispatchSmsWrite (Parcel &p, RequestInfo *pRI) {
-    RIL_SMS_WriteArgs args;
-    int32_t t;
-    status_t status;
-
-    RLOGD("dispatchSmsWrite");
-    memset (&args, 0, sizeof(args));
-
-    status = p.readInt32(&t);
-    args.status = (int)t;
-
-    args.pdu = strdupReadString(p);
-
-    if (status != NO_ERROR || args.pdu == NULL) {
-        goto invalid;
-    }
-
-    args.smsc = strdupReadString(p);
-
-    startRequest;
-    appendPrintBuf("%s%d,%s,smsc=%s", printBuf, args.status,
-        (char*)args.pdu,  (char*)args.smsc);
-    closeRequest;
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &args, sizeof(args), pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memsetString (args.pdu);
-#endif
-
-    free (args.pdu);
-
-#ifdef MEMSET_FREED
-    memset(&args, 0, sizeof(args));
-#endif
-
-    return;
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-/**
- * Callee expects const RIL_Dial *
- * Payload is:
- *   String address
- *   int32_t clir
- */
-static void
-dispatchDial (Parcel &p, RequestInfo *pRI) {
-    RIL_Dial dial;
-    RIL_UUS_Info uusInfo;
-    int32_t sizeOfDial;
-    int32_t t;
-    int32_t uusPresent;
-    status_t status;
-
-    RLOGD("dispatchDial");
-    memset (&dial, 0, sizeof(dial));
-
-    dial.address = strdupReadString(p);
-
-    status = p.readInt32(&t);
-    dial.clir = (int)t;
-
-    if (status != NO_ERROR || dial.address == NULL) {
-        goto invalid;
-    }
-
-    if (s_callbacks.version < 3) { // Remove when partners upgrade to version 3
-        uusPresent = 0;
-        sizeOfDial = sizeof(dial) - sizeof(RIL_UUS_Info *);
-    } else {
-        status = p.readInt32(&uusPresent);
-
-        if (status != NO_ERROR) {
-            goto invalid;
-        }
-
-        if (uusPresent == 0) {
-            dial.uusInfo = NULL;
-        } else {
-            int32_t len;
-
-            memset(&uusInfo, 0, sizeof(RIL_UUS_Info));
-
-            status = p.readInt32(&t);
-            uusInfo.uusType = (RIL_UUS_Type) t;
-
-            status = p.readInt32(&t);
-            uusInfo.uusDcs = (RIL_UUS_DCS) t;
-
-            status = p.readInt32(&len);
-            if (status != NO_ERROR) {
-                goto invalid;
-            }
-
-            // The java code writes -1 for null arrays
-            if (((int) len) == -1) {
-                uusInfo.uusData = NULL;
-                len = 0;
-            } else {
-                uusInfo.uusData = (char*) p.readInplace(len);
-            }
-
-            uusInfo.uusLength = len;
-            dial.uusInfo = &uusInfo;
-        }
-        sizeOfDial = sizeof(dial);
-    }
-
-    startRequest;
-    appendPrintBuf("%snum=%s,clir=%d", printBuf, dial.address, dial.clir);
-    if (uusPresent) {
-        appendPrintBuf("%s,uusType=%d,uusDcs=%d,uusLen=%d", printBuf,
-                dial.uusInfo->uusType, dial.uusInfo->uusDcs,
-                dial.uusInfo->uusLength);
-    }
-    closeRequest;
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &dial, sizeOfDial, pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memsetString (dial.address);
-#endif
-
-    free (dial.address);
-
-#ifdef MEMSET_FREED
-    memset(&uusInfo, 0, sizeof(RIL_UUS_Info));
-    memset(&dial, 0, sizeof(dial));
-#endif
-
-    return;
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-/**
- * Callee expects const RIL_SIM_IO *
- * Payload is:
- *   int32_t command
- *   int32_t fileid
- *   String path
- *   int32_t p1, p2, p3
- *   String data
- *   String pin2
- *   String aidPtr
- */
-static void
-dispatchSIM_IO (Parcel &p, RequestInfo *pRI) {
-    union RIL_SIM_IO {
-        RIL_SIM_IO_v6 v6;
-        RIL_SIM_IO_v5 v5;
-    } simIO;
-
-    int32_t t;
-    int size;
-    status_t status;
-
-#if VDBG
-    RLOGD("dispatchSIM_IO");
-#endif
-    memset (&simIO, 0, sizeof(simIO));
-
-    // note we only check status at the end
-
-    status = p.readInt32(&t);
-    simIO.v6.command = (int)t;
-
-    status = p.readInt32(&t);
-    simIO.v6.fileid = (int)t;
-
-    simIO.v6.path = strdupReadString(p);
-
-    status = p.readInt32(&t);
-    simIO.v6.p1 = (int)t;
-
-    status = p.readInt32(&t);
-    simIO.v6.p2 = (int)t;
-
-    status = p.readInt32(&t);
-    simIO.v6.p3 = (int)t;
-
-    simIO.v6.data = strdupReadString(p);
-    simIO.v6.pin2 = strdupReadString(p);
-    simIO.v6.aidPtr = strdupReadString(p);
-
-    startRequest;
-    appendPrintBuf("%scmd=0x%X,efid=0x%X,path=%s,%d,%d,%d,%s,pin2=%s,aid=%s", printBuf,
-        simIO.v6.command, simIO.v6.fileid, (char*)simIO.v6.path,
-        simIO.v6.p1, simIO.v6.p2, simIO.v6.p3,
-        (char*)simIO.v6.data,  (char*)simIO.v6.pin2, simIO.v6.aidPtr);
-    closeRequest;
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    size = (s_callbacks.version < 6) ? sizeof(simIO.v5) : sizeof(simIO.v6);
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &simIO, size, pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memsetString (simIO.v6.path);
-    memsetString (simIO.v6.data);
-    memsetString (simIO.v6.pin2);
-    memsetString (simIO.v6.aidPtr);
-#endif
-
-    free (simIO.v6.path);
-    free (simIO.v6.data);
-    free (simIO.v6.pin2);
-    free (simIO.v6.aidPtr);
-
-#ifdef MEMSET_FREED
-    memset(&simIO, 0, sizeof(simIO));
-#endif
-
-    return;
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-/**
- * Callee expects const RIL_SIM_APDU *
- * Payload is:
- *   int32_t sessionid
- *   int32_t cla
- *   int32_t instruction
- *   int32_t p1, p2, p3
- *   String data
- */
-static void
-dispatchSIM_APDU (Parcel &p, RequestInfo *pRI) {
-    int32_t t;
-    status_t status;
-    RIL_SIM_APDU apdu;
-
-#if VDBG
-    RLOGD("dispatchSIM_APDU");
-#endif
-    memset (&apdu, 0, sizeof(RIL_SIM_APDU));
-
-    // Note we only check status at the end. Any single failure leads to
-    // subsequent reads filing.
-    status = p.readInt32(&t);
-    apdu.sessionid = (int)t;
-
-    status = p.readInt32(&t);
-    apdu.cla = (int)t;
-
-    status = p.readInt32(&t);
-    apdu.instruction = (int)t;
-
-    status = p.readInt32(&t);
-    apdu.p1 = (int)t;
-
-    status = p.readInt32(&t);
-    apdu.p2 = (int)t;
-
-    status = p.readInt32(&t);
-    apdu.p3 = (int)t;
-
-    apdu.data = strdupReadString(p);
-
-    startRequest;
-    appendPrintBuf("%ssessionid=%d,cla=%d,ins=%d,p1=%d,p2=%d,p3=%d,data=%s",
-        printBuf, apdu.sessionid, apdu.cla, apdu.instruction, apdu.p1, apdu.p2,
-        apdu.p3, (char*)apdu.data);
-    closeRequest;
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &apdu, sizeof(RIL_SIM_APDU), pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memsetString(apdu.data);
-#endif
-    free(apdu.data);
-
-#ifdef MEMSET_FREED
-    memset(&apdu, 0, sizeof(RIL_SIM_APDU));
-#endif
-
-    return;
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-
-/**
- * Callee expects const RIL_CallForwardInfo *
- * Payload is:
- *  int32_t status/action
- *  int32_t reason
- *  int32_t serviceCode
- *  int32_t toa
- *  String number  (0 length -> null)
- *  int32_t timeSeconds
- */
-static void
-dispatchCallForward(Parcel &p, RequestInfo *pRI) {
-    RIL_CallForwardInfo cff;
-    int32_t t;
-    status_t status;
-
-    RLOGD("dispatchCallForward");
-    memset (&cff, 0, sizeof(cff));
-
-    // note we only check status at the end
-
-    status = p.readInt32(&t);
-    cff.status = (int)t;
-
-    status = p.readInt32(&t);
-    cff.reason = (int)t;
-
-    status = p.readInt32(&t);
-    cff.serviceClass = (int)t;
-
-    status = p.readInt32(&t);
-    cff.toa = (int)t;
-
-    cff.number = strdupReadString(p);
-
-    status = p.readInt32(&t);
-    cff.timeSeconds = (int)t;
-
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    // special case: number 0-length fields is null
-
-    if (cff.number != NULL && strlen (cff.number) == 0) {
-        cff.number = NULL;
-    }
-
-    startRequest;
-    appendPrintBuf("%sstat=%d,reason=%d,serv=%d,toa=%d,%s,tout=%d", printBuf,
-        cff.status, cff.reason, cff.serviceClass, cff.toa,
-        (char*)cff.number, cff.timeSeconds);
-    closeRequest;
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &cff, sizeof(cff), pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memsetString(cff.number);
-#endif
-
-    free (cff.number);
-
-#ifdef MEMSET_FREED
-    memset(&cff, 0, sizeof(cff));
-#endif
-
-    return;
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-
-static void
-dispatchRaw(Parcel &p, RequestInfo *pRI) {
-    int32_t len;
-    status_t status;
-    const void *data;
-
-    status = p.readInt32(&len);
-
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    // The java code writes -1 for null arrays
-    if (((int)len) == -1) {
-        data = NULL;
-        len = 0;
-    }
-
-    data = p.readInplace(len);
-
-    startRequest;
-    appendPrintBuf("%sraw_size=%d", printBuf, len);
-    closeRequest;
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, const_cast<void *>(data), len, pRI, pRI->socket_id);
-
-    return;
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-static status_t
-constructCdmaSms(Parcel &p, RequestInfo *pRI, RIL_CDMA_SMS_Message& rcsm) {
-    int32_t  t;
-    uint8_t ut;
-    status_t status;
-    int32_t digitCount;
-    int digitLimit;
-
-    memset(&rcsm, 0, sizeof(rcsm));
-
-    status = p.readInt32(&t);
-    rcsm.uTeleserviceID = (int) t;
-
-    status = p.read(&ut,sizeof(ut));
-    rcsm.bIsServicePresent = (uint8_t) ut;
-
-    status = p.readInt32(&t);
-    rcsm.uServicecategory = (int) t;
-
-    status = p.readInt32(&t);
-    rcsm.sAddress.digit_mode = (RIL_CDMA_SMS_DigitMode) t;
-
-    status = p.readInt32(&t);
-    rcsm.sAddress.number_mode = (RIL_CDMA_SMS_NumberMode) t;
-
-    status = p.readInt32(&t);
-    rcsm.sAddress.number_type = (RIL_CDMA_SMS_NumberType) t;
-
-    status = p.readInt32(&t);
-    rcsm.sAddress.number_plan = (RIL_CDMA_SMS_NumberPlan) t;
-
-    status = p.read(&ut,sizeof(ut));
-    rcsm.sAddress.number_of_digits= (uint8_t) ut;
-
-    digitLimit= MIN((rcsm.sAddress.number_of_digits), RIL_CDMA_SMS_ADDRESS_MAX);
-    for(digitCount =0 ; digitCount < digitLimit; digitCount ++) {
-        status = p.read(&ut,sizeof(ut));
-        rcsm.sAddress.digits[digitCount] = (uint8_t) ut;
-    }
-
-    status = p.readInt32(&t);
-    rcsm.sSubAddress.subaddressType = (RIL_CDMA_SMS_SubaddressType) t;
-
-    status = p.read(&ut,sizeof(ut));
-    rcsm.sSubAddress.odd = (uint8_t) ut;
-
-    status = p.read(&ut,sizeof(ut));
-    rcsm.sSubAddress.number_of_digits = (uint8_t) ut;
-
-    digitLimit= MIN((rcsm.sSubAddress.number_of_digits), RIL_CDMA_SMS_SUBADDRESS_MAX);
-    for(digitCount =0 ; digitCount < digitLimit; digitCount ++) {
-        status = p.read(&ut,sizeof(ut));
-        rcsm.sSubAddress.digits[digitCount] = (uint8_t) ut;
-    }
-
-    status = p.readInt32(&t);
-    rcsm.uBearerDataLen = (int) t;
-
-    digitLimit= MIN((rcsm.uBearerDataLen), RIL_CDMA_SMS_BEARER_DATA_MAX);
-    for(digitCount =0 ; digitCount < digitLimit; digitCount ++) {
-        status = p.read(&ut, sizeof(ut));
-        rcsm.aBearerData[digitCount] = (uint8_t) ut;
-    }
-
-    if (status != NO_ERROR) {
-        return status;
-    }
-
-    startRequest;
-    appendPrintBuf("%suTeleserviceID=%d, bIsServicePresent=%d, uServicecategory=%d, \
-            sAddress.digit_mode=%d, sAddress.Number_mode=%d, sAddress.number_type=%d, ",
-            printBuf, rcsm.uTeleserviceID,rcsm.bIsServicePresent,rcsm.uServicecategory,
-            rcsm.sAddress.digit_mode, rcsm.sAddress.number_mode,rcsm.sAddress.number_type);
-    closeRequest;
-
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    return status;
-}
-
-static void
-dispatchCdmaSms(Parcel &p, RequestInfo *pRI) {
-    RIL_CDMA_SMS_Message rcsm;
-
-    RLOGD("dispatchCdmaSms");
-    if (NO_ERROR != constructCdmaSms(p, pRI, rcsm)) {
-        goto invalid;
-    }
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsm, sizeof(rcsm),pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memset(&rcsm, 0, sizeof(rcsm));
-#endif
-
-    return;
-
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-static void
-dispatchImsCdmaSms(Parcel &p, RequestInfo *pRI, uint8_t retry, int32_t messageRef) {
-    RIL_IMS_SMS_Message rism;
-    RIL_CDMA_SMS_Message rcsm;
-
-    RLOGD("dispatchImsCdmaSms: retry=%d, messageRef=%d", retry, messageRef);
-
-    if (NO_ERROR != constructCdmaSms(p, pRI, rcsm)) {
-        goto invalid;
-    }
-    memset(&rism, 0, sizeof(rism));
-    rism.tech = RADIO_TECH_3GPP2;
-    rism.retry = retry;
-    rism.messageRef = messageRef;
-    rism.message.cdmaMessage = &rcsm;
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &rism,
-            sizeof(RIL_RadioTechnologyFamily)+sizeof(uint8_t)+sizeof(int32_t)
-            +sizeof(rcsm),pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memset(&rcsm, 0, sizeof(rcsm));
-    memset(&rism, 0, sizeof(rism));
-#endif
-
-    return;
-
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-static void
-dispatchImsGsmSms(Parcel &p, RequestInfo *pRI, uint8_t retry, int32_t messageRef) {
-    RIL_IMS_SMS_Message rism;
-    int32_t countStrings;
-    status_t status;
-    size_t datalen;
-    char **pStrings;
-    RLOGD("dispatchImsGsmSms: retry=%d, messageRef=%d", retry, messageRef);
-
-    status = p.readInt32 (&countStrings);
-
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    memset(&rism, 0, sizeof(rism));
-    rism.tech = RADIO_TECH_3GPP;
-    rism.retry = retry;
-    rism.messageRef = messageRef;
-
-    startRequest;
-    appendPrintBuf("%stech=%d, retry=%d, messageRef=%d, ", printBuf,
-                    (int)rism.tech, (int)rism.retry, rism.messageRef);
-    if (countStrings == 0) {
-        // just some non-null pointer
-        pStrings = (char **)calloc(1, sizeof(char *));
-        if (pStrings == NULL) {
-            RLOGE("Memory allocation failed for request %s",
-                    requestToString(pRI->pCI->requestNumber));
-            closeRequest;
-            return;
-        }
-
-        datalen = 0;
-    } else if (countStrings < 0) {
-        pStrings = NULL;
-        datalen = 0;
-    } else {
-        if (countStrings > (INT_MAX/sizeof(char *))) {
-            RLOGE("Invalid value of countStrings: \n");
-            closeRequest;
-            return;
-        }
-        datalen = sizeof(char *) * countStrings;
-
-        pStrings = (char **)calloc(countStrings, sizeof(char *));
-        if (pStrings == NULL) {
-            RLOGE("Memory allocation failed for request %s",
-                    requestToString(pRI->pCI->requestNumber));
-            closeRequest;
-            return;
-        }
-
-        for (int i = 0 ; i < countStrings ; i++) {
-            pStrings[i] = strdupReadString(p);
-            appendPrintBuf("%s%s,", printBuf, pStrings[i]);
-        }
-    }
-    removeLastChar;
-    closeRequest;
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    rism.message.gsmMessage = pStrings;
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &rism,
-            sizeof(RIL_RadioTechnologyFamily)+sizeof(uint8_t)+sizeof(int32_t)
-            +datalen, pRI, pRI->socket_id);
-
-    if (pStrings != NULL) {
-        for (int i = 0 ; i < countStrings ; i++) {
-#ifdef MEMSET_FREED
-            memsetString (pStrings[i]);
-#endif
-            free(pStrings[i]);
-        }
-
-#ifdef MEMSET_FREED
-        memset(pStrings, 0, datalen);
-#endif
-        free(pStrings);
-    }
-
-#ifdef MEMSET_FREED
-    memset(&rism, 0, sizeof(rism));
-#endif
-    return;
-invalid:
-    ALOGE("dispatchImsGsmSms invalid block");
-    invalidCommandBlock(pRI);
-    return;
-}
-
-static void
-dispatchImsSms(Parcel &p, RequestInfo *pRI) {
-    int32_t  t;
-    status_t status = p.readInt32(&t);
-    RIL_RadioTechnologyFamily format;
-    uint8_t retry;
-    int32_t messageRef;
-
-    RLOGD("dispatchImsSms");
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-    format = (RIL_RadioTechnologyFamily) t;
-
-    // read retry field
-    status = p.read(&retry,sizeof(retry));
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-    // read messageRef field
-    status = p.read(&messageRef,sizeof(messageRef));
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    if (RADIO_TECH_3GPP == format) {
-        dispatchImsGsmSms(p, pRI, retry, messageRef);
-    } else if (RADIO_TECH_3GPP2 == format) {
-        dispatchImsCdmaSms(p, pRI, retry, messageRef);
-    } else {
-        ALOGE("requestImsSendSMS invalid format value =%d", format);
-    }
-
-    return;
-
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-static void
-dispatchCdmaSmsAck(Parcel &p, RequestInfo *pRI) {
-    RIL_CDMA_SMS_Ack rcsa;
-    int32_t  t;
-    status_t status;
-    int32_t digitCount;
-
-    RLOGD("dispatchCdmaSmsAck");
-    memset(&rcsa, 0, sizeof(rcsa));
-
-    status = p.readInt32(&t);
-    rcsa.uErrorClass = (RIL_CDMA_SMS_ErrorClass) t;
-
-    status = p.readInt32(&t);
-    rcsa.uSMSCauseCode = (int) t;
-
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    startRequest;
-    appendPrintBuf("%suErrorClass=%d, uTLStatus=%d, ",
-            printBuf, rcsa.uErrorClass, rcsa.uSMSCauseCode);
-    closeRequest;
-
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsa, sizeof(rcsa),pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memset(&rcsa, 0, sizeof(rcsa));
-#endif
-
-    return;
-
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-static void
-dispatchGsmBrSmsCnf(Parcel &p, RequestInfo *pRI) {
-    int32_t t;
-    status_t status;
-    int32_t num;
-
-    status = p.readInt32(&num);
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    {
-        RIL_GSM_BroadcastSmsConfigInfo gsmBci[num];
-        RIL_GSM_BroadcastSmsConfigInfo *gsmBciPtrs[num];
-
-        startRequest;
-        for (int i = 0 ; i < num ; i++ ) {
-            gsmBciPtrs[i] = &gsmBci[i];
-
-            status = p.readInt32(&t);
-            gsmBci[i].fromServiceId = (int) t;
-
-            status = p.readInt32(&t);
-            gsmBci[i].toServiceId = (int) t;
-
-            status = p.readInt32(&t);
-            gsmBci[i].fromCodeScheme = (int) t;
-
-            status = p.readInt32(&t);
-            gsmBci[i].toCodeScheme = (int) t;
-
-            status = p.readInt32(&t);
-            gsmBci[i].selected = (uint8_t) t;
-
-            appendPrintBuf("%s [%d: fromServiceId=%d, toServiceId =%d, \
-                  fromCodeScheme=%d, toCodeScheme=%d, selected =%d]", printBuf, i,
-                  gsmBci[i].fromServiceId, gsmBci[i].toServiceId,
-                  gsmBci[i].fromCodeScheme, gsmBci[i].toCodeScheme,
-                  gsmBci[i].selected);
-        }
-        closeRequest;
-
-        if (status != NO_ERROR) {
-            goto invalid;
-        }
-
-        CALL_ONREQUEST(pRI->pCI->requestNumber,
-                              gsmBciPtrs,
-                              num * sizeof(RIL_GSM_BroadcastSmsConfigInfo *),
-                              pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-        memset(gsmBci, 0, num * sizeof(RIL_GSM_BroadcastSmsConfigInfo));
-        memset(gsmBciPtrs, 0, num * sizeof(RIL_GSM_BroadcastSmsConfigInfo *));
-#endif
-    }
-
-    return;
-
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-static void
-dispatchCdmaBrSmsCnf(Parcel &p, RequestInfo *pRI) {
-    int32_t t;
-    status_t status;
-    int32_t num;
-
-    status = p.readInt32(&num);
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    {
-        RIL_CDMA_BroadcastSmsConfigInfo cdmaBci[num];
-        RIL_CDMA_BroadcastSmsConfigInfo *cdmaBciPtrs[num];
-
-        startRequest;
-        for (int i = 0 ; i < num ; i++ ) {
-            cdmaBciPtrs[i] = &cdmaBci[i];
-
-            status = p.readInt32(&t);
-            cdmaBci[i].service_category = (int) t;
-
-            status = p.readInt32(&t);
-            cdmaBci[i].language = (int) t;
-
-            status = p.readInt32(&t);
-            cdmaBci[i].selected = (uint8_t) t;
-
-            appendPrintBuf("%s [%d: service_category=%d, language =%d, \
-                  entries.bSelected =%d]", printBuf, i, cdmaBci[i].service_category,
-                  cdmaBci[i].language, cdmaBci[i].selected);
-        }
-        closeRequest;
-
-        if (status != NO_ERROR) {
-            goto invalid;
-        }
-
-        CALL_ONREQUEST(pRI->pCI->requestNumber,
-                              cdmaBciPtrs,
-                              num * sizeof(RIL_CDMA_BroadcastSmsConfigInfo *),
-                              pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-        memset(cdmaBci, 0, num * sizeof(RIL_CDMA_BroadcastSmsConfigInfo));
-        memset(cdmaBciPtrs, 0, num * sizeof(RIL_CDMA_BroadcastSmsConfigInfo *));
-#endif
-    }
-
-    return;
-
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-static void dispatchRilCdmaSmsWriteArgs(Parcel &p, RequestInfo *pRI) {
-    RIL_CDMA_SMS_WriteArgs rcsw;
-    int32_t  t;
-    uint32_t ut;
-    uint8_t  uct;
-    status_t status;
-    int32_t  digitCount;
-    int32_t  digitLimit;
-
-    memset(&rcsw, 0, sizeof(rcsw));
-
-    status = p.readInt32(&t);
-    rcsw.status = t;
-
-    status = p.readInt32(&t);
-    rcsw.message.uTeleserviceID = (int) t;
-
-    status = p.read(&uct,sizeof(uct));
-    rcsw.message.bIsServicePresent = (uint8_t) uct;
-
-    status = p.readInt32(&t);
-    rcsw.message.uServicecategory = (int) t;
-
-    status = p.readInt32(&t);
-    rcsw.message.sAddress.digit_mode = (RIL_CDMA_SMS_DigitMode) t;
-
-    status = p.readInt32(&t);
-    rcsw.message.sAddress.number_mode = (RIL_CDMA_SMS_NumberMode) t;
-
-    status = p.readInt32(&t);
-    rcsw.message.sAddress.number_type = (RIL_CDMA_SMS_NumberType) t;
-
-    status = p.readInt32(&t);
-    rcsw.message.sAddress.number_plan = (RIL_CDMA_SMS_NumberPlan) t;
-
-    status = p.read(&uct,sizeof(uct));
-    rcsw.message.sAddress.number_of_digits = (uint8_t) uct;
-
-    digitLimit = MIN((rcsw.message.sAddress.number_of_digits), RIL_CDMA_SMS_ADDRESS_MAX);
-
-    for(digitCount = 0 ; digitCount < digitLimit; digitCount ++) {
-        status = p.read(&uct,sizeof(uct));
-        rcsw.message.sAddress.digits[digitCount] = (uint8_t) uct;
-    }
-
-    status = p.readInt32(&t);
-    rcsw.message.sSubAddress.subaddressType = (RIL_CDMA_SMS_SubaddressType) t;
-
-    status = p.read(&uct,sizeof(uct));
-    rcsw.message.sSubAddress.odd = (uint8_t) uct;
-
-    status = p.read(&uct,sizeof(uct));
-    rcsw.message.sSubAddress.number_of_digits = (uint8_t) uct;
-
-    digitLimit = MIN((rcsw.message.sSubAddress.number_of_digits), RIL_CDMA_SMS_SUBADDRESS_MAX);
-
-    for(digitCount = 0 ; digitCount < digitLimit; digitCount ++) {
-        status = p.read(&uct,sizeof(uct));
-        rcsw.message.sSubAddress.digits[digitCount] = (uint8_t) uct;
-    }
-
-    status = p.readInt32(&t);
-    rcsw.message.uBearerDataLen = (int) t;
-
-    digitLimit = MIN((rcsw.message.uBearerDataLen), RIL_CDMA_SMS_BEARER_DATA_MAX);
-
-    for(digitCount = 0 ; digitCount < digitLimit; digitCount ++) {
-        status = p.read(&uct, sizeof(uct));
-        rcsw.message.aBearerData[digitCount] = (uint8_t) uct;
-    }
-
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    startRequest;
-    appendPrintBuf("%sstatus=%d, message.uTeleserviceID=%d, message.bIsServicePresent=%d, \
-            message.uServicecategory=%d, message.sAddress.digit_mode=%d, \
-            message.sAddress.number_mode=%d, \
-            message.sAddress.number_type=%d, ",
-            printBuf, rcsw.status, rcsw.message.uTeleserviceID, rcsw.message.bIsServicePresent,
-            rcsw.message.uServicecategory, rcsw.message.sAddress.digit_mode,
-            rcsw.message.sAddress.number_mode,
-            rcsw.message.sAddress.number_type);
-    closeRequest;
-
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &rcsw, sizeof(rcsw),pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memset(&rcsw, 0, sizeof(rcsw));
-#endif
-
-    return;
-
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-
-}
-
-// For backwards compatibility in RIL_REQUEST_SETUP_DATA_CALL.
-// Version 4 of the RIL interface adds a new PDP type parameter to support
-// IPv6 and dual-stack PDP contexts. When dealing with a previous version of
-// RIL, remove the parameter from the request.
-static void dispatchDataCall(Parcel& p, RequestInfo *pRI) {
-    // In RIL v3, REQUEST_SETUP_DATA_CALL takes 6 parameters.
-    const int numParamsRilV3 = 6;
-
-    // The first bytes of the RIL parcel contain the request number and the
-    // serial number - see processCommandBuffer(). Copy them over too.
-    int pos = p.dataPosition();
-
-    int numParams = p.readInt32();
-    if (s_callbacks.version < 4 && numParams > numParamsRilV3) {
-      Parcel p2;
-      p2.appendFrom(&p, 0, pos);
-      p2.writeInt32(numParamsRilV3);
-      for(int i = 0; i < numParamsRilV3; i++) {
-        p2.writeString16(p.readString16());
-      }
-      p2.setDataPosition(pos);
-      dispatchStrings(p2, pRI);
-    } else {
-      p.setDataPosition(pos);
-      dispatchStrings(p, pRI);
-    }
-}
-
-// For backwards compatibility with RILs that dont support RIL_REQUEST_VOICE_RADIO_TECH.
-// When all RILs handle this request, this function can be removed and
-// the request can be sent directly to the RIL using dispatchVoid.
-static void dispatchVoiceRadioTech(Parcel& p, RequestInfo *pRI) {
-    RIL_RadioState state = CALL_ONSTATEREQUEST((RIL_SOCKET_ID)pRI->socket_id);
-
-    if ((RADIO_STATE_UNAVAILABLE == state) || (RADIO_STATE_OFF == state)) {
-        RIL_onRequestComplete(pRI, RIL_E_RADIO_NOT_AVAILABLE, NULL, 0);
-    }
-
-    // RILs that support RADIO_STATE_ON should support this request.
-    if (RADIO_STATE_ON == state) {
-        dispatchVoid(p, pRI);
-        return;
-    }
-
-    // For Older RILs, that do not support RADIO_STATE_ON, assume that they
-    // will not support this new request either and decode Voice Radio Technology
-    // from Radio State
-    voiceRadioTech = decodeVoiceRadioTechnology(state);
-
-    if (voiceRadioTech < 0)
-        RIL_onRequestComplete(pRI, RIL_E_GENERIC_FAILURE, NULL, 0);
-    else
-        RIL_onRequestComplete(pRI, RIL_E_SUCCESS, &voiceRadioTech, sizeof(int));
-}
-
-// For backwards compatibility in RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE:.
-// When all RILs handle this request, this function can be removed and
-// the request can be sent directly to the RIL using dispatchVoid.
-static void dispatchCdmaSubscriptionSource(Parcel& p, RequestInfo *pRI) {
-    RIL_RadioState state = CALL_ONSTATEREQUEST((RIL_SOCKET_ID)pRI->socket_id);
-
-    if ((RADIO_STATE_UNAVAILABLE == state) || (RADIO_STATE_OFF == state)) {
-        RIL_onRequestComplete(pRI, RIL_E_RADIO_NOT_AVAILABLE, NULL, 0);
-    }
-
-    // RILs that support RADIO_STATE_ON should support this request.
-    if (RADIO_STATE_ON == state) {
-        dispatchVoid(p, pRI);
-        return;
-    }
-
-    // For Older RILs, that do not support RADIO_STATE_ON, assume that they
-    // will not support this new request either and decode CDMA Subscription Source
-    // from Radio State
-    cdmaSubscriptionSource = decodeCdmaSubscriptionSource(state);
-
-    if (cdmaSubscriptionSource < 0)
-        RIL_onRequestComplete(pRI, RIL_E_GENERIC_FAILURE, NULL, 0);
-    else
-        RIL_onRequestComplete(pRI, RIL_E_SUCCESS, &cdmaSubscriptionSource, sizeof(int));
-}
-
-static void dispatchSetInitialAttachApn(Parcel &p, RequestInfo *pRI)
-{
-    RIL_InitialAttachApn pf;
-    int32_t  t;
-    status_t status;
-
-    memset(&pf, 0, sizeof(pf));
-
-    pf.apn = strdupReadString(p);
-    pf.protocol = strdupReadString(p);
-
-    status = p.readInt32(&t);
-    pf.authtype = (int) t;
-
-    pf.username = strdupReadString(p);
-    pf.password = strdupReadString(p);
-
-    startRequest;
-    appendPrintBuf("%sapn=%s, protocol=%s, authtype=%d, username=%s, password=%s",
-            printBuf, pf.apn, pf.protocol, pf.authtype, pf.username, pf.password);
-    closeRequest;
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memsetString(pf.apn);
-    memsetString(pf.protocol);
-    memsetString(pf.username);
-    memsetString(pf.password);
-#endif
-
-    free(pf.apn);
-    free(pf.protocol);
-    free(pf.username);
-    free(pf.password);
-
-#ifdef MEMSET_FREED
-    memset(&pf, 0, sizeof(pf));
-#endif
-
-    return;
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-static void dispatchNVReadItem(Parcel &p, RequestInfo *pRI) {
-    RIL_NV_ReadItem nvri;
-    int32_t  t;
-    status_t status;
-
-    memset(&nvri, 0, sizeof(nvri));
-
-    status = p.readInt32(&t);
-    nvri.itemID = (RIL_NV_Item) t;
-
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    startRequest;
-    appendPrintBuf("%snvri.itemID=%d, ", printBuf, nvri.itemID);
-    closeRequest;
-
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &nvri, sizeof(nvri), pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memset(&nvri, 0, sizeof(nvri));
-#endif
-
-    return;
-
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-static void dispatchNVWriteItem(Parcel &p, RequestInfo *pRI) {
-    RIL_NV_WriteItem nvwi;
-    int32_t  t;
-    status_t status;
-
-    memset(&nvwi, 0, sizeof(nvwi));
-
-    status = p.readInt32(&t);
-    nvwi.itemID = (RIL_NV_Item) t;
-
-    nvwi.value = strdupReadString(p);
-
-    if (status != NO_ERROR || nvwi.value == NULL) {
-        goto invalid;
-    }
-
-    startRequest;
-    appendPrintBuf("%snvwi.itemID=%d, value=%s, ", printBuf, nvwi.itemID,
-            nvwi.value);
-    closeRequest;
-
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &nvwi, sizeof(nvwi), pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memsetString(nvwi.value);
-#endif
-
-    free(nvwi.value);
-
-#ifdef MEMSET_FREED
-    memset(&nvwi, 0, sizeof(nvwi));
-#endif
-
-    return;
-
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-
-static void dispatchUiccSubscripton(Parcel &p, RequestInfo *pRI) {
-    RIL_SelectUiccSub uicc_sub;
-    status_t status;
-    int32_t  t;
-    memset(&uicc_sub, 0, sizeof(uicc_sub));
-
-    status = p.readInt32(&t);
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-    uicc_sub.slot = (int) t;
-
-    status = p.readInt32(&t);
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-    uicc_sub.app_index = (int) t;
-
-    status = p.readInt32(&t);
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-    uicc_sub.sub_type = (RIL_SubscriptionType) t;
-
-    status = p.readInt32(&t);
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-    uicc_sub.act_status = (RIL_UiccSubActStatus) t;
-
-    startRequest;
-    appendPrintBuf("slot=%d, app_index=%d, act_status = %d", uicc_sub.slot, uicc_sub.app_index,
-            uicc_sub.act_status);
-    RLOGD("dispatchUiccSubscription, slot=%d, app_index=%d, act_status = %d", uicc_sub.slot,
-            uicc_sub.app_index, uicc_sub.act_status);
-    closeRequest;
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &uicc_sub, sizeof(uicc_sub), pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memset(&uicc_sub, 0, sizeof(uicc_sub));
-#endif
-    return;
-
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-static void dispatchSimAuthentication(Parcel &p, RequestInfo *pRI)
-{
-    RIL_SimAuthentication pf;
-    int32_t  t;
-    status_t status;
-
-    memset(&pf, 0, sizeof(pf));
-
-    status = p.readInt32(&t);
-    pf.authContext = (int) t;
-    pf.authData = strdupReadString(p);
-    pf.aid = strdupReadString(p);
-
-    startRequest;
-    appendPrintBuf("authContext=%s, authData=%s, aid=%s", pf.authContext, pf.authData, pf.aid);
-    closeRequest;
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-    CALL_ONREQUEST(pRI->pCI->requestNumber, &pf, sizeof(pf), pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-    memsetString(pf.authData);
-    memsetString(pf.aid);
-#endif
-
-    free(pf.authData);
-    free(pf.aid);
-
-#ifdef MEMSET_FREED
-    memset(&pf, 0, sizeof(pf));
-#endif
-
-    return;
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-static void dispatchDataProfile(Parcel &p, RequestInfo *pRI) {
-    int32_t t;
-    status_t status;
-    int32_t num;
-
-    status = p.readInt32(&num);
-    if (status != NO_ERROR || num < 0) {
-        goto invalid;
-    }
-
-    {
-        RIL_DataProfileInfo *dataProfiles =
-                (RIL_DataProfileInfo *)calloc(num, sizeof(RIL_DataProfileInfo));
-        if (dataProfiles == NULL) {
-            RLOGE("Memory allocation failed for request %s",
-                    requestToString(pRI->pCI->requestNumber));
-            return;
-        }
-        RIL_DataProfileInfo **dataProfilePtrs =
-                (RIL_DataProfileInfo **)calloc(num, sizeof(RIL_DataProfileInfo *));
-        if (dataProfilePtrs == NULL) {
-            RLOGE("Memory allocation failed for request %s",
-                    requestToString(pRI->pCI->requestNumber));
-            free(dataProfiles);
-            return;
-        }
-
-        startRequest;
-        for (int i = 0 ; i < num ; i++ ) {
-            dataProfilePtrs[i] = &dataProfiles[i];
-
-            status = p.readInt32(&t);
-            dataProfiles[i].profileId = (int) t;
-
-            dataProfiles[i].apn = strdupReadString(p);
-            dataProfiles[i].protocol = strdupReadString(p);
-            status = p.readInt32(&t);
-            dataProfiles[i].authType = (int) t;
-
-            dataProfiles[i].user = strdupReadString(p);
-            dataProfiles[i].password = strdupReadString(p);
-
-            status = p.readInt32(&t);
-            dataProfiles[i].type = (int) t;
-
-            status = p.readInt32(&t);
-            dataProfiles[i].maxConnsTime = (int) t;
-            status = p.readInt32(&t);
-            dataProfiles[i].maxConns = (int) t;
-            status = p.readInt32(&t);
-            dataProfiles[i].waitTime = (int) t;
-
-            status = p.readInt32(&t);
-            dataProfiles[i].enabled = (int) t;
-
-            appendPrintBuf("%s [%d: profileId=%d, apn =%s, protocol =%s, authType =%d, \
-                  user =%s, password =%s, type =%d, maxConnsTime =%d, maxConns =%d, \
-                  waitTime =%d, enabled =%d]", printBuf, i, dataProfiles[i].profileId,
-                  dataProfiles[i].apn, dataProfiles[i].protocol, dataProfiles[i].authType,
-                  dataProfiles[i].user, dataProfiles[i].password, dataProfiles[i].type,
-                  dataProfiles[i].maxConnsTime, dataProfiles[i].maxConns,
-                  dataProfiles[i].waitTime, dataProfiles[i].enabled);
-        }
-        closeRequest;
-        printRequest(pRI->token, pRI->pCI->requestNumber);
-
-        if (status != NO_ERROR) {
-            free(dataProfiles);
-            free(dataProfilePtrs);
-            goto invalid;
-        }
-        CALL_ONREQUEST(pRI->pCI->requestNumber,
-                              dataProfilePtrs,
-                              num * sizeof(RIL_DataProfileInfo *),
-                              pRI, pRI->socket_id);
-
-#ifdef MEMSET_FREED
-        memset(dataProfiles, 0, num * sizeof(RIL_DataProfileInfo));
-        memset(dataProfilePtrs, 0, num * sizeof(RIL_DataProfileInfo *));
-#endif
-        free(dataProfiles);
-        free(dataProfilePtrs);
-    }
-
-    return;
-
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-static void dispatchRadioCapability(Parcel &p, RequestInfo *pRI){
-    RIL_RadioCapability rc;
-    int32_t t;
-    status_t status;
-
-    memset (&rc, 0, sizeof(RIL_RadioCapability));
-
-    status = p.readInt32(&t);
-    rc.version = (int)t;
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    status = p.readInt32(&t);
-    rc.session= (int)t;
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    status = p.readInt32(&t);
-    rc.phase= (int)t;
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    status = p.readInt32(&t);
-    rc.rat = (int)t;
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    status = readStringFromParcelInplace(p, rc.logicalModemUuid, sizeof(rc.logicalModemUuid));
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    status = p.readInt32(&t);
-    rc.status = (int)t;
-
-    if (status != NO_ERROR) {
-        goto invalid;
-    }
-
-    startRequest;
-    appendPrintBuf("%s [version:%d, session:%d, phase:%d, rat:%d, \
-            logicalModemUuid:%s, status:%d", printBuf, rc.version, rc.session,
-            rc.phase, rc.rat, rc.logicalModemUuid, rc.session);
-
-    closeRequest;
-    printRequest(pRI->token, pRI->pCI->requestNumber);
-
-    CALL_ONREQUEST(pRI->pCI->requestNumber,
-                &rc,
-                sizeof(RIL_RadioCapability),
-                pRI, pRI->socket_id);
-    return;
-invalid:
-    invalidCommandBlock(pRI);
-    return;
-}
-
-static int
-blockingWrite(int fd, const void *buffer, size_t len) {
-    size_t writeOffset = 0;
-    const uint8_t *toWrite;
-
-    toWrite = (const uint8_t *)buffer;
-
-    while (writeOffset < len) {
-        ssize_t written;
-        do {
-            written = write (fd, toWrite + writeOffset,
-                                len - writeOffset);
-        } while (written < 0 && ((errno == EINTR) || (errno == EAGAIN)));
-
-        if (written >= 0) {
-            writeOffset += written;
-        } else {   // written < 0
-            RLOGE ("RIL Response: unexpected error on write errno:%d", errno);
-            close(fd);
-            return -1;
-        }
-    }
-#if VDBG
-    RLOGE("RIL Response bytes written:%d", writeOffset);
-#endif
-    return 0;
-}
-
-static int
-sendResponseRaw (const void *data, size_t dataSize, RIL_SOCKET_ID socket_id) {
-    int fd = s_ril_param_socket.fdCommand;
-    int ret;
-    uint32_t header;
-    pthread_mutex_t * writeMutexHook = &s_writeMutex;
-
-#if VDBG
-    RLOGE("Send Response to %s", rilSocketIdToString(socket_id));
-#endif
-
-#if (SIM_COUNT >= 2)
-    if (socket_id == RIL_SOCKET_2) {
-        fd = s_ril_param_socket2.fdCommand;
-        writeMutexHook = &s_writeMutex_socket2;
-    }
-#if (SIM_COUNT >= 3)
-    else if (socket_id == RIL_SOCKET_3) {
-        fd = s_ril_param_socket3.fdCommand;
-        writeMutexHook = &s_writeMutex_socket3;
-    }
-#endif
-#if (SIM_COUNT >= 4)
-    else if (socket_id == RIL_SOCKET_4) {
-        fd = s_ril_param_socket4.fdCommand;
-        writeMutexHook = &s_writeMutex_socket4;
-    }
-#endif
-#endif
-    if (fd < 0) {
-        return -1;
-    }
-
-    if (dataSize > MAX_COMMAND_BYTES) {
-        RLOGE("RIL: packet larger than %u (%u)",
-                MAX_COMMAND_BYTES, (unsigned int )dataSize);
-
-        return -1;
-    }
-
-    pthread_mutex_lock(writeMutexHook);
-
-    header = htonl(dataSize);
-
-    ret = blockingWrite(fd, (void *)&header, sizeof(header));
-
-    if (ret < 0) {
-        pthread_mutex_unlock(writeMutexHook);
-        return ret;
-    }
-
-    ret = blockingWrite(fd, data, dataSize);
-
-    if (ret < 0) {
-        pthread_mutex_unlock(writeMutexHook);
-        return ret;
-    }
-
-    pthread_mutex_unlock(writeMutexHook);
-
-    return 0;
-}
-
-static int
-sendResponse (Parcel &p, RIL_SOCKET_ID socket_id) {
-    printResponse;
-    return sendResponseRaw(p.data(), p.dataSize(), socket_id);
-}
-
-/** response is an int* pointing to an array of ints */
-
-static int
-responseInts(Parcel &p, void *response, size_t responselen) {
-    int numInts;
-
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-    if (responselen % sizeof(int) != 0) {
-        RLOGE("responseInts: invalid response length %d expected multiple of %d\n",
-            (int)responselen, (int)sizeof(int));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    int *p_int = (int *) response;
-
-    numInts = responselen / sizeof(int);
-    p.writeInt32 (numInts);
-
-    /* each int*/
-    startResponse;
-    for (int i = 0 ; i < numInts ; i++) {
-        appendPrintBuf("%s%d,", printBuf, p_int[i]);
-        p.writeInt32(p_int[i]);
-    }
-    removeLastChar;
-    closeResponse;
-
-    return 0;
-}
-
-// Response is an int or RIL_LastCallFailCauseInfo.
-// Currently, only Shamu plans to use RIL_LastCallFailCauseInfo.
-// TODO(yjl): Let all implementations use RIL_LastCallFailCauseInfo.
-static int responseFailCause(Parcel &p, void *response, size_t responselen) {
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen == sizeof(int)) {
-      startResponse;
-      int *p_int = (int *) response;
-      appendPrintBuf("%s%d,", printBuf, p_int[0]);
-      p.writeInt32(p_int[0]);
-      removeLastChar;
-      closeResponse;
-    } else if (responselen == sizeof(RIL_LastCallFailCauseInfo)) {
-      startResponse;
-      RIL_LastCallFailCauseInfo *p_fail_cause_info = (RIL_LastCallFailCauseInfo *) response;
-      appendPrintBuf("%s[cause_code=%d,vendor_cause=%s]", printBuf, p_fail_cause_info->cause_code,
-                     p_fail_cause_info->vendor_cause);
-      p.writeInt32(p_fail_cause_info->cause_code);
-      writeStringToParcel(p, p_fail_cause_info->vendor_cause);
-      removeLastChar;
-      closeResponse;
-    } else {
-      RLOGE("responseFailCause: invalid response length %d expected an int or "
-            "RIL_LastCallFailCauseInfo", (int)responselen);
-      return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    return 0;
-}
-
-/** response is a char **, pointing to an array of char *'s
-    The parcel will begin with the version */
-static int responseStringsWithVersion(int version, Parcel &p, void *response, size_t responselen) {
-    p.writeInt32(version);
-    return responseStrings(p, response, responselen);
-}
-
-/** response is a char **, pointing to an array of char *'s */
-static int responseStrings(Parcel &p, void *response, size_t responselen) {
-    int numStrings;
-
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-    if (responselen % sizeof(char *) != 0) {
-        RLOGE("responseStrings: invalid response length %d expected multiple of %d\n",
-            (int)responselen, (int)sizeof(char *));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (response == NULL) {
-        p.writeInt32 (0);
-    } else {
-        char **p_cur = (char **) response;
-
-        numStrings = responselen / sizeof(char *);
-        p.writeInt32 (numStrings);
-
-        /* each string*/
-        startResponse;
-        for (int i = 0 ; i < numStrings ; i++) {
-            appendPrintBuf("%s%s,", printBuf, (char*)p_cur[i]);
-            writeStringToParcel (p, p_cur[i]);
-        }
-        removeLastChar;
-        closeResponse;
-    }
-    return 0;
-}
-
-
-/**
- * NULL strings are accepted
- * FIXME currently ignores responselen
- */
-static int responseString(Parcel &p, void *response, size_t responselen) {
-    /* one string only */
-    startResponse;
-    appendPrintBuf("%s%s", printBuf, (char*)response);
-    closeResponse;
-
-    writeStringToParcel(p, (const char *)response);
-
-    return 0;
-}
-
-static int responseVoid(Parcel &p, void *response, size_t responselen) {
-    startResponse;
-    removeLastChar;
-    return 0;
-}
-
-static int responseCallList(Parcel &p, void *response, size_t responselen) {
-    int num;
-
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen % sizeof (RIL_Call *) != 0) {
-        RLOGE("responseCallList: invalid response length %d expected multiple of %d\n",
-            (int)responselen, (int)sizeof (RIL_Call *));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    startResponse;
-    /* number of call info's */
-    num = responselen / sizeof(RIL_Call *);
-    p.writeInt32(num);
-
-    for (int i = 0 ; i < num ; i++) {
-        RIL_Call *p_cur = ((RIL_Call **) response)[i];
-        /* each call info */
-        p.writeInt32(p_cur->state);
-        p.writeInt32(p_cur->index);
-        p.writeInt32(p_cur->toa);
-        p.writeInt32(p_cur->isMpty);
-        p.writeInt32(p_cur->isMT);
-        p.writeInt32(p_cur->als);
-        p.writeInt32(p_cur->isVoice);
-        p.writeInt32(p_cur->isVoicePrivacy);
-        writeStringToParcel(p, p_cur->number);
-        p.writeInt32(p_cur->numberPresentation);
-        writeStringToParcel(p, p_cur->name);
-        p.writeInt32(p_cur->namePresentation);
-        // Remove when partners upgrade to version 3
-        if ((s_callbacks.version < 3) || (p_cur->uusInfo == NULL || p_cur->uusInfo->uusData == NULL)) {
-            p.writeInt32(0); /* UUS Information is absent */
-        } else {
-            RIL_UUS_Info *uusInfo = p_cur->uusInfo;
-            p.writeInt32(1); /* UUS Information is present */
-            p.writeInt32(uusInfo->uusType);
-            p.writeInt32(uusInfo->uusDcs);
-            p.writeInt32(uusInfo->uusLength);
-            p.write(uusInfo->uusData, uusInfo->uusLength);
-        }
-        appendPrintBuf("%s[id=%d,%s,toa=%d,",
-            printBuf,
-            p_cur->index,
-            callStateToString(p_cur->state),
-            p_cur->toa);
-        appendPrintBuf("%s%s,%s,als=%d,%s,%s,",
-            printBuf,
-            (p_cur->isMpty)?"conf":"norm",
-            (p_cur->isMT)?"mt":"mo",
-            p_cur->als,
-            (p_cur->isVoice)?"voc":"nonvoc",
-            (p_cur->isVoicePrivacy)?"evp":"noevp");
-        appendPrintBuf("%s%s,cli=%d,name='%s',%d]",
-            printBuf,
-            p_cur->number,
-            p_cur->numberPresentation,
-            p_cur->name,
-            p_cur->namePresentation);
-    }
-    removeLastChar;
-    closeResponse;
-
-    return 0;
-}
-
-static int responseSMS(Parcel &p, void *response, size_t responselen) {
-    if (response == NULL) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen != sizeof (RIL_SMS_Response) ) {
-        RLOGE("invalid response length %d expected %d",
-                (int)responselen, (int)sizeof (RIL_SMS_Response));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    RIL_SMS_Response *p_cur = (RIL_SMS_Response *) response;
-
-    p.writeInt32(p_cur->messageRef);
-    writeStringToParcel(p, p_cur->ackPDU);
-    p.writeInt32(p_cur->errorCode);
-
-    startResponse;
-    appendPrintBuf("%s%d,%s,%d", printBuf, p_cur->messageRef,
-        (char*)p_cur->ackPDU, p_cur->errorCode);
-    closeResponse;
-
-    return 0;
-}
-
-static int responseDataCallListV4(Parcel &p, void *response, size_t responselen)
-{
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen % sizeof(RIL_Data_Call_Response_v4) != 0) {
-        RLOGE("responseDataCallListV4: invalid response length %d expected multiple of %d",
-                (int)responselen, (int)sizeof(RIL_Data_Call_Response_v4));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    // Write version
-    p.writeInt32(4);
-
-    int num = responselen / sizeof(RIL_Data_Call_Response_v4);
-    p.writeInt32(num);
-
-    RIL_Data_Call_Response_v4 *p_cur = (RIL_Data_Call_Response_v4 *) response;
-    startResponse;
-    int i;
-    for (i = 0; i < num; i++) {
-        p.writeInt32(p_cur[i].cid);
-        p.writeInt32(p_cur[i].active);
-        writeStringToParcel(p, p_cur[i].type);
-        // apn is not used, so don't send.
-        writeStringToParcel(p, p_cur[i].address);
-        appendPrintBuf("%s[cid=%d,%s,%s,%s],", printBuf,
-            p_cur[i].cid,
-            (p_cur[i].active==0)?"down":"up",
-            (char*)p_cur[i].type,
-            (char*)p_cur[i].address);
-    }
-    removeLastChar;
-    closeResponse;
-
-    return 0;
-}
-
-static int responseDataCallListV6(Parcel &p, void *response, size_t responselen)
-{
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen % sizeof(RIL_Data_Call_Response_v6) != 0) {
-        RLOGE("responseDataCallListV6: invalid response length %d expected multiple of %d",
-                (int)responselen, (int)sizeof(RIL_Data_Call_Response_v6));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    // Write version
-    p.writeInt32(6);
-
-    int num = responselen / sizeof(RIL_Data_Call_Response_v6);
-    p.writeInt32(num);
-
-    RIL_Data_Call_Response_v6 *p_cur = (RIL_Data_Call_Response_v6 *) response;
-    startResponse;
-    int i;
-    for (i = 0; i < num; i++) {
-        p.writeInt32((int)p_cur[i].status);
-        p.writeInt32(p_cur[i].suggestedRetryTime);
-        p.writeInt32(p_cur[i].cid);
-        p.writeInt32(p_cur[i].active);
-        writeStringToParcel(p, p_cur[i].type);
-        writeStringToParcel(p, p_cur[i].ifname);
-        writeStringToParcel(p, p_cur[i].addresses);
-        writeStringToParcel(p, p_cur[i].dnses);
-        writeStringToParcel(p, p_cur[i].gateways);
-        appendPrintBuf("%s[status=%d,retry=%d,cid=%d,%s,%s,%s,%s,%s,%s],", printBuf,
-            p_cur[i].status,
-            p_cur[i].suggestedRetryTime,
-            p_cur[i].cid,
-            (p_cur[i].active==0)?"down":"up",
-            (char*)p_cur[i].type,
-            (char*)p_cur[i].ifname,
-            (char*)p_cur[i].addresses,
-            (char*)p_cur[i].dnses,
-            (char*)p_cur[i].gateways);
-    }
-    removeLastChar;
-    closeResponse;
-
-    return 0;
-}
-
-static int responseDataCallListV9(Parcel &p, void *response, size_t responselen)
-{
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen % sizeof(RIL_Data_Call_Response_v9) != 0) {
-        RLOGE("responseDataCallListV9: invalid response length %d expected multiple of %d",
-                (int)responselen, (int)sizeof(RIL_Data_Call_Response_v9));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    // Write version
-    p.writeInt32(10);
-
-    int num = responselen / sizeof(RIL_Data_Call_Response_v9);
-    p.writeInt32(num);
-
-    RIL_Data_Call_Response_v9 *p_cur = (RIL_Data_Call_Response_v9 *) response;
-    startResponse;
-    int i;
-    for (i = 0; i < num; i++) {
-        p.writeInt32((int)p_cur[i].status);
-        p.writeInt32(p_cur[i].suggestedRetryTime);
-        p.writeInt32(p_cur[i].cid);
-        p.writeInt32(p_cur[i].active);
-        writeStringToParcel(p, p_cur[i].type);
-        writeStringToParcel(p, p_cur[i].ifname);
-        writeStringToParcel(p, p_cur[i].addresses);
-        writeStringToParcel(p, p_cur[i].dnses);
-        writeStringToParcel(p, p_cur[i].gateways);
-        writeStringToParcel(p, p_cur[i].pcscf);
-        appendPrintBuf("%s[status=%d,retry=%d,cid=%d,%s,%s,%s,%s,%s,%s,%s],", printBuf,
-            p_cur[i].status,
-            p_cur[i].suggestedRetryTime,
-            p_cur[i].cid,
-            (p_cur[i].active==0)?"down":"up",
-            (char*)p_cur[i].type,
-            (char*)p_cur[i].ifname,
-            (char*)p_cur[i].addresses,
-            (char*)p_cur[i].dnses,
-            (char*)p_cur[i].gateways,
-            (char*)p_cur[i].pcscf);
-    }
-    removeLastChar;
-    closeResponse;
-
-    return 0;
-}
-
-static int responseDataCallListV11(Parcel &p, void *response, size_t responselen) {
-    if (response == NULL && responselen != 0) {
-                RLOGE("invalid response: NULL");
-                return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen % sizeof(RIL_Data_Call_Response_v11) != 0) {
-        RLOGE("invalid response length %d expected multiple of %d",
-        (int)responselen, (int)sizeof(RIL_Data_Call_Response_v11));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    // Write version
-    p.writeInt32(11);
-
-    int num = responselen / sizeof(RIL_Data_Call_Response_v11);
-    p.writeInt32(num);
-
-    RIL_Data_Call_Response_v11 *p_cur = (RIL_Data_Call_Response_v11 *) response;
-    startResponse;
-    int i;
-    for (i = 0; i < num; i++) {
-        p.writeInt32((int)p_cur[i].status);
-        p.writeInt32(p_cur[i].suggestedRetryTime);
-        p.writeInt32(p_cur[i].cid);
-        p.writeInt32(p_cur[i].active);
-        writeStringToParcel(p, p_cur[i].type);
-        writeStringToParcel(p, p_cur[i].ifname);
-        writeStringToParcel(p, p_cur[i].addresses);
-        writeStringToParcel(p, p_cur[i].dnses);
-        writeStringToParcel(p, p_cur[i].gateways);
-        writeStringToParcel(p, p_cur[i].pcscf);
-        p.writeInt32(p_cur[i].mtu);
-        appendPrintBuf("%s[status=%d,retry=%d,cid=%d,%s,%s,%s,%s,%s,%s,%s,mtu=%d],", printBuf,
-        p_cur[i].status,
-        p_cur[i].suggestedRetryTime,
-        p_cur[i].cid,
-        (p_cur[i].active==0)?"down":"up",
-        (char*)p_cur[i].type,
-        (char*)p_cur[i].ifname,
-        (char*)p_cur[i].addresses,
-        (char*)p_cur[i].dnses,
-        (char*)p_cur[i].gateways,
-        (char*)p_cur[i].pcscf,
-        p_cur[i].mtu);
-    }
-    removeLastChar;
-    closeResponse;
-
-    return 0;
-}
-
-static int responseDataCallList(Parcel &p, void *response, size_t responselen)
-{
-    if (s_callbacks.version <= LAST_IMPRECISE_RIL_VERSION) {
-        if (s_callbacks.version < 5) {
-            RLOGD("responseDataCallList: v4");
-            return responseDataCallListV4(p, response, responselen);
-        } else if (responselen % sizeof(RIL_Data_Call_Response_v6) == 0) {
-            return responseDataCallListV6(p, response, responselen);
-        } else if (responselen % sizeof(RIL_Data_Call_Response_v9) == 0) {
-            return responseDataCallListV9(p, response, responselen);
-        } else {
-            return responseDataCallListV11(p, response, responselen);
-        }
-    } else { // RIL version >= 13
-        if (responselen % sizeof(RIL_Data_Call_Response_v11) != 0) {
-            RLOGE("Data structure expected is RIL_Data_Call_Response_v11");
-            if (!isDebuggable()) {
-                return RIL_ERRNO_INVALID_RESPONSE;
-            } else {
-                assert(0);
-            }
-        }
-        return responseDataCallListV11(p, response, responselen);
-    }
-}
-
-static int responseSetupDataCall(Parcel &p, void *response, size_t responselen)
-{
-    if (s_callbacks.version < 5) {
-        return responseStringsWithVersion(s_callbacks.version, p, response, responselen);
-    } else {
-        return responseDataCallList(p, response, responselen);
-    }
-}
-
-static int responseRaw(Parcel &p, void *response, size_t responselen) {
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL with responselen != 0");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    // The java code reads -1 size as null byte array
-    if (response == NULL) {
-        p.writeInt32(-1);
-    } else {
-        p.writeInt32(responselen);
-        p.write(response, responselen);
-    }
-
-    return 0;
-}
-
-
-static int responseSIM_IO(Parcel &p, void *response, size_t responselen) {
-    if (response == NULL) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen != sizeof (RIL_SIM_IO_Response) ) {
-        RLOGE("invalid response length was %d expected %d",
-                (int)responselen, (int)sizeof (RIL_SIM_IO_Response));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    RIL_SIM_IO_Response *p_cur = (RIL_SIM_IO_Response *) response;
-    p.writeInt32(p_cur->sw1);
-    p.writeInt32(p_cur->sw2);
-    writeStringToParcel(p, p_cur->simResponse);
-
-    startResponse;
-    appendPrintBuf("%ssw1=0x%X,sw2=0x%X,%s", printBuf, p_cur->sw1, p_cur->sw2,
-        (char*)p_cur->simResponse);
-    closeResponse;
-
-
-    return 0;
-}
-
-static int responseCallForwards(Parcel &p, void *response, size_t responselen) {
-    int num;
-
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen % sizeof(RIL_CallForwardInfo *) != 0) {
-        RLOGE("responseCallForwards: invalid response length %d expected multiple of %d",
-                (int)responselen, (int)sizeof(RIL_CallForwardInfo *));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    /* number of call info's */
-    num = responselen / sizeof(RIL_CallForwardInfo *);
-    p.writeInt32(num);
-
-    startResponse;
-    for (int i = 0 ; i < num ; i++) {
-        RIL_CallForwardInfo *p_cur = ((RIL_CallForwardInfo **) response)[i];
-
-        p.writeInt32(p_cur->status);
-        p.writeInt32(p_cur->reason);
-        p.writeInt32(p_cur->serviceClass);
-        p.writeInt32(p_cur->toa);
-        writeStringToParcel(p, p_cur->number);
-        p.writeInt32(p_cur->timeSeconds);
-        appendPrintBuf("%s[%s,reason=%d,cls=%d,toa=%d,%s,tout=%d],", printBuf,
-            (p_cur->status==1)?"enable":"disable",
-            p_cur->reason, p_cur->serviceClass, p_cur->toa,
-            (char*)p_cur->number,
-            p_cur->timeSeconds);
-    }
-    removeLastChar;
-    closeResponse;
-
-    return 0;
-}
-
-static int responseSsn(Parcel &p, void *response, size_t responselen) {
-    if (response == NULL) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen != sizeof(RIL_SuppSvcNotification)) {
-        RLOGE("invalid response length was %d expected %d",
-                (int)responselen, (int)sizeof (RIL_SuppSvcNotification));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    RIL_SuppSvcNotification *p_cur = (RIL_SuppSvcNotification *) response;
-    p.writeInt32(p_cur->notificationType);
-    p.writeInt32(p_cur->code);
-    p.writeInt32(p_cur->index);
-    p.writeInt32(p_cur->type);
-    writeStringToParcel(p, p_cur->number);
-
-    startResponse;
-    appendPrintBuf("%s%s,code=%d,id=%d,type=%d,%s", printBuf,
-        (p_cur->notificationType==0)?"mo":"mt",
-         p_cur->code, p_cur->index, p_cur->type,
-        (char*)p_cur->number);
-    closeResponse;
-
-    return 0;
-}
-
-static int responseCellList(Parcel &p, void *response, size_t responselen) {
-    int num;
-
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen % sizeof (RIL_NeighboringCell *) != 0) {
-        RLOGE("responseCellList: invalid response length %d expected multiple of %d\n",
-            (int)responselen, (int)sizeof (RIL_NeighboringCell *));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    startResponse;
-    /* number of records */
-    num = responselen / sizeof(RIL_NeighboringCell *);
-    p.writeInt32(num);
-
-    for (int i = 0 ; i < num ; i++) {
-        RIL_NeighboringCell *p_cur = ((RIL_NeighboringCell **) response)[i];
-
-        p.writeInt32(p_cur->rssi);
-        writeStringToParcel (p, p_cur->cid);
-
-        appendPrintBuf("%s[cid=%s,rssi=%d],", printBuf,
-            p_cur->cid, p_cur->rssi);
-    }
-    removeLastChar;
-    closeResponse;
-
-    return 0;
-}
-
-/**
- * Marshall the signalInfoRecord into the parcel if it exists.
- */
-static void marshallSignalInfoRecord(Parcel &p,
-            RIL_CDMA_SignalInfoRecord &p_signalInfoRecord) {
-    p.writeInt32(p_signalInfoRecord.isPresent);
-    p.writeInt32(p_signalInfoRecord.signalType);
-    p.writeInt32(p_signalInfoRecord.alertPitch);
-    p.writeInt32(p_signalInfoRecord.signal);
-}
-
-static int responseCdmaInformationRecords(Parcel &p,
-            void *response, size_t responselen) {
-    int num;
-    char* string8 = NULL;
-    int buffer_lenght;
-    RIL_CDMA_InformationRecord *infoRec;
-
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen != sizeof (RIL_CDMA_InformationRecords)) {
-        RLOGE("responseCdmaInformationRecords: invalid response length %d expected multiple of %d\n",
-            (int)responselen, (int)sizeof (RIL_CDMA_InformationRecords *));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    RIL_CDMA_InformationRecords *p_cur =
-                             (RIL_CDMA_InformationRecords *) response;
-    num = MIN(p_cur->numberOfInfoRecs, RIL_CDMA_MAX_NUMBER_OF_INFO_RECS);
-
-    startResponse;
-    p.writeInt32(num);
-
-    for (int i = 0 ; i < num ; i++) {
-        infoRec = &p_cur->infoRec[i];
-        p.writeInt32(infoRec->name);
-        switch (infoRec->name) {
-            case RIL_CDMA_DISPLAY_INFO_REC:
-            case RIL_CDMA_EXTENDED_DISPLAY_INFO_REC:
-                if (infoRec->rec.display.alpha_len >
-                                         CDMA_ALPHA_INFO_BUFFER_LENGTH) {
-                    RLOGE("invalid display info response length %d \
-                          expected not more than %d\n",
-                         (int)infoRec->rec.display.alpha_len,
-                         CDMA_ALPHA_INFO_BUFFER_LENGTH);
-                    return RIL_ERRNO_INVALID_RESPONSE;
-                }
-                string8 = (char*) calloc(infoRec->rec.display.alpha_len + 1, sizeof(char));
-                if (string8 == NULL) {
-                    RLOGE("Memory allocation failed for responseCdmaInformationRecords");
-                    closeRequest;
-                    return RIL_ERRNO_NO_MEMORY;
-                }
-                for (int i = 0 ; i < infoRec->rec.display.alpha_len ; i++) {
-                    string8[i] = infoRec->rec.display.alpha_buf[i];
-                }
-                string8[(int)infoRec->rec.display.alpha_len] = '\0';
-                writeStringToParcel(p, (const char*)string8);
-                free(string8);
-                string8 = NULL;
-                break;
-            case RIL_CDMA_CALLED_PARTY_NUMBER_INFO_REC:
-            case RIL_CDMA_CALLING_PARTY_NUMBER_INFO_REC:
-            case RIL_CDMA_CONNECTED_NUMBER_INFO_REC:
-                if (infoRec->rec.number.len > CDMA_NUMBER_INFO_BUFFER_LENGTH) {
-                    RLOGE("invalid display info response length %d \
-                          expected not more than %d\n",
-                         (int)infoRec->rec.number.len,
-                         CDMA_NUMBER_INFO_BUFFER_LENGTH);
-                    return RIL_ERRNO_INVALID_RESPONSE;
-                }
-                string8 = (char*) calloc(infoRec->rec.number.len + 1, sizeof(char));
-                if (string8 == NULL) {
-                    RLOGE("Memory allocation failed for responseCdmaInformationRecords");
-                    closeRequest;
-                    return RIL_ERRNO_NO_MEMORY;
-                }
-                for (int i = 0 ; i < infoRec->rec.number.len; i++) {
-                    string8[i] = infoRec->rec.number.buf[i];
-                }
-                string8[(int)infoRec->rec.number.len] = '\0';
-                writeStringToParcel(p, (const char*)string8);
-                free(string8);
-                string8 = NULL;
-                p.writeInt32(infoRec->rec.number.number_type);
-                p.writeInt32(infoRec->rec.number.number_plan);
-                p.writeInt32(infoRec->rec.number.pi);
-                p.writeInt32(infoRec->rec.number.si);
-                break;
-            case RIL_CDMA_SIGNAL_INFO_REC:
-                p.writeInt32(infoRec->rec.signal.isPresent);
-                p.writeInt32(infoRec->rec.signal.signalType);
-                p.writeInt32(infoRec->rec.signal.alertPitch);
-                p.writeInt32(infoRec->rec.signal.signal);
-
-                appendPrintBuf("%sisPresent=%X, signalType=%X, \
-                                alertPitch=%X, signal=%X, ",
-                   printBuf, (int)infoRec->rec.signal.isPresent,
-                   (int)infoRec->rec.signal.signalType,
-                   (int)infoRec->rec.signal.alertPitch,
-                   (int)infoRec->rec.signal.signal);
-                removeLastChar;
-                break;
-            case RIL_CDMA_REDIRECTING_NUMBER_INFO_REC:
-                if (infoRec->rec.redir.redirectingNumber.len >
-                                              CDMA_NUMBER_INFO_BUFFER_LENGTH) {
-                    RLOGE("invalid display info response length %d \
-                          expected not more than %d\n",
-                         (int)infoRec->rec.redir.redirectingNumber.len,
-                         CDMA_NUMBER_INFO_BUFFER_LENGTH);
-                    return RIL_ERRNO_INVALID_RESPONSE;
-                }
-                string8 = (char*) calloc(infoRec->rec.redir.redirectingNumber.len + 1,
-                        sizeof(char));
-                if (string8 == NULL) {
-                    RLOGE("Memory allocation failed for responseCdmaInformationRecords");
-                    closeRequest;
-                    return RIL_ERRNO_NO_MEMORY;
-                }
-                for (int i = 0;
-                         i < infoRec->rec.redir.redirectingNumber.len;
-                         i++) {
-                    string8[i] = infoRec->rec.redir.redirectingNumber.buf[i];
-                }
-                string8[(int)infoRec->rec.redir.redirectingNumber.len] = '\0';
-                writeStringToParcel(p, (const char*)string8);
-                free(string8);
-                string8 = NULL;
-                p.writeInt32(infoRec->rec.redir.redirectingNumber.number_type);
-                p.writeInt32(infoRec->rec.redir.redirectingNumber.number_plan);
-                p.writeInt32(infoRec->rec.redir.redirectingNumber.pi);
-                p.writeInt32(infoRec->rec.redir.redirectingNumber.si);
-                p.writeInt32(infoRec->rec.redir.redirectingReason);
-                break;
-            case RIL_CDMA_LINE_CONTROL_INFO_REC:
-                p.writeInt32(infoRec->rec.lineCtrl.lineCtrlPolarityIncluded);
-                p.writeInt32(infoRec->rec.lineCtrl.lineCtrlToggle);
-                p.writeInt32(infoRec->rec.lineCtrl.lineCtrlReverse);
-                p.writeInt32(infoRec->rec.lineCtrl.lineCtrlPowerDenial);
-
-                appendPrintBuf("%slineCtrlPolarityIncluded=%d, \
-                                lineCtrlToggle=%d, lineCtrlReverse=%d, \
-                                lineCtrlPowerDenial=%d, ", printBuf,
-                       (int)infoRec->rec.lineCtrl.lineCtrlPolarityIncluded,
-                       (int)infoRec->rec.lineCtrl.lineCtrlToggle,
-                       (int)infoRec->rec.lineCtrl.lineCtrlReverse,
-                       (int)infoRec->rec.lineCtrl.lineCtrlPowerDenial);
-                removeLastChar;
-                break;
-            case RIL_CDMA_T53_CLIR_INFO_REC:
-                p.writeInt32((int)(infoRec->rec.clir.cause));
-
-                appendPrintBuf("%scause%d", printBuf, infoRec->rec.clir.cause);
-                removeLastChar;
-                break;
-            case RIL_CDMA_T53_AUDIO_CONTROL_INFO_REC:
-                p.writeInt32(infoRec->rec.audioCtrl.upLink);
-                p.writeInt32(infoRec->rec.audioCtrl.downLink);
-
-                appendPrintBuf("%supLink=%d, downLink=%d, ", printBuf,
-                        infoRec->rec.audioCtrl.upLink,
-                        infoRec->rec.audioCtrl.downLink);
-                removeLastChar;
-                break;
-            case RIL_CDMA_T53_RELEASE_INFO_REC:
-                // TODO(Moto): See David Krause, he has the answer:)
-                RLOGE("RIL_CDMA_T53_RELEASE_INFO_REC: return INVALID_RESPONSE");
-                return RIL_ERRNO_INVALID_RESPONSE;
-            default:
-                RLOGE("Incorrect name value");
-                return RIL_ERRNO_INVALID_RESPONSE;
-        }
-    }
-    closeResponse;
-
-    return 0;
-}
-
-static void responseRilSignalStrengthV5(Parcel &p, RIL_SignalStrength_v10 *p_cur) {
-    p.writeInt32(p_cur->GW_SignalStrength.signalStrength);
-    p.writeInt32(p_cur->GW_SignalStrength.bitErrorRate);
-    p.writeInt32(p_cur->CDMA_SignalStrength.dbm);
-    p.writeInt32(p_cur->CDMA_SignalStrength.ecio);
-    p.writeInt32(p_cur->EVDO_SignalStrength.dbm);
-    p.writeInt32(p_cur->EVDO_SignalStrength.ecio);
-    p.writeInt32(p_cur->EVDO_SignalStrength.signalNoiseRatio);
-}
-
-static void responseRilSignalStrengthV6Extra(Parcel &p, RIL_SignalStrength_v10 *p_cur) {
-    /*
-     * Fixup LTE for backwards compatibility
-     */
-    // signalStrength: -1 -> 99
-    if (p_cur->LTE_SignalStrength.signalStrength == -1) {
-        p_cur->LTE_SignalStrength.signalStrength = 99;
-    }
-    // rsrp: -1 -> INT_MAX all other negative value to positive.
-    // So remap here
-    if (p_cur->LTE_SignalStrength.rsrp == -1) {
-        p_cur->LTE_SignalStrength.rsrp = INT_MAX;
-    } else if (p_cur->LTE_SignalStrength.rsrp < -1) {
-        p_cur->LTE_SignalStrength.rsrp = -p_cur->LTE_SignalStrength.rsrp;
-    }
-    // rsrq: -1 -> INT_MAX
-    if (p_cur->LTE_SignalStrength.rsrq == -1) {
-        p_cur->LTE_SignalStrength.rsrq = INT_MAX;
-    }
-    // Not remapping rssnr is already using INT_MAX
-
-    // cqi: -1 -> INT_MAX
-    if (p_cur->LTE_SignalStrength.cqi == -1) {
-        p_cur->LTE_SignalStrength.cqi = INT_MAX;
-    }
-
-    p.writeInt32(p_cur->LTE_SignalStrength.signalStrength);
-    p.writeInt32(p_cur->LTE_SignalStrength.rsrp);
-    p.writeInt32(p_cur->LTE_SignalStrength.rsrq);
-    p.writeInt32(p_cur->LTE_SignalStrength.rssnr);
-    p.writeInt32(p_cur->LTE_SignalStrength.cqi);
-}
-
-static void responseRilSignalStrengthV10(Parcel &p, RIL_SignalStrength_v10 *p_cur) {
-    responseRilSignalStrengthV5(p, p_cur);
-    responseRilSignalStrengthV6Extra(p, p_cur);
-    p.writeInt32(p_cur->TD_SCDMA_SignalStrength.rscp);
-}
-
-static int responseRilSignalStrength(Parcel &p,
-                    void *response, size_t responselen) {
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    RIL_SignalStrength_v10 *p_cur;
-    if (s_callbacks.version <= LAST_IMPRECISE_RIL_VERSION) {
-        if (responselen >= sizeof (RIL_SignalStrength_v5)) {
-            p_cur = ((RIL_SignalStrength_v10 *) response);
-
-            responseRilSignalStrengthV5(p, p_cur);
-
-            if (responselen >= sizeof (RIL_SignalStrength_v6)) {
-                responseRilSignalStrengthV6Extra(p, p_cur);
-                if (responselen >= sizeof (RIL_SignalStrength_v10)) {
-                    p.writeInt32(p_cur->TD_SCDMA_SignalStrength.rscp);
-                } else {
-                    p.writeInt32(INT_MAX);
-                }
-            } else {
-                p.writeInt32(99);
-                p.writeInt32(INT_MAX);
-                p.writeInt32(INT_MAX);
-                p.writeInt32(INT_MAX);
-                p.writeInt32(INT_MAX);
-                p.writeInt32(INT_MAX);
-            }
-        } else {
-            RLOGE("invalid response length");
-            return RIL_ERRNO_INVALID_RESPONSE;
-        }
-    } else { // RIL version >= 13
-        if (responselen % sizeof(RIL_SignalStrength_v10) != 0) {
-            RLOGE("Data structure expected is RIL_SignalStrength_v10");
-            if (!isDebuggable()) {
-                return RIL_ERRNO_INVALID_RESPONSE;
-            } else {
-                assert(0);
-            }
-        }
-        p_cur = ((RIL_SignalStrength_v10 *) response);
-        responseRilSignalStrengthV10(p, p_cur);
-    }
-    startResponse;
-    appendPrintBuf("%s[signalStrength=%d,bitErrorRate=%d,\
-            CDMA_SS.dbm=%d,CDMA_SSecio=%d,\
-            EVDO_SS.dbm=%d,EVDO_SS.ecio=%d,\
-            EVDO_SS.signalNoiseRatio=%d,\
-            LTE_SS.signalStrength=%d,LTE_SS.rsrp=%d,LTE_SS.rsrq=%d,\
-            LTE_SS.rssnr=%d,LTE_SS.cqi=%d,TDSCDMA_SS.rscp=%d]",
-            printBuf,
-            p_cur->GW_SignalStrength.signalStrength,
-            p_cur->GW_SignalStrength.bitErrorRate,
-            p_cur->CDMA_SignalStrength.dbm,
-            p_cur->CDMA_SignalStrength.ecio,
-            p_cur->EVDO_SignalStrength.dbm,
-            p_cur->EVDO_SignalStrength.ecio,
-            p_cur->EVDO_SignalStrength.signalNoiseRatio,
-            p_cur->LTE_SignalStrength.signalStrength,
-            p_cur->LTE_SignalStrength.rsrp,
-            p_cur->LTE_SignalStrength.rsrq,
-            p_cur->LTE_SignalStrength.rssnr,
-            p_cur->LTE_SignalStrength.cqi,
-            p_cur->TD_SCDMA_SignalStrength.rscp);
-    closeResponse;
-    return 0;
-}
-
-static int responseCallRing(Parcel &p, void *response, size_t responselen) {
-    if ((response == NULL) || (responselen == 0)) {
-        return responseVoid(p, response, responselen);
-    } else {
-        return responseCdmaSignalInfoRecord(p, response, responselen);
-    }
-}
-
-static int responseCdmaSignalInfoRecord(Parcel &p, void *response, size_t responselen) {
-    if (response == NULL || responselen == 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen != sizeof (RIL_CDMA_SignalInfoRecord)) {
-        RLOGE("invalid response length %d expected sizeof (RIL_CDMA_SignalInfoRecord) of %d\n",
-            (int)responselen, (int)sizeof (RIL_CDMA_SignalInfoRecord));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    startResponse;
-
-    RIL_CDMA_SignalInfoRecord *p_cur = ((RIL_CDMA_SignalInfoRecord *) response);
-    marshallSignalInfoRecord(p, *p_cur);
-
-    appendPrintBuf("%s[isPresent=%d,signalType=%d,alertPitch=%d\
-              signal=%d]",
-              printBuf,
-              p_cur->isPresent,
-              p_cur->signalType,
-              p_cur->alertPitch,
-              p_cur->signal);
-
-    closeResponse;
-    return 0;
-}
-
-static int responseCdmaCallWaiting(Parcel &p, void *response,
-            size_t responselen) {
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen < sizeof(RIL_CDMA_CallWaiting_v6)) {
-        RLOGW("Upgrade to ril version %d\n", RIL_VERSION);
-    }
-
-    RIL_CDMA_CallWaiting_v6 *p_cur = ((RIL_CDMA_CallWaiting_v6 *) response);
-
-    writeStringToParcel(p, p_cur->number);
-    p.writeInt32(p_cur->numberPresentation);
-    writeStringToParcel(p, p_cur->name);
-    marshallSignalInfoRecord(p, p_cur->signalInfoRecord);
-
-    if (s_callbacks.version <= LAST_IMPRECISE_RIL_VERSION) {
-        if (responselen >= sizeof(RIL_CDMA_CallWaiting_v6)) {
-            p.writeInt32(p_cur->number_type);
-            p.writeInt32(p_cur->number_plan);
-        } else {
-            p.writeInt32(0);
-            p.writeInt32(0);
-        }
-    } else { // RIL version >= 13
-        if (responselen % sizeof(RIL_CDMA_CallWaiting_v6) != 0) {
-            RLOGE("Data structure expected is RIL_CDMA_CallWaiting_v6");
-            if (!isDebuggable()) {
-                return RIL_ERRNO_INVALID_RESPONSE;
-            } else {
-                assert(0);
-            }
-        }
-        p.writeInt32(p_cur->number_type);
-        p.writeInt32(p_cur->number_plan);
-    }
-
-    startResponse;
-    appendPrintBuf("%snumber=%s,numberPresentation=%d, name=%s,\
-            signalInfoRecord[isPresent=%d,signalType=%d,alertPitch=%d\
-            signal=%d,number_type=%d,number_plan=%d]",
-            printBuf,
-            p_cur->number,
-            p_cur->numberPresentation,
-            p_cur->name,
-            p_cur->signalInfoRecord.isPresent,
-            p_cur->signalInfoRecord.signalType,
-            p_cur->signalInfoRecord.alertPitch,
-            p_cur->signalInfoRecord.signal,
-            p_cur->number_type,
-            p_cur->number_plan);
-    closeResponse;
-
-    return 0;
-}
-
-static void responseSimRefreshV7(Parcel &p, void *response) {
-      RIL_SimRefreshResponse_v7 *p_cur = ((RIL_SimRefreshResponse_v7 *) response);
-      p.writeInt32(p_cur->result);
-      p.writeInt32(p_cur->ef_id);
-      writeStringToParcel(p, p_cur->aid);
-
-      appendPrintBuf("%sresult=%d, ef_id=%d, aid=%s",
-            printBuf,
-            p_cur->result,
-            p_cur->ef_id,
-            p_cur->aid);
-
-}
-
-static int responseSimRefresh(Parcel &p, void *response, size_t responselen) {
-    if (response == NULL && responselen != 0) {
-        RLOGE("responseSimRefresh: invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    startResponse;
-    if (s_callbacks.version <= LAST_IMPRECISE_RIL_VERSION) {
-        if (s_callbacks.version >= 7) {
-            responseSimRefreshV7(p, response);
-        } else {
-            int *p_cur = ((int *) response);
-            p.writeInt32(p_cur[0]);
-            p.writeInt32(p_cur[1]);
-            writeStringToParcel(p, NULL);
-
-            appendPrintBuf("%sresult=%d, ef_id=%d",
-                    printBuf,
-                    p_cur[0],
-                    p_cur[1]);
-        }
-    } else { // RIL version >= 13
-        if (responselen % sizeof(RIL_SimRefreshResponse_v7) != 0) {
-            RLOGE("Data structure expected is RIL_SimRefreshResponse_v7");
-            if (!isDebuggable()) {
-                return RIL_ERRNO_INVALID_RESPONSE;
-            } else {
-                assert(0);
-            }
-        }
-        responseSimRefreshV7(p, response);
-
-    }
-    closeResponse;
-
-    return 0;
-}
-
-static int responseCellInfoListV6(Parcel &p, void *response, size_t responselen) {
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen % sizeof(RIL_CellInfo) != 0) {
-        RLOGE("responseCellInfoList: invalid response length %d expected multiple of %d",
-                (int)responselen, (int)sizeof(RIL_CellInfo));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    int num = responselen / sizeof(RIL_CellInfo);
-    p.writeInt32(num);
-
-    RIL_CellInfo *p_cur = (RIL_CellInfo *) response;
-    startResponse;
-    int i;
-    for (i = 0; i < num; i++) {
-        p.writeInt32((int)p_cur->cellInfoType);
-        p.writeInt32(p_cur->registered);
-        p.writeInt32(p_cur->timeStampType);
-        p.writeInt64(p_cur->timeStamp);
-        switch(p_cur->cellInfoType) {
-            case RIL_CELL_INFO_TYPE_GSM: {
-                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.mcc);
-                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.mnc);
-                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.lac);
-                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.cid);
-                p.writeInt32(p_cur->CellInfo.gsm.signalStrengthGsm.signalStrength);
-                p.writeInt32(p_cur->CellInfo.gsm.signalStrengthGsm.bitErrorRate);
-                break;
-            }
-            case RIL_CELL_INFO_TYPE_WCDMA: {
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.mcc);
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.mnc);
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.lac);
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.cid);
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.psc);
-                p.writeInt32(p_cur->CellInfo.wcdma.signalStrengthWcdma.signalStrength);
-                p.writeInt32(p_cur->CellInfo.wcdma.signalStrengthWcdma.bitErrorRate);
-                break;
-            }
-            case RIL_CELL_INFO_TYPE_CDMA: {
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.networkId);
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.systemId);
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.basestationId);
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.longitude);
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.latitude);
-
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthCdma.dbm);
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthCdma.ecio);
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.dbm);
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.ecio);
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.signalNoiseRatio);
-                break;
-            }
-            case RIL_CELL_INFO_TYPE_LTE: {
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.mcc);
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.mnc);
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.ci);
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.pci);
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.tac);
-
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.signalStrength);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rsrp);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rsrq);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rssnr);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.cqi);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.timingAdvance);
-                break;
-            }
-            case RIL_CELL_INFO_TYPE_TD_SCDMA: {
-                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.mcc);
-                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.mnc);
-                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.lac);
-                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.cid);
-                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.cpid);
-                p.writeInt32(p_cur->CellInfo.tdscdma.signalStrengthTdscdma.rscp);
-                break;
-            }
-        }
-        p_cur += 1;
-    }
-    removeLastChar;
-    closeResponse;
-
-    return 0;
-}
-
-static int responseCellInfoListV12(Parcel &p, void *response, size_t responselen) {
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen % sizeof(RIL_CellInfo_v12) != 0) {
-        RLOGE("responseCellInfoList: invalid response length %d expected multiple of %d",
-                (int)responselen, (int)sizeof(RIL_CellInfo_v12));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    int num = responselen / sizeof(RIL_CellInfo_v12);
-    p.writeInt32(num);
-
-    RIL_CellInfo_v12 *p_cur = (RIL_CellInfo_v12 *) response;
-    startResponse;
-    int i;
-    for (i = 0; i < num; i++) {
-        p.writeInt32((int)p_cur->cellInfoType);
-        p.writeInt32(p_cur->registered);
-        p.writeInt32(p_cur->timeStampType);
-        p.writeInt64(p_cur->timeStamp);
-        switch(p_cur->cellInfoType) {
-            case RIL_CELL_INFO_TYPE_GSM: {
-                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.mcc);
-                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.mnc);
-                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.lac);
-                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.cid);
-                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.arfcn);
-                p.writeInt32(p_cur->CellInfo.gsm.cellIdentityGsm.bsic);
-                p.writeInt32(p_cur->CellInfo.gsm.signalStrengthGsm.signalStrength);
-                p.writeInt32(p_cur->CellInfo.gsm.signalStrengthGsm.bitErrorRate);
-                p.writeInt32(p_cur->CellInfo.gsm.signalStrengthGsm.timingAdvance);
-                break;
-            }
-            case RIL_CELL_INFO_TYPE_WCDMA: {
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.mcc);
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.mnc);
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.lac);
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.cid);
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.psc);
-                p.writeInt32(p_cur->CellInfo.wcdma.cellIdentityWcdma.uarfcn);
-                p.writeInt32(p_cur->CellInfo.wcdma.signalStrengthWcdma.signalStrength);
-                p.writeInt32(p_cur->CellInfo.wcdma.signalStrengthWcdma.bitErrorRate);
-                break;
-            }
-            case RIL_CELL_INFO_TYPE_CDMA: {
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.networkId);
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.systemId);
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.basestationId);
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.longitude);
-                p.writeInt32(p_cur->CellInfo.cdma.cellIdentityCdma.latitude);
-
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthCdma.dbm);
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthCdma.ecio);
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.dbm);
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.ecio);
-                p.writeInt32(p_cur->CellInfo.cdma.signalStrengthEvdo.signalNoiseRatio);
-                break;
-            }
-            case RIL_CELL_INFO_TYPE_LTE: {
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.mcc);
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.mnc);
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.ci);
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.pci);
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.tac);
-                p.writeInt32(p_cur->CellInfo.lte.cellIdentityLte.earfcn);
-
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.signalStrength);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rsrp);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rsrq);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.rssnr);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.cqi);
-                p.writeInt32(p_cur->CellInfo.lte.signalStrengthLte.timingAdvance);
-                break;
-            }
-            case RIL_CELL_INFO_TYPE_TD_SCDMA: {
-                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.mcc);
-                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.mnc);
-                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.lac);
-                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.cid);
-                p.writeInt32(p_cur->CellInfo.tdscdma.cellIdentityTdscdma.cpid);
-                p.writeInt32(p_cur->CellInfo.tdscdma.signalStrengthTdscdma.rscp);
-                break;
-            }
-        }
-        p_cur += 1;
-    }
-    removeLastChar;
-    closeResponse;
-    return 0;
-}
-
-static int responseCellInfoList(Parcel &p, void *response, size_t responselen)
-{
-    if (s_callbacks.version <= LAST_IMPRECISE_RIL_VERSION) {
-        if (s_callbacks.version < 12) {
-            RLOGD("responseCellInfoList: v6");
-            return responseCellInfoListV6(p, response, responselen);
-        } else {
-            RLOGD("responseCellInfoList: v12");
-            return responseCellInfoListV12(p, response, responselen);
-        }
-    } else { // RIL version >= 13
-        if (responselen % sizeof(RIL_CellInfo_v12) != 0) {
-            RLOGE("Data structure expected is RIL_CellInfo_v12");
-            if (!isDebuggable()) {
-                return RIL_ERRNO_INVALID_RESPONSE;
-            } else {
-                assert(0);
-            }
-        }
-        return responseCellInfoListV12(p, response, responselen);
-    }
-
-    return 0;
-}
-
-static int responseHardwareConfig(Parcel &p, void *response, size_t responselen)
-{
-   if (response == NULL && responselen != 0) {
-       RLOGE("invalid response: NULL");
-       return RIL_ERRNO_INVALID_RESPONSE;
-   }
-
-   if (responselen % sizeof(RIL_HardwareConfig) != 0) {
-       RLOGE("responseHardwareConfig: invalid response length %d expected multiple of %d",
-          (int)responselen, (int)sizeof(RIL_HardwareConfig));
-       return RIL_ERRNO_INVALID_RESPONSE;
-   }
-
-   int num = responselen / sizeof(RIL_HardwareConfig);
-   int i;
-   RIL_HardwareConfig *p_cur = (RIL_HardwareConfig *) response;
-
-   p.writeInt32(num);
-
-   startResponse;
-   for (i = 0; i < num; i++) {
-      switch (p_cur[i].type) {
-         case RIL_HARDWARE_CONFIG_MODEM: {
-            writeStringToParcel(p, p_cur[i].uuid);
-            p.writeInt32((int)p_cur[i].state);
-            p.writeInt32(p_cur[i].cfg.modem.rat);
-            p.writeInt32(p_cur[i].cfg.modem.maxVoice);
-            p.writeInt32(p_cur[i].cfg.modem.maxData);
-            p.writeInt32(p_cur[i].cfg.modem.maxStandby);
-
-            appendPrintBuf("%s modem: uuid=%s,state=%d,rat=%08x,maxV=%d,maxD=%d,maxS=%d", printBuf,
-               p_cur[i].uuid, (int)p_cur[i].state, p_cur[i].cfg.modem.rat,
-               p_cur[i].cfg.modem.maxVoice, p_cur[i].cfg.modem.maxData, p_cur[i].cfg.modem.maxStandby);
-            break;
-         }
-         case RIL_HARDWARE_CONFIG_SIM: {
-            writeStringToParcel(p, p_cur[i].uuid);
-            p.writeInt32((int)p_cur[i].state);
-            writeStringToParcel(p, p_cur[i].cfg.sim.modemUuid);
-
-            appendPrintBuf("%s sim: uuid=%s,state=%d,modem-uuid=%s", printBuf,
-               p_cur[i].uuid, (int)p_cur[i].state, p_cur[i].cfg.sim.modemUuid);
-            break;
-         }
-      }
-   }
-   removeLastChar;
-   closeResponse;
-   return 0;
-}
-
-static int responseRadioCapability(Parcel &p, void *response, size_t responselen) {
-    if (response == NULL) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen != sizeof (RIL_RadioCapability) ) {
-        RLOGE("invalid response length was %d expected %d",
-                (int)responselen, (int)sizeof (RIL_SIM_IO_Response));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    RIL_RadioCapability *p_cur = (RIL_RadioCapability *) response;
-    p.writeInt32(p_cur->version);
-    p.writeInt32(p_cur->session);
-    p.writeInt32(p_cur->phase);
-    p.writeInt32(p_cur->rat);
-    writeStringToParcel(p, p_cur->logicalModemUuid);
-    p.writeInt32(p_cur->status);
-
-    startResponse;
-    appendPrintBuf("%s[version=%d,session=%d,phase=%d,\
-            rat=%s,logicalModemUuid=%s,status=%d]",
-            printBuf,
-            p_cur->version,
-            p_cur->session,
-            p_cur->phase,
-            p_cur->rat,
-            p_cur->logicalModemUuid,
-            p_cur->status);
-    closeResponse;
-    return 0;
-}
-
-static int responseSSData(Parcel &p, void *response, size_t responselen) {
-    RLOGD("In responseSSData");
-    int num;
-
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response length was %d expected %d",
-                (int)responselen, (int)sizeof (RIL_SIM_IO_Response));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen != sizeof(RIL_StkCcUnsolSsResponse)) {
-        RLOGE("invalid response length %d, expected %d",
-               (int)responselen, (int)sizeof(RIL_StkCcUnsolSsResponse));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    startResponse;
-    RIL_StkCcUnsolSsResponse *p_cur = (RIL_StkCcUnsolSsResponse *) response;
-    p.writeInt32(p_cur->serviceType);
-    p.writeInt32(p_cur->requestType);
-    p.writeInt32(p_cur->teleserviceType);
-    p.writeInt32(p_cur->serviceClass);
-    p.writeInt32(p_cur->result);
-
-    if (isServiceTypeCfQuery(p_cur->serviceType, p_cur->requestType)) {
-        RLOGD("responseSSData CF type, num of Cf elements %d", p_cur->cfData.numValidIndexes);
-        if (p_cur->cfData.numValidIndexes > NUM_SERVICE_CLASSES) {
-            RLOGE("numValidIndexes is greater than max value %d, "
-                  "truncating it to max value", NUM_SERVICE_CLASSES);
-            p_cur->cfData.numValidIndexes = NUM_SERVICE_CLASSES;
-        }
-        /* number of call info's */
-        p.writeInt32(p_cur->cfData.numValidIndexes);
-
-        for (int i = 0; i < p_cur->cfData.numValidIndexes; i++) {
-             RIL_CallForwardInfo cf = p_cur->cfData.cfInfo[i];
-
-             p.writeInt32(cf.status);
-             p.writeInt32(cf.reason);
-             p.writeInt32(cf.serviceClass);
-             p.writeInt32(cf.toa);
-             writeStringToParcel(p, cf.number);
-             p.writeInt32(cf.timeSeconds);
-             appendPrintBuf("%s[%s,reason=%d,cls=%d,toa=%d,%s,tout=%d],", printBuf,
-                 (cf.status==1)?"enable":"disable", cf.reason, cf.serviceClass, cf.toa,
-                  (char*)cf.number, cf.timeSeconds);
-             RLOGD("Data: %d,reason=%d,cls=%d,toa=%d,num=%s,tout=%d],", cf.status,
-                  cf.reason, cf.serviceClass, cf.toa, (char*)cf.number, cf.timeSeconds);
-        }
-    } else {
-        p.writeInt32 (SS_INFO_MAX);
-
-        /* each int*/
-        for (int i = 0; i < SS_INFO_MAX; i++) {
-             appendPrintBuf("%s%d,", printBuf, p_cur->ssInfo[i]);
-             RLOGD("Data: %d",p_cur->ssInfo[i]);
-             p.writeInt32(p_cur->ssInfo[i]);
-        }
-    }
-    removeLastChar;
-    closeResponse;
-
-    return 0;
-}
-
-static bool isServiceTypeCfQuery(RIL_SsServiceType serType, RIL_SsRequestType reqType) {
-    if ((reqType == SS_INTERROGATION) &&
-        (serType == SS_CFU ||
-         serType == SS_CF_BUSY ||
-         serType == SS_CF_NO_REPLY ||
-         serType == SS_CF_NOT_REACHABLE ||
-         serType == SS_CF_ALL ||
-         serType == SS_CF_ALL_CONDITIONAL)) {
-        return true;
-    }
-    return false;
-}
-
-static void triggerEvLoop() {
-    int ret;
-    if (!pthread_equal(pthread_self(), s_tid_dispatch)) {
-        /* trigger event loop to wakeup. No reason to do this,
-         * if we're in the event loop thread */
-         do {
-            ret = write (s_fdWakeupWrite, " ", 1);
-         } while (ret < 0 && errno == EINTR);
-    }
-}
-
-static void rilEventAddWakeup(struct ril_event *ev) {
-    ril_event_add(ev);
-    triggerEvLoop();
-}
-
-static void sendSimStatusAppInfo(Parcel &p, int num_apps, RIL_AppStatus appStatus[]) {
-        p.writeInt32(num_apps);
-        startResponse;
-        for (int i = 0; i < num_apps; i++) {
-            p.writeInt32(appStatus[i].app_type);
-            p.writeInt32(appStatus[i].app_state);
-            p.writeInt32(appStatus[i].perso_substate);
-            writeStringToParcel(p, (const char*)(appStatus[i].aid_ptr));
-            writeStringToParcel(p, (const char*)
-                                          (appStatus[i].app_label_ptr));
-            p.writeInt32(appStatus[i].pin1_replaced);
-            p.writeInt32(appStatus[i].pin1);
-            p.writeInt32(appStatus[i].pin2);
-            appendPrintBuf("%s[app_type=%d,app_state=%d,perso_substate=%d,\
-                    aid_ptr=%s,app_label_ptr=%s,pin1_replaced=%d,pin1=%d,pin2=%d],",
-                    printBuf,
-                    appStatus[i].app_type,
-                    appStatus[i].app_state,
-                    appStatus[i].perso_substate,
-                    appStatus[i].aid_ptr,
-                    appStatus[i].app_label_ptr,
-                    appStatus[i].pin1_replaced,
-                    appStatus[i].pin1,
-                    appStatus[i].pin2);
-        }
-        closeResponse;
-}
-
-static void responseSimStatusV5(Parcel &p, void *response) {
-    RIL_CardStatus_v5 *p_cur = ((RIL_CardStatus_v5 *) response);
-
-    p.writeInt32(p_cur->card_state);
-    p.writeInt32(p_cur->universal_pin_state);
-    p.writeInt32(p_cur->gsm_umts_subscription_app_index);
-    p.writeInt32(p_cur->cdma_subscription_app_index);
-
-    sendSimStatusAppInfo(p, p_cur->num_applications, p_cur->applications);
-}
-
-static void responseSimStatusV6(Parcel &p, void *response) {
-    RIL_CardStatus_v6 *p_cur = ((RIL_CardStatus_v6 *) response);
-
-    p.writeInt32(p_cur->card_state);
-    p.writeInt32(p_cur->universal_pin_state);
-    p.writeInt32(p_cur->gsm_umts_subscription_app_index);
-    p.writeInt32(p_cur->cdma_subscription_app_index);
-    p.writeInt32(p_cur->ims_subscription_app_index);
-
-    sendSimStatusAppInfo(p, p_cur->num_applications, p_cur->applications);
-}
-
-static int responseSimStatus(Parcel &p, void *response, size_t responselen) {
-    int i;
-
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (s_callbacks.version <= LAST_IMPRECISE_RIL_VERSION) {
-        if (responselen == sizeof (RIL_CardStatus_v6)) {
-            responseSimStatusV6(p, response);
-        } else if (responselen == sizeof (RIL_CardStatus_v5)) {
-            responseSimStatusV5(p, response);
-        } else {
-            RLOGE("responseSimStatus: A RilCardStatus_v6 or _v5 expected\n");
-            return RIL_ERRNO_INVALID_RESPONSE;
-        }
-    } else { // RIL version >= 13
-        if (responselen % sizeof(RIL_CardStatus_v6) != 0) {
-            RLOGE("Data structure expected is RIL_CardStatus_v6");
-            if (!isDebuggable()) {
-                return RIL_ERRNO_INVALID_RESPONSE;
-            } else {
-                assert(0);
-            }
-        }
-        responseSimStatusV6(p, response);
-    }
-
-    return 0;
-}
-
-static int responseGsmBrSmsCnf(Parcel &p, void *response, size_t responselen) {
-    int num = responselen / sizeof(RIL_GSM_BroadcastSmsConfigInfo *);
-    p.writeInt32(num);
-
-    startResponse;
-    RIL_GSM_BroadcastSmsConfigInfo **p_cur =
-                (RIL_GSM_BroadcastSmsConfigInfo **) response;
-    for (int i = 0; i < num; i++) {
-        p.writeInt32(p_cur[i]->fromServiceId);
-        p.writeInt32(p_cur[i]->toServiceId);
-        p.writeInt32(p_cur[i]->fromCodeScheme);
-        p.writeInt32(p_cur[i]->toCodeScheme);
-        p.writeInt32(p_cur[i]->selected);
-
-        appendPrintBuf("%s [%d: fromServiceId=%d, toServiceId=%d, \
-                fromCodeScheme=%d, toCodeScheme=%d, selected =%d]",
-                printBuf, i, p_cur[i]->fromServiceId, p_cur[i]->toServiceId,
-                p_cur[i]->fromCodeScheme, p_cur[i]->toCodeScheme,
-                p_cur[i]->selected);
-    }
-    closeResponse;
-
-    return 0;
-}
-
-static int responseCdmaBrSmsCnf(Parcel &p, void *response, size_t responselen) {
-    RIL_CDMA_BroadcastSmsConfigInfo **p_cur =
-               (RIL_CDMA_BroadcastSmsConfigInfo **) response;
-
-    int num = responselen / sizeof (RIL_CDMA_BroadcastSmsConfigInfo *);
-    p.writeInt32(num);
-
-    startResponse;
-    for (int i = 0 ; i < num ; i++ ) {
-        p.writeInt32(p_cur[i]->service_category);
-        p.writeInt32(p_cur[i]->language);
-        p.writeInt32(p_cur[i]->selected);
-
-        appendPrintBuf("%s [%d: srvice_category=%d, language =%d, \
-              selected =%d], ",
-              printBuf, i, p_cur[i]->service_category, p_cur[i]->language,
-              p_cur[i]->selected);
-    }
-    closeResponse;
-
-    return 0;
-}
-
-static int responseCdmaSms(Parcel &p, void *response, size_t responselen) {
-    int num;
-    int digitCount;
-    int digitLimit;
-    uint8_t uct;
-    void* dest;
-
-    RLOGD("Inside responseCdmaSms");
-
-    if (response == NULL && responselen != 0) {
-        RLOGE("invalid response: NULL");
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    if (responselen != sizeof(RIL_CDMA_SMS_Message)) {
-        RLOGE("invalid response length was %d expected %d",
-                (int)responselen, (int)sizeof(RIL_CDMA_SMS_Message));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    RIL_CDMA_SMS_Message *p_cur = (RIL_CDMA_SMS_Message *) response;
-    p.writeInt32(p_cur->uTeleserviceID);
-    p.write(&(p_cur->bIsServicePresent),sizeof(uct));
-    p.writeInt32(p_cur->uServicecategory);
-    p.writeInt32(p_cur->sAddress.digit_mode);
-    p.writeInt32(p_cur->sAddress.number_mode);
-    p.writeInt32(p_cur->sAddress.number_type);
-    p.writeInt32(p_cur->sAddress.number_plan);
-    p.write(&(p_cur->sAddress.number_of_digits), sizeof(uct));
-    digitLimit= MIN((p_cur->sAddress.number_of_digits), RIL_CDMA_SMS_ADDRESS_MAX);
-    for(digitCount =0 ; digitCount < digitLimit; digitCount ++) {
-        p.write(&(p_cur->sAddress.digits[digitCount]),sizeof(uct));
-    }
-
-    p.writeInt32(p_cur->sSubAddress.subaddressType);
-    p.write(&(p_cur->sSubAddress.odd),sizeof(uct));
-    p.write(&(p_cur->sSubAddress.number_of_digits),sizeof(uct));
-    digitLimit= MIN((p_cur->sSubAddress.number_of_digits), RIL_CDMA_SMS_SUBADDRESS_MAX);
-    for(digitCount =0 ; digitCount < digitLimit; digitCount ++) {
-        p.write(&(p_cur->sSubAddress.digits[digitCount]),sizeof(uct));
-    }
-
-    digitLimit= MIN((p_cur->uBearerDataLen), RIL_CDMA_SMS_BEARER_DATA_MAX);
-    p.writeInt32(p_cur->uBearerDataLen);
-    for(digitCount =0 ; digitCount < digitLimit; digitCount ++) {
-       p.write(&(p_cur->aBearerData[digitCount]), sizeof(uct));
-    }
-
-    startResponse;
-    appendPrintBuf("%suTeleserviceID=%d, bIsServicePresent=%d, uServicecategory=%d, \
-            sAddress.digit_mode=%d, sAddress.number_mode=%d, sAddress.number_type=%d, ",
-            printBuf, p_cur->uTeleserviceID,p_cur->bIsServicePresent,p_cur->uServicecategory,
-            p_cur->sAddress.digit_mode, p_cur->sAddress.number_mode,p_cur->sAddress.number_type);
-    closeResponse;
-
-    return 0;
-}
-
-static int responseDcRtInfo(Parcel &p, void *response, size_t responselen)
-{
-    int num = responselen / sizeof(RIL_DcRtInfo);
-    if ((responselen % sizeof(RIL_DcRtInfo) != 0) || (num != 1)) {
-        RLOGE("responseDcRtInfo: invalid response length %d expected multiple of %d",
-                (int)responselen, (int)sizeof(RIL_DcRtInfo));
-        return RIL_ERRNO_INVALID_RESPONSE;
-    }
-
-    startResponse;
-    RIL_DcRtInfo *pDcRtInfo = (RIL_DcRtInfo *)response;
-    p.writeInt64(pDcRtInfo->time);
-    p.writeInt32(pDcRtInfo->powerState);
-    appendPrintBuf("%s[time=%d,powerState=%d]", printBuf,
-        pDcRtInfo->time,
-        pDcRtInfo->powerState);
-    closeResponse;
-
-    return 0;
-}
-
-static int responseLceStatus(Parcel &p, void *response, size_t responselen) {
-  if (response == NULL || responselen != sizeof(RIL_LceStatusInfo)) {
-    if (response == NULL) {
-      RLOGE("invalid response: NULL");
-    }
-    else {
-      RLOGE("responseLceStatus: invalid response length %d expecting len: d%",
-            sizeof(RIL_LceStatusInfo), responselen);
-    }
-    return RIL_ERRNO_INVALID_RESPONSE;
-  }
-
-  RIL_LceStatusInfo *p_cur = (RIL_LceStatusInfo *)response;
-  p.write((void *)p_cur, 1);  // p_cur->lce_status takes one byte.
-  p.writeInt32(p_cur->actual_interval_ms);
-
-  startResponse;
-  appendPrintBuf("LCE Status: %d, actual_interval_ms: %d",
-                 p_cur->lce_status, p_cur->actual_interval_ms);
-  closeResponse;
-
-  return 0;
-}
-
-static int responseLceData(Parcel &p, void *response, size_t responselen) {
-  if (response == NULL || responselen != sizeof(RIL_LceDataInfo)) {
-    if (response == NULL) {
-      RLOGE("invalid response: NULL");
-    }
-    else {
-      RLOGE("responseLceData: invalid response length %d expecting len: d%",
-            sizeof(RIL_LceDataInfo), responselen);
-    }
-    return RIL_ERRNO_INVALID_RESPONSE;
-  }
-
-  RIL_LceDataInfo *p_cur = (RIL_LceDataInfo *)response;
-  p.writeInt32(p_cur->last_hop_capacity_kbps);
-
-  /* p_cur->confidence_level and p_cur->lce_suspended take 1 byte each.*/
-  p.write((void *)&(p_cur->confidence_level), 1);
-  p.write((void *)&(p_cur->lce_suspended), 1);
-
-  startResponse;
-  appendPrintBuf("LCE info received: capacity %d confidence level %d \
-                  and suspended %d",
-                  p_cur->last_hop_capacity_kbps, p_cur->confidence_level,
-                  p_cur->lce_suspended);
-  closeResponse;
-
-  return 0;
-}
-
-static int responseActivityData(Parcel &p, void *response, size_t responselen) {
-  if (response == NULL || responselen != sizeof(RIL_ActivityStatsInfo)) {
-    if (response == NULL) {
-      RLOGE("invalid response: NULL");
-    }
-    else {
-      RLOGE("responseActivityData: invalid response length %d expecting len: d%",
-            sizeof(RIL_ActivityStatsInfo), responselen);
-    }
-    return RIL_ERRNO_INVALID_RESPONSE;
-  }
-
-  RIL_ActivityStatsInfo *p_cur = (RIL_ActivityStatsInfo *)response;
-  p.writeInt32(p_cur->sleep_mode_time_ms);
-  p.writeInt32(p_cur->idle_mode_time_ms);
-  for(int i = 0; i < RIL_NUM_TX_POWER_LEVELS; i++) {
-    p.writeInt32(p_cur->tx_mode_time_ms[i]);
-  }
-  p.writeInt32(p_cur->rx_mode_time_ms);
-
-  startResponse;
-  appendPrintBuf("Modem activity info received: sleep_mode_time_ms %d idle_mode_time_ms %d \
-                  tx_mode_time_ms %d %d %d %d %d and rx_mode_time_ms %d",
-                  p_cur->sleep_mode_time_ms, p_cur->idle_mode_time_ms, p_cur->tx_mode_time_ms[0],
-                  p_cur->tx_mode_time_ms[1], p_cur->tx_mode_time_ms[2], p_cur->tx_mode_time_ms[3],
-                  p_cur->tx_mode_time_ms[4], p_cur->rx_mode_time_ms);
-   closeResponse;
-
-  return 0;
-}
-
-/**
- * A write on the wakeup fd is done just to pop us out of select()
- * We empty the buffer here and then ril_event will reset the timers on the
- * way back down
- */
-static void processWakeupCallback(int fd, short flags, void *param) {
-    char buff[16];
-    int ret;
-
-    RLOGV("processWakeupCallback");
-
-    /* empty our wakeup socket out */
-    do {
-        ret = read(s_fdWakeupRead, &buff, sizeof(buff));
-    } while (ret > 0 || (ret < 0 && errno == EINTR));
-}
-
-static void onCommandsSocketClosed(RIL_SOCKET_ID socket_id) {
-    int ret;
-    RequestInfo *p_cur;
-    /* Hook for current context
-       pendingRequestsMutextHook refer to &s_pendingRequestsMutex */
-    pthread_mutex_t * pendingRequestsMutexHook = &s_pendingRequestsMutex;
-    /* pendingRequestsHook refer to &s_pendingRequests */
-    RequestInfo **    pendingRequestsHook = &s_pendingRequests;
-
-#if (SIM_COUNT >= 2)
-    if (socket_id == RIL_SOCKET_2) {
-        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket2;
-        pendingRequestsHook = &s_pendingRequests_socket2;
-    }
-#if (SIM_COUNT >= 3)
-    else if (socket_id == RIL_SOCKET_3) {
-        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket3;
-        pendingRequestsHook = &s_pendingRequests_socket3;
-    }
-#endif
-#if (SIM_COUNT >= 4)
-    else if (socket_id == RIL_SOCKET_4) {
-        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket4;
-        pendingRequestsHook = &s_pendingRequests_socket4;
-    }
-#endif
-#endif
-    /* mark pending requests as "cancelled" so we dont report responses */
-    ret = pthread_mutex_lock(pendingRequestsMutexHook);
-    assert (ret == 0);
-
-    p_cur = *pendingRequestsHook;
-
-    for (p_cur = *pendingRequestsHook
-            ; p_cur != NULL
-            ; p_cur  = p_cur->p_next
-    ) {
-        p_cur->cancelled = 1;
-    }
-
-    ret = pthread_mutex_unlock(pendingRequestsMutexHook);
-    assert (ret == 0);
-}
-
-static void processCommandsCallback(int fd, short flags, void *param) {
-    RecordStream *p_rs;
-    void *p_record;
-    size_t recordlen;
-    int ret;
-    SocketListenParam *p_info = (SocketListenParam *)param;
-
-    assert(fd == p_info->fdCommand);
-
-    p_rs = p_info->p_rs;
-
-    for (;;) {
-        /* loop until EAGAIN/EINTR, end of stream, or other error */
-        ret = record_stream_get_next(p_rs, &p_record, &recordlen);
-
-        if (ret == 0 && p_record == NULL) {
-            /* end-of-stream */
-            break;
-        } else if (ret < 0) {
-            break;
-        } else if (ret == 0) { /* && p_record != NULL */
-            processCommandBuffer(p_record, recordlen, p_info->socket_id);
-        }
-    }
-
-    if (ret == 0 || !(errno == EAGAIN || errno == EINTR)) {
-        /* fatal error or end-of-stream */
-        if (ret != 0) {
-            RLOGE("error on reading command socket errno:%d\n", errno);
-        } else {
-            RLOGW("EOS.  Closing command socket.");
-        }
-
-        close(fd);
-        p_info->fdCommand = -1;
-
-        ril_event_del(p_info->commands_event);
-
-        record_stream_free(p_rs);
-
-        /* start listening for new connections again */
-        rilEventAddWakeup(&s_listen_event);
-
-        onCommandsSocketClosed(p_info->socket_id);
-    }
-}
-
-
-static void onNewCommandConnect(RIL_SOCKET_ID socket_id) {
-    // Inform we are connected and the ril version
-    int rilVer = s_callbacks.version;
-    RIL_UNSOL_RESPONSE(RIL_UNSOL_RIL_CONNECTED,
-                                    &rilVer, sizeof(rilVer), socket_id);
-
-    // implicit radio state changed
-    RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED,
-                                    NULL, 0, socket_id);
-
-    // Send last NITZ time data, in case it was missed
-    if (s_lastNITZTimeData != NULL) {
-        sendResponseRaw(s_lastNITZTimeData, s_lastNITZTimeDataSize, socket_id);
-
-        free(s_lastNITZTimeData);
-        s_lastNITZTimeData = NULL;
-    }
-
-    // Get version string
-    if (s_callbacks.getVersion != NULL) {
-        const char *version;
-        version = s_callbacks.getVersion();
-        RLOGI("RIL Daemon version: %s\n", version);
-
-        property_set(PROPERTY_RIL_IMPL, version);
-    } else {
-        RLOGI("RIL Daemon version: unavailable\n");
-        property_set(PROPERTY_RIL_IMPL, "unavailable");
-    }
-
-}
-
-static void listenCallback (int fd, short flags, void *param) {
-    int ret;
-    int err;
-    int is_phone_socket;
-    int fdCommand = -1;
-    char* processName;
-    RecordStream *p_rs;
-    MySocketListenParam* listenParam;
-    RilSocket *sapSocket = NULL;
-    socketClient *sClient = NULL;
-
-    SocketListenParam *p_info = (SocketListenParam *)param;
-
-    if(RIL_SAP_SOCKET == p_info->type) {
-        listenParam = (MySocketListenParam *)param;
-        sapSocket = listenParam->socket;
-    }
-
-    struct sockaddr_un peeraddr;
-    socklen_t socklen = sizeof (peeraddr);
-
-    struct ucred creds;
-    socklen_t szCreds = sizeof(creds);
-
-    struct passwd *pwd = NULL;
-
-    if(NULL == sapSocket) {
-        assert (*p_info->fdCommand < 0);
-        assert (fd == *p_info->fdListen);
-        processName = PHONE_PROCESS;
-    } else {
-        assert (sapSocket->commandFd < 0);
-        assert (fd == sapSocket->listenFd);
-        processName = BLUETOOTH_PROCESS;
-    }
-
-
-    fdCommand = accept(fd, (sockaddr *) &peeraddr, &socklen);
-
-    if (fdCommand < 0 ) {
-        RLOGE("Error on accept() errno:%d", errno);
-        /* start listening for new connections again */
-        if(NULL == sapSocket) {
-            rilEventAddWakeup(p_info->listen_event);
-        } else {
-            rilEventAddWakeup(sapSocket->getListenEvent());
-        }
-        return;
-    }
-
-    /* check the credential of the other side and only accept socket from
-     * phone process
-     */
-    errno = 0;
-    is_phone_socket = 0;
-
-    err = getsockopt(fdCommand, SOL_SOCKET, SO_PEERCRED, &creds, &szCreds);
-
-    if (err == 0 && szCreds > 0) {
-        errno = 0;
-        pwd = getpwuid(creds.uid);
-        if (pwd != NULL) {
-            if (strcmp(pwd->pw_name, processName) == 0) {
-                is_phone_socket = 1;
-            } else {
-                RLOGE("RILD can't accept socket from process %s", pwd->pw_name);
-            }
-        } else {
-            RLOGE("Error on getpwuid() errno: %d", errno);
-        }
-    } else {
-        RLOGD("Error on getsockopt() errno: %d", errno);
-    }
-
-    if (!is_phone_socket) {
-        RLOGE("RILD must accept socket from %s", processName);
-
-        close(fdCommand);
-        fdCommand = -1;
-
-        if(NULL == sapSocket) {
-            onCommandsSocketClosed(p_info->socket_id);
-
-            /* start listening for new connections again */
-            rilEventAddWakeup(p_info->listen_event);
-        } else {
-            sapSocket->onCommandsSocketClosed();
-
-            /* start listening for new connections again */
-            rilEventAddWakeup(sapSocket->getListenEvent());
-        }
-
-        return;
-    }
-
-    ret = fcntl(fdCommand, F_SETFL, O_NONBLOCK);
-
-    if (ret < 0) {
-        RLOGE ("Error setting O_NONBLOCK errno:%d", errno);
-    }
-
-    if(NULL == sapSocket) {
-        RLOGI("libril: new connection to %s", rilSocketIdToString(p_info->socket_id));
-
-        p_info->fdCommand = fdCommand;
-        p_rs = record_stream_new(p_info->fdCommand, MAX_COMMAND_BYTES);
-        p_info->p_rs = p_rs;
-
-        ril_event_set (p_info->commands_event, p_info->fdCommand, 1,
-        p_info->processCommandsCallback, p_info);
-        rilEventAddWakeup (p_info->commands_event);
-
-        onNewCommandConnect(p_info->socket_id);
-    } else {
-        RLOGI("libril: new connection");
-
-        sapSocket->setCommandFd(fdCommand);
-        p_rs = record_stream_new(sapSocket->getCommandFd(), MAX_COMMAND_BYTES);
-        sClient = new socketClient(sapSocket,p_rs);
-        ril_event_set (sapSocket->getCallbackEvent(), sapSocket->getCommandFd(), 1,
-        sapSocket->getCommandCb(), sClient);
-
-        rilEventAddWakeup(sapSocket->getCallbackEvent());
-        sapSocket->onNewCommandConnect();
-    }
-}
-
-static void freeDebugCallbackArgs(int number, char **args) {
-    for (int i = 0; i < number; i++) {
-        if (args[i] != NULL) {
-            free(args[i]);
-        }
-    }
-    free(args);
-}
-
-static void debugCallback (int fd, short flags, void *param) {
-    int acceptFD, option;
-    struct sockaddr_un peeraddr;
-    socklen_t socklen = sizeof (peeraddr);
-    int data;
-    unsigned int qxdm_data[6];
-    const char *deactData[1] = {"1"};
-    char *actData[1];
-    RIL_Dial dialData;
-    int hangupData[1] = {1};
-    int number;
-    char **args;
-    RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
-    int sim_id = 0;
-
-    RLOGI("debugCallback for socket %s", rilSocketIdToString(socket_id));
-
-    acceptFD = accept (fd,  (sockaddr *) &peeraddr, &socklen);
-
-    if (acceptFD < 0) {
-        RLOGE ("error accepting on debug port: %d\n", errno);
-        return;
-    }
-
-    if (recv(acceptFD, &number, sizeof(int), 0) != sizeof(int)) {
-        RLOGE ("error reading on socket: number of Args: \n");
-        close(acceptFD);
-        return;
-    }
-
-    if (number < 0) {
-        RLOGE ("Invalid number of arguments: \n");
-        close(acceptFD);
-        return;
-    }
-
-    args = (char **) calloc(number, sizeof(char*));
-    if (args == NULL) {
-        RLOGE("Memory allocation failed for debug args");
-        close(acceptFD);
-        return;
-    }
-
-    for (int i = 0; i < number; i++) {
-        int len;
-        if (recv(acceptFD, &len, sizeof(int), 0) != sizeof(int)) {
-            RLOGE ("error reading on socket: Len of Args: \n");
-            freeDebugCallbackArgs(i, args);
-            close(acceptFD);
-            return;
-        }
-        if (len == INT_MAX || len < 0) {
-            RLOGE("Invalid value of len: \n");
-            freeDebugCallbackArgs(i, args);
-            close(acceptFD);
-            return;
-        }
-
-        // +1 for null-term
-        args[i] = (char *) calloc(len + 1, sizeof(char));
-        if (args[i] == NULL) {
-            RLOGE("Memory allocation failed for debug args");
-            freeDebugCallbackArgs(i, args);
-            close(acceptFD);
-            return;
-        }
-        if (recv(acceptFD, args[i], sizeof(char) * len, 0)
-            != (int)sizeof(char) * len) {
-            RLOGE ("error reading on socket: Args[%d] \n", i);
-            freeDebugCallbackArgs(i, args);
-            close(acceptFD);
-            return;
-        }
-        char * buf = args[i];
-        buf[len] = 0;
-        if ((i+1) == number) {
-            /* The last argument should be sim id 0(SIM1)~3(SIM4) */
-            sim_id = atoi(args[i]);
-            switch (sim_id) {
-                case 0:
-                    socket_id = RIL_SOCKET_1;
-                    break;
-            #if (SIM_COUNT >= 2)
-                case 1:
-                    socket_id = RIL_SOCKET_2;
-                    break;
-            #endif
-            #if (SIM_COUNT >= 3)
-                case 2:
-                    socket_id = RIL_SOCKET_3;
-                    break;
-            #endif
-            #if (SIM_COUNT >= 4)
-                case 3:
-                    socket_id = RIL_SOCKET_4;
-                    break;
-            #endif
-                default:
-                    socket_id = RIL_SOCKET_1;
-                    break;
-            }
-        }
-    }
-
-    switch (atoi(args[0])) {
-        case 0:
-            RLOGI ("Connection on debug port: issuing reset.");
-            issueLocalRequest(RIL_REQUEST_RESET_RADIO, NULL, 0, socket_id);
-            break;
-        case 1:
-            RLOGI ("Connection on debug port: issuing radio power off.");
-            data = 0;
-            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);
-            // Close the socket
-            if (socket_id == RIL_SOCKET_1 && s_ril_param_socket.fdCommand > 0) {
-                close(s_ril_param_socket.fdCommand);
-                s_ril_param_socket.fdCommand = -1;
-            }
-        #if (SIM_COUNT == 2)
-            else if (socket_id == RIL_SOCKET_2 && s_ril_param_socket2.fdCommand > 0) {
-                close(s_ril_param_socket2.fdCommand);
-                s_ril_param_socket2.fdCommand = -1;
-            }
-        #endif
-            break;
-        case 2:
-            RLOGI ("Debug port: issuing unsolicited voice network change.");
-            RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, NULL, 0, socket_id);
-            break;
-        case 3:
-            RLOGI ("Debug port: QXDM log enable.");
-            qxdm_data[0] = 65536;     // head.func_tag
-            qxdm_data[1] = 16;        // head.len
-            qxdm_data[2] = 1;         // mode: 1 for 'start logging'
-            qxdm_data[3] = 32;        // log_file_size: 32megabytes
-            qxdm_data[4] = 0;         // log_mask
-            qxdm_data[5] = 8;         // log_max_fileindex
-            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
-                              6 * sizeof(int), socket_id);
-            break;
-        case 4:
-            RLOGI ("Debug port: QXDM log disable.");
-            qxdm_data[0] = 65536;
-            qxdm_data[1] = 16;
-            qxdm_data[2] = 0;          // mode: 0 for 'stop logging'
-            qxdm_data[3] = 32;
-            qxdm_data[4] = 0;
-            qxdm_data[5] = 8;
-            issueLocalRequest(RIL_REQUEST_OEM_HOOK_RAW, qxdm_data,
-                              6 * sizeof(int), socket_id);
-            break;
-        case 5:
-            RLOGI("Debug port: Radio On");
-            data = 1;
-            issueLocalRequest(RIL_REQUEST_RADIO_POWER, &data, sizeof(int), socket_id);
-            sleep(2);
-            // Set network selection automatic.
-            issueLocalRequest(RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, NULL, 0, socket_id);
-            break;
-        case 6:
-            RLOGI("Debug port: Setup Data Call, Apn :%s\n", args[1]);
-            actData[0] = args[1];
-            issueLocalRequest(RIL_REQUEST_SETUP_DATA_CALL, &actData,
-                              sizeof(actData), socket_id);
-            break;
-        case 7:
-            RLOGI("Debug port: Deactivate Data Call");
-            issueLocalRequest(RIL_REQUEST_DEACTIVATE_DATA_CALL, &deactData,
-                              sizeof(deactData), socket_id);
-            break;
-        case 8:
-            RLOGI("Debug port: Dial Call");
-            dialData.clir = 0;
-            dialData.address = args[1];
-            issueLocalRequest(RIL_REQUEST_DIAL, &dialData, sizeof(dialData), socket_id);
-            break;
-        case 9:
-            RLOGI("Debug port: Answer Call");
-            issueLocalRequest(RIL_REQUEST_ANSWER, NULL, 0, socket_id);
-            break;
-        case 10:
-            RLOGI("Debug port: End Call");
-            issueLocalRequest(RIL_REQUEST_HANGUP, &hangupData,
-                              sizeof(hangupData), socket_id);
-            break;
-        default:
-            RLOGE ("Invalid request");
-            break;
-    }
-    freeDebugCallbackArgs(number, args);
-    close(acceptFD);
-}
-
-
-static void userTimerCallback (int fd, short flags, void *param) {
-    UserCallbackInfo *p_info;
-
-    p_info = (UserCallbackInfo *)param;
-
-    p_info->p_callback(p_info->userParam);
-
-
-    // FIXME generalize this...there should be a cancel mechanism
-    if (s_last_wake_timeout_info != NULL && s_last_wake_timeout_info == p_info) {
-        s_last_wake_timeout_info = NULL;
-    }
-
-    free(p_info);
-}
-
-
-static void *
-eventLoop(void *param) {
-    int ret;
-    int filedes[2];
-
-    ril_event_init();
-
-    pthread_mutex_lock(&s_startupMutex);
-
-    s_started = 1;
-    pthread_cond_broadcast(&s_startupCond);
-
-    pthread_mutex_unlock(&s_startupMutex);
-
-    ret = pipe(filedes);
-
-    if (ret < 0) {
-        RLOGE("Error in pipe() errno:%d", errno);
-        return NULL;
-    }
-
-    s_fdWakeupRead = filedes[0];
-    s_fdWakeupWrite = filedes[1];
-
-    fcntl(s_fdWakeupRead, F_SETFL, O_NONBLOCK);
-
-    ril_event_set (&s_wakeupfd_event, s_fdWakeupRead, true,
-                processWakeupCallback, NULL);
-
-    rilEventAddWakeup (&s_wakeupfd_event);
-
-    // Only returns on error
-    ril_event_loop();
-    RLOGE ("error in event_loop_base errno:%d", errno);
-    // kill self to restart on error
-    kill(0, SIGKILL);
-
-    return NULL;
-}
-
-extern "C" void
-RIL_startEventLoop(void) {
-    /* spin up eventLoop thread and wait for it to get started */
-    s_started = 0;
-    pthread_mutex_lock(&s_startupMutex);
-
-    pthread_attr_t attr;
-    pthread_attr_init(&attr);
-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-
-    int result = pthread_create(&s_tid_dispatch, &attr, eventLoop, NULL);
-    if (result != 0) {
-        RLOGE("Failed to create dispatch thread: %s", strerror(result));
-        goto done;
-    }
-
-    while (s_started == 0) {
-        pthread_cond_wait(&s_startupCond, &s_startupMutex);
-    }
-
-done:
-    pthread_mutex_unlock(&s_startupMutex);
-}
-
-// Used for testing purpose only.
-extern "C" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks) {
-    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
-}
-
-static void startListen(RIL_SOCKET_ID socket_id, SocketListenParam* socket_listen_p) {
-    int fdListen = -1;
-    int ret;
-    char socket_name[10];
-
-    memset(socket_name, 0, sizeof(char)*10);
-
-    switch(socket_id) {
-        case RIL_SOCKET_1:
-            strncpy(socket_name, RIL_getRilSocketName(), 9);
-            break;
-    #if (SIM_COUNT >= 2)
-        case RIL_SOCKET_2:
-            strncpy(socket_name, SOCKET2_NAME_RIL, 9);
-            break;
-    #endif
-    #if (SIM_COUNT >= 3)
-        case RIL_SOCKET_3:
-            strncpy(socket_name, SOCKET3_NAME_RIL, 9);
-            break;
-    #endif
-    #if (SIM_COUNT >= 4)
-        case RIL_SOCKET_4:
-            strncpy(socket_name, SOCKET4_NAME_RIL, 9);
-            break;
-    #endif
-        default:
-            RLOGE("Socket id is wrong!!");
-            return;
-    }
-
-    RLOGI("Start to listen %s", rilSocketIdToString(socket_id));
-
-    fdListen = android_get_control_socket(socket_name);
-    if (fdListen < 0) {
-        RLOGE("Failed to get socket %s", socket_name);
-        exit(-1);
-    }
-
-    ret = listen(fdListen, 4);
-
-    if (ret < 0) {
-        RLOGE("Failed to listen on control socket '%d': %s",
-             fdListen, strerror(errno));
-        exit(-1);
-    }
-    socket_listen_p->fdListen = fdListen;
-
-    /* note: non-persistent so we can accept only one connection at a time */
-    ril_event_set (socket_listen_p->listen_event, fdListen, false,
-                listenCallback, socket_listen_p);
-
-    rilEventAddWakeup (socket_listen_p->listen_event);
-}
-
-extern "C" void
-RIL_register (const RIL_RadioFunctions *callbacks) {
-    int ret;
-    int flags;
-
-    RLOGI("SIM_COUNT: %d", SIM_COUNT);
-
-    if (callbacks == NULL) {
-        RLOGE("RIL_register: RIL_RadioFunctions * null");
-        return;
-    }
-    if (callbacks->version < RIL_VERSION_MIN) {
-        RLOGE("RIL_register: version %d is to old, min version is %d",
-             callbacks->version, RIL_VERSION_MIN);
-        return;
-    }
-
-    RLOGE("RIL_register: RIL version %d", callbacks->version);
-
-    if (s_registerCalled > 0) {
-        RLOGE("RIL_register has been called more than once. "
-                "Subsequent call ignored");
-        return;
-    }
-
-    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
-
-    /* Initialize socket1 parameters */
-    s_ril_param_socket = {
-                        RIL_SOCKET_1,             /* socket_id */
-                        -1,                       /* fdListen */
-                        -1,                       /* fdCommand */
-                        PHONE_PROCESS,            /* processName */
-                        &s_commands_event,        /* commands_event */
-                        &s_listen_event,          /* listen_event */
-                        processCommandsCallback,  /* processCommandsCallback */
-                        NULL                      /* p_rs */
-                        };
-
-#if (SIM_COUNT >= 2)
-    s_ril_param_socket2 = {
-                        RIL_SOCKET_2,               /* socket_id */
-                        -1,                         /* fdListen */
-                        -1,                         /* fdCommand */
-                        PHONE_PROCESS,              /* processName */
-                        &s_commands_event_socket2,  /* commands_event */
-                        &s_listen_event_socket2,    /* listen_event */
-                        processCommandsCallback,    /* processCommandsCallback */
-                        NULL                        /* p_rs */
-                        };
-#endif
-
-#if (SIM_COUNT >= 3)
-    s_ril_param_socket3 = {
-                        RIL_SOCKET_3,               /* socket_id */
-                        -1,                         /* fdListen */
-                        -1,                         /* fdCommand */
-                        PHONE_PROCESS,              /* processName */
-                        &s_commands_event_socket3,  /* commands_event */
-                        &s_listen_event_socket3,    /* listen_event */
-                        processCommandsCallback,    /* processCommandsCallback */
-                        NULL                        /* p_rs */
-                        };
-#endif
-
-#if (SIM_COUNT >= 4)
-    s_ril_param_socket4 = {
-                        RIL_SOCKET_4,               /* socket_id */
-                        -1,                         /* fdListen */
-                        -1,                         /* fdCommand */
-                        PHONE_PROCESS,              /* processName */
-                        &s_commands_event_socket4,  /* commands_event */
-                        &s_listen_event_socket4,    /* listen_event */
-                        processCommandsCallback,    /* processCommandsCallback */
-                        NULL                        /* p_rs */
-                        };
-#endif
-
-
-    s_registerCalled = 1;
-
-    RLOGI("s_registerCalled flag set, %d", s_started);
-    // Little self-check
-
-    for (int i = 0; i < (int)NUM_ELEMS(s_commands); i++) {
-        assert(i == s_commands[i].requestNumber);
-    }
-
-    for (int i = 0; i < (int)NUM_ELEMS(s_unsolResponses); i++) {
-        assert(i + RIL_UNSOL_RESPONSE_BASE
-                == s_unsolResponses[i].requestNumber);
-    }
-
-    // New rild impl calls RIL_startEventLoop() first
-    // old standalone impl wants it here.
-
-    if (s_started == 0) {
-        RIL_startEventLoop();
-    }
-
-    // start listen socket1
-    startListen(RIL_SOCKET_1, &s_ril_param_socket);
-
-#if (SIM_COUNT >= 2)
-    // start listen socket2
-    startListen(RIL_SOCKET_2, &s_ril_param_socket2);
-#endif /* (SIM_COUNT == 2) */
-
-#if (SIM_COUNT >= 3)
-    // start listen socket3
-    startListen(RIL_SOCKET_3, &s_ril_param_socket3);
-#endif /* (SIM_COUNT == 3) */
-
-#if (SIM_COUNT >= 4)
-    // start listen socket4
-    startListen(RIL_SOCKET_4, &s_ril_param_socket4);
-#endif /* (SIM_COUNT == 4) */
-
-
-#if 1
-    // start debug interface socket
-
-    char *inst = NULL;
-    if (strlen(RIL_getRilSocketName()) >= strlen(SOCKET_NAME_RIL)) {
-        inst = RIL_getRilSocketName() + strlen(SOCKET_NAME_RIL);
-    }
-
-    char rildebug[MAX_DEBUG_SOCKET_NAME_LENGTH] = SOCKET_NAME_RIL_DEBUG;
-    if (inst != NULL) {
-        strlcat(rildebug, inst, MAX_DEBUG_SOCKET_NAME_LENGTH);
-    }
-
-    s_fdDebug = android_get_control_socket(rildebug);
-    if (s_fdDebug < 0) {
-        RLOGE("Failed to get socket : %s errno:%d", rildebug, errno);
-        exit(-1);
-    }
-
-    ret = listen(s_fdDebug, 4);
-
-    if (ret < 0) {
-        RLOGE("Failed to listen on ril debug socket '%d': %s",
-             s_fdDebug, strerror(errno));
-        exit(-1);
-    }
-
-    ril_event_set (&s_debug_event, s_fdDebug, true,
-                debugCallback, NULL);
-
-    rilEventAddWakeup (&s_debug_event);
-#endif
-
-}
-
-extern "C" void
-RIL_register_socket (RIL_RadioFunctions *(*Init)(const struct RIL_Env *, int, char **),RIL_SOCKET_TYPE socketType, int argc, char **argv) {
-
-    RIL_RadioFunctions* UimFuncs = NULL;
-
-    if(Init) {
-        UimFuncs = Init(&RilSapSocket::uimRilEnv, argc, argv);
-
-        switch(socketType) {
-            case RIL_SAP_SOCKET:
-                RilSapSocket::initSapSocket("sap_uim_socket1", UimFuncs);
-
-#if (SIM_COUNT >= 2)
-                RilSapSocket::initSapSocket("sap_uim_socket2", UimFuncs);
-#endif
-
-#if (SIM_COUNT >= 3)
-                RilSapSocket::initSapSocket("sap_uim_socket3", UimFuncs);
-#endif
-
-#if (SIM_COUNT >= 4)
-                RilSapSocket::initSapSocket("sap_uim_socket4", UimFuncs);
-#endif
-        }
-    }
-}
-
-// Check and remove RequestInfo if its a response and not just ack sent back
-static int
-checkAndDequeueRequestInfoIfAck(struct RequestInfo *pRI, bool isAck) {
-    int ret = 0;
-    /* Hook for current context
-       pendingRequestsMutextHook refer to &s_pendingRequestsMutex */
-    pthread_mutex_t* pendingRequestsMutexHook = &s_pendingRequestsMutex;
-    /* pendingRequestsHook refer to &s_pendingRequests */
-    RequestInfo ** pendingRequestsHook = &s_pendingRequests;
-
-    if (pRI == NULL) {
-        return 0;
-    }
-
-#if (SIM_COUNT >= 2)
-    if (pRI->socket_id == RIL_SOCKET_2) {
-        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket2;
-        pendingRequestsHook = &s_pendingRequests_socket2;
-    }
-#if (SIM_COUNT >= 3)
-        if (pRI->socket_id == RIL_SOCKET_3) {
-            pendingRequestsMutexHook = &s_pendingRequestsMutex_socket3;
-            pendingRequestsHook = &s_pendingRequests_socket3;
-        }
-#endif
-#if (SIM_COUNT >= 4)
-    if (pRI->socket_id == RIL_SOCKET_4) {
-        pendingRequestsMutexHook = &s_pendingRequestsMutex_socket4;
-        pendingRequestsHook = &s_pendingRequests_socket4;
-    }
-#endif
-#endif
-    pthread_mutex_lock(pendingRequestsMutexHook);
-
-    for(RequestInfo **ppCur = pendingRequestsHook
-        ; *ppCur != NULL
-        ; ppCur = &((*ppCur)->p_next)
-    ) {
-        if (pRI == *ppCur) {
-            ret = 1;
-            if (isAck) { // Async ack
-                if (pRI->wasAckSent == 1) {
-                    RLOGD("Ack was already sent for %s", requestToString(pRI->pCI->requestNumber));
-                } else {
-                    pRI->wasAckSent = 1;
-                }
-            } else {
-                *ppCur = (*ppCur)->p_next;
-            }
-            break;
-        }
-    }
-
-    pthread_mutex_unlock(pendingRequestsMutexHook);
-
-    return ret;
-}
-
-static int findFd(int socket_id) {
-    int fd = s_ril_param_socket.fdCommand;
-#if (SIM_COUNT >= 2)
-    if (socket_id == RIL_SOCKET_2) {
-        fd = s_ril_param_socket2.fdCommand;
-    }
-#if (SIM_COUNT >= 3)
-    if (socket_id == RIL_SOCKET_3) {
-        fd = s_ril_param_socket3.fdCommand;
-    }
-#endif
-#if (SIM_COUNT >= 4)
-    if (socket_id == RIL_SOCKET_4) {
-        fd = s_ril_param_socket4.fdCommand;
-    }
-#endif
-#endif
-    return fd;
-}
-
-extern "C" void
-RIL_onRequestAck(RIL_Token t) {
-    RequestInfo *pRI;
-    int ret, fd;
-
-    size_t errorOffset;
-    RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
-
-    pRI = (RequestInfo *)t;
-
-    if (!checkAndDequeueRequestInfoIfAck(pRI, true)) {
-        RLOGE ("RIL_onRequestAck: invalid RIL_Token");
-        return;
-    }
-
-    socket_id = pRI->socket_id;
-    fd = findFd(socket_id);
-
-#if VDBG
-    RLOGD("Request Ack, %s", rilSocketIdToString(socket_id));
-#endif
-
-    appendPrintBuf("Ack [%04d]< %s", pRI->token, requestToString(pRI->pCI->requestNumber));
-
-    if (pRI->cancelled == 0) {
-        Parcel p;
-
-        p.writeInt32 (RESPONSE_SOLICITED_ACK);
-        p.writeInt32 (pRI->token);
-
-        if (fd < 0) {
-            RLOGD ("RIL onRequestComplete: Command channel closed");
-        }
-
-        sendResponse(p, socket_id);
-    }
-}
-
-extern "C" void
-RIL_onRequestComplete(RIL_Token t, RIL_Errno e, void *response, size_t responselen) {
-    RequestInfo *pRI;
-    int ret;
-    int fd;
-    size_t errorOffset;
-    RIL_SOCKET_ID socket_id = RIL_SOCKET_1;
-
-    pRI = (RequestInfo *)t;
-
-    if (!checkAndDequeueRequestInfoIfAck(pRI, false)) {
-        RLOGE ("RIL_onRequestComplete: invalid RIL_Token");
-        return;
-    }
-
-    socket_id = pRI->socket_id;
-    fd = findFd(socket_id);
-
-#if VDBG
-    RLOGD("RequestComplete, %s", rilSocketIdToString(socket_id));
-#endif
-
-    if (pRI->local > 0) {
-        // Locally issued command...void only!
-        // response does not go back up the command socket
-        RLOGD("C[locl]< %s", requestToString(pRI->pCI->requestNumber));
-
-        goto done;
-    }
-
-    appendPrintBuf("[%04d]< %s",
-        pRI->token, requestToString(pRI->pCI->requestNumber));
-
-    if (pRI->cancelled == 0) {
-        Parcel p;
-
-        if (s_callbacks.version >= 13 && pRI->wasAckSent == 1) {
-            // If ack was already sent, then this call is an asynchronous response. So we need to
-            // send id indicating that we expect an ack from RIL.java as we acquire wakelock here.
-            p.writeInt32 (RESPONSE_SOLICITED_ACK_EXP);
-            grabPartialWakeLock();
-        } else {
-            p.writeInt32 (RESPONSE_SOLICITED);
-        }
-        p.writeInt32 (pRI->token);
-        errorOffset = p.dataPosition();
-
-        p.writeInt32 (e);
-
-        if (response != NULL) {
-            // there is a response payload, no matter success or not.
-            ret = pRI->pCI->responseFunction(p, response, responselen);
-
-            /* if an error occurred, rewind and mark it */
-            if (ret != 0) {
-                RLOGE ("responseFunction error, ret %d", ret);
-                p.setDataPosition(errorOffset);
-                p.writeInt32 (ret);
-            }
-        }
-
-        if (e != RIL_E_SUCCESS) {
-            appendPrintBuf("%s fails by %s", printBuf, failCauseToString(e));
-        }
-
-        if (fd < 0) {
-            RLOGD ("RIL onRequestComplete: Command channel closed");
-        }
-        sendResponse(p, socket_id);
-    }
-
-done:
-    free(pRI);
-}
-
-static void
-grabPartialWakeLock() {
-    if (s_callbacks.version >= 13) {
-        int ret;
-        ret = pthread_mutex_lock(&s_wakeLockCountMutex);
-        assert(ret == 0);
-        acquire_wake_lock(PARTIAL_WAKE_LOCK, ANDROID_WAKE_LOCK_NAME);
-
-        UserCallbackInfo *p_info =
-                internalRequestTimedCallback(wakeTimeoutCallback, NULL, &TIMEVAL_WAKE_TIMEOUT);
-        if (p_info == NULL) {
-            release_wake_lock(ANDROID_WAKE_LOCK_NAME);
-        } else {
-            s_wakelock_count++;
-            if (s_last_wake_timeout_info != NULL) {
-                s_last_wake_timeout_info->userParam = (void *)1;
-            }
-            s_last_wake_timeout_info = p_info;
-        }
-        ret = pthread_mutex_unlock(&s_wakeLockCountMutex);
-        assert(ret == 0);
-    } else {
-        acquire_wake_lock(PARTIAL_WAKE_LOCK, ANDROID_WAKE_LOCK_NAME);
-    }
-}
-
-static void
-releaseWakeLock() {
-    if (s_callbacks.version >= 13) {
-        int ret;
-        ret = pthread_mutex_lock(&s_wakeLockCountMutex);
-        assert(ret == 0);
-
-        if (s_wakelock_count > 1) {
-            s_wakelock_count--;
-        } else {
-            s_wakelock_count = 0;
-            release_wake_lock(ANDROID_WAKE_LOCK_NAME);
-            if (s_last_wake_timeout_info != NULL) {
-                s_last_wake_timeout_info->userParam = (void *)1;
-            }
-        }
-
-        ret = pthread_mutex_unlock(&s_wakeLockCountMutex);
-        assert(ret == 0);
-    } else {
-        release_wake_lock(ANDROID_WAKE_LOCK_NAME);
-    }
-}
-
-/**
- * Timer callback to put us back to sleep before the default timeout
- */
-static void
-wakeTimeoutCallback (void *param) {
-    // We're using "param != NULL" as a cancellation mechanism
-    if (s_callbacks.version >= 13) {
-        if (param == NULL) {
-            int ret;
-            ret = pthread_mutex_lock(&s_wakeLockCountMutex);
-            assert(ret == 0);
-            s_wakelock_count = 0;
-            release_wake_lock(ANDROID_WAKE_LOCK_NAME);
-            ret = pthread_mutex_unlock(&s_wakeLockCountMutex);
-            assert(ret == 0);
-        }
-    } else {
-        if (param == NULL) {
-            releaseWakeLock();
-        }
-    }
-}
-
-static int
-decodeVoiceRadioTechnology (RIL_RadioState radioState) {
-    switch (radioState) {
-        case RADIO_STATE_SIM_NOT_READY:
-        case RADIO_STATE_SIM_LOCKED_OR_ABSENT:
-        case RADIO_STATE_SIM_READY:
-            return RADIO_TECH_UMTS;
-
-        case RADIO_STATE_RUIM_NOT_READY:
-        case RADIO_STATE_RUIM_READY:
-        case RADIO_STATE_RUIM_LOCKED_OR_ABSENT:
-        case RADIO_STATE_NV_NOT_READY:
-        case RADIO_STATE_NV_READY:
-            return RADIO_TECH_1xRTT;
-
-        default:
-            RLOGD("decodeVoiceRadioTechnology: Invoked with incorrect RadioState");
-            return -1;
-    }
-}
-
-static int
-decodeCdmaSubscriptionSource (RIL_RadioState radioState) {
-    switch (radioState) {
-        case RADIO_STATE_SIM_NOT_READY:
-        case RADIO_STATE_SIM_LOCKED_OR_ABSENT:
-        case RADIO_STATE_SIM_READY:
-        case RADIO_STATE_RUIM_NOT_READY:
-        case RADIO_STATE_RUIM_READY:
-        case RADIO_STATE_RUIM_LOCKED_OR_ABSENT:
-            return CDMA_SUBSCRIPTION_SOURCE_RUIM_SIM;
-
-        case RADIO_STATE_NV_NOT_READY:
-        case RADIO_STATE_NV_READY:
-            return CDMA_SUBSCRIPTION_SOURCE_NV;
-
-        default:
-            RLOGD("decodeCdmaSubscriptionSource: Invoked with incorrect RadioState");
-            return -1;
-    }
-}
-
-static int
-decodeSimStatus (RIL_RadioState radioState) {
-   switch (radioState) {
-       case RADIO_STATE_SIM_NOT_READY:
-       case RADIO_STATE_RUIM_NOT_READY:
-       case RADIO_STATE_NV_NOT_READY:
-       case RADIO_STATE_NV_READY:
-           return -1;
-       case RADIO_STATE_SIM_LOCKED_OR_ABSENT:
-       case RADIO_STATE_SIM_READY:
-       case RADIO_STATE_RUIM_READY:
-       case RADIO_STATE_RUIM_LOCKED_OR_ABSENT:
-           return radioState;
-       default:
-           RLOGD("decodeSimStatus: Invoked with incorrect RadioState");
-           return -1;
-   }
-}
-
-static bool is3gpp2(int radioTech) {
-    switch (radioTech) {
-        case RADIO_TECH_IS95A:
-        case RADIO_TECH_IS95B:
-        case RADIO_TECH_1xRTT:
-        case RADIO_TECH_EVDO_0:
-        case RADIO_TECH_EVDO_A:
-        case RADIO_TECH_EVDO_B:
-        case RADIO_TECH_EHRPD:
-            return true;
-        default:
-            return false;
-    }
-}
-
-/* If RIL sends SIM states or RUIM states, store the voice radio
- * technology and subscription source information so that they can be
- * returned when telephony framework requests them
- */
-static RIL_RadioState
-processRadioState(RIL_RadioState newRadioState, RIL_SOCKET_ID socket_id) {
-
-    if((newRadioState > RADIO_STATE_UNAVAILABLE) && (newRadioState < RADIO_STATE_ON)) {
-        int newVoiceRadioTech;
-        int newCdmaSubscriptionSource;
-        int newSimStatus;
-
-        /* This is old RIL. Decode Subscription source and Voice Radio Technology
-           from Radio State and send change notifications if there has been a change */
-        newVoiceRadioTech = decodeVoiceRadioTechnology(newRadioState);
-        if(newVoiceRadioTech != voiceRadioTech) {
-            voiceRadioTech = newVoiceRadioTech;
-            RIL_UNSOL_RESPONSE(RIL_UNSOL_VOICE_RADIO_TECH_CHANGED,
-                        &voiceRadioTech, sizeof(voiceRadioTech), socket_id);
-        }
-        if(is3gpp2(newVoiceRadioTech)) {
-            newCdmaSubscriptionSource = decodeCdmaSubscriptionSource(newRadioState);
-            if(newCdmaSubscriptionSource != cdmaSubscriptionSource) {
-                cdmaSubscriptionSource = newCdmaSubscriptionSource;
-                RIL_UNSOL_RESPONSE(RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED,
-                        &cdmaSubscriptionSource, sizeof(cdmaSubscriptionSource), socket_id);
-            }
-        }
-        newSimStatus = decodeSimStatus(newRadioState);
-        if(newSimStatus != simRuimStatus) {
-            simRuimStatus = newSimStatus;
-            RIL_UNSOL_RESPONSE(RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, NULL, 0, socket_id);
-        }
-
-        /* Send RADIO_ON to telephony */
-        newRadioState = RADIO_STATE_ON;
-    }
-
-    return newRadioState;
-}
-
-
-#if defined(ANDROID_MULTI_SIM)
-extern "C"
-void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
-                                size_t datalen, RIL_SOCKET_ID socket_id)
-#else
-extern "C"
-void RIL_onUnsolicitedResponse(int unsolResponse, const void *data,
-                                size_t datalen)
-#endif
-{
-    int unsolResponseIndex;
-    int ret;
-    int64_t timeReceived = 0;
-    bool shouldScheduleTimeout = false;
-    RIL_RadioState newState;
-    RIL_SOCKET_ID soc_id = RIL_SOCKET_1;
-
-#if defined(ANDROID_MULTI_SIM)
-    soc_id = socket_id;
-#endif
-
-
-    if (s_registerCalled == 0) {
-        // Ignore RIL_onUnsolicitedResponse before RIL_register
-        RLOGW("RIL_onUnsolicitedResponse called before RIL_register");
-        return;
-    }
-
-    unsolResponseIndex = unsolResponse - RIL_UNSOL_RESPONSE_BASE;
-
-    if ((unsolResponseIndex < 0)
-        || (unsolResponseIndex >= (int32_t)NUM_ELEMS(s_unsolResponses))) {
-        RLOGE("unsupported unsolicited response code %d", unsolResponse);
-        return;
-    }
-
-    // Grab a wake lock if needed for this reponse,
-    // as we exit we'll either release it immediately
-    // or set a timer to release it later.
-    switch (s_unsolResponses[unsolResponseIndex].wakeType) {
-        case WAKE_PARTIAL:
-            grabPartialWakeLock();
-            shouldScheduleTimeout = true;
-        break;
-
-        case DONT_WAKE:
-        default:
-            // No wake lock is grabed so don't set timeout
-            shouldScheduleTimeout = false;
-            break;
-    }
-
-    // Mark the time this was received, doing this
-    // after grabing the wakelock incase getting
-    // the elapsedRealTime might cause us to goto
-    // sleep.
-    if (unsolResponse == RIL_UNSOL_NITZ_TIME_RECEIVED) {
-        timeReceived = elapsedRealtime();
-    }
-
-    appendPrintBuf("[UNSL]< %s", requestToString(unsolResponse));
-
-    Parcel p;
-    if (s_callbacks.version >= 13
-                && s_unsolResponses[unsolResponseIndex].wakeType == WAKE_PARTIAL) {
-        p.writeInt32 (RESPONSE_UNSOLICITED_ACK_EXP);
-    } else {
-        p.writeInt32 (RESPONSE_UNSOLICITED);
-    }
-    p.writeInt32 (unsolResponse);
-
-    ret = s_unsolResponses[unsolResponseIndex]
-                .responseFunction(p, const_cast<void*>(data), datalen);
-    if (ret != 0) {
-        // Problem with the response. Don't continue;
-        goto error_exit;
-    }
-
-    // some things get more payload
-    switch(unsolResponse) {
-        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED:
-            newState = processRadioState(CALL_ONSTATEREQUEST(soc_id), soc_id);
-            p.writeInt32(newState);
-            appendPrintBuf("%s {%s}", printBuf,
-                radioStateToString(CALL_ONSTATEREQUEST(soc_id)));
-        break;
-
-
-        case RIL_UNSOL_NITZ_TIME_RECEIVED:
-            // Store the time that this was received so the
-            // handler of this message can account for
-            // the time it takes to arrive and process. In
-            // particular the system has been known to sleep
-            // before this message can be processed.
-            p.writeInt64(timeReceived);
-        break;
-    }
-
-    if (s_callbacks.version < 13) {
-        if (shouldScheduleTimeout) {
-            UserCallbackInfo *p_info = internalRequestTimedCallback(wakeTimeoutCallback, NULL,
-                    &TIMEVAL_WAKE_TIMEOUT);
-
-            if (p_info == NULL) {
-                goto error_exit;
-            } else {
-                // Cancel the previous request
-                if (s_last_wake_timeout_info != NULL) {
-                    s_last_wake_timeout_info->userParam = (void *)1;
-                }
-                s_last_wake_timeout_info = p_info;
-            }
-        }
-    }
-
-#if VDBG
-    RLOGI("%s UNSOLICITED: %s length:%d", rilSocketIdToString(soc_id), requestToString(unsolResponse), p.dataSize());
-#endif
-    ret = sendResponse(p, soc_id);
-    if (ret != 0 && unsolResponse == RIL_UNSOL_NITZ_TIME_RECEIVED) {
-
-        // Unfortunately, NITZ time is not poll/update like everything
-        // else in the system. So, if the upstream client isn't connected,
-        // keep a copy of the last NITZ response (with receive time noted
-        // above) around so we can deliver it when it is connected
-
-        if (s_lastNITZTimeData != NULL) {
-            free (s_lastNITZTimeData);
-            s_lastNITZTimeData = NULL;
-        }
-
-        s_lastNITZTimeData = calloc(p.dataSize(), 1);
-        if (s_lastNITZTimeData == NULL) {
-             RLOGE("Memory allocation failed in RIL_onUnsolicitedResponse");
-             goto error_exit;
-        }
-        s_lastNITZTimeDataSize = p.dataSize();
-        memcpy(s_lastNITZTimeData, p.data(), p.dataSize());
-    }
-
-    // Normal exit
-    return;
-
-error_exit:
-    if (shouldScheduleTimeout) {
-        releaseWakeLock();
-    }
-}
-
-/** FIXME generalize this if you track UserCAllbackInfo, clear it
-    when the callback occurs
-*/
-static UserCallbackInfo *
-internalRequestTimedCallback (RIL_TimedCallback callback, void *param,
-                                const struct timeval *relativeTime)
-{
-    struct timeval myRelativeTime;
-    UserCallbackInfo *p_info;
-
-    p_info = (UserCallbackInfo *) calloc(1, sizeof(UserCallbackInfo));
-    if (p_info == NULL) {
-        RLOGE("Memory allocation failed in internalRequestTimedCallback");
-        return p_info;
-
-    }
-
-    p_info->p_callback = callback;
-    p_info->userParam = param;
-
-    if (relativeTime == NULL) {
-        /* treat null parameter as a 0 relative time */
-        memset (&myRelativeTime, 0, sizeof(myRelativeTime));
-    } else {
-        /* FIXME I think event_add's tv param is really const anyway */
-        memcpy (&myRelativeTime, relativeTime, sizeof(myRelativeTime));
-    }
-
-    ril_event_set(&(p_info->event), -1, false, userTimerCallback, p_info);
-
-    ril_timer_add(&(p_info->event), &myRelativeTime);
-
-    triggerEvLoop();
-    return p_info;
-}
-
-
-extern "C" void
-RIL_requestTimedCallback (RIL_TimedCallback callback, void *param,
-                                const struct timeval *relativeTime) {
-    internalRequestTimedCallback (callback, param, relativeTime);
-}
-
-const char *
-failCauseToString(RIL_Errno e) {
-    switch(e) {
-        case RIL_E_SUCCESS: return "E_SUCCESS";
-        case RIL_E_RADIO_NOT_AVAILABLE: return "E_RADIO_NOT_AVAILABLE";
-        case RIL_E_GENERIC_FAILURE: return "E_GENERIC_FAILURE";
-        case RIL_E_PASSWORD_INCORRECT: return "E_PASSWORD_INCORRECT";
-        case RIL_E_SIM_PIN2: return "E_SIM_PIN2";
-        case RIL_E_SIM_PUK2: return "E_SIM_PUK2";
-        case RIL_E_REQUEST_NOT_SUPPORTED: return "E_REQUEST_NOT_SUPPORTED";
-        case RIL_E_CANCELLED: return "E_CANCELLED";
-        case RIL_E_OP_NOT_ALLOWED_DURING_VOICE_CALL: return "E_OP_NOT_ALLOWED_DURING_VOICE_CALL";
-        case RIL_E_OP_NOT_ALLOWED_BEFORE_REG_TO_NW: return "E_OP_NOT_ALLOWED_BEFORE_REG_TO_NW";
-        case RIL_E_SMS_SEND_FAIL_RETRY: return "E_SMS_SEND_FAIL_RETRY";
-        case RIL_E_SIM_ABSENT:return "E_SIM_ABSENT";
-        case RIL_E_ILLEGAL_SIM_OR_ME:return "E_ILLEGAL_SIM_OR_ME";
-#ifdef FEATURE_MULTIMODE_ANDROID
-        case RIL_E_SUBSCRIPTION_NOT_AVAILABLE:return "E_SUBSCRIPTION_NOT_AVAILABLE";
-        case RIL_E_MODE_NOT_SUPPORTED:return "E_MODE_NOT_SUPPORTED";
-#endif
-        case RIL_E_FDN_CHECK_FAILURE: return "E_FDN_CHECK_FAILURE";
-        case RIL_E_MISSING_RESOURCE: return "E_MISSING_RESOURCE";
-        case RIL_E_NO_SUCH_ELEMENT: return "E_NO_SUCH_ELEMENT";
-        case RIL_E_DIAL_MODIFIED_TO_USSD: return "E_DIAL_MODIFIED_TO_USSD";
-        case RIL_E_DIAL_MODIFIED_TO_SS: return "E_DIAL_MODIFIED_TO_SS";
-        case RIL_E_DIAL_MODIFIED_TO_DIAL: return "E_DIAL_MODIFIED_TO_DIAL";
-        case RIL_E_USSD_MODIFIED_TO_DIAL: return "E_USSD_MODIFIED_TO_DIAL";
-        case RIL_E_USSD_MODIFIED_TO_SS: return "E_USSD_MODIFIED_TO_SS";
-        case RIL_E_USSD_MODIFIED_TO_USSD: return "E_USSD_MODIFIED_TO_USSD";
-        case RIL_E_SS_MODIFIED_TO_DIAL: return "E_SS_MODIFIED_TO_DIAL";
-        case RIL_E_SS_MODIFIED_TO_USSD: return "E_SS_MODIFIED_TO_USSD";
-        case RIL_E_SUBSCRIPTION_NOT_SUPPORTED: return "E_SUBSCRIPTION_NOT_SUPPORTED";
-        case RIL_E_SS_MODIFIED_TO_SS: return "E_SS_MODIFIED_TO_SS";
-        case RIL_E_LCE_NOT_SUPPORTED: return "E_LCE_NOT_SUPPORTED";
-        case RIL_E_NO_MEMORY: return "E_NO_MEMORY";
-        case RIL_E_INTERNAL_ERR: return "E_INTERNAL_ERR";
-        case RIL_E_SYSTEM_ERR: return "E_SYSTEM_ERR";
-        case RIL_E_MODEM_ERR: return "E_MODEM_ERR";
-        case RIL_E_INVALID_STATE: return "E_INVALID_STATE";
-        case RIL_E_NO_RESOURCES: return "E_NO_RESOURCES";
-        case RIL_E_SIM_ERR: return "E_SIM_ERR";
-        case RIL_E_INVALID_ARGUMENTS: return "E_INVALID_ARGUMENTS";
-        case RIL_E_INVALID_SIM_STATE: return "E_INVALID_SIM_STATE";
-        case RIL_E_INVALID_MODEM_STATE: return "E_INVALID_MODEM_STATE";
-        case RIL_E_INVALID_CALL_ID: return "E_INVALID_CALL_ID";
-        case RIL_E_NO_SMS_TO_ACK: return "E_NO_SMS_TO_ACK";
-        case RIL_E_NETWORK_ERR: return "E_NETWORK_ERR";
-        case RIL_E_REQUEST_RATE_LIMITED: return "E_REQUEST_RATE_LIMITED";
-        case RIL_E_SIM_BUSY: return "E_SIM_BUSY";
-        case RIL_E_SIM_FULL: return "E_SIM_FULL";
-        case RIL_E_NETWORK_REJECT: return "E_NETWORK_REJECT";
-        case RIL_E_OPERATION_NOT_ALLOWED: return "E_OPERATION_NOT_ALLOWED";
-        case RIL_E_EMPTY_RECORD: "E_EMPTY_RECORD";
-        case RIL_E_INVALID_SMS_FORMAT: return "E_INVALID_SMS_FORMAT";
-        case RIL_E_ENCODING_ERR: return "E_ENCODING_ERR";
-        case RIL_E_INVALID_SMSC_ADDRESS: return "E_INVALID_SMSC_ADDRESS";
-        case RIL_E_NO_SUCH_ENTRY: return "E_NO_SUCH_ENTRY";
-        case RIL_E_NETWORK_NOT_READY: return "E_NETWORK_NOT_READY";
-        case RIL_E_NOT_PROVISIONED: return "E_NOT_PROVISIONED";
-        case RIL_E_NO_SUBSCRIPTION: return "E_NO_SUBSCRIPTION";
-        case RIL_E_NO_NETWORK_FOUND: return "E_NO_NETWORK_FOUND";
-        case RIL_E_DEVICE_IN_USE: return "E_DEVICE_IN_USE";
-        case RIL_E_ABORTED: return "E_ABORTED";
-        case RIL_E_OEM_ERROR_1: return "E_OEM_ERROR_1";
-        case RIL_E_OEM_ERROR_2: return "E_OEM_ERROR_2";
-        case RIL_E_OEM_ERROR_3: return "E_OEM_ERROR_3";
-        case RIL_E_OEM_ERROR_4: return "E_OEM_ERROR_4";
-        case RIL_E_OEM_ERROR_5: return "E_OEM_ERROR_5";
-        case RIL_E_OEM_ERROR_6: return "E_OEM_ERROR_6";
-        case RIL_E_OEM_ERROR_7: return "E_OEM_ERROR_7";
-        case RIL_E_OEM_ERROR_8: return "E_OEM_ERROR_8";
-        case RIL_E_OEM_ERROR_9: return "E_OEM_ERROR_9";
-        case RIL_E_OEM_ERROR_10: return "E_OEM_ERROR_10";
-        case RIL_E_OEM_ERROR_11: return "E_OEM_ERROR_11";
-        case RIL_E_OEM_ERROR_12: return "E_OEM_ERROR_12";
-        case RIL_E_OEM_ERROR_13: return "E_OEM_ERROR_13";
-        case RIL_E_OEM_ERROR_14: return "E_OEM_ERROR_14";
-        case RIL_E_OEM_ERROR_15: return "E_OEM_ERROR_15";
-        case RIL_E_OEM_ERROR_16: return "E_OEM_ERROR_16";
-        case RIL_E_OEM_ERROR_17: return "E_OEM_ERROR_17";
-        case RIL_E_OEM_ERROR_18: return "E_OEM_ERROR_18";
-        case RIL_E_OEM_ERROR_19: return "E_OEM_ERROR_19";
-        case RIL_E_OEM_ERROR_20: return "E_OEM_ERROR_20";
-        case RIL_E_OEM_ERROR_21: return "E_OEM_ERROR_21";
-        case RIL_E_OEM_ERROR_22: return "E_OEM_ERROR_22";
-        case RIL_E_OEM_ERROR_23: return "E_OEM_ERROR_23";
-        case RIL_E_OEM_ERROR_24: return "E_OEM_ERROR_24";
-        case RIL_E_OEM_ERROR_25: return "E_OEM_ERROR_25";
-        default: return "<unknown error>";
-    }
-}
-
-const char *
-radioStateToString(RIL_RadioState s) {
-    switch(s) {
-        case RADIO_STATE_OFF: return "RADIO_OFF";
-        case RADIO_STATE_UNAVAILABLE: return "RADIO_UNAVAILABLE";
-        case RADIO_STATE_SIM_NOT_READY: return "RADIO_SIM_NOT_READY";
-        case RADIO_STATE_SIM_LOCKED_OR_ABSENT: return "RADIO_SIM_LOCKED_OR_ABSENT";
-        case RADIO_STATE_SIM_READY: return "RADIO_SIM_READY";
-        case RADIO_STATE_RUIM_NOT_READY:return"RADIO_RUIM_NOT_READY";
-        case RADIO_STATE_RUIM_READY:return"RADIO_RUIM_READY";
-        case RADIO_STATE_RUIM_LOCKED_OR_ABSENT:return"RADIO_RUIM_LOCKED_OR_ABSENT";
-        case RADIO_STATE_NV_NOT_READY:return"RADIO_NV_NOT_READY";
-        case RADIO_STATE_NV_READY:return"RADIO_NV_READY";
-        case RADIO_STATE_ON:return"RADIO_ON";
-        default: return "<unknown state>";
-    }
-}
-
-const char *
-callStateToString(RIL_CallState s) {
-    switch(s) {
-        case RIL_CALL_ACTIVE : return "ACTIVE";
-        case RIL_CALL_HOLDING: return "HOLDING";
-        case RIL_CALL_DIALING: return "DIALING";
-        case RIL_CALL_ALERTING: return "ALERTING";
-        case RIL_CALL_INCOMING: return "INCOMING";
-        case RIL_CALL_WAITING: return "WAITING";
-        default: return "<unknown state>";
-    }
-}
-
-const char *
-requestToString(int request) {
-/*
- cat libs/telephony/ril_commands.h \
- | egrep "^ *{RIL_" \
- | sed -re 's/\{RIL_([^,]+),[^,]+,([^}]+).+/case RIL_\1: return "\1";/'
-
-
- cat libs/telephony/ril_unsol_commands.h \
- | egrep "^ *{RIL_" \
- | sed -re 's/\{RIL_([^,]+),([^}]+).+/case RIL_\1: return "\1";/'
-
-*/
-    switch(request) {
-        case RIL_REQUEST_GET_SIM_STATUS: return "GET_SIM_STATUS";
-        case RIL_REQUEST_ENTER_SIM_PIN: return "ENTER_SIM_PIN";
-        case RIL_REQUEST_ENTER_SIM_PUK: return "ENTER_SIM_PUK";
-        case RIL_REQUEST_ENTER_SIM_PIN2: return "ENTER_SIM_PIN2";
-        case RIL_REQUEST_ENTER_SIM_PUK2: return "ENTER_SIM_PUK2";
-        case RIL_REQUEST_CHANGE_SIM_PIN: return "CHANGE_SIM_PIN";
-        case RIL_REQUEST_CHANGE_SIM_PIN2: return "CHANGE_SIM_PIN2";
-        case RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION: return "ENTER_NETWORK_DEPERSONALIZATION";
-        case RIL_REQUEST_GET_CURRENT_CALLS: return "GET_CURRENT_CALLS";
-        case RIL_REQUEST_DIAL: return "DIAL";
-        case RIL_REQUEST_GET_IMSI: return "GET_IMSI";
-        case RIL_REQUEST_HANGUP: return "HANGUP";
-        case RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND: return "HANGUP_WAITING_OR_BACKGROUND";
-        case RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND: return "HANGUP_FOREGROUND_RESUME_BACKGROUND";
-        case RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE: return "SWITCH_WAITING_OR_HOLDING_AND_ACTIVE";
-        case RIL_REQUEST_CONFERENCE: return "CONFERENCE";
-        case RIL_REQUEST_UDUB: return "UDUB";
-        case RIL_REQUEST_LAST_CALL_FAIL_CAUSE: return "LAST_CALL_FAIL_CAUSE";
-        case RIL_REQUEST_SIGNAL_STRENGTH: return "SIGNAL_STRENGTH";
-        case RIL_REQUEST_VOICE_REGISTRATION_STATE: return "VOICE_REGISTRATION_STATE";
-        case RIL_REQUEST_DATA_REGISTRATION_STATE: return "DATA_REGISTRATION_STATE";
-        case RIL_REQUEST_OPERATOR: return "OPERATOR";
-        case RIL_REQUEST_RADIO_POWER: return "RADIO_POWER";
-        case RIL_REQUEST_DTMF: return "DTMF";
-        case RIL_REQUEST_SEND_SMS: return "SEND_SMS";
-        case RIL_REQUEST_SEND_SMS_EXPECT_MORE: return "SEND_SMS_EXPECT_MORE";
-        case RIL_REQUEST_SETUP_DATA_CALL: return "SETUP_DATA_CALL";
-        case RIL_REQUEST_SIM_IO: return "SIM_IO";
-        case RIL_REQUEST_SEND_USSD: return "SEND_USSD";
-        case RIL_REQUEST_CANCEL_USSD: return "CANCEL_USSD";
-        case RIL_REQUEST_GET_CLIR: return "GET_CLIR";
-        case RIL_REQUEST_SET_CLIR: return "SET_CLIR";
-        case RIL_REQUEST_QUERY_CALL_FORWARD_STATUS: return "QUERY_CALL_FORWARD_STATUS";
-        case RIL_REQUEST_SET_CALL_FORWARD: return "SET_CALL_FORWARD";
-        case RIL_REQUEST_QUERY_CALL_WAITING: return "QUERY_CALL_WAITING";
-        case RIL_REQUEST_SET_CALL_WAITING: return "SET_CALL_WAITING";
-        case RIL_REQUEST_SMS_ACKNOWLEDGE: return "SMS_ACKNOWLEDGE";
-        case RIL_REQUEST_GET_IMEI: return "GET_IMEI";
-        case RIL_REQUEST_GET_IMEISV: return "GET_IMEISV";
-        case RIL_REQUEST_ANSWER: return "ANSWER";
-        case RIL_REQUEST_DEACTIVATE_DATA_CALL: return "DEACTIVATE_DATA_CALL";
-        case RIL_REQUEST_QUERY_FACILITY_LOCK: return "QUERY_FACILITY_LOCK";
-        case RIL_REQUEST_SET_FACILITY_LOCK: return "SET_FACILITY_LOCK";
-        case RIL_REQUEST_CHANGE_BARRING_PASSWORD: return "CHANGE_BARRING_PASSWORD";
-        case RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE: return "QUERY_NETWORK_SELECTION_MODE";
-        case RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC: return "SET_NETWORK_SELECTION_AUTOMATIC";
-        case RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL: return "SET_NETWORK_SELECTION_MANUAL";
-        case RIL_REQUEST_QUERY_AVAILABLE_NETWORKS : return "QUERY_AVAILABLE_NETWORKS ";
-        case RIL_REQUEST_DTMF_START: return "DTMF_START";
-        case RIL_REQUEST_DTMF_STOP: return "DTMF_STOP";
-        case RIL_REQUEST_BASEBAND_VERSION: return "BASEBAND_VERSION";
-        case RIL_REQUEST_SEPARATE_CONNECTION: return "SEPARATE_CONNECTION";
-        case RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE: return "SET_PREFERRED_NETWORK_TYPE";
-        case RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE: return "GET_PREFERRED_NETWORK_TYPE";
-        case RIL_REQUEST_GET_NEIGHBORING_CELL_IDS: return "GET_NEIGHBORING_CELL_IDS";
-        case RIL_REQUEST_SET_MUTE: return "SET_MUTE";
-        case RIL_REQUEST_GET_MUTE: return "GET_MUTE";
-        case RIL_REQUEST_QUERY_CLIP: return "QUERY_CLIP";
-        case RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE: return "LAST_DATA_CALL_FAIL_CAUSE";
-        case RIL_REQUEST_DATA_CALL_LIST: return "DATA_CALL_LIST";
-        case RIL_REQUEST_RESET_RADIO: return "RESET_RADIO";
-        case RIL_REQUEST_OEM_HOOK_RAW: return "OEM_HOOK_RAW";
-        case RIL_REQUEST_OEM_HOOK_STRINGS: return "OEM_HOOK_STRINGS";
-        case RIL_REQUEST_SET_BAND_MODE: return "SET_BAND_MODE";
-        case RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE: return "QUERY_AVAILABLE_BAND_MODE";
-        case RIL_REQUEST_STK_GET_PROFILE: return "STK_GET_PROFILE";
-        case RIL_REQUEST_STK_SET_PROFILE: return "STK_SET_PROFILE";
-        case RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND: return "STK_SEND_ENVELOPE_COMMAND";
-        case RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE: return "STK_SEND_TERMINAL_RESPONSE";
-        case RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM: return "STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM";
-        case RIL_REQUEST_SCREEN_STATE: return "SCREEN_STATE";
-        case RIL_REQUEST_EXPLICIT_CALL_TRANSFER: return "EXPLICIT_CALL_TRANSFER";
-        case RIL_REQUEST_SET_LOCATION_UPDATES: return "SET_LOCATION_UPDATES";
-        case RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE:return"CDMA_SET_SUBSCRIPTION_SOURCE";
-        case RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE:return"CDMA_SET_ROAMING_PREFERENCE";
-        case RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE:return"CDMA_QUERY_ROAMING_PREFERENCE";
-        case RIL_REQUEST_SET_TTY_MODE:return"SET_TTY_MODE";
-        case RIL_REQUEST_QUERY_TTY_MODE:return"QUERY_TTY_MODE";
-        case RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE:return"CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE";
-        case RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE:return"CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE";
-        case RIL_REQUEST_CDMA_FLASH:return"CDMA_FLASH";
-        case RIL_REQUEST_CDMA_BURST_DTMF:return"CDMA_BURST_DTMF";
-        case RIL_REQUEST_CDMA_SEND_SMS:return"CDMA_SEND_SMS";
-        case RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE:return"CDMA_SMS_ACKNOWLEDGE";
-        case RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG:return"GSM_GET_BROADCAST_SMS_CONFIG";
-        case RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG:return"GSM_SET_BROADCAST_SMS_CONFIG";
-        case RIL_REQUEST_CDMA_GET_BROADCAST_SMS_CONFIG:return "CDMA_GET_BROADCAST_SMS_CONFIG";
-        case RIL_REQUEST_CDMA_SET_BROADCAST_SMS_CONFIG:return "CDMA_SET_BROADCAST_SMS_CONFIG";
-        case RIL_REQUEST_CDMA_SMS_BROADCAST_ACTIVATION:return "CDMA_SMS_BROADCAST_ACTIVATION";
-        case RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY: return"CDMA_VALIDATE_AND_WRITE_AKEY";
-        case RIL_REQUEST_CDMA_SUBSCRIPTION: return"CDMA_SUBSCRIPTION";
-        case RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM: return "CDMA_WRITE_SMS_TO_RUIM";
-        case RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM: return "CDMA_DELETE_SMS_ON_RUIM";
-        case RIL_REQUEST_DEVICE_IDENTITY: return "DEVICE_IDENTITY";
-        case RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE: return "EXIT_EMERGENCY_CALLBACK_MODE";
-        case RIL_REQUEST_GET_SMSC_ADDRESS: return "GET_SMSC_ADDRESS";
-        case RIL_REQUEST_SET_SMSC_ADDRESS: return "SET_SMSC_ADDRESS";
-        case RIL_REQUEST_REPORT_SMS_MEMORY_STATUS: return "REPORT_SMS_MEMORY_STATUS";
-        case RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING: return "REPORT_STK_SERVICE_IS_RUNNING";
-        case RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE: return "CDMA_GET_SUBSCRIPTION_SOURCE";
-        case RIL_REQUEST_ISIM_AUTHENTICATION: return "ISIM_AUTHENTICATION";
-        case RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU: return "RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU";
-        case RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS: return "RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS";
-        case RIL_REQUEST_VOICE_RADIO_TECH: return "VOICE_RADIO_TECH";
-        case RIL_REQUEST_WRITE_SMS_TO_SIM: return "WRITE_SMS_TO_SIM";
-        case RIL_REQUEST_GET_CELL_INFO_LIST: return"GET_CELL_INFO_LIST";
-        case RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE: return"SET_UNSOL_CELL_INFO_LIST_RATE";
-        case RIL_REQUEST_SET_INITIAL_ATTACH_APN: return "RIL_REQUEST_SET_INITIAL_ATTACH_APN";
-        case RIL_REQUEST_IMS_REGISTRATION_STATE: return "IMS_REGISTRATION_STATE";
-        case RIL_REQUEST_IMS_SEND_SMS: return "IMS_SEND_SMS";
-        case RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC: return "SIM_TRANSMIT_APDU_BASIC";
-        case RIL_REQUEST_SIM_OPEN_CHANNEL: return "SIM_OPEN_CHANNEL";
-        case RIL_REQUEST_SIM_CLOSE_CHANNEL: return "SIM_CLOSE_CHANNEL";
-        case RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL: return "SIM_TRANSMIT_APDU_CHANNEL";
-        case RIL_REQUEST_GET_RADIO_CAPABILITY: return "RIL_REQUEST_GET_RADIO_CAPABILITY";
-        case RIL_REQUEST_SET_RADIO_CAPABILITY: return "RIL_REQUEST_SET_RADIO_CAPABILITY";
-        case RIL_REQUEST_SET_UICC_SUBSCRIPTION: return "SET_UICC_SUBSCRIPTION";
-        case RIL_REQUEST_ALLOW_DATA: return "ALLOW_DATA";
-        case RIL_REQUEST_GET_HARDWARE_CONFIG: return "GET_HARDWARE_CONFIG";
-        case RIL_REQUEST_SIM_AUTHENTICATION: return "SIM_AUTHENTICATION";
-        case RIL_REQUEST_GET_DC_RT_INFO: return "GET_DC_RT_INFO";
-        case RIL_REQUEST_SET_DC_RT_INFO_RATE: return "SET_DC_RT_INFO_RATE";
-        case RIL_REQUEST_SET_DATA_PROFILE: return "SET_DATA_PROFILE";
-        case RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED: return "UNSOL_RESPONSE_RADIO_STATE_CHANGED";
-        case RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED: return "UNSOL_RESPONSE_CALL_STATE_CHANGED";
-        case RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED: return "UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED";
-        case RIL_UNSOL_RESPONSE_NEW_SMS: return "UNSOL_RESPONSE_NEW_SMS";
-        case RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT: return "UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT";
-        case RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM: return "UNSOL_RESPONSE_NEW_SMS_ON_SIM";
-        case RIL_UNSOL_ON_USSD: return "UNSOL_ON_USSD";
-        case RIL_UNSOL_ON_USSD_REQUEST: return "UNSOL_ON_USSD_REQUEST(obsolete)";
-        case RIL_UNSOL_NITZ_TIME_RECEIVED: return "UNSOL_NITZ_TIME_RECEIVED";
-        case RIL_UNSOL_SIGNAL_STRENGTH: return "UNSOL_SIGNAL_STRENGTH";
-        case RIL_UNSOL_SUPP_SVC_NOTIFICATION: return "UNSOL_SUPP_SVC_NOTIFICATION";
-        case RIL_UNSOL_STK_SESSION_END: return "UNSOL_STK_SESSION_END";
-        case RIL_UNSOL_STK_PROACTIVE_COMMAND: return "UNSOL_STK_PROACTIVE_COMMAND";
-        case RIL_UNSOL_STK_EVENT_NOTIFY: return "UNSOL_STK_EVENT_NOTIFY";
-        case RIL_UNSOL_STK_CALL_SETUP: return "UNSOL_STK_CALL_SETUP";
-        case RIL_UNSOL_SIM_SMS_STORAGE_FULL: return "UNSOL_SIM_SMS_STORAGE_FUL";
-        case RIL_UNSOL_SIM_REFRESH: return "UNSOL_SIM_REFRESH";
-        case RIL_UNSOL_DATA_CALL_LIST_CHANGED: return "UNSOL_DATA_CALL_LIST_CHANGED";
-        case RIL_UNSOL_CALL_RING: return "UNSOL_CALL_RING";
-        case RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED: return "UNSOL_RESPONSE_SIM_STATUS_CHANGED";
-        case RIL_UNSOL_RESPONSE_CDMA_NEW_SMS: return "UNSOL_NEW_CDMA_SMS";
-        case RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS: return "UNSOL_NEW_BROADCAST_SMS";
-        case RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL: return "UNSOL_CDMA_RUIM_SMS_STORAGE_FULL";
-        case RIL_UNSOL_RESTRICTED_STATE_CHANGED: return "UNSOL_RESTRICTED_STATE_CHANGED";
-        case RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE: return "UNSOL_ENTER_EMERGENCY_CALLBACK_MODE";
-        case RIL_UNSOL_CDMA_CALL_WAITING: return "UNSOL_CDMA_CALL_WAITING";
-        case RIL_UNSOL_CDMA_OTA_PROVISION_STATUS: return "UNSOL_CDMA_OTA_PROVISION_STATUS";
-        case RIL_UNSOL_CDMA_INFO_REC: return "UNSOL_CDMA_INFO_REC";
-        case RIL_UNSOL_OEM_HOOK_RAW: return "UNSOL_OEM_HOOK_RAW";
-        case RIL_UNSOL_RINGBACK_TONE: return "UNSOL_RINGBACK_TONE";
-        case RIL_UNSOL_RESEND_INCALL_MUTE: return "UNSOL_RESEND_INCALL_MUTE";
-        case RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED: return "UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED";
-        case RIL_UNSOL_CDMA_PRL_CHANGED: return "UNSOL_CDMA_PRL_CHANGED";
-        case RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE: return "UNSOL_EXIT_EMERGENCY_CALLBACK_MODE";
-        case RIL_UNSOL_RIL_CONNECTED: return "UNSOL_RIL_CONNECTED";
-        case RIL_UNSOL_VOICE_RADIO_TECH_CHANGED: return "UNSOL_VOICE_RADIO_TECH_CHANGED";
-        case RIL_UNSOL_CELL_INFO_LIST: return "UNSOL_CELL_INFO_LIST";
-        case RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED: return "RESPONSE_IMS_NETWORK_STATE_CHANGED";
-        case RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED: return "UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED";
-        case RIL_UNSOL_SRVCC_STATE_NOTIFY: return "UNSOL_SRVCC_STATE_NOTIFY";
-        case RIL_UNSOL_HARDWARE_CONFIG_CHANGED: return "HARDWARE_CONFIG_CHANGED";
-        case RIL_UNSOL_DC_RT_INFO_CHANGED: return "UNSOL_DC_RT_INFO_CHANGED";
-        case RIL_REQUEST_SHUTDOWN: return "SHUTDOWN";
-        case RIL_UNSOL_RADIO_CAPABILITY: return "RIL_UNSOL_RADIO_CAPABILITY";
-        case RIL_RESPONSE_ACKNOWLEDGEMENT: return "RIL_RESPONSE_ACKNOWLEDGEMENT";
-        default: return "<unknown request>";
-    }
-}
-
-const char *
-rilSocketIdToString(RIL_SOCKET_ID socket_id)
-{
-    switch(socket_id) {
-        case RIL_SOCKET_1:
-            return "RIL_SOCKET_1";
-#if (SIM_COUNT >= 2)
-        case RIL_SOCKET_2:
-            return "RIL_SOCKET_2";
-#endif
-#if (SIM_COUNT >= 3)
-        case RIL_SOCKET_3:
-            return "RIL_SOCKET_3";
-#endif
-#if (SIM_COUNT >= 4)
-        case RIL_SOCKET_4:
-            return "RIL_SOCKET_4";
-#endif
-        default:
-            return "not a valid RIL";
-    }
-}
-
-/*
- * Returns true for a debuggable build.
- */
-static bool isDebuggable() {
-    char debuggable[PROP_VALUE_MAX];
-    property_get("ro.debuggable", debuggable, "0");
-    if (strcmp(debuggable, "1") == 0) {
-        return true;
-    }
-    return false;
-}
-
-} /* namespace android */
-
-void rilEventAddWakeup_helper(struct ril_event *ev) {
-    android::rilEventAddWakeup(ev);
-}
-
-void listenCallback_helper(int fd, short flags, void *param) {
-    android::listenCallback(fd, flags, param);
-}
-
-int blockingWrite_helper(int fd, void *buffer, size_t len) {
-    return android::blockingWrite(fd, buffer, len);
-}
diff --git a/libril/rilSocketQueue.h b/libril/rilSocketQueue.h
deleted file mode 100644
index eaa5155..0000000
--- a/libril/rilSocketQueue.h
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
-* Copyright (C) 2014 The Android Open Source Project
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-*     http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
-*/
-
-#include "pb_decode.h"
-#include <pthread.h>
-#include <hardware/ril/librilutils/proto/sap-api.pb.h>
-#include <utils/Log.h>
-
-using namespace std;
-
-/**
- * Template queue class to handling requests for a rild socket.
- * <p>
- * This class performs the following functions :
- * <ul>
- *     <li>Enqueue.
- *     <li>Dequeue.
- *     <li>Check and dequeue.
- * </ul>
- */
-
-template <typename T>
-class Ril_queue {
-
-   /**
-     * Mutex attribute used in queue mutex initialization.
-     */
-    pthread_mutexattr_t attr;
-
-   /**
-     * Queue mutex variable for synchronized queue access.
-     */
-    pthread_mutex_t mutex_instance;
-
-   /**
-     * Condition to be waited on for dequeuing.
-     */
-    pthread_cond_t cond;
-
-   /**
-     * Front of the queue.
-     */
-    T *front;
-
-    public:
-
-       /**
-         * Remove the first element of the queue.
-         *
-         * @return first element of the queue.
-         */
-        T* dequeue(void);
-
-       /**
-         * Add a request to the front of the queue.
-         *
-         * @param Request to be added.
-         */
-        void enqueue(T* request);
-
-       /**
-         * Check if the queue is empty.
-         */
-        int empty(void);
-
-       /**
-         * Check and remove an element with a particular message id and token.
-         *
-         * @param Request message id.
-         * @param Request token.
-         */
-        int checkAndDequeue( MsgId id, int token);
-
-       /**
-         * Queue constructor.
-         */
-        Ril_queue(void);
-};
-
-template <typename T>
-Ril_queue<T>::Ril_queue(void) {
-    pthread_mutexattr_init(&attr);
-    pthread_mutex_init(&mutex_instance, &attr);
-    cond = PTHREAD_COND_INITIALIZER;
-    front = NULL;
-}
-
-template <typename T>
-T* Ril_queue<T>::dequeue(void) {
-    T* temp = NULL;
-
-    pthread_mutex_lock(&mutex_instance);
-    while(empty()) {
-        pthread_cond_wait(&cond, &mutex_instance);
-    }
-    temp = this->front;
-    if(NULL != this->front->p_next) {
-        this->front = this->front->p_next;
-    } else {
-        this->front = NULL;
-    }
-    pthread_mutex_unlock(&mutex_instance);
-
-    return temp;
-}
-
-template <typename T>
-void Ril_queue<T>::enqueue(T* request) {
-
-    pthread_mutex_lock(&mutex_instance);
-
-    if(NULL == this->front) {
-        this->front = request;
-        request->p_next = NULL;
-    } else {
-        request->p_next = this->front;
-        this->front = request;
-    }
-    pthread_cond_broadcast(&cond);
-    pthread_mutex_unlock(&mutex_instance);
-}
-
-template <typename T>
-int Ril_queue<T>::checkAndDequeue(MsgId id, int token) {
-    int ret = 0;
-    T* temp;
-
-    pthread_mutex_lock(&mutex_instance);
-
-    for(T **ppCur = &(this->front); *ppCur != NULL; ppCur = &((*ppCur)->p_next)) {
-        if (token == (*ppCur)->token && id == (*ppCur)->curr->id) {
-            ret = 1;
-            temp = *ppCur;
-            *ppCur = (*ppCur)->p_next;
-            free(temp);
-            break;
-        }
-    }
-
-    pthread_mutex_unlock(&mutex_instance);
-
-    return ret;
-}
-
-
-template <typename T>
-int Ril_queue<T>::empty(void) {
-
-    if(this->front == NULL) {
-        return 1;
-    } else {
-        return 0;
-    }
-}
diff --git a/libril/ril_commands.h b/libril/ril_commands.h
deleted file mode 100644
index 163aa46..0000000
--- a/libril/ril_commands.h
+++ /dev/null
@@ -1,152 +0,0 @@
-/* //device/libs/telephony/ril_commands.h
-**
-** Copyright 2006, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-    {0, NULL, NULL},                   //none
-    {RIL_REQUEST_GET_SIM_STATUS, dispatchVoid, responseSimStatus},
-    {RIL_REQUEST_ENTER_SIM_PIN, dispatchStrings, responseInts},
-    {RIL_REQUEST_ENTER_SIM_PUK, dispatchStrings, responseInts},
-    {RIL_REQUEST_ENTER_SIM_PIN2, dispatchStrings, responseInts},
-    {RIL_REQUEST_ENTER_SIM_PUK2, dispatchStrings, responseInts},
-    {RIL_REQUEST_CHANGE_SIM_PIN, dispatchStrings, responseInts},
-    {RIL_REQUEST_CHANGE_SIM_PIN2, dispatchStrings, responseInts},
-    {RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION, dispatchStrings, responseInts},
-    {RIL_REQUEST_GET_CURRENT_CALLS, dispatchVoid, responseCallList},
-    {RIL_REQUEST_DIAL, dispatchDial, responseVoid},
-    {RIL_REQUEST_GET_IMSI, dispatchStrings, responseString},
-    {RIL_REQUEST_HANGUP, dispatchInts, responseVoid},
-    {RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND, dispatchVoid, responseVoid},
-    {RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND, dispatchVoid, responseVoid},
-    {RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE, dispatchVoid, responseVoid},
-    {RIL_REQUEST_CONFERENCE, dispatchVoid, responseVoid},
-    {RIL_REQUEST_UDUB, dispatchVoid, responseVoid},
-    {RIL_REQUEST_LAST_CALL_FAIL_CAUSE, dispatchVoid, responseFailCause},
-    {RIL_REQUEST_SIGNAL_STRENGTH, dispatchVoid, responseRilSignalStrength},
-    {RIL_REQUEST_VOICE_REGISTRATION_STATE, dispatchVoid, responseStrings},
-    {RIL_REQUEST_DATA_REGISTRATION_STATE, dispatchVoid, responseStrings},
-    {RIL_REQUEST_OPERATOR, dispatchVoid, responseStrings},
-    {RIL_REQUEST_RADIO_POWER, dispatchInts, responseVoid},
-    {RIL_REQUEST_DTMF, dispatchString, responseVoid},
-    {RIL_REQUEST_SEND_SMS, dispatchStrings, responseSMS},
-    {RIL_REQUEST_SEND_SMS_EXPECT_MORE, dispatchStrings, responseSMS},
-    {RIL_REQUEST_SETUP_DATA_CALL, dispatchDataCall, responseSetupDataCall},
-    {RIL_REQUEST_SIM_IO, dispatchSIM_IO, responseSIM_IO},
-    {RIL_REQUEST_SEND_USSD, dispatchString, responseVoid},
-    {RIL_REQUEST_CANCEL_USSD, dispatchVoid, responseVoid},
-    {RIL_REQUEST_GET_CLIR, dispatchVoid, responseInts},
-    {RIL_REQUEST_SET_CLIR, dispatchInts, responseVoid},
-    {RIL_REQUEST_QUERY_CALL_FORWARD_STATUS, dispatchCallForward, responseCallForwards},
-    {RIL_REQUEST_SET_CALL_FORWARD, dispatchCallForward, responseVoid},
-    {RIL_REQUEST_QUERY_CALL_WAITING, dispatchInts, responseInts},
-    {RIL_REQUEST_SET_CALL_WAITING, dispatchInts, responseVoid},
-    {RIL_REQUEST_SMS_ACKNOWLEDGE, dispatchInts, responseVoid},
-    {RIL_REQUEST_GET_IMEI, dispatchVoid, responseString},
-    {RIL_REQUEST_GET_IMEISV, dispatchVoid, responseString},
-    {RIL_REQUEST_ANSWER,dispatchVoid, responseVoid},
-    {RIL_REQUEST_DEACTIVATE_DATA_CALL, dispatchStrings, responseVoid},
-    {RIL_REQUEST_QUERY_FACILITY_LOCK, dispatchStrings, responseInts},
-    {RIL_REQUEST_SET_FACILITY_LOCK, dispatchStrings, responseInts},
-    {RIL_REQUEST_CHANGE_BARRING_PASSWORD, dispatchStrings, responseVoid},
-    {RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE, dispatchVoid, responseInts},
-    {RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC, dispatchVoid, responseVoid},
-    {RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL, dispatchString, responseVoid},
-    {RIL_REQUEST_QUERY_AVAILABLE_NETWORKS , dispatchVoid, responseStrings},
-    {RIL_REQUEST_DTMF_START, dispatchString, responseVoid},
-    {RIL_REQUEST_DTMF_STOP, dispatchVoid, responseVoid},
-    {RIL_REQUEST_BASEBAND_VERSION, dispatchVoid, responseString},
-    {RIL_REQUEST_SEPARATE_CONNECTION, dispatchInts, responseVoid},
-    {RIL_REQUEST_SET_MUTE, dispatchInts, responseVoid},
-    {RIL_REQUEST_GET_MUTE, dispatchVoid, responseInts},
-    {RIL_REQUEST_QUERY_CLIP, dispatchVoid, responseInts},
-    {RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE, dispatchVoid, responseInts},
-    {RIL_REQUEST_DATA_CALL_LIST, dispatchVoid, responseDataCallList},
-    {RIL_REQUEST_RESET_RADIO, dispatchVoid, responseVoid},
-    {RIL_REQUEST_OEM_HOOK_RAW, dispatchRaw, responseRaw},
-    {RIL_REQUEST_OEM_HOOK_STRINGS, dispatchStrings, responseStrings},
-    {RIL_REQUEST_SCREEN_STATE, dispatchInts, responseVoid},
-    {RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION, dispatchInts, responseVoid},
-    {RIL_REQUEST_WRITE_SMS_TO_SIM, dispatchSmsWrite, responseInts},
-    {RIL_REQUEST_DELETE_SMS_ON_SIM, dispatchInts, responseVoid},
-    {RIL_REQUEST_SET_BAND_MODE, dispatchInts, responseVoid},
-    {RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE, dispatchVoid, responseInts},
-    {RIL_REQUEST_STK_GET_PROFILE, dispatchVoid, responseString},
-    {RIL_REQUEST_STK_SET_PROFILE, dispatchString, responseVoid},
-    {RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND, dispatchString, responseString},
-    {RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE, dispatchString, responseVoid},
-    {RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM, dispatchInts, responseVoid},
-    {RIL_REQUEST_EXPLICIT_CALL_TRANSFER, dispatchVoid, responseVoid},
-    {RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE, dispatchInts, responseVoid},
-    {RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE, dispatchVoid, responseInts},
-    {RIL_REQUEST_GET_NEIGHBORING_CELL_IDS, dispatchVoid, responseCellList},
-    {RIL_REQUEST_SET_LOCATION_UPDATES, dispatchInts, responseVoid},
-    {RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE, dispatchInts, responseVoid},
-    {RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE, dispatchInts, responseVoid},
-    {RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE, dispatchVoid, responseInts},
-    {RIL_REQUEST_SET_TTY_MODE, dispatchInts, responseVoid},
-    {RIL_REQUEST_QUERY_TTY_MODE, dispatchVoid, responseInts},
-    {RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE, dispatchInts, responseVoid},
-    {RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE, dispatchVoid, responseInts},
-    {RIL_REQUEST_CDMA_FLASH, dispatchString, responseVoid},
-    {RIL_REQUEST_CDMA_BURST_DTMF, dispatchStrings, responseVoid},
-    {RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY, dispatchString, responseVoid},
-    {RIL_REQUEST_CDMA_SEND_SMS, dispatchCdmaSms, responseSMS},
-    {RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE, dispatchCdmaSmsAck, responseVoid},
-    {RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG, dispatchVoid, responseGsmBrSmsCnf},
-    {RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG, dispatchGsmBrSmsCnf, responseVoid},
-    {RIL_REQUEST_GSM_SMS_BROADCAST_ACTIVATION, dispatchInts, responseVoid},
-    {RIL_REQUEST_CDMA_GET_BROADCAST_SMS_CONFIG, dispatchVoid, responseCdmaBrSmsCnf},
-    {RIL_REQUEST_CDMA_SET_BROADCAST_SMS_CONFIG, dispatchCdmaBrSmsCnf, responseVoid},
-    {RIL_REQUEST_CDMA_SMS_BROADCAST_ACTIVATION, dispatchInts, responseVoid},
-    {RIL_REQUEST_CDMA_SUBSCRIPTION, dispatchVoid, responseStrings},
-    {RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM, dispatchRilCdmaSmsWriteArgs, responseInts},
-    {RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM, dispatchInts, responseVoid},
-    {RIL_REQUEST_DEVICE_IDENTITY, dispatchVoid, responseStrings},
-    {RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE, dispatchVoid, responseVoid},
-    {RIL_REQUEST_GET_SMSC_ADDRESS, dispatchVoid, responseString},
-    {RIL_REQUEST_SET_SMSC_ADDRESS, dispatchString, responseVoid},
-    {RIL_REQUEST_REPORT_SMS_MEMORY_STATUS, dispatchInts, responseVoid},
-    {RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING, dispatchVoid, responseVoid},
-    {RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE, dispatchCdmaSubscriptionSource, responseInts},
-    {RIL_REQUEST_ISIM_AUTHENTICATION, dispatchString, responseString},
-    {RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU, dispatchStrings, responseVoid},
-    {RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS, dispatchString, responseSIM_IO},
-    {RIL_REQUEST_VOICE_RADIO_TECH, dispatchVoiceRadioTech, responseInts},
-    {RIL_REQUEST_GET_CELL_INFO_LIST, dispatchVoid, responseCellInfoList},
-    {RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE, dispatchInts, responseVoid},
-    {RIL_REQUEST_SET_INITIAL_ATTACH_APN, dispatchSetInitialAttachApn, responseVoid},
-    {RIL_REQUEST_IMS_REGISTRATION_STATE, dispatchVoid, responseInts},
-    {RIL_REQUEST_IMS_SEND_SMS, dispatchImsSms, responseSMS},
-    {RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC, dispatchSIM_APDU, responseSIM_IO},
-    {RIL_REQUEST_SIM_OPEN_CHANNEL, dispatchString, responseInts},
-    {RIL_REQUEST_SIM_CLOSE_CHANNEL, dispatchInts, responseVoid},
-    {RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL, dispatchSIM_APDU, responseSIM_IO},
-    {RIL_REQUEST_NV_READ_ITEM, dispatchNVReadItem, responseString},
-    {RIL_REQUEST_NV_WRITE_ITEM, dispatchNVWriteItem, responseVoid},
-    {RIL_REQUEST_NV_WRITE_CDMA_PRL, dispatchRaw, responseVoid},
-    {RIL_REQUEST_NV_RESET_CONFIG, dispatchInts, responseVoid},
-    {RIL_REQUEST_SET_UICC_SUBSCRIPTION, dispatchUiccSubscripton, responseVoid},
-    {RIL_REQUEST_ALLOW_DATA, dispatchInts, responseVoid},
-    {RIL_REQUEST_GET_HARDWARE_CONFIG, dispatchVoid, responseHardwareConfig},
-    {RIL_REQUEST_SIM_AUTHENTICATION, dispatchSimAuthentication, responseSIM_IO},
-    {RIL_REQUEST_GET_DC_RT_INFO, dispatchVoid, responseDcRtInfo},
-    {RIL_REQUEST_SET_DC_RT_INFO_RATE, dispatchInts, responseVoid},
-    {RIL_REQUEST_SET_DATA_PROFILE, dispatchDataProfile, responseVoid},
-    {RIL_REQUEST_SHUTDOWN, dispatchVoid, responseVoid},
-    {RIL_REQUEST_GET_RADIO_CAPABILITY, dispatchVoid, responseRadioCapability},
-    {RIL_REQUEST_SET_RADIO_CAPABILITY, dispatchRadioCapability, responseRadioCapability},
-    {RIL_REQUEST_START_LCE, dispatchInts, responseLceStatus},
-    {RIL_REQUEST_STOP_LCE, dispatchVoid, responseLceStatus},
-    {RIL_REQUEST_PULL_LCEDATA, dispatchVoid, responseLceData},
-    {RIL_REQUEST_GET_ACTIVITY_INFO, dispatchVoid, responseActivityData},
diff --git a/libril/ril_event.cpp b/libril/ril_event.cpp
deleted file mode 100644
index 84b8b72..0000000
--- a/libril/ril_event.cpp
+++ /dev/null
@@ -1,384 +0,0 @@
-/* //device/libs/telephony/ril_event.cpp
-**
-** Copyright 2008, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-#define LOG_TAG "RILC"
-
-#include <stdlib.h>
-#include <unistd.h>
-#include <errno.h>
-#include <fcntl.h>
-#include <utils/Log.h>
-#include <ril_event.h>
-#include <string.h>
-#include <sys/time.h>
-#include <time.h>
-
-#include <pthread.h>
-static pthread_mutex_t listMutex;
-#define MUTEX_ACQUIRE() pthread_mutex_lock(&listMutex)
-#define MUTEX_RELEASE() pthread_mutex_unlock(&listMutex)
-#define MUTEX_INIT() pthread_mutex_init(&listMutex, NULL)
-#define MUTEX_DESTROY() pthread_mutex_destroy(&listMutex)
-
-#ifndef timeradd
-#define timeradd(tvp, uvp, vvp)						\
-	do {								\
-		(vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec;		\
-		(vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec;       \
-		if ((vvp)->tv_usec >= 1000000) {			\
-			(vvp)->tv_sec++;				\
-			(vvp)->tv_usec -= 1000000;			\
-		}							\
-	} while (0)
-#endif
-
-#ifndef timercmp
-#define timercmp(a, b, op)               \
-        ((a)->tv_sec == (b)->tv_sec      \
-        ? (a)->tv_usec op (b)->tv_usec   \
-        : (a)->tv_sec op (b)->tv_sec)
-#endif
-
-#ifndef timersub
-#define timersub(a, b, res)                           \
-    do {                                              \
-        (res)->tv_sec = (a)->tv_sec - (b)->tv_sec;    \
-        (res)->tv_usec = (a)->tv_usec - (b)->tv_usec; \
-        if ((res)->tv_usec < 0) {                     \
-            (res)->tv_usec += 1000000;                \
-            (res)->tv_sec -= 1;                       \
-        }                                             \
-    } while(0);
-#endif
-
-static fd_set readFds;
-static int nfds = 0;
-
-static struct ril_event * watch_table[MAX_FD_EVENTS];
-static struct ril_event timer_list;
-static struct ril_event pending_list;
-
-#define DEBUG 0
-
-#if DEBUG
-#define dlog(x...) RLOGD( x )
-static void dump_event(struct ril_event * ev)
-{
-    dlog("~~~~ Event %x ~~~~", (unsigned int)ev);
-    dlog("     next    = %x", (unsigned int)ev->next);
-    dlog("     prev    = %x", (unsigned int)ev->prev);
-    dlog("     fd      = %d", ev->fd);
-    dlog("     pers    = %d", ev->persist);
-    dlog("     timeout = %ds + %dus", (int)ev->timeout.tv_sec, (int)ev->timeout.tv_usec);
-    dlog("     func    = %x", (unsigned int)ev->func);
-    dlog("     param   = %x", (unsigned int)ev->param);
-    dlog("~~~~~~~~~~~~~~~~~~");
-}
-#else
-#define dlog(x...) do {} while(0)
-#define dump_event(x) do {} while(0)
-#endif
-
-static void getNow(struct timeval * tv)
-{
-    struct timespec ts;
-    clock_gettime(CLOCK_MONOTONIC, &ts);
-    tv->tv_sec = ts.tv_sec;
-    tv->tv_usec = ts.tv_nsec/1000;
-}
-
-static void init_list(struct ril_event * list)
-{
-    memset(list, 0, sizeof(struct ril_event));
-    list->next = list;
-    list->prev = list;
-    list->fd = -1;
-}
-
-static void addToList(struct ril_event * ev, struct ril_event * list)
-{
-    ev->next = list;
-    ev->prev = list->prev;
-    ev->prev->next = ev;
-    list->prev = ev;
-    dump_event(ev);
-}
-
-static void removeFromList(struct ril_event * ev)
-{
-    dlog("~~~~ +removeFromList ~~~~");
-    dump_event(ev);
-
-    ev->next->prev = ev->prev;
-    ev->prev->next = ev->next;
-    ev->next = NULL;
-    ev->prev = NULL;
-    dlog("~~~~ -removeFromList ~~~~");
-}
-
-
-static void removeWatch(struct ril_event * ev, int index)
-{
-    dlog("~~~~ +removeWatch ~~~~");
-    watch_table[index] = NULL;
-    ev->index = -1;
-
-    FD_CLR(ev->fd, &readFds);
-
-    if (ev->fd+1 == nfds) {
-        int n = 0;
-
-        for (int i = 0; i < MAX_FD_EVENTS; i++) {
-            struct ril_event * rev = watch_table[i];
-
-            if ((rev != NULL) && (rev->fd > n)) {
-                n = rev->fd;
-            }
-        }
-        nfds = n + 1;
-        dlog("~~~~ nfds = %d ~~~~", nfds);
-    }
-    dlog("~~~~ -removeWatch ~~~~");
-}
-
-static void processTimeouts()
-{
-    dlog("~~~~ +processTimeouts ~~~~");
-    MUTEX_ACQUIRE();
-    struct timeval now;
-    struct ril_event * tev = timer_list.next;
-    struct ril_event * next;
-
-    getNow(&now);
-    // walk list, see if now >= ev->timeout for any events
-
-    dlog("~~~~ Looking for timers <= %ds + %dus ~~~~", (int)now.tv_sec, (int)now.tv_usec);
-    while ((tev != &timer_list) && (timercmp(&now, &tev->timeout, >))) {
-        // Timer expired
-        dlog("~~~~ firing timer ~~~~");
-        next = tev->next;
-        removeFromList(tev);
-        addToList(tev, &pending_list);
-        tev = next;
-    }
-    MUTEX_RELEASE();
-    dlog("~~~~ -processTimeouts ~~~~");
-}
-
-static void processReadReadies(fd_set * rfds, int n)
-{
-    dlog("~~~~ +processReadReadies (%d) ~~~~", n);
-    MUTEX_ACQUIRE();
-
-    for (int i = 0; (i < MAX_FD_EVENTS) && (n > 0); i++) {
-        struct ril_event * rev = watch_table[i];
-        if (rev != NULL && FD_ISSET(rev->fd, rfds)) {
-            addToList(rev, &pending_list);
-            if (rev->persist == false) {
-                removeWatch(rev, i);
-            }
-            n--;
-        }
-    }
-
-    MUTEX_RELEASE();
-    dlog("~~~~ -processReadReadies (%d) ~~~~", n);
-}
-
-static void firePending()
-{
-    dlog("~~~~ +firePending ~~~~");
-    struct ril_event * ev = pending_list.next;
-    while (ev != &pending_list) {
-        struct ril_event * next = ev->next;
-        removeFromList(ev);
-        ev->func(ev->fd, 0, ev->param);
-        ev = next;
-    }
-    dlog("~~~~ -firePending ~~~~");
-}
-
-static int calcNextTimeout(struct timeval * tv)
-{
-    struct ril_event * tev = timer_list.next;
-    struct timeval now;
-
-    getNow(&now);
-
-    // Sorted list, so calc based on first node
-    if (tev == &timer_list) {
-        // no pending timers
-        return -1;
-    }
-
-    dlog("~~~~ now = %ds + %dus ~~~~", (int)now.tv_sec, (int)now.tv_usec);
-    dlog("~~~~ next = %ds + %dus ~~~~",
-            (int)tev->timeout.tv_sec, (int)tev->timeout.tv_usec);
-    if (timercmp(&tev->timeout, &now, >)) {
-        timersub(&tev->timeout, &now, tv);
-    } else {
-        // timer already expired.
-        tv->tv_sec = tv->tv_usec = 0;
-    }
-    return 0;
-}
-
-// Initialize internal data structs
-void ril_event_init()
-{
-    MUTEX_INIT();
-
-    FD_ZERO(&readFds);
-    init_list(&timer_list);
-    init_list(&pending_list);
-    memset(watch_table, 0, sizeof(watch_table));
-}
-
-// Initialize an event
-void ril_event_set(struct ril_event * ev, int fd, bool persist, ril_event_cb func, void * param)
-{
-    dlog("~~~~ ril_event_set %x ~~~~", (unsigned int)ev);
-    memset(ev, 0, sizeof(struct ril_event));
-    ev->fd = fd;
-    ev->index = -1;
-    ev->persist = persist;
-    ev->func = func;
-    ev->param = param;
-    fcntl(fd, F_SETFL, O_NONBLOCK);
-}
-
-// Add event to watch list
-void ril_event_add(struct ril_event * ev)
-{
-    dlog("~~~~ +ril_event_add ~~~~");
-    MUTEX_ACQUIRE();
-    for (int i = 0; i < MAX_FD_EVENTS; i++) {
-        if (watch_table[i] == NULL) {
-            watch_table[i] = ev;
-            ev->index = i;
-            dlog("~~~~ added at %d ~~~~", i);
-            dump_event(ev);
-            FD_SET(ev->fd, &readFds);
-            if (ev->fd >= nfds) nfds = ev->fd+1;
-            dlog("~~~~ nfds = %d ~~~~", nfds);
-            break;
-        }
-    }
-    MUTEX_RELEASE();
-    dlog("~~~~ -ril_event_add ~~~~");
-}
-
-// Add timer event
-void ril_timer_add(struct ril_event * ev, struct timeval * tv)
-{
-    dlog("~~~~ +ril_timer_add ~~~~");
-    MUTEX_ACQUIRE();
-
-    struct ril_event * list;
-    if (tv != NULL) {
-        // add to timer list
-        list = timer_list.next;
-        ev->fd = -1; // make sure fd is invalid
-
-        struct timeval now;
-        getNow(&now);
-        timeradd(&now, tv, &ev->timeout);
-
-        // keep list sorted
-        while (timercmp(&list->timeout, &ev->timeout, < )
-                && (list != &timer_list)) {
-            list = list->next;
-        }
-        // list now points to the first event older than ev
-        addToList(ev, list);
-    }
-
-    MUTEX_RELEASE();
-    dlog("~~~~ -ril_timer_add ~~~~");
-}
-
-// Remove event from watch or timer list
-void ril_event_del(struct ril_event * ev)
-{
-    dlog("~~~~ +ril_event_del ~~~~");
-    MUTEX_ACQUIRE();
-
-    if (ev->index < 0 || ev->index >= MAX_FD_EVENTS) {
-        MUTEX_RELEASE();
-        return;
-    }
-
-    removeWatch(ev, ev->index);
-
-    MUTEX_RELEASE();
-    dlog("~~~~ -ril_event_del ~~~~");
-}
-
-#if DEBUG
-static void printReadies(fd_set * rfds)
-{
-    for (int i = 0; (i < MAX_FD_EVENTS); i++) {
-        struct ril_event * rev = watch_table[i];
-        if (rev != NULL && FD_ISSET(rev->fd, rfds)) {
-          dlog("DON: fd=%d is ready", rev->fd);
-        }
-    }
-}
-#else
-#define printReadies(rfds) do {} while(0)
-#endif
-
-void ril_event_loop()
-{
-    int n;
-    fd_set rfds;
-    struct timeval tv;
-    struct timeval * ptv;
-
-
-    for (;;) {
-
-        // make local copy of read fd_set
-        memcpy(&rfds, &readFds, sizeof(fd_set));
-        if (-1 == calcNextTimeout(&tv)) {
-            // no pending timers; block indefinitely
-            dlog("~~~~ no timers; blocking indefinitely ~~~~");
-            ptv = NULL;
-        } else {
-            dlog("~~~~ blocking for %ds + %dus ~~~~", (int)tv.tv_sec, (int)tv.tv_usec);
-            ptv = &tv;
-        }
-        printReadies(&rfds);
-        n = select(nfds, &rfds, NULL, NULL, ptv);
-        printReadies(&rfds);
-        dlog("~~~~ %d events fired ~~~~", n);
-        if (n < 0) {
-            if (errno == EINTR) continue;
-
-            RLOGE("ril_event: select error (%d)", errno);
-            // bail?
-            return;
-        }
-
-        // Check for timeouts
-        processTimeouts();
-        // Check for read-ready
-        processReadReadies(&rfds, n);
-        // Fire away
-        firePending();
-    }
-}
diff --git a/libril/ril_event.h b/libril/ril_event.h
deleted file mode 100644
index 7ba231b..0000000
--- a/libril/ril_event.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/* //device/libs/telephony/ril_event.h
-**
-** Copyright 2008, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-// Max number of fd's we watch at any one time.  Increase if necessary.
-#define MAX_FD_EVENTS 8
-
-typedef void (*ril_event_cb)(int fd, short events, void *userdata);
-
-struct ril_event {
-    struct ril_event *next;
-    struct ril_event *prev;
-
-    int fd;
-    int index;
-    bool persist;
-    struct timeval timeout;
-    ril_event_cb func;
-    void *param;
-};
-
-// Initialize internal data structs
-void ril_event_init();
-
-// Initialize an event
-void ril_event_set(struct ril_event * ev, int fd, bool persist, ril_event_cb func, void * param);
-
-// Add event to watch list
-void ril_event_add(struct ril_event * ev);
-
-// Add timer event
-void ril_timer_add(struct ril_event * ev, struct timeval * tv);
-
-// Remove event from watch list
-void ril_event_del(struct ril_event * ev);
-
-// Event loop
-void ril_event_loop();
-
diff --git a/libril/ril_unsol_commands.h b/libril/ril_unsol_commands.h
deleted file mode 100755
index eb9e12d..0000000
--- a/libril/ril_unsol_commands.h
+++ /dev/null
@@ -1,62 +0,0 @@
-/* //device/libs/telephony/ril_unsol_commands.h
-**
-** Copyright 2006, The Android Open Source Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-    {RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED, responseVoid, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED, responseVoid, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED, responseVoid, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_NEW_SMS, responseString, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT, responseString, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM, responseInts, WAKE_PARTIAL},
-    {RIL_UNSOL_ON_USSD, responseStrings, WAKE_PARTIAL},
-    {RIL_UNSOL_ON_USSD_REQUEST, responseVoid, DONT_WAKE},
-    {RIL_UNSOL_NITZ_TIME_RECEIVED, responseString, WAKE_PARTIAL},
-    {RIL_UNSOL_SIGNAL_STRENGTH, responseRilSignalStrength, DONT_WAKE},
-    {RIL_UNSOL_DATA_CALL_LIST_CHANGED, responseDataCallList, WAKE_PARTIAL},
-    {RIL_UNSOL_SUPP_SVC_NOTIFICATION, responseSsn, WAKE_PARTIAL},
-    {RIL_UNSOL_STK_SESSION_END, responseVoid, WAKE_PARTIAL},
-    {RIL_UNSOL_STK_PROACTIVE_COMMAND, responseString, WAKE_PARTIAL},
-    {RIL_UNSOL_STK_EVENT_NOTIFY, responseString, WAKE_PARTIAL},
-    {RIL_UNSOL_STK_CALL_SETUP, responseInts, WAKE_PARTIAL},
-    {RIL_UNSOL_SIM_SMS_STORAGE_FULL, responseVoid, WAKE_PARTIAL},
-    {RIL_UNSOL_SIM_REFRESH, responseSimRefresh, WAKE_PARTIAL},
-    {RIL_UNSOL_CALL_RING, responseCallRing, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED, responseVoid, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_CDMA_NEW_SMS, responseCdmaSms, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS, responseRaw, WAKE_PARTIAL},
-    {RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL, responseVoid, WAKE_PARTIAL},
-    {RIL_UNSOL_RESTRICTED_STATE_CHANGED, responseInts, WAKE_PARTIAL},
-    {RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE, responseVoid, WAKE_PARTIAL},
-    {RIL_UNSOL_CDMA_CALL_WAITING, responseCdmaCallWaiting, WAKE_PARTIAL},
-    {RIL_UNSOL_CDMA_OTA_PROVISION_STATUS, responseInts, WAKE_PARTIAL},
-    {RIL_UNSOL_CDMA_INFO_REC, responseCdmaInformationRecords, WAKE_PARTIAL},
-    {RIL_UNSOL_OEM_HOOK_RAW, responseRaw, WAKE_PARTIAL},
-    {RIL_UNSOL_RINGBACK_TONE, responseInts, WAKE_PARTIAL},
-    {RIL_UNSOL_RESEND_INCALL_MUTE, responseVoid, WAKE_PARTIAL},
-    {RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED, responseInts, WAKE_PARTIAL},
-    {RIL_UNSOL_CDMA_PRL_CHANGED, responseInts, WAKE_PARTIAL},
-    {RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE, responseVoid, WAKE_PARTIAL},
-    {RIL_UNSOL_RIL_CONNECTED, responseInts, WAKE_PARTIAL},
-    {RIL_UNSOL_VOICE_RADIO_TECH_CHANGED, responseInts, WAKE_PARTIAL},
-    {RIL_UNSOL_CELL_INFO_LIST, responseCellInfoList, WAKE_PARTIAL},
-    {RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED, responseVoid, WAKE_PARTIAL},
-    {RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED, responseInts, WAKE_PARTIAL},
-    {RIL_UNSOL_SRVCC_STATE_NOTIFY, responseInts, WAKE_PARTIAL},
-    {RIL_UNSOL_HARDWARE_CONFIG_CHANGED, responseHardwareConfig, WAKE_PARTIAL},
-    {RIL_UNSOL_DC_RT_INFO_CHANGED, responseDcRtInfo, WAKE_PARTIAL},
-    {RIL_UNSOL_RADIO_CAPABILITY, responseRadioCapability, WAKE_PARTIAL},
-    {RIL_UNSOL_ON_SS, responseSSData, WAKE_PARTIAL},
-    {RIL_UNSOL_STK_CC_ALPHA_NOTIFY, responseString, WAKE_PARTIAL},
-    {RIL_UNSOL_LCEDATA_RECV, responseLceData, WAKE_PARTIAL},
-- 
2.5.0

