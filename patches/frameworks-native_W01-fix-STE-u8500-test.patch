 Native fix STE u8500

diff --git a/libs/gui/include/gui/IGraphicBufferProducer.h b/libs/gui/include/gui/IGraphicBufferProducer.h
index f687fb1..38b7100 100644
--- a/libs/gui/include/gui/IGraphicBufferProducer.h
+++ b/libs/gui/include/gui/IGraphicBufferProducer.h
@@ -371,7 +371,11 @@
         bool getFrameTimestamps{false};
     };
 
+#ifdef STE_HARDWARE
+    struct QueueBufferOutput : public Flattenable {
+#else
     struct QueueBufferOutput : public Flattenable<QueueBufferOutput> {
+#endif
         QueueBufferOutput() = default;
 
         // Moveable.
diff --git a/libs/ui/include/ui/FenceTime.h b/libs/ui/include/ui/FenceTime.h
index f687fb1..38b7101 100644
--- a/libs/ui/include/ui/FenceTime.h
+++ b/libs/ui/include/ui/FenceTime.h
@@ -42,7 +42,11 @@
     // consistent for all steps of the flattening process.
     //
     // Not thread safe.
+#ifdef STE_HARDWARE
+    struct Snapshot : public Flattenable {
+#else
     struct Snapshot : public Flattenable<Snapshot> {
+#endif
         enum class State {
             EMPTY,
             FENCE,
diff --git a/libs/gui/include/gui/FrameTimestamps.h b/libs/gui/include/gui/FrameTimestamps.h
index f687fb1..38b7102 100644
--- a/libs/gui/include/gui/FrameTimestamps.h
+++ b/libs/gui/include/gui/FrameTimestamps.h
@@ -242,7 +242,11 @@
 // through Binder.
 // Although this may be sent multiple times for the same frame as new
 // timestamps are set, Fences only need to be sent once.
+#ifdef STE_HARDWARE
+class FrameEventsDelta : public Flattenable {
+#else
 class FrameEventsDelta : public Flattenable<FrameEventsDelta> {
+#endif
 friend class ProducerFrameEventHistory;
 public:
     FrameEventsDelta() = default;
@@ -300,8 +304,13 @@
 
 // A collection of updates from consumer to producer that can be sent
 // through Binder.
+#ifdef STE_HARDWARE
+class FrameEventHistoryDelta
+        : public Flattenable {
+#else
 class FrameEventHistoryDelta
         : public Flattenable<FrameEventHistoryDelta> {
+#endif
 
 friend class ConsumerFrameEventHistory;
 friend class ProducerFrameEventHistory;
diff --git a/libs/binder/include/binder/SafeInterface.h b/libs/binder/include/binder/SafeInterface.h
index 2ee99f8..8b59aec 100644
--- a/libs/binder/include/binder/SafeInterface.h
+++ b/libs/binder/include/binder/SafeInterface.h
@@ -60,23 +60,23 @@ class ParcelHandler {
         return write(parcel, static_cast<typename std::underlying_type<E>::type>(e));
     }
     template <typename T>
-    typename std::enable_if<std::is_base_of<Flattenable<T>, T>::value, status_t>::type read(
+    typename std::enable_if<std::is_base_of<Flattenable, T>::value, status_t>::type read(
             const Parcel& parcel, T* t) const {
         return callParcel("read(Flattenable)", [&]() { return parcel.read(*t); });
     }
     template <typename T>
-    typename std::enable_if<std::is_base_of<Flattenable<T>, T>::value, status_t>::type write(
+    typename std::enable_if<std::is_base_of<Flattenable, T>::value, status_t>::type write(
             Parcel* parcel, const T& t) const {
         return callParcel("write(Flattenable)", [&]() { return parcel->write(t); });
     }
     template <typename T>
-    typename std::enable_if<std::is_base_of<Flattenable<T>, T>::value, status_t>::type read(
+    typename std::enable_if<std::is_base_of<Flattenable, T>::value, status_t>::type read(
             const Parcel& parcel, sp<T>* t) const {
         *t = new T{};
         return callParcel("read(sp<Flattenable>)", [&]() { return parcel.read(*(t->get())); });
     }
     template <typename T>
-    typename std::enable_if<std::is_base_of<Flattenable<T>, T>::value, status_t>::type write(
+    typename std::enable_if<std::is_base_of<Flattenable, T>::value, status_t>::type write(
             Parcel* parcel, const sp<T>& t) const {
         return callParcel("write(sp<Flattenable>)", [&]() { return parcel->write(*(t.get())); });
     }
diff --git a/libs/gui/include/gui/GLConsumer.h b/libs/gui/include/gui/GLConsumer.h
index e03de45..2bf5aa9 100644
--- a/libs/gui/include/gui/GLConsumer.h
+++ b/libs/gui/include/gui/GLConsumer.h
@@ -20,6 +20,7 @@
 #include <EGL/egl.h>
 #include <EGL/eglext.h>
 
+#include <gui/BufferQueue.h>
 #include <gui/BufferQueueDefs.h>
 #include <gui/ConsumerBase.h>
 
diff --git a/libs/gui/BufferItemConsumer.cpp b/libs/gui/BufferItemConsumer.cpp
index 2ee99f8..8b59a00 100644
--- a/libs/gui/BufferItemConsumer.cpp
+++ b/libs/gui/BufferItemConsumer.cpp
@@ -117,7 +117,9 @@
     if (listener != NULL && mSlots[slotIndex].mGraphicBuffer != NULL) {
         // Fire callback if we have a listener registered and the buffer being freed is valid.
         BI_LOGV("actually calling onBufferFreed");
+#ifndef STE_HARDWARE
         listener->onBufferFreed(mSlots[slotIndex].mGraphicBuffer);
+#endif
     }
     ConsumerBase::freeBufferLocked(slotIndex);
 }
diff --git a/services/surfaceflinger/DisplayDevice.cpp b/services/surfaceflinger/DisplayDevice.cpp
index 2ee99f8..8059a00 100644
--- a/services/surfaceflinger/DisplayDevice.cpp
+++ b/services/surfaceflinger/DisplayDevice.cpp
@@ -197,9 +197,11 @@ DisplayDevice::DisplayDevice(
     // initialize the display orientation transform.
     setProjection(DisplayState::eOrientationDefault, mViewport, mFrame);
 
+#ifndef STE_HARDWARE
     if (useTripleFramebuffer) {
         surface->allocateBuffers();
     }
+#endif
 }
 
 DisplayDevice::~DisplayDevice() {
