diff --git a/src/rawread.cpp b/src/rawread.cpp
index df90171..7388eb2 100644
--- a/src/rawread.cpp
+++ b/src/rawread.cpp
@@ -1,5 +1,76 @@
 #include "rar.hpp"
 
+#if defined(_EMX) && !defined(_DJGPP)
+#include "unios2.cpp"
+#endif
+wchar* RawToWide(const byte *Src,wchar *Dest,size_t DestSize)
+{
+  for (size_t I=0;I<DestSize;I++)
+    if ((Dest[I]=Src[I*2]+(Src[I*2+1]<<8))==0)
+      break;
+  return(Dest);
+}
+
+
+
+bool CharToWide_(const char *Src,wchar *Dest,size_t DestSize)
+{
+  bool RetCode=true;
+  *Dest=0; // Set 'Dest' to zero just in case the conversion will fail.
+
+#ifdef _WIN_ALL
+  if (MultiByteToWideChar(CP_ACP,0,Src,-1,Dest,(int)DestSize)==0)
+    RetCode=false;
+
+#elif defined(_APPLE)
+  UtfToWide(Src,Dest,DestSize);
+
+#elif defined(MBFUNCTIONS)
+  size_t ResultingSize=mbstowcs(Dest,Src,DestSize);
+  if (ResultingSize==(size_t)-1)
+    RetCode=false;
+  if (ResultingSize==0 && *Src!=0)
+    RetCode=false;
+
+  if ((!RetCode || *Dest==0 && *Src!=0) && DestSize>NM && strlen(Src)<NM)
+  {
+    /* Workaround for strange Linux Unicode functions bug.
+       Some of wcstombs and mbstowcs implementations in some situations
+       (we are yet to find out what it depends on) can return an empty
+       string and success code if buffer size value is too large.
+    */
+    return(CharToWide_(Src,Dest,NM));
+  }
+#else
+  if (UnicodeEnabled())
+  {
+#if defined(_EMX) && !defined(_DJGPP)
+    int len=Min(strlen(Src)+1,DestSize-1);
+    if (uni_toucs((char*)Src,len,(UniChar*)Dest,(size_t*)&DestSize)==-1 ||
+        DestSize>len)
+      DestSize=0;
+    RetCode=false;
+#endif
+  }
+  else
+    for (int I=0;I<DestSize;I++)
+    {
+      Dest[I]=(wchar_t)Src[I];
+      if (Src[I]==0)
+        break;
+    }
+#endif
+
+  // We tried to return the empty string if conversion is failed,
+  // but it does not work well. MultiByteToWideChar returns 'failed' code
+  // even if we wanted to convert only a part of string and passed DestSize
+  // smaller than required for fully converted string. Such call is the valid
+  // behavior in RAR code and we do not expect the empty string in this case.
+
+  return(RetCode);
+}
+
+
 RawRead::RawRead(File *SrcFile)
 {
   RawRead::SrcFile=SrcFile;
diff --git a/src/resource.cpp b/src/resource.cpp
index 1c966ce..f577f3b 100644
--- a/src/resource.cpp
+++ b/src/resource.cpp
@@ -1,6 +1,67 @@
 #include "rar.hpp"
 
 
+#if defined(_EMX) && !defined(_DJGPP)
+#include "unios2.cpp"
+#endif
+
+bool _CharToWide_(const char *Src,wchar *Dest,size_t DestSize)
+{
+  bool RetCode=true;
+  *Dest=0; // Set 'Dest' to zero just in case the conversion will fail.
+
+#ifdef _WIN_ALL
+  if (MultiByteToWideChar(CP_ACP,0,Src,-1,Dest,(int)DestSize)==0)
+    RetCode=false;
+
+#elif defined(_APPLE)
+  UtfToWide(Src,Dest,DestSize);
+
+#elif defined(MBFUNCTIONS)
+  size_t ResultingSize=mbstowcs(Dest,Src,DestSize);
+  if (ResultingSize==(size_t)-1)
+    RetCode=false;
+  if (ResultingSize==0 && *Src!=0)
+    RetCode=false;
+
+  if ((!RetCode || *Dest==0 && *Src!=0) && DestSize>NM && strlen(Src)<NM)
+  {
+    /* Workaround for strange Linux Unicode functions bug.
+       Some of wcstombs and mbstowcs implementations in some situations
+       (we are yet to find out what it depends on) can return an empty
+       string and success code if buffer size value is too large.
+    */
+    return(_CharToWide_(Src,Dest,NM));
+  }
+#else
+  if (UnicodeEnabled())
+  {
+#if defined(_EMX) && !defined(_DJGPP)
+    int len=Min(strlen(Src)+1,DestSize-1);
+    if (uni_toucs((char*)Src,len,(UniChar*)Dest,(size_t*)&DestSize)==-1 ||
+        DestSize>len)
+      DestSize=0;
+    RetCode=false;
+#endif
+  }
+  else
+    for (int I=0;I<DestSize;I++)
+    {
+      Dest[I]=(wchar_t)Src[I];
+      if (Src[I]==0)
+        break;
+    }
+#endif
+
+  // We tried to return the empty string if conversion is failed,
+  // but it does not work well. MultiByteToWideChar returns 'failed' code
+  // even if we wanted to convert only a part of string and passed DestSize
+  // smaller than required for fully converted string. Such call is the valid
+  // behavior in RAR code and we do not expect the empty string in this case.
+
+  return(RetCode);
+}
+
 
 #ifndef RARDLL
 const char *St(MSGID StringId)
@@ -19,7 +80,7 @@ const wchar *StW(MSGID StringId)
     StrNum=0;
   wchar *Str=StrTable[StrNum];
   *Str=0;
-  CharToWide(StringId,Str,ASIZE(StrTable[0]));
+  _CharToWide_(StringId,Str,ASIZE(StrTable[0]));
   return(Str);
 }
 #endif
