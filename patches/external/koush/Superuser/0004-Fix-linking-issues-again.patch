From 888e3898b4ceca0932f12aa82e527ab573625085 Mon Sep 17 00:00:00 2001
From: Shilin Victor <chrono.monochrome@gmail.com>
Date: Sat, 21 May 2016 18:52:12 +0700
Subject: [PATCH 4/5] Fix linking issues [again]

---
 Android.mk                  |   2 +-
 Superuser/jni/Android.mk    |   4 +-
 Superuser/jni/activity.c    | 208 ++++++++++
 Superuser/jni/daemon.c      | 658 +++++++++++++++++++++++++++++++
 Superuser/jni/db.c          | 105 +++++
 Superuser/jni/pts.c         | 336 ++++++++++++++++
 Superuser/jni/pts.h         | 116 ++++++
 Superuser/jni/su.c          | 934 ++++++++++++++++++++++++++++++++++++++++++++
 Superuser/jni/su.h          | 173 ++++++++
 Superuser/jni/su/activity.c | 208 ----------
 Superuser/jni/su/daemon.c   | 658 -------------------------------
 Superuser/jni/su/db.c       | 105 -----
 Superuser/jni/su/pts.c      | 336 ----------------
 Superuser/jni/su/pts.h      | 116 ------
 Superuser/jni/su/su.c       | 929 -------------------------------------------
 Superuser/jni/su/su.h       | 173 --------
 Superuser/jni/su/utils.c    | 112 ------
 Superuser/jni/su/utils.h    |  30 --
 Superuser/jni/utils.c       | 112 ++++++
 Superuser/jni/utils.h       |  30 ++
 20 files changed, 2675 insertions(+), 2670 deletions(-)
 create mode 100644 Superuser/jni/activity.c
 create mode 100644 Superuser/jni/daemon.c
 create mode 100644 Superuser/jni/db.c
 create mode 100644 Superuser/jni/pts.c
 create mode 100644 Superuser/jni/pts.h
 create mode 100644 Superuser/jni/su.c
 create mode 100644 Superuser/jni/su.h
 delete mode 100644 Superuser/jni/su/activity.c
 delete mode 100644 Superuser/jni/su/daemon.c
 delete mode 100644 Superuser/jni/su/db.c
 delete mode 100644 Superuser/jni/su/pts.c
 delete mode 100644 Superuser/jni/su/pts.h
 delete mode 100644 Superuser/jni/su/su.c
 delete mode 100644 Superuser/jni/su/su.h
 delete mode 100644 Superuser/jni/su/utils.c
 delete mode 100644 Superuser/jni/su/utils.h
 create mode 100644 Superuser/jni/utils.c
 create mode 100644 Superuser/jni/utils.h

diff --git a/Android.mk b/Android.mk
index 4708076..315fa78 100644
--- a/Android.mk
+++ b/Android.mk
@@ -21,7 +21,7 @@ LOCAL_MODULE_TAGS := optional
 LOCAL_FORCE_STATIC_EXECUTABLE := true
 LOCAL_STATIC_LIBRARIES := libc libcutils liblog
 LOCAL_C_INCLUDES := external/sqlite/dist
-LOCAL_SRC_FILES := Superuser/jni/su/su.c Superuser/jni/su/daemon.c Superuser/jni/su/activity.c Superuser/jni/su/db.c Superuser/jni/su/utils.c Superuser/jni/su/pts.c ../../sqlite/dist/sqlite3.c
+LOCAL_SRC_FILES := Superuser/jni/su.c Superuser/jni/daemon.c Superuser/jni/activity.c Superuser/jni/db.c Superuser/jni/utils.c Superuser/jni/pts.c ../../sqlite/dist/sqlite3.c
 LOCAL_CFLAGS := -DSQLITE_OMIT_LOAD_EXTENSION -DREQUESTOR=\"$(SUPERUSER_PACKAGE)\"
 
 ifdef SUPERUSER_PACKAGE_PREFIX
diff --git a/Superuser/jni/Android.mk b/Superuser/jni/Android.mk
index 04c7b8b..93f57df 100644
--- a/Superuser/jni/Android.mk
+++ b/Superuser/jni/Android.mk
@@ -4,9 +4,9 @@ include $(CLEAR_VARS)
 
 LOCAL_MODULE := su
 LOCAL_FORCE_STATIC_EXECUTABLE := true
-LOCAL_STATIC_LIBRARIES := sqlite3 libcutils libc
+LOCAL_STATIC_LIBRARIES := sqlite3 libc_nolto
 LOCAL_C_INCLUDES := $(LOCAL_PATH)/sqlite3
-LOCAL_SRC_FILES := su/su.c su/activity.c su/db.c su/utils.c su/daemon.c su/pts.c
+LOCAL_SRC_FILES := su.c activity.c db.c utils.c daemon.c pts.c
 include $(BUILD_EXECUTABLE)
 
 
diff --git a/Superuser/jni/activity.c b/Superuser/jni/activity.c
new file mode 100644
index 0000000..a3ef9c7
--- /dev/null
+++ b/Superuser/jni/activity.c
@@ -0,0 +1,208 @@
+/*
+** Copyright 2010, Adam Shanks (@ChainsDD)
+** Copyright 2008, Zinx Verituse (@zinxv)
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <paths.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+#include "su.h"
+
+/* intent actions */
+#define ACTION_REQUEST "start", "-n", REQUESTOR "/" REQUESTOR_PREFIX ".RequestActivity"
+#define ACTION_NOTIFY "start", "-n", REQUESTOR "/" REQUESTOR_PREFIX ".NotifyActivity"
+#define ACTION_RESULT "broadcast", "-n", REQUESTOR "/" REQUESTOR_PREFIX ".SuReceiver"
+
+#define AM_PATH "/system/bin/app_process", "/system/bin", "com.android.commands.am.Am"
+
+// TODO: leverage this with exec_log?
+int silent_run(char* const args[]) {
+    set_identity(0);
+    pid_t pid;
+    pid = fork();
+    /* Parent */
+    if (pid < 0) {
+        PLOGE("fork");
+        return -1;
+    }
+    else if (pid > 0) {
+        return 0;
+    }
+    int zero = open("/dev/zero", O_RDONLY | O_CLOEXEC);
+    dup2(zero, 0);
+    int null = open("/dev/null", O_WRONLY | O_CLOEXEC);
+    dup2(null, 1);
+    dup2(null, 2);
+    setenv("CLASSPATH", "/system/framework/am.jar", 1);
+    execv(args[0], args);
+    PLOGE("exec am");
+    _exit(EXIT_FAILURE);
+    return -1;
+}
+
+int get_owner_login_user_args(struct su_context *ctx, char* user, int user_len) {
+    int needs_owner_login_prompt = 0;
+    
+    if (ctx->user.multiuser_mode == MULTIUSER_MODE_OWNER_MANAGED) {
+        if (0 != ctx->user.android_user_id) {
+            needs_owner_login_prompt = 1;
+        }
+        snprintf(user, user_len, "0");
+    }
+    else if (ctx->user.multiuser_mode == MULTIUSER_MODE_USER) {
+        snprintf(user, user_len, "%d", ctx->user.android_user_id);
+    }
+    else if (ctx->user.multiuser_mode == MULTIUSER_MODE_NONE) {
+        user[0] = '\0';
+    }
+    else {
+        snprintf(user, user_len, "0");
+    }
+    
+    return needs_owner_login_prompt;
+}
+
+int send_result(struct su_context *ctx, policy_t policy) {
+    char binary_version[256];
+    sprintf(binary_version, "%d", VERSION_CODE);
+
+    char uid[256];
+    sprintf(uid, "%d", ctx->from.uid);
+
+    char desired_uid[256];
+    sprintf(desired_uid, "%d", ctx->to.uid);
+
+    char user[64];
+    get_owner_login_user_args(ctx, user, sizeof(user));
+
+    if (0 != ctx->user.android_user_id) {
+        char android_user_id[256];
+        sprintf(android_user_id, "%d", ctx->user.android_user_id);
+
+        char *user_result_command[] = {
+            AM_PATH,
+            ACTION_RESULT,
+            "--ei",
+            "binary_version",
+            binary_version,
+            "--es",
+            "from_name",
+            ctx->from.name,
+            "--es",
+            "desired_name",
+            ctx->to.name,
+            "--ei",
+            "uid",
+            uid,
+            "--ei",
+            "desired_uid",
+            desired_uid,
+            "--es",
+            "command",
+            get_command(&ctx->to),
+            "--es",
+            "action",
+            policy == ALLOW ? "allow" : "deny",
+            user[0] ? "--user" : NULL,
+            android_user_id,
+            NULL
+        };
+        silent_run(user_result_command);
+    }
+
+    char *result_command[] = {
+        AM_PATH,
+        ACTION_RESULT,
+        "--ei",
+        "binary_version",
+        binary_version,
+        "--es",
+        "from_name",
+        ctx->from.name,
+        "--es",
+        "desired_name",
+        ctx->to.name,
+        "--ei",
+        "uid",
+        uid,
+        "--ei",
+        "desired_uid",
+        desired_uid,
+        "--es",
+        "command",
+        get_command(&ctx->to),
+        "--es",
+        "action",
+        policy == ALLOW ? "allow" : "deny",
+        user[0] ? "--user" : NULL,
+        user,
+        NULL
+    };
+    return silent_run(result_command);
+}
+
+int send_request(struct su_context *ctx) {
+    // if su is operating in MULTIUSER_MODEL_OWNER,
+    // and the user requestor is not the owner,
+    // the owner needs to be notified of the request.
+    // so there will be two activities shown.
+    char user[64];
+    int needs_owner_login_prompt = get_owner_login_user_args(ctx, user, sizeof(user));
+
+    int ret;
+    if (needs_owner_login_prompt) {
+        char uid[256];
+        sprintf(uid, "%d", ctx->from.uid);
+
+        char android_user_id[256];
+        sprintf(android_user_id, "%d", ctx->user.android_user_id);
+
+        // in multiuser mode, the owner gets the su prompt
+        char *notify_command[] = {
+            AM_PATH,
+            ACTION_NOTIFY,
+            "--ei",
+            "caller_uid",
+            uid,
+            "--user",
+            android_user_id,
+            NULL
+        };
+
+        int ret = silent_run(notify_command);
+        if (ret) {
+            return ret;
+        }
+    }
+
+    char *request_command[] = {
+        AM_PATH,
+        ACTION_REQUEST,
+        "--es",
+        "socket",
+        ctx->sock_path,
+        user[0] ? "--user" : NULL,
+        user,
+        NULL
+    };
+
+    return silent_run(request_command);
+}
diff --git a/Superuser/jni/daemon.c b/Superuser/jni/daemon.c
new file mode 100644
index 0000000..6a271d1
--- /dev/null
+++ b/Superuser/jni/daemon.c
@@ -0,0 +1,658 @@
+/*
+** Copyright 2010, Adam Shanks (@ChainsDD)
+** Copyright 2008, Zinx Verituse (@zinxv)
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#define _GNU_SOURCE /* for unshare() */
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <sys/wait.h>
+#include <sys/select.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <limits.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <stdint.h>
+#include <pwd.h>
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <stdarg.h>
+#include <sys/types.h>
+#include <pthread.h>
+#include <sched.h>
+#include <termios.h>
+#include <signal.h>
+#include <string.h>
+
+#ifdef SUPERUSER_EMBEDDED
+#include <cutils/multiuser.h>
+#endif
+
+#include "su.h"
+#include "utils.h"
+#include "pts.h"
+
+int is_daemon = 0;
+int daemon_from_uid = 0;
+int daemon_from_pid = 0;
+
+// Constants for the atty bitfield
+#define ATTY_IN     1
+#define ATTY_OUT    2
+#define ATTY_ERR    4
+
+/*
+ * Receive a file descriptor from a Unix socket.
+ * Contributed by @mkasick
+ *
+ * Returns the file descriptor on success, or -1 if a file
+ * descriptor was not actually included in the message
+ *
+ * On error the function terminates by calling exit(-1)
+ */
+static int recv_fd(int sockfd) {
+    // Need to receive data from the message, otherwise don't care about it.
+    char iovbuf;
+
+    struct iovec iov = {
+        .iov_base = &iovbuf,
+        .iov_len  = 1,
+    };
+
+    char cmsgbuf[CMSG_SPACE(sizeof(int))];
+
+    struct msghdr msg = {
+        .msg_iov        = &iov,
+        .msg_iovlen     = 1,
+        .msg_control    = cmsgbuf,
+        .msg_controllen = sizeof(cmsgbuf),
+    };
+
+    if (recvmsg(sockfd, &msg, MSG_WAITALL) != 1) {
+        goto error;
+    }
+
+    // Was a control message actually sent?
+    switch (msg.msg_controllen) {
+    case 0:
+        // No, so the file descriptor was closed and won't be used.
+        return -1;
+    case sizeof(cmsgbuf):
+        // Yes, grab the file descriptor from it.
+        break;
+    default:
+        goto error;
+    }
+
+    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
+
+    if (cmsg             == NULL                  ||
+        cmsg->cmsg_len   != CMSG_LEN(sizeof(int)) ||
+        cmsg->cmsg_level != SOL_SOCKET            ||
+        cmsg->cmsg_type  != SCM_RIGHTS) {
+error:
+        ALOGE("unable to read fd");
+        exit(-1);
+    }
+
+    return *(int *)CMSG_DATA(cmsg);
+}
+
+/*
+ * Send a file descriptor through a Unix socket.
+ * Contributed by @mkasick
+ *
+ * On error the function terminates by calling exit(-1)
+ *
+ * fd may be -1, in which case the dummy data is sent,
+ * but no control message with the FD is sent.
+ */
+static void send_fd(int sockfd, int fd) {
+    // Need to send some data in the message, this will do.
+    struct iovec iov = {
+        .iov_base = "",
+        .iov_len  = 1,
+    };
+
+    struct msghdr msg = {
+        .msg_iov        = &iov,
+        .msg_iovlen     = 1,
+    };
+
+    char cmsgbuf[CMSG_SPACE(sizeof(int))];
+
+    if (fd != -1) {
+        // Is the file descriptor actually open?
+        if (fcntl(fd, F_GETFD) == -1) {
+            if (errno != EBADF) {
+                goto error;
+            }
+            // It's closed, don't send a control message or sendmsg will EBADF.
+        } else {
+            // It's open, send the file descriptor in a control message.
+            msg.msg_control    = cmsgbuf;
+            msg.msg_controllen = sizeof(cmsgbuf);
+
+            struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
+
+            cmsg->cmsg_len   = CMSG_LEN(sizeof(int));
+            cmsg->cmsg_level = SOL_SOCKET;
+            cmsg->cmsg_type  = SCM_RIGHTS;
+
+            *(int *)CMSG_DATA(cmsg) = fd;
+        }
+    }
+
+    if (sendmsg(sockfd, &msg, 0) != 1) {
+error:
+        PLOGE("unable to send fd");
+        exit(-1);
+    }
+}
+
+static int read_int(int fd) {
+    int val;
+    int len = read(fd, &val, sizeof(int));
+    if (len != sizeof(int)) {
+        ALOGE("unable to read int: %d", len);
+        exit(-1);
+    }
+    return val;
+}
+
+static void write_int(int fd, int val) {
+    int written = write(fd, &val, sizeof(int));
+    if (written != sizeof(int)) {
+        PLOGE("unable to write int");
+        exit(-1);
+    }
+}
+
+static char* read_string(int fd) {
+    int len = read_int(fd);
+    if (len > PATH_MAX || len < 0) {
+        ALOGE("invalid string length %d", len);
+        exit(-1);
+    }
+    char* val = malloc(sizeof(char) * (len + 1));
+    if (val == NULL) {
+        ALOGE("unable to malloc string");
+        exit(-1);
+    }
+    val[len] = '\0';
+    int amount = read(fd, val, len);
+    if (amount != len) {
+        ALOGE("unable to read string");
+        exit(-1);
+    }
+    return val;
+}
+
+static void write_string(int fd, char* val) {
+    int len = strlen(val);
+    write_int(fd, len);
+    int written = write(fd, val, len);
+    if (written != len) {
+        PLOGE("unable to write string");
+        exit(-1);
+    }
+}
+
+#ifdef SUPERUSER_EMBEDDED
+static void mount_emulated_storage(int user_id) {
+    const char *emulated_source = getenv("EMULATED_STORAGE_SOURCE");
+    const char *emulated_target = getenv("EMULATED_STORAGE_TARGET");
+    const char* legacy = getenv("EXTERNAL_STORAGE");
+
+    if (!emulated_source || !emulated_target) {
+        // No emulated storage is present
+        return;
+    }
+
+    // Create a second private mount namespace for our process
+    if (unshare(CLONE_NEWNS) < 0) {
+        PLOGE("unshare");
+        return;
+    }
+
+    if (mount("rootfs", "/", NULL, MS_SLAVE | MS_REC, NULL) < 0) {
+        PLOGE("mount rootfs as slave");
+        return;
+    }
+
+    // /mnt/shell/emulated -> /storage/emulated
+    if (mount(emulated_source, emulated_target, NULL, MS_BIND, NULL) < 0) {
+        PLOGE("mount emulated storage");
+    }
+
+    char target_user[PATH_MAX];
+    snprintf(target_user, PATH_MAX, "%s/%d", emulated_target, user_id);
+
+    // /mnt/shell/emulated/<user> -> /storage/emulated/legacy
+    if (mount(target_user, legacy, NULL, MS_BIND | MS_REC, NULL) < 0) {
+        PLOGE("mount legacy path");
+    }
+}
+#endif
+
+static int run_daemon_child(int infd, int outfd, int errfd, int argc, char** argv) {
+    if (-1 == dup2(outfd, STDOUT_FILENO)) {
+        PLOGE("dup2 child outfd");
+        exit(-1);
+    }
+
+    if (-1 == dup2(errfd, STDERR_FILENO)) {
+        PLOGE("dup2 child errfd");
+        exit(-1);
+    }
+
+    if (-1 == dup2(infd, STDIN_FILENO)) {
+        PLOGE("dup2 child infd");
+        exit(-1);
+    }
+
+    close(infd);
+    close(outfd);
+    close(errfd);
+
+    return su_main(argc, argv, 0);
+}
+
+static int daemon_accept(int fd) {
+    char mypath[PATH_MAX], remotepath[PATH_MAX];
+    int caller_is_self = 0;
+
+    is_daemon = 1;
+    int pid = read_int(fd);
+    ALOGD("remote pid: %d", pid);
+    char *pts_slave = read_string(fd);
+    ALOGD("remote pts_slave: %s", pts_slave);
+    daemon_from_pid = read_int(fd);
+    ALOGV("remote req pid: %d", daemon_from_pid);
+
+    struct ucred credentials;
+    socklen_t ucred_length = sizeof(struct ucred);
+    /* fill in the user data structure */
+    if (getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &credentials, &ucred_length)) {
+        ALOGE("could obtain credentials from unix domain socket");
+        exit(-1);
+    }
+
+    daemon_from_uid = credentials.uid;
+
+    int mount_storage = read_int(fd);
+    // The the FDs for each of the streams
+    int infd  = recv_fd(fd);
+    int outfd = recv_fd(fd);
+    int errfd = recv_fd(fd);
+
+    int argc = read_int(fd);
+    if (argc < 0 || argc > 512) {
+        ALOGE("unable to allocate args: %d", argc);
+        exit(-1);
+    }
+    ALOGV("remote args: %d", argc);
+    char** argv = (char**)malloc(sizeof(char*) * (argc + 1));
+    argv[argc] = NULL;
+    int i;
+    for (i = 0; i < argc; i++) {
+        argv[i] = read_string(fd);
+    }
+
+    // ack
+    write_int(fd, 1);
+
+    // Fork the child process. The fork has to happen before calling
+    // setsid() and opening the pseudo-terminal so that the parent
+    // is not affected
+    int child = fork();
+    if (child < 0) {
+        // fork failed, send a return code and bail out
+        PLOGE("unable to fork");
+        write(fd, &child, sizeof(int));
+        close(fd);
+        return child;
+    }
+
+    if (child != 0) {
+        // In parent, wait for the child to exit, and send the exit code
+        // across the wire.
+        int status, code;
+
+        free(pts_slave);
+
+        ALOGD("waiting for child exit");
+        if (waitpid(child, &status, 0) > 0) {
+            code = WEXITSTATUS(status);
+        }
+        else {
+            code = -1;
+        }
+
+        // Pass the return code back to the client
+        ALOGD("sending code");
+        if (write(fd, &code, sizeof(int)) != sizeof(int)) {
+            PLOGE("unable to write exit code");
+        }
+
+        close(fd);
+        ALOGD("child exited");
+        return code;
+    }
+
+    // We are in the child now
+    // Close the unix socket file descriptor
+    close (fd);
+
+    // Become session leader
+    if (setsid() == (pid_t) -1) {
+        PLOGE("setsid");
+    }
+
+    int ptsfd;
+    if (pts_slave[0]) {
+        // Opening the TTY has to occur after the
+        // fork() and setsid() so that it becomes
+        // our controlling TTY and not the daemon's
+        ptsfd = open(pts_slave, O_RDWR);
+        if (ptsfd == -1) {
+            PLOGE("open(pts_slave) daemon");
+            exit(-1);
+        }
+
+        struct stat st;
+        if (fstat(ptsfd, &st)) {
+            PLOGE("failed to stat pts_slave");
+            exit(-1);
+        }
+
+        if (st.st_uid != credentials.uid) {
+            PLOGE("caller doesn't own proposed PTY");
+            exit(-1);
+        }
+
+        if (!S_ISCHR(st.st_mode)) {
+            PLOGE("proposed PTY isn't a chardev");
+            exit(-1);
+        }
+
+        if (infd < 0)  {
+            ALOGD("daemon: stdin using PTY");
+            infd  = ptsfd;
+        }
+        if (outfd < 0) {
+            ALOGD("daemon: stdout using PTY");
+            outfd = ptsfd;
+        }
+        if (errfd < 0) {
+            ALOGD("daemon: stderr using PTY");
+            errfd = ptsfd;
+        }
+    } else {
+        // TODO: Check system property, if PTYs are disabled,
+        // made infd the CTTY using:
+        // ioctl(infd, TIOCSCTTY, 1);
+    }
+    free(pts_slave);
+
+#ifdef SUPERUSER_EMBEDDED
+    if (mount_storage) {
+        mount_emulated_storage(multiuser_get_user_id(daemon_from_uid));
+    }
+#endif
+
+    return run_daemon_child(infd, outfd, errfd, argc, argv);
+}
+
+int run_daemon() {
+    if (getuid() != 0 || getgid() != 0) {
+        PLOGE("daemon requires root. uid/gid not root");
+        return -1;
+    }
+
+    int fd;
+    struct sockaddr_un sun;
+
+    fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+    if (fd < 0) {
+        PLOGE("socket");
+        return -1;
+    }
+    if (fcntl(fd, F_SETFD, FD_CLOEXEC)) {
+        PLOGE("fcntl FD_CLOEXEC");
+        goto err;
+    }
+
+    memset(&sun, 0, sizeof(sun));
+    sun.sun_family = AF_LOCAL;
+    sprintf(sun.sun_path, "%s/server", REQUESTOR_DAEMON_PATH);
+
+    /*
+     * Delete the socket to protect from situations when
+     * something bad occured previously and the kernel reused pid from that process.
+     * Small probability, isn't it.
+     */
+    unlink(sun.sun_path);
+    unlink(REQUESTOR_DAEMON_PATH);
+
+    int previous_umask = umask(027);
+    mkdir(REQUESTOR_DAEMON_PATH, 0777);
+
+    if (bind(fd, (struct sockaddr*)&sun, sizeof(sun)) < 0) {
+        PLOGE("daemon bind");
+        goto err;
+    }
+
+    chmod(REQUESTOR_DAEMON_PATH, 0755);
+    chmod(sun.sun_path, 0777);
+
+    umask(previous_umask);
+
+    if (listen(fd, 10) < 0) {
+        PLOGE("daemon listen");
+        goto err;
+    }
+
+    int client;
+    while ((client = accept(fd, NULL, NULL)) > 0) {
+        if (fork_zero_fucks() == 0) {
+            close(fd);
+            return daemon_accept(client);
+        }
+        else {
+            close(client);
+        }
+    }
+
+    ALOGE("daemon exiting");
+err:
+    close(fd);
+    return -1;
+}
+
+// List of signals which cause process termination
+static int quit_signals[] = { SIGALRM, SIGHUP, SIGPIPE, SIGQUIT, SIGTERM, SIGINT, 0 };
+
+static void sighandler(int sig) {
+    restore_stdin();
+
+    // Assume we'll only be called before death
+    // See note before sigaction() in set_stdin_raw()
+    //
+    // Now, close all standard I/O to cause the pumps
+    // to exit so we can continue and retrieve the exit
+    // code
+    close(STDIN_FILENO);
+    close(STDOUT_FILENO);
+    close(STDERR_FILENO);
+
+    // Put back all the default handlers
+    struct sigaction act;
+    int i;
+
+    memset(&act, '\0', sizeof(act));
+    act.sa_handler = SIG_DFL;
+    for (i = 0; quit_signals[i]; i++) {
+        if (sigaction(quit_signals[i], &act, NULL) < 0) {
+            PLOGE("Error removing signal handler");
+            continue;
+        }
+    }
+}
+
+/**
+ * Setup signal handlers trap signals which should result in program termination
+ * so that we can restore the terminal to its normal state and retrieve the 
+ * return code.
+ */
+static void setup_sighandlers(void) {
+    struct sigaction act;
+    int i;
+
+    // Install the termination handlers
+    // Note: we're assuming that none of these signal handlers are already trapped.
+    // If they are, we'll need to modify this code to save the previous handler and
+    // call it after we restore stdin to its previous state.
+    memset(&act, '\0', sizeof(act));
+    act.sa_handler = &sighandler;
+    for (i = 0; quit_signals[i]; i++) {
+        if (sigaction(quit_signals[i], &act, NULL) < 0) {
+            PLOGE("Error installing signal handler");
+            continue;
+        }
+    }
+}
+
+int connect_daemon(int argc, char *argv[], int ppid) {
+    int ptmx = -1;
+    char pts_slave[PATH_MAX];
+
+    struct sockaddr_un sun;
+
+    // Open a socket to the daemon
+    int socketfd = socket(AF_LOCAL, SOCK_STREAM, 0);
+    if (socketfd < 0) {
+        PLOGE("socket");
+        exit(-1);
+    }
+    if (fcntl(socketfd, F_SETFD, FD_CLOEXEC)) {
+        PLOGE("fcntl FD_CLOEXEC");
+        exit(-1);
+    }
+
+    memset(&sun, 0, sizeof(sun));
+    sun.sun_family = AF_LOCAL;
+    sprintf(sun.sun_path, "%s/server", REQUESTOR_DAEMON_PATH);
+
+    if (0 != connect(socketfd, (struct sockaddr*)&sun, sizeof(sun))) {
+        PLOGE("connect");
+        exit(-1);
+    }
+
+    ALOGV("connecting client %d", getpid());
+
+    int mount_storage = getenv("MOUNT_EMULATED_STORAGE") != NULL;
+
+    // Determine which one of our streams are attached to a TTY
+    int atty = 0;
+
+    // TODO: Check a system property and never use PTYs if
+    // the property is set.
+    if (isatty(STDIN_FILENO))  atty |= ATTY_IN;
+    if (isatty(STDOUT_FILENO)) atty |= ATTY_OUT;
+    if (isatty(STDERR_FILENO)) atty |= ATTY_ERR;
+
+    if (atty) {
+        // We need a PTY. Get one.
+        ptmx = pts_open(pts_slave, sizeof(pts_slave));
+        if (ptmx < 0) {
+            PLOGE("pts_open");
+            exit(-1);
+        }
+    } else {
+        pts_slave[0] = '\0';
+    }
+
+    // Send some info to the daemon, starting with our PID
+    write_int(socketfd, getpid());
+    // Send the slave path to the daemon
+    // (This is "" if we're not using PTYs)
+    write_string(socketfd, pts_slave);
+    // Parent PID
+    write_int(socketfd, ppid);
+    write_int(socketfd, mount_storage);
+
+    // Send stdin
+    if (atty & ATTY_IN) {
+        // Using PTY
+        send_fd(socketfd, -1);
+    } else {
+        send_fd(socketfd, STDIN_FILENO);
+    }
+
+    // Send stdout
+    if (atty & ATTY_OUT) {
+        // Forward SIGWINCH
+        watch_sigwinch_async(STDOUT_FILENO, ptmx);
+
+        // Using PTY
+        send_fd(socketfd, -1);
+    } else {
+        send_fd(socketfd, STDOUT_FILENO);
+    }
+
+    // Send stderr
+    if (atty & ATTY_ERR) {
+        // Using PTY
+        send_fd(socketfd, -1);
+    } else {
+        send_fd(socketfd, STDERR_FILENO);
+    }
+
+    // Number of command line arguments
+    write_int(socketfd, mount_storage ? argc - 1 : argc);
+
+    // Command line arguments
+    int i;
+    for (i = 0; i < argc; i++) {
+        if (i == 1 && mount_storage) {
+            continue;
+        }
+        write_string(socketfd, argv[i]);
+    }
+
+    // Wait for acknowledgement from daemon
+    read_int(socketfd);
+
+    if (atty & ATTY_IN) {
+        setup_sighandlers();
+        pump_stdin_async(ptmx);
+    }
+    if (atty & ATTY_OUT) {
+        pump_stdout_blocking(ptmx);
+    }
+
+    // Get the exit code
+    int code = read_int(socketfd);
+    close(socketfd);
+    ALOGD("client exited %d", code);
+
+    return code;
+}
diff --git a/Superuser/jni/db.c b/Superuser/jni/db.c
new file mode 100644
index 0000000..d8e0bcf
--- /dev/null
+++ b/Superuser/jni/db.c
@@ -0,0 +1,105 @@
+/*
+** Copyright 2013, Koushik Dutta (@koush)
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <limits.h>
+#include <sqlite3.h>
+#include <time.h>
+
+#include "su.h"
+
+struct callback_data_t {
+    struct su_context *ctx;
+    policy_t policy;
+};
+
+static int database_callback(void *v, int argc, char **argv, char **azColName){
+    struct callback_data_t *data = (struct callback_data_t *)v;
+    int command_match = 0;
+    policy_t policy = DENY;
+    int i;
+    time_t until = 0;
+    for(i = 0; i < argc; i++) {
+        if (strcmp(azColName[i], "policy") == 0) {
+            if (argv[i] == NULL) {
+                policy = DENY;
+            }
+            if (strcmp(argv[i], "allow") == 0) {
+                policy = ALLOW;
+            }
+            else if (strcmp(argv[i], "interactive") == 0) {
+                policy = INTERACTIVE;
+            }
+            else {
+                policy = DENY;
+            }
+        }
+        else if (strcmp(azColName[i], "command") == 0) {
+            // null or empty command means to match all commands (whitelist all from uid)
+            command_match = argv[i] == NULL || strlen(argv[i]) == 0 || strcmp(argv[i], get_command(&(data->ctx->to))) == 0;
+        }
+        else if (strcmp(azColName[i], "until") == 0) {
+            if (argv[i] != NULL) {
+                until = atoi(argv[i]);
+            }
+        }
+    }
+
+    // check for command match
+    if (command_match) {
+        // also make sure this policy has not expired
+        if (until == 0 || until > time(NULL)) {
+            if (policy == DENY) {
+                data->policy = DENY;
+                return -1;
+            }
+
+            data->policy = ALLOW;
+            // even though we allow, continue, so we can see if there's another policy
+            // that denies...
+        }
+    }
+    
+    return 0;
+}
+
+policy_t database_check(struct su_context *ctx) {
+    sqlite3 *db = NULL;
+    
+    char query[512];
+    snprintf(query, sizeof(query), "select policy, until, command from uid_policy where uid=%d", ctx->from.uid);
+    int ret = sqlite3_open_v2(ctx->user.database_path, &db, SQLITE_OPEN_READONLY, NULL);
+    if (ret) {
+        ALOGE("sqlite3 open failure: %d", ret);
+        sqlite3_close(db);
+        return INTERACTIVE;
+    }
+    
+    int result;
+    char *err = NULL;
+    struct callback_data_t data;
+    data.ctx = ctx;
+    data.policy = INTERACTIVE;
+    ret = sqlite3_exec(db, query, database_callback, &data, &err);
+    sqlite3_close(db);
+    if (err != NULL) {
+        ALOGE("sqlite3_exec: %s", err);
+        return DENY;
+    }
+
+    return data.policy;
+}
diff --git a/Superuser/jni/pts.c b/Superuser/jni/pts.c
new file mode 100644
index 0000000..26927a9
--- /dev/null
+++ b/Superuser/jni/pts.c
@@ -0,0 +1,336 @@
+/*
+ * Copyright 2013, Tan Chee Eng (@tan-ce)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+ /*
+ * pts.c
+ *
+ * Manages the pseudo-terminal driver on Linux/Android and provides some
+ * helper functions to handle raw input mode and terminal window resizing
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <signal.h>
+#include <termios.h>
+#include <errno.h>
+#include <pthread.h>
+
+#include "pts.h"
+
+/**
+ * Helper functions
+ */
+// Ensures all the data is written out
+static int write_blocking(int fd, char *buf, size_t bufsz) {
+    ssize_t ret, written;
+
+    written = 0;
+    do {
+        ret = write(fd, buf + written, bufsz - written);
+        if (ret == -1) return -1;
+        written += ret;
+    } while (written < (ssize_t)bufsz);
+
+    return 0;
+}
+
+/**
+ * Pump data from input FD to output FD. If close_output is
+ * true, then close the output FD when we're done.
+ */
+static void pump_ex(int input, int output, int close_output) {
+    char buf[4096];
+    int len;
+    while ((len = read(input, buf, 4096)) > 0) {
+        if (write_blocking(output, buf, len) == -1) break;
+    }
+    close(input);
+    if (close_output) close(output);
+}
+
+/**
+ * Pump data from input FD to output FD. Will close the
+ * output FD when done.
+ */
+static void pump(int input, int output) {
+    pump_ex(input, output, 1);
+}
+
+static void* pump_thread(void* data) {
+    int* files = (int*)data;
+    int input = files[0];
+    int output = files[1];
+    pump(input, output);
+    free(data);
+    return NULL;
+}
+
+static void pump_async(int input, int output) {
+    pthread_t writer;
+    int* files = (int*)malloc(sizeof(int) * 2);
+    if (files == NULL) {
+        exit(-1);
+    }
+    files[0] = input;
+    files[1] = output;
+    pthread_create(&writer, NULL, pump_thread, files);
+}
+
+
+/**
+ * pts_open
+ *
+ * Opens a pts device and returns the name of the slave tty device.
+ *
+ * Arguments
+ * slave_name       the name of the slave device
+ * slave_name_size  the size of the buffer passed via slave_name
+ *
+ * Return Values
+ * on failure either -2 or -1 (errno set) is returned.
+ * on success, the file descriptor of the master device is returned.
+ */
+int pts_open(char *slave_name, size_t slave_name_size) {
+    int fdm;
+    char sn_tmp[slave_name_size];
+
+    // Open master ptmx device
+    fdm = open("/dev/ptmx", O_RDWR);
+    if (fdm == -1) return -1;
+
+    // Get the slave name
+    if (ptsname_r(fdm, sn_tmp, slave_name_size) != 0) {
+        close(fdm);
+        return -2;
+    }
+
+    if (strlcpy(slave_name, sn_tmp, slave_name_size) >= slave_name_size) {
+        return -1;
+    }
+
+    // Grant, then unlock
+    if (grantpt(fdm) == -1) {
+        close(fdm);
+        return -1;
+    }
+    if (unlockpt(fdm) == -1) {
+        close(fdm);
+        return -1;
+    }
+
+    return fdm;
+}
+
+// Stores the previous termios of stdin
+static struct termios old_stdin;
+static int stdin_is_raw = 0;
+
+/**
+ * set_stdin_raw
+ *
+ * Changes stdin to raw unbuffered mode, disables echo, 
+ * auto carriage return, etc.
+ *
+ * Return Value
+ * on failure -1, and errno is set
+ * on success 0
+ */
+int set_stdin_raw(void) {
+    struct termios new_termios;
+
+    // Save the current stdin termios
+    if (tcgetattr(STDIN_FILENO, &old_stdin) < 0) {
+        return -1;
+    }
+
+    // Start from the current settings
+    new_termios = old_stdin;
+
+    // Make the terminal like an SSH or telnet client
+    new_termios.c_iflag |= IGNPAR;
+    new_termios.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);
+    new_termios.c_lflag &= ~(ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);
+    new_termios.c_oflag &= ~OPOST;
+    new_termios.c_cc[VMIN] = 1;
+    new_termios.c_cc[VTIME] = 0;
+
+    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &new_termios) < 0) {
+        return -1;
+    }
+
+    stdin_is_raw = 1;
+
+    return 0;
+}
+
+/**
+ * restore_stdin
+ *
+ * Restore termios on stdin to the state it was before
+ * set_stdin_raw() was called. If set_stdin_raw() was
+ * never called, does nothing and doesn't return an error.
+ *
+ * This function is async-safe.
+ *
+ * Return Value
+ * on failure, -1 and errno is set
+ * on success, 0
+ */
+int restore_stdin(void) {
+    if (!stdin_is_raw) return 0;
+
+    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &old_stdin) < 0) {
+        return -1;
+    }
+
+    stdin_is_raw = 0;
+
+    return 0;
+}
+
+// Flag indicating whether the sigwinch watcher should terminate.
+static volatile int closing_time = 0;
+
+/**
+ * Thread process. Wait for a SIGWINCH to be received, then update 
+ * the terminal size.
+ */
+static void *watch_sigwinch(void *data) {
+    sigset_t winch;
+    int sig;
+    int master = ((int *)data)[0];
+    int slave = ((int *)data)[1];
+
+    sigemptyset(&winch);
+    sigaddset(&winch, SIGWINCH);
+
+    do {
+        // Wait for a SIGWINCH
+        sigwait(&winch, &sig);
+
+        if (closing_time) break;
+
+        // Get the new terminal size
+        struct winsize w;
+        if (ioctl(master, TIOCGWINSZ, &w) == -1) {
+            continue;
+        }
+
+        // Set the new terminal size
+        ioctl(slave, TIOCSWINSZ, &w);
+
+    } while (1);
+
+    free(data);
+    return NULL;
+}
+
+/**
+ * watch_sigwinch_async
+ *
+ * After calling this function, if the application receives
+ * SIGWINCH, the terminal window size will be read from 
+ * "input" and set on "output".
+ *
+ * NOTE: This function blocks SIGWINCH and spawns a thread.
+ * NOTE 2: This function must be called before any of the
+ *         pump functions.
+ *
+ * Arguments
+ * master   A file descriptor of the TTY window size to follow
+ * slave    A file descriptor of the TTY window size which is
+ *          to be set on SIGWINCH
+ *
+ * Return Value
+ * on failure, -1 and errno will be set. In this case, no
+ *      thread has been spawned and SIGWINCH will not be 
+ *      blocked.
+ * on success, 0
+ */
+int watch_sigwinch_async(int master, int slave) {
+    pthread_t watcher;
+    int *files = (int *) malloc(sizeof(int) * 2);
+    if (files == NULL) {
+        return -1;
+    }
+
+    // Block SIGWINCH so sigwait can later receive it
+    sigset_t winch;
+    sigemptyset(&winch);
+    sigaddset(&winch, SIGWINCH);
+    if (sigprocmask(SIG_BLOCK, &winch, NULL) == -1) {
+        free(files);
+        return -1;
+    }
+
+    // Initialize some variables, then start the thread
+    closing_time = 0;
+    files[0] = master;
+    files[1] = slave;
+    int ret = pthread_create(&watcher, NULL, &watch_sigwinch, files);
+    if (ret != 0) {
+        free(files);
+        errno = ret;
+        return -1;
+    }
+
+    // Set the initial terminal size
+    raise(SIGWINCH);
+    return 0;
+}
+
+/**
+ * watch_sigwinch_cleanup
+ *
+ * Cause the SIGWINCH watcher thread to terminate
+ */
+void watch_sigwinch_cleanup(void) {
+    closing_time = 1;
+    raise(SIGWINCH);
+}
+
+/**
+ * pump_stdin_async
+ *
+ * Forward data from STDIN to the given FD
+ * in a seperate thread
+ */
+void pump_stdin_async(int outfd) {
+    // Put stdin into raw mode
+    set_stdin_raw();
+
+    // Pump data from stdin to the PTY
+    pump_async(STDIN_FILENO, outfd);
+}
+
+/**
+ * pump_stdout_blocking
+ *
+ * Forward data from the FD to STDOUT.
+ * Returns when the remote end of the FD closes.
+ *
+ * Before returning, restores stdin settings.
+ */
+void pump_stdout_blocking(int infd) {
+    // Pump data from stdout to PTY
+    pump_ex(infd, STDOUT_FILENO, 0 /* Don't close output when done */);
+
+    // Cleanup
+    restore_stdin();
+    watch_sigwinch_cleanup();
+}
diff --git a/Superuser/jni/pts.h b/Superuser/jni/pts.h
new file mode 100644
index 0000000..c323643
--- /dev/null
+++ b/Superuser/jni/pts.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2013, Tan Chee Eng (@tan-ce)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+ /*
+ * pts.h
+ *
+ * Manages the pseudo-terminal driver on Linux/Android and provides some
+ * helper functions to handle raw input mode and terminal window resizing
+ */
+
+#ifndef _PTS_H_
+#define _PTS_H_
+
+/**
+ * pts_open
+ *
+ * Opens a pts device and returns the name of the slave tty device.
+ *
+ * Arguments
+ * slave_name       the name of the slave device
+ * slave_name_size  the size of the buffer passed via slave_name
+ *
+ * Return Values
+ * on failure either -2 or -1 (errno set) is returned.
+ * on success, the file descriptor of the master device is returned.
+ */
+int pts_open(char *slave_name, size_t slave_name_size);
+
+/**
+ * set_stdin_raw
+ *
+ * Changes stdin to raw unbuffered mode, disables echo, 
+ * auto carriage return, etc.
+ *
+ * Return Value
+ * on failure -1, and errno is set
+ * on success 0
+ */
+int set_stdin_raw(void);
+
+/**
+ * restore_stdin
+ *
+ * Restore termios on stdin to the state it was before
+ * set_stdin_raw() was called. If set_stdin_raw() was
+ * never called, does nothing and doesn't return an error.
+ *
+ * This function is async-safe.
+ *
+ * Return Value
+ * on failure, -1 and errno is set
+ * on success, 0
+ */
+int restore_stdin(void);
+
+/**
+ * watch_sigwinch_async
+ *
+ * After calling this function, if the application receives
+ * SIGWINCH, the terminal window size will be read from 
+ * "input" and set on "output".
+ *
+ * NOTE: This function blocks SIGWINCH and spawns a thread.
+ *
+ * Arguments
+ * master   A file descriptor of the TTY window size to follow
+ * slave    A file descriptor of the TTY window size which is
+ *          to be set on SIGWINCH
+ *
+ * Return Value
+ * on failure, -1 and errno will be set. In this case, no
+ *      thread has been spawned and SIGWINCH will not be 
+ *      blocked.
+ * on success, 0
+ */
+int watch_sigwinch_async(int master, int slave);
+
+/**
+ * watch_sigwinch_cleanup
+ *
+ * Cause the SIGWINCH watcher thread to terminate
+ */
+void watch_sigwinch_cleanup(void);
+
+/**
+ * pump_stdin_async
+ *
+ * Forward data from STDIN to the given FD
+ * in a seperate thread
+ */
+void pump_stdin_async(int outfd);
+
+/**
+ * pump_stdout_blocking
+ *
+ * Forward data from the FD to STDOUT.
+ * Returns when the remote end of the FD closes.
+ *
+ * Before returning, restores stdin settings.
+ */
+void pump_stdout_blocking(int infd);
+
+#endif
diff --git a/Superuser/jni/su.c b/Superuser/jni/su.c
new file mode 100644
index 0000000..0ba303f
--- /dev/null
+++ b/Superuser/jni/su.c
@@ -0,0 +1,934 @@
+/*
+** Copyright 2010, Adam Shanks (@ChainsDD)
+** Copyright 2008, Zinx Verituse (@zinxv)
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/uio.h>
+#include <sys/un.h>
+#include <sys/wait.h>
+#include <sys/select.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <limits.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <stdint.h>
+#include <pwd.h>
+#include <sys/stat.h>
+#include <stdarg.h>
+#include <sys/types.h>
+#include <utils/Log.h>
+#include <private/android_filesystem_config.h>
+
+#include "su.h"
+#include "utils.h"
+
+extern int is_daemon;
+extern int daemon_from_uid;
+extern int daemon_from_pid;
+
+int fork_zero_fucks() {
+    int pid = fork();
+    if (pid) {
+        int status;
+        waitpid(pid, &status, 0);
+        return pid;
+    }
+    else {
+        if ((pid = fork()))
+            exit(0);
+        return 0;
+    }
+}
+
+void exec_log(int priority, const char* fmt, ...) {
+    static int log_fd = -1;
+    struct iovec vec[3];
+    va_list args;
+    char msg[PATH_MAX];
+
+    if (log_fd < 0) {
+        log_fd = open("/dev/log/main", O_WRONLY);
+        if (log_fd < 0) {
+            return;
+        }
+    }
+
+    va_start(args, fmt);
+    vsnprintf(msg, PATH_MAX, fmt, args);
+    va_end(args);
+
+    vec[0].iov_base   = (unsigned char *) &priority;
+    vec[0].iov_len    = 1;
+    vec[1].iov_base   = (void *) LOG_TAG;
+    vec[1].iov_len    = strlen(LOG_TAG) + 1;
+    vec[2].iov_base   = (void *) msg;
+    vec[2].iov_len    = strlen(msg) + 1;
+
+    writev(log_fd, vec, 3);
+}
+
+static int from_init(struct su_initiator *from) {
+    char path[PATH_MAX], exe[PATH_MAX];
+    char args[4096], *argv0, *argv_rest;
+    int fd;
+    ssize_t len;
+    int i;
+    int err;
+
+    from->uid = getuid();
+    from->pid = getppid();
+
+    if (is_daemon) {
+        from->uid = daemon_from_uid;
+        from->pid = daemon_from_pid;
+    }
+
+    /* Get the command line */
+    snprintf(path, sizeof(path), "/proc/%u/cmdline", from->pid);
+    fd = open(path, O_RDONLY);
+    if (fd < 0) {
+        PLOGE("Opening command line");
+        return -1;
+    }
+    len = read(fd, args, sizeof(args));
+    err = errno;
+    close(fd);
+    if (len < 0 || len == sizeof(args)) {
+        PLOGEV("Reading command line", err);
+        return -1;
+    }
+
+    argv0 = args;
+    argv_rest = NULL;
+    for (i = 0; i < len; i++) {
+        if (args[i] == '\0') {
+            if (!argv_rest) {
+                argv_rest = &args[i+1];
+            } else {
+                args[i] = ' ';
+            }
+        }
+    }
+    args[len] = '\0';
+
+    if (argv_rest) {
+        if (strlcpy(from->args, argv_rest, sizeof(from->args)) >= sizeof(from->args)) {
+            ALOGE("argument too long");
+            return -1;
+        }
+    } else {
+        from->args[0] = '\0';
+    }
+
+    /* If this isn't app_process, use the real path instead of argv[0] */
+    snprintf(path, sizeof(path), "/proc/%u/exe", from->pid);
+    len = readlink(path, exe, sizeof(exe));
+    if (len < 0) {
+        PLOGE("Getting exe path");
+        return -1;
+    }
+    exe[len] = '\0';
+    if (strcmp(exe, "/system/bin/app_process")) {
+        argv0 = exe;
+    }
+
+    if (strlcpy(from->bin, argv0, sizeof(from->bin)) >= sizeof(from->bin)) {
+        ALOGE("binary path too long");
+        return -1;
+    }
+
+    struct passwd *pw;
+    pw = getpwuid(from->uid);
+    if (pw && pw->pw_name) {
+        if (strlcpy(from->name, pw->pw_name, sizeof(from->name)) >= sizeof(from->name)) {
+            ALOGE("name too long");
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+static int get_multiuser_mode() {
+    char *data;
+    char sdk_ver[PROPERTY_VALUE_MAX];
+
+    data = read_file("/system/build.prop");
+    get_property(data, sdk_ver, "ro.build.version.sdk", "0");
+    free(data);
+
+    int sdk = atoi(sdk_ver);
+    if (sdk < 17)
+        return MULTIUSER_MODE_NONE;
+
+    int ret = MULTIUSER_MODE_OWNER_ONLY;
+    char mode[12];
+    FILE *fp;
+    if ((fp = fopen(REQUESTOR_MULTIUSER_MODE, "r"))) {
+        fgets(mode, sizeof(mode), fp);
+        int last = strlen(mode) - 1;
+        if (mode[last] == '\n')
+            mode[last] = '\0';
+        if (strcmp(mode, MULTIUSER_VALUE_USER) == 0) {
+            ret = MULTIUSER_MODE_USER;
+        } else if (strcmp(mode, MULTIUSER_VALUE_OWNER_MANAGED) == 0) {
+            ret = MULTIUSER_MODE_OWNER_MANAGED;
+        }
+        else {
+            ret = MULTIUSER_MODE_OWNER_ONLY;
+        }
+        fclose(fp);
+    }
+    return ret;
+}
+
+static void read_options(struct su_context *ctx) {
+    ctx->user.multiuser_mode = get_multiuser_mode();
+}
+
+static void user_init(struct su_context *ctx) {
+    if (ctx->from.uid > 99999) {
+        ctx->user.android_user_id = ctx->from.uid / 100000;
+        if (ctx->user.multiuser_mode == MULTIUSER_MODE_USER) {
+            snprintf(ctx->user.database_path, PATH_MAX, "%s/%d/%s", REQUESTOR_USER_PATH, ctx->user.android_user_id, REQUESTOR_DATABASE_PATH);
+            snprintf(ctx->user.base_path, PATH_MAX, "%s/%d/%s", REQUESTOR_USER_PATH, ctx->user.android_user_id, REQUESTOR);
+        }
+    }
+}
+
+static void populate_environment(const struct su_context *ctx) {
+    struct passwd *pw;
+
+    if (ctx->to.keepenv)
+        return;
+
+    pw = getpwuid(ctx->to.uid);
+    if (pw) {
+        setenv("HOME", pw->pw_dir, 1);
+        if (ctx->to.shell)
+            setenv("SHELL", ctx->to.shell, 1);
+        else
+            setenv("SHELL", DEFAULT_SHELL, 1);
+        if (ctx->to.login || ctx->to.uid) {
+            setenv("USER", pw->pw_name, 1);
+            setenv("LOGNAME", pw->pw_name, 1);
+        }
+    }
+}
+
+void set_identity(unsigned int uid) {
+    /*
+     * Set effective uid back to root, otherwise setres[ug]id will fail
+     * if uid isn't root.
+     */
+    if (seteuid(0)) {
+        PLOGE("seteuid (root)");
+        exit(EXIT_FAILURE);
+    }
+    if (setresgid(uid, uid, uid)) {
+        PLOGE("setresgid (%u)", uid);
+        exit(EXIT_FAILURE);
+    }
+    if (setresuid(uid, uid, uid)) {
+        PLOGE("setresuid (%u)", uid);
+        exit(EXIT_FAILURE);
+    }
+}
+
+static void socket_cleanup(struct su_context *ctx) {
+    if (ctx && ctx->sock_path[0]) {
+        if (unlink(ctx->sock_path))
+            PLOGE("unlink (%s)", ctx->sock_path);
+        ctx->sock_path[0] = 0;
+    }
+}
+
+/*
+ * For use in signal handlers/atexit-function
+ * NOTE: su_ctx points to main's local variable.
+ *       It's OK due to the program uses exit(3), not return from main()
+ */
+static struct su_context *su_ctx = NULL;
+
+static void cleanup(void) {
+    socket_cleanup(su_ctx);
+}
+
+static void cleanup_signal(int sig) {
+    socket_cleanup(su_ctx);
+    exit(128 + sig);
+}
+
+static int socket_create_temp(char *path, size_t len) {
+    int fd;
+    struct sockaddr_un sun;
+
+    fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+    if (fd < 0) {
+        PLOGE("socket");
+        return -1;
+    }
+    if (fcntl(fd, F_SETFD, FD_CLOEXEC)) {
+        PLOGE("fcntl FD_CLOEXEC");
+        goto err;
+    }
+
+    memset(&sun, 0, sizeof(sun));
+    sun.sun_family = AF_LOCAL;
+    snprintf(path, len, "%s/.socket%d", REQUESTOR_CACHE_PATH, getpid());
+    memset(sun.sun_path, 0, sizeof(sun.sun_path));
+    snprintf(sun.sun_path, sizeof(sun.sun_path), "%s", path);
+
+    /*
+     * Delete the socket to protect from situations when
+     * something bad occured previously and the kernel reused pid from that process.
+     * Small probability, isn't it.
+     */
+    unlink(sun.sun_path);
+
+    if (bind(fd, (struct sockaddr*)&sun, sizeof(sun)) < 0) {
+        PLOGE("bind");
+        goto err;
+    }
+
+    if (listen(fd, 1) < 0) {
+        PLOGE("listen");
+        goto err;
+    }
+
+    return fd;
+err:
+    close(fd);
+    return -1;
+}
+
+static int socket_accept(int serv_fd) {
+    struct timeval tv;
+    fd_set fds;
+    int fd, rc;
+
+    /* Wait 20 seconds for a connection, then give up. */
+    tv.tv_sec = 20;
+    tv.tv_usec = 0;
+    FD_ZERO(&fds);
+    FD_SET(serv_fd, &fds);
+    do {
+        rc = select(serv_fd + 1, &fds, NULL, NULL, &tv);
+    } while (rc < 0 && errno == EINTR);
+    if (rc < 1) {
+        PLOGE("select");
+        return -1;
+    }
+
+    fd = accept(serv_fd, NULL, NULL);
+    if (fd < 0) {
+        PLOGE("accept");
+        return -1;
+    }
+
+    return fd;
+}
+
+static int socket_send_request(int fd, const struct su_context *ctx) {
+#define write_data(fd, data, data_len)              \
+do {                                                \
+    size_t __len = htonl(data_len);                 \
+    __len = write((fd), &__len, sizeof(__len));     \
+    if (__len != sizeof(__len)) {                   \
+        PLOGE("write(" #data ")");                  \
+        return -1;                                  \
+    }                                               \
+    __len = write((fd), data, data_len);            \
+    if (__len != data_len) {                        \
+        PLOGE("write(" #data ")");                  \
+        return -1;                                  \
+    }                                               \
+} while (0)
+
+#define write_string_data(fd, name, data)        \
+do {                                        \
+    write_data(fd, name, strlen(name));     \
+    write_data(fd, data, strlen(data));     \
+} while (0)
+
+// stringify everything.
+#define write_token(fd, name, data)         \
+do {                                        \
+    char buf[16];                           \
+    snprintf(buf, sizeof(buf), "%d", data); \
+    write_string_data(fd, name, buf);            \
+} while (0)
+
+    write_token(fd, "version", PROTO_VERSION);
+    write_token(fd, "binary.version", VERSION_CODE);
+    write_token(fd, "pid", ctx->from.pid);
+    write_string_data(fd, "from.name", ctx->from.name);
+    write_string_data(fd, "to.name", ctx->to.name);
+    write_token(fd, "from.uid", ctx->from.uid);
+    write_token(fd, "to.uid", ctx->to.uid);
+    write_string_data(fd, "from.bin", ctx->from.bin);
+    // TODO: Fix issue where not using -c does not result a in a command
+    write_string_data(fd, "command", get_command(&ctx->to));
+    write_token(fd, "eof", PROTO_VERSION);
+    return 0;
+}
+
+static int socket_receive_result(int fd, char *result, ssize_t result_len) {
+    ssize_t len;
+
+    ALOGV("waiting for user");
+    len = read(fd, result, result_len-1);
+    if (len < 0) {
+        PLOGE("read(result)");
+        return -1;
+    }
+    result[len] = '\0';
+
+    return 0;
+}
+
+static void usage(int status) {
+    FILE *stream = (status == EXIT_SUCCESS) ? stdout : stderr;
+
+    fprintf(stream,
+    "Usage: su [options] [--] [-] [LOGIN] [--] [args...]\n\n"
+    "Options:\n"
+    "  --daemon                      start the su daemon agent\n"
+    "  -c, --command COMMAND         pass COMMAND to the invoked shell\n"
+    "  -h, --help                    display this help message and exit\n"
+    "  -, -l, --login                pretend the shell to be a login shell\n"
+    "  -m, -p,\n"
+    "  --preserve-environment        do not change environment variables\n"
+    "  -s, --shell SHELL             use SHELL instead of the default " DEFAULT_SHELL "\n"
+    "  -u                            display the multiuser mode and exit\n"
+    "  -v, --version                 display version number and exit\n"
+    "  -V                            display version code and exit,\n"
+    "                                this is used almost exclusively by Superuser.apk\n");
+    exit(status);
+}
+
+static __attribute__ ((noreturn)) void deny(struct su_context *ctx) {
+    char *cmd = get_command(&ctx->to);
+
+    int send_to_app = 1;
+
+    // no need to log if called by root
+    if (ctx->from.uid == AID_ROOT)
+        send_to_app = 0;
+
+    // dumpstate (which logs to logcat/shell) will spam the crap out of the system with su calls
+    if (strcmp("/system/bin/dumpstate", ctx->from.bin) == 0)
+        send_to_app = 0;
+
+    if (send_to_app)
+        send_result(ctx, DENY);
+
+    ALOGW("request rejected (%u->%u %s)", ctx->from.uid, ctx->to.uid, cmd);
+    fprintf(stderr, "%s\n", strerror(EACCES));
+    exit(EXIT_FAILURE);
+}
+
+static __attribute__ ((noreturn)) void allow(struct su_context *ctx) {
+    char *arg0;
+    int argc, err;
+
+    umask(ctx->umask);
+    int send_to_app = 1;
+
+    // no need to log if called by root
+    if (ctx->from.uid == AID_ROOT)
+        send_to_app = 0;
+
+    // dumpstate (which logs to logcat/shell) will spam the crap out of the system with su calls
+    if (strcmp("/system/bin/dumpstate", ctx->from.bin) == 0)
+        send_to_app = 0;
+
+    if (send_to_app)
+        send_result(ctx, ALLOW);
+
+    char *binary;
+    argc = ctx->to.optind;
+    if (ctx->to.command) {
+        binary = ctx->to.shell;
+        ctx->to.argv[--argc] = ctx->to.command;
+        ctx->to.argv[--argc] = "-c";
+    }
+    else if (ctx->to.shell) {
+        binary = ctx->to.shell;
+    }
+    else {
+        if (ctx->to.argv[argc]) {
+            binary = ctx->to.argv[argc++];
+        }
+        else {
+            binary = DEFAULT_SHELL;
+        }
+    }
+
+    arg0 = strrchr (binary, '/');
+    arg0 = (arg0) ? arg0 + 1 : binary;
+    if (ctx->to.login) {
+        int s = strlen(arg0) + 2;
+        char *p = malloc(s);
+
+        if (!p)
+            exit(EXIT_FAILURE);
+
+        *p = '-';
+        strcpy(p + 1, arg0);
+        arg0 = p;
+    }
+
+    populate_environment(ctx);
+    set_identity(ctx->to.uid);
+
+#define PARG(arg)                                    \
+    (argc + (arg) < ctx->to.argc) ? " " : "",                    \
+    (argc + (arg) < ctx->to.argc) ? ctx->to.argv[argc + (arg)] : ""
+
+    ALOGD("%u %s executing %u %s using binary %s : %s%s%s%s%s%s%s%s%s%s%s%s%s%s",
+            ctx->from.uid, ctx->from.bin,
+            ctx->to.uid, get_command(&ctx->to), binary,
+            arg0, PARG(0), PARG(1), PARG(2), PARG(3), PARG(4), PARG(5),
+            (ctx->to.optind + 6 < ctx->to.argc) ? " ..." : "");
+
+    ctx->to.argv[--argc] = arg0;
+    execvp(binary, ctx->to.argv + argc);
+    err = errno;
+    PLOGE("exec");
+    fprintf(stderr, "Cannot execute %s: %s\n", binary, strerror(err));
+    exit(EXIT_FAILURE);
+}
+
+/*
+ * CyanogenMod-specific behavior
+ *
+ * we can't simply use the property service, since we aren't launched from init
+ * and can't trust the location of the property workspace.
+ * Find the properties ourselves.
+ */
+int access_disabled(const struct su_initiator *from) {
+#ifndef SUPERUSER_EMBEDDED
+    return 0;
+#else
+    char *data;
+    char build_type[PROPERTY_VALUE_MAX];
+    char debuggable[PROPERTY_VALUE_MAX], enabled[PROPERTY_VALUE_MAX];
+    size_t len;
+
+    data = read_file("/system/build.prop");
+    if (check_property(data, "ro.cm.version")) {
+        get_property(data, build_type, "ro.build.type", "");
+        free(data);
+
+        data = read_file("/default.prop");
+        get_property(data, debuggable, "ro.debuggable", "0");
+        free(data);
+        /* only allow su on debuggable builds */
+        if (strcmp("1", debuggable) != 0) {
+            ALOGE("Root access is disabled on non-debug builds");
+            return 1;
+        }
+
+        data = read_file("/data/property/persist.sys.root_access");
+        if (data != NULL) {
+            len = strlen(data);
+            if (len >= PROPERTY_VALUE_MAX)
+                memcpy(enabled, "0", 2);
+            else
+                memcpy(enabled, data, len + 1);
+            free(data);
+        } else
+            memcpy(enabled, "0", 2);
+
+        /* enforce persist.sys.root_access on non-eng builds for apps */
+        if (strcmp("eng", build_type) != 0 &&
+                from->uid != AID_SHELL && from->uid != AID_ROOT &&
+                (atoi(enabled) & CM_ROOT_ACCESS_APPS_ONLY) != CM_ROOT_ACCESS_APPS_ONLY ) {
+            ALOGE("Apps root access is disabled by system setting - "
+                 "enable it under settings -> developer options");
+            return 1;
+        }
+
+        /* disallow su in a shell if appropriate */
+        if (from->uid == AID_SHELL &&
+                (atoi(enabled) & CM_ROOT_ACCESS_ADB_ONLY) != CM_ROOT_ACCESS_ADB_ONLY ) {
+            ALOGE("Shell root access is disabled by a system setting - "
+                 "enable it under settings -> developer options");
+            return 1;
+        }
+
+    }
+    return 0;
+#endif
+}
+
+static void fork_for_samsung(void)
+{
+    // Samsung CONFIG_SEC_RESTRICT_SETUID wants the parent process to have
+    // EUID 0, or else our setresuid() calls will be denied.  So make sure
+    // all such syscalls are executed by a child process.
+    int rv;
+
+    switch (fork()) {
+    case 0:
+        return;
+    case -1:
+        PLOGE("fork");
+        exit(1);
+    default:
+        if (wait(&rv) < 0) {
+            exit(1);
+        } else {
+            exit(WEXITSTATUS(rv));
+        }
+    }
+}
+
+int main(int argc, char *argv[]) {
+    if (getuid() != geteuid()) {
+        ALOGE("must not be a setuid binary");
+        return 1;
+    }
+
+    return su_main(argc, argv, 1);
+}
+
+int su_main(int argc, char *argv[], int need_client) {
+    // start up in daemon mode if prompted
+    if (argc == 2 && strcmp(argv[1], "--daemon") == 0) {
+        return run_daemon();
+    }
+
+    int ppid = getppid();
+    fork_for_samsung();
+
+    // Sanitize all secure environment variables (from linker_environ.c in AOSP linker).
+    /* The same list than GLibc at this point */
+    static const char* const unsec_vars[] = {
+        "GCONV_PATH",
+        "GETCONF_DIR",
+        "HOSTALIASES",
+        "LD_AUDIT",
+        "LD_DEBUG",
+        "LD_DEBUG_OUTPUT",
+        "LD_DYNAMIC_WEAK",
+        "LD_LIBRARY_PATH",
+        "LD_ORIGIN_PATH",
+        "LD_PRELOAD",
+        "LD_PROFILE",
+        "LD_SHOW_AUXV",
+        "LD_USE_LOAD_BIAS",
+        "LOCALDOMAIN",
+        "LOCPATH",
+        "MALLOC_TRACE",
+        "MALLOC_CHECK_",
+        "NIS_PATH",
+        "NLSPATH",
+        "RESOLV_HOST_CONF",
+        "RES_OPTIONS",
+        "TMPDIR",
+        "TZDIR",
+        "LD_AOUT_LIBRARY_PATH",
+        "LD_AOUT_PRELOAD",
+        // not listed in linker, used due to system() call
+        "IFS",
+    };
+    const char* const* cp   = unsec_vars;
+    const char* const* endp = cp + sizeof(unsec_vars)/sizeof(unsec_vars[0]);
+    while (cp < endp) {
+        unsetenv(*cp);
+        cp++;
+    }
+
+    ALOGD("su invoked.");
+
+    struct su_context ctx = {
+        .from = {
+            .pid = -1,
+            .uid = 0,
+            .bin = "",
+            .args = "",
+            .name = "",
+        },
+        .to = {
+            .uid = AID_ROOT,
+            .login = 0,
+            .keepenv = 0,
+            .shell = NULL,
+            .command = NULL,
+            .argv = argv,
+            .argc = argc,
+            .optind = 0,
+            .name = "",
+        },
+        .user = {
+            .android_user_id = 0,
+            .multiuser_mode = MULTIUSER_MODE_OWNER_ONLY,
+            .database_path = REQUESTOR_DATA_PATH REQUESTOR_DATABASE_PATH,
+            .base_path = REQUESTOR_DATA_PATH REQUESTOR
+        },
+    };
+    struct stat st;
+    int c, socket_serv_fd, fd;
+    char buf[64], *result;
+    policy_t dballow;
+    struct option long_opts[] = {
+        { "command",            required_argument,    NULL, 'c' },
+        { "help",            no_argument,        NULL, 'h' },
+        { "login",            no_argument,        NULL, 'l' },
+        { "preserve-environment",    no_argument,        NULL, 'p' },
+        { "shell",            required_argument,    NULL, 's' },
+        { "version",            no_argument,        NULL, 'v' },
+        { NULL, 0, NULL, 0 },
+    };
+
+    while ((c = getopt_long(argc, argv, "+c:hlmps:Vvu", long_opts, NULL)) != -1) {
+        switch(c) {
+        case 'c':
+            ctx.to.shell = DEFAULT_SHELL;
+            ctx.to.command = optarg;
+            break;
+        case 'h':
+            usage(EXIT_SUCCESS);
+            break;
+        case 'l':
+            ctx.to.login = 1;
+            break;
+        case 'm':
+        case 'p':
+            ctx.to.keepenv = 1;
+            break;
+        case 's':
+            ctx.to.shell = optarg;
+            break;
+        case 'V':
+            printf("%d\n", VERSION_CODE);
+            exit(EXIT_SUCCESS);
+        case 'v':
+            printf("%s\n", VERSION);
+            exit(EXIT_SUCCESS);
+        case 'u':
+            switch (get_multiuser_mode()) {
+            case MULTIUSER_MODE_USER:
+                printf("%s\n", MULTIUSER_VALUE_USER);
+                break;
+            case MULTIUSER_MODE_OWNER_MANAGED:
+                printf("%s\n", MULTIUSER_VALUE_OWNER_MANAGED);
+                break;
+            case MULTIUSER_MODE_OWNER_ONLY:
+                printf("%s\n", MULTIUSER_VALUE_OWNER_ONLY);
+                break;
+            case MULTIUSER_MODE_NONE:
+                printf("%s\n", MULTIUSER_VALUE_NONE);
+                break;
+            }
+            exit(EXIT_SUCCESS);
+        default:
+            /* Bionic getopt_long doesn't terminate its error output by newline */
+            fprintf(stderr, "\n");
+            usage(2);
+        }
+    }
+
+    if (need_client) {
+        // attempt to connect to daemon...
+        ALOGD("starting daemon client %d %d", getuid(), geteuid());
+        return connect_daemon(argc, argv, ppid);
+    }
+
+    if (optind < argc && !strcmp(argv[optind], "-")) {
+        ctx.to.login = 1;
+        optind++;
+    }
+    /* username or uid */
+    if (optind < argc && strcmp(argv[optind], "--")) {
+        struct passwd *pw;
+        pw = getpwnam(argv[optind]);
+        if (!pw) {
+            char *endptr;
+
+            /* It seems we shouldn't do this at all */
+            errno = 0;
+            ctx.to.uid = strtoul(argv[optind], &endptr, 10);
+            if (errno || *endptr) {
+                ALOGE("Unknown id: %s\n", argv[optind]);
+                fprintf(stderr, "Unknown id: %s\n", argv[optind]);
+                exit(EXIT_FAILURE);
+            }
+        } else {
+            ctx.to.uid = pw->pw_uid;
+            if (pw->pw_name) {
+                if (strlcpy(ctx.to.name, pw->pw_name, sizeof(ctx.to.name)) >= sizeof(ctx.to.name)) {
+                    ALOGE("name too long");
+                    exit(EXIT_FAILURE);
+                }
+            }
+        }
+        optind++;
+    }
+    if (optind < argc && !strcmp(argv[optind], "--")) {
+        optind++;
+    }
+    ctx.to.optind = optind;
+
+    su_ctx = &ctx;
+    if (from_init(&ctx.from) < 0) {
+        deny(&ctx);
+    }
+
+    read_options(&ctx);
+    user_init(&ctx);
+
+    // the latter two are necessary for stock ROMs like note 2 which do dumb things with su, or crash otherwise
+    if (ctx.from.uid == AID_ROOT) {
+        ALOGD("Allowing root/system/radio.");
+        allow(&ctx);
+    }
+
+    // verify superuser is installed
+    if (stat(ctx.user.base_path, &st) < 0) {
+        // send to market (disabled, because people are and think this is hijacking their su)
+        // if (0 == strcmp(JAVA_PACKAGE_NAME, REQUESTOR))
+        //     silent_run("am start -d http://www.clockworkmod.com/superuser/install.html -a android.intent.action.VIEW");
+        PLOGE("stat %s", ctx.user.base_path);
+        deny(&ctx);
+    }
+
+    // odd perms on superuser data dir
+    if (st.st_gid != st.st_uid) {
+        ALOGE("Bad uid/gid %d/%d for Superuser Requestor application",
+                (int)st.st_uid, (int)st.st_gid);
+        deny(&ctx);
+    }
+
+    // always allow if this is the superuser uid
+    // superuser needs to be able to reenable itself when disabled...
+    if (ctx.from.uid == st.st_uid) {
+        allow(&ctx);
+    }
+
+    // check if superuser is disabled completely
+    if (access_disabled(&ctx.from)) {
+        ALOGD("access_disabled");
+        deny(&ctx);
+    }
+
+    // autogrant shell at this point
+    if (ctx.from.uid == AID_SHELL) {
+        ALOGD("Allowing shell.");
+        allow(&ctx);
+    }
+
+    // deny if this is a non owner request and owner mode only
+    if (ctx.user.multiuser_mode == MULTIUSER_MODE_OWNER_ONLY && ctx.user.android_user_id != 0) {
+        deny(&ctx);
+    }
+
+    ctx.umask = umask(027);
+
+    int ret = mkdir(REQUESTOR_CACHE_PATH, 0770);
+    if (chown(REQUESTOR_CACHE_PATH, st.st_uid, st.st_gid)) {
+        PLOGE("chown (%s, %ld, %ld)", REQUESTOR_CACHE_PATH, st.st_uid, st.st_gid);
+        deny(&ctx);
+    }
+
+    if (setgroups(0, NULL)) {
+        PLOGE("setgroups");
+        deny(&ctx);
+    }
+    if (setegid(st.st_gid)) {
+        PLOGE("setegid (%lu)", st.st_gid);
+        deny(&ctx);
+    }
+    if (seteuid(st.st_uid)) {
+        PLOGE("seteuid (%lu)", st.st_uid);
+        deny(&ctx);
+    }
+
+    dballow = database_check(&ctx);
+    switch (dballow) {
+        case INTERACTIVE:
+            break;
+        case ALLOW:
+            ALOGD("db allowed");
+            allow(&ctx);    /* never returns */
+        case DENY:
+        default:
+            ALOGD("db denied");
+            deny(&ctx);        /* never returns too */
+    }
+
+    socket_serv_fd = socket_create_temp(ctx.sock_path, sizeof(ctx.sock_path));
+    ALOGD(ctx.sock_path);
+    if (socket_serv_fd < 0) {
+        deny(&ctx);
+    }
+
+    signal(SIGHUP, cleanup_signal);
+    signal(SIGPIPE, cleanup_signal);
+    signal(SIGTERM, cleanup_signal);
+    signal(SIGQUIT, cleanup_signal);
+    signal(SIGINT, cleanup_signal);
+    signal(SIGABRT, cleanup_signal);
+
+    if (send_request(&ctx) < 0) {
+        deny(&ctx);
+    }
+
+    atexit(cleanup);
+
+    fd = socket_accept(socket_serv_fd);
+    if (fd < 0) {
+        deny(&ctx);
+    }
+    if (socket_send_request(fd, &ctx)) {
+        deny(&ctx);
+    }
+    if (socket_receive_result(fd, buf, sizeof(buf))) {
+        deny(&ctx);
+    }
+
+    close(fd);
+    close(socket_serv_fd);
+    socket_cleanup(&ctx);
+
+    result = buf;
+
+#define SOCKET_RESPONSE    "socket:"
+    if (strncmp(result, SOCKET_RESPONSE, sizeof(SOCKET_RESPONSE) - 1))
+        ALOGW("SECURITY RISK: Requestor still receives credentials in intent");
+    else
+        result += sizeof(SOCKET_RESPONSE) - 1;
+
+    if (!strcmp(result, "DENY")) {
+        deny(&ctx);
+    } else if (!strcmp(result, "ALLOW")) {
+        allow(&ctx);
+    } else {
+        ALOGE("unknown response from Superuser Requestor: %s", result);
+        deny(&ctx);
+    }
+}
+
+
+int __android_log_print(int prio, const char *tag,  const char *fmt, ...)
+{
+}
diff --git a/Superuser/jni/su.h b/Superuser/jni/su.h
new file mode 100644
index 0000000..48283dd
--- /dev/null
+++ b/Superuser/jni/su.h
@@ -0,0 +1,173 @@
+/*
+** Copyright 2010, Adam Shanks (@ChainsDD)
+** Copyright 2008, Zinx Verituse (@zinxv)
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#ifndef SU_h 
+#define SU_h 1
+
+#ifdef LOG_TAG
+#undef LOG_TAG
+#endif
+#define LOG_TAG "su"
+
+// CyanogenMod-specific behavior
+#define CM_ROOT_ACCESS_DISABLED      0
+#define CM_ROOT_ACCESS_APPS_ONLY     1
+#define CM_ROOT_ACCESS_ADB_ONLY      2
+#define CM_ROOT_ACCESS_APPS_AND_ADB  3
+
+// DO NOT CHANGE LINE BELOW, java package name will always be the same
+#define JAVA_PACKAGE_NAME "com.koushikdutta.superuser"
+
+// If --rename-manifest-package is used in AAPT, this
+// must be changed to correspond to the new APK package name
+// See the two Android.mk files for more details.
+#ifndef REQUESTOR
+#define REQUESTOR JAVA_PACKAGE_NAME
+#endif
+// This is used if wrapping the fragment classes and activities
+// with classes in another package. CM requirement.
+#ifndef REQUESTOR_PREFIX
+#define REQUESTOR_PREFIX JAVA_PACKAGE_NAME
+#endif
+#define REQUESTOR_DATA_PATH "/data/data/"
+#define REQUESTOR_FILES_PATH REQUESTOR_DATA_PATH REQUESTOR "/files"
+#define REQUESTOR_USER_PATH "/data/user/"
+#define REQUESTOR_CACHE_PATH "/dev/" REQUESTOR
+#define REQUESTOR_DAEMON_PATH REQUESTOR_CACHE_PATH ".daemon"
+
+// there's no guarantee that the db or files are actually created named as such by
+// SQLiteOpenHelper, etc. Though that is the behavior as of current.
+// it is up to the Android application to symlink as appropriate.
+#define REQUESTOR_DATABASE_PATH REQUESTOR "/databases/su.sqlite"
+#define REQUESTOR_MULTIUSER_MODE REQUESTOR_FILES_PATH "/multiuser_mode"
+
+#define DEFAULT_SHELL "/system/bin/sh"
+
+#define xstr(a) str(a)
+#define str(a) #a
+
+#ifndef VERSION_CODE
+#define VERSION_CODE 16
+#endif
+#define VERSION xstr(VERSION_CODE) " " REQUESTOR
+
+#define PROTO_VERSION 1
+
+struct su_initiator {
+    pid_t pid;
+    unsigned uid;
+    unsigned user;
+    char name[64];
+    char bin[PATH_MAX];
+    char args[4096];
+};
+
+struct su_request {
+    unsigned uid;
+    char name[64];
+    int login;
+    int keepenv;
+    char *shell;
+    char *command;
+    char **argv;
+    int argc;
+    int optind;
+};
+
+struct su_user_info {
+    // the user in android userspace (multiuser)
+    // that invoked this action.
+    unsigned android_user_id;
+    // how su behaves with multiuser. see enum below.
+    int multiuser_mode;
+    // path to superuser directory. this is populated according
+    // to the multiuser mode.
+    // this is used to check uid/gid for protecting socket.
+    // this is used instead of database, as it is more likely
+    // to exist. db will not exist if su has never launched.
+    char base_path[PATH_MAX];
+    // path to su database. this is populated according
+    // to the multiuser mode.
+    char database_path[PATH_MAX];
+};
+
+struct su_context {
+    struct su_initiator from;
+    struct su_request to;
+    struct su_user_info user;
+    mode_t umask;
+    char sock_path[PATH_MAX];
+};
+
+// multiuser su behavior
+typedef enum {
+  // only owner can su
+  MULTIUSER_MODE_OWNER_ONLY = 0,
+  // owner gets a su prompt
+  MULTIUSER_MODE_OWNER_MANAGED = 1,
+  // user gets a su prompt
+  MULTIUSER_MODE_USER = 2,
+  MULTIUSER_MODE_NONE = 3,
+} multiuser_mode_t;
+
+#define MULTIUSER_VALUE_OWNER_ONLY    "owner"
+#define MULTIUSER_VALUE_OWNER_MANAGED "managed"
+#define MULTIUSER_VALUE_USER          "user"
+#define MULTIUSER_VALUE_NONE          "none"
+
+typedef enum {
+    INTERACTIVE = 0,
+    DENY = 1,
+    ALLOW = 2,
+} policy_t;
+
+extern policy_t database_check(struct su_context *ctx);
+extern void set_identity(unsigned int uid);
+extern int send_request(struct su_context *ctx);
+extern int send_result(struct su_context *ctx, policy_t policy);
+
+static inline char *get_command(const struct su_request *to)
+{
+  if (to->command)
+    return to->command;
+  if (to->shell)
+    return to->shell;
+  char* ret = to->argv[to->optind];
+  if (ret)
+    return ret;
+  return DEFAULT_SHELL;
+}
+
+int run_daemon();
+int connect_daemon(int argc, char *argv[], int ppid);
+int su_main(int argc, char *argv[], int need_client);
+// for when you give zero fucks about the state of the child process.
+// this version of fork understands you don't care about the child.
+// deadbeat dad fork.
+int fork_zero_fucks();
+
+#ifndef LOG_NDEBUG
+#define LOG_NDEBUG 1
+#endif
+
+#include <errno.h>
+#include <string.h>
+#include <log/log.h>
+#define PLOGE(fmt,args...) ALOGE(fmt " failed with %d: %s", ##args, errno, strerror(errno))
+#define PLOGEV(fmt,err,args...) ALOGE(fmt " failed with %d: %s", ##args, err, strerror(err))
+
+#endif
diff --git a/Superuser/jni/su/activity.c b/Superuser/jni/su/activity.c
deleted file mode 100644
index a3ef9c7..0000000
--- a/Superuser/jni/su/activity.c
+++ /dev/null
@@ -1,208 +0,0 @@
-/*
-** Copyright 2010, Adam Shanks (@ChainsDD)
-** Copyright 2008, Zinx Verituse (@zinxv)
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <unistd.h>
-#include <stdlib.h>
-#include <fcntl.h>
-#include <paths.h>
-#include <stdio.h>
-#include <stdarg.h>
-
-#include "su.h"
-
-/* intent actions */
-#define ACTION_REQUEST "start", "-n", REQUESTOR "/" REQUESTOR_PREFIX ".RequestActivity"
-#define ACTION_NOTIFY "start", "-n", REQUESTOR "/" REQUESTOR_PREFIX ".NotifyActivity"
-#define ACTION_RESULT "broadcast", "-n", REQUESTOR "/" REQUESTOR_PREFIX ".SuReceiver"
-
-#define AM_PATH "/system/bin/app_process", "/system/bin", "com.android.commands.am.Am"
-
-// TODO: leverage this with exec_log?
-int silent_run(char* const args[]) {
-    set_identity(0);
-    pid_t pid;
-    pid = fork();
-    /* Parent */
-    if (pid < 0) {
-        PLOGE("fork");
-        return -1;
-    }
-    else if (pid > 0) {
-        return 0;
-    }
-    int zero = open("/dev/zero", O_RDONLY | O_CLOEXEC);
-    dup2(zero, 0);
-    int null = open("/dev/null", O_WRONLY | O_CLOEXEC);
-    dup2(null, 1);
-    dup2(null, 2);
-    setenv("CLASSPATH", "/system/framework/am.jar", 1);
-    execv(args[0], args);
-    PLOGE("exec am");
-    _exit(EXIT_FAILURE);
-    return -1;
-}
-
-int get_owner_login_user_args(struct su_context *ctx, char* user, int user_len) {
-    int needs_owner_login_prompt = 0;
-    
-    if (ctx->user.multiuser_mode == MULTIUSER_MODE_OWNER_MANAGED) {
-        if (0 != ctx->user.android_user_id) {
-            needs_owner_login_prompt = 1;
-        }
-        snprintf(user, user_len, "0");
-    }
-    else if (ctx->user.multiuser_mode == MULTIUSER_MODE_USER) {
-        snprintf(user, user_len, "%d", ctx->user.android_user_id);
-    }
-    else if (ctx->user.multiuser_mode == MULTIUSER_MODE_NONE) {
-        user[0] = '\0';
-    }
-    else {
-        snprintf(user, user_len, "0");
-    }
-    
-    return needs_owner_login_prompt;
-}
-
-int send_result(struct su_context *ctx, policy_t policy) {
-    char binary_version[256];
-    sprintf(binary_version, "%d", VERSION_CODE);
-
-    char uid[256];
-    sprintf(uid, "%d", ctx->from.uid);
-
-    char desired_uid[256];
-    sprintf(desired_uid, "%d", ctx->to.uid);
-
-    char user[64];
-    get_owner_login_user_args(ctx, user, sizeof(user));
-
-    if (0 != ctx->user.android_user_id) {
-        char android_user_id[256];
-        sprintf(android_user_id, "%d", ctx->user.android_user_id);
-
-        char *user_result_command[] = {
-            AM_PATH,
-            ACTION_RESULT,
-            "--ei",
-            "binary_version",
-            binary_version,
-            "--es",
-            "from_name",
-            ctx->from.name,
-            "--es",
-            "desired_name",
-            ctx->to.name,
-            "--ei",
-            "uid",
-            uid,
-            "--ei",
-            "desired_uid",
-            desired_uid,
-            "--es",
-            "command",
-            get_command(&ctx->to),
-            "--es",
-            "action",
-            policy == ALLOW ? "allow" : "deny",
-            user[0] ? "--user" : NULL,
-            android_user_id,
-            NULL
-        };
-        silent_run(user_result_command);
-    }
-
-    char *result_command[] = {
-        AM_PATH,
-        ACTION_RESULT,
-        "--ei",
-        "binary_version",
-        binary_version,
-        "--es",
-        "from_name",
-        ctx->from.name,
-        "--es",
-        "desired_name",
-        ctx->to.name,
-        "--ei",
-        "uid",
-        uid,
-        "--ei",
-        "desired_uid",
-        desired_uid,
-        "--es",
-        "command",
-        get_command(&ctx->to),
-        "--es",
-        "action",
-        policy == ALLOW ? "allow" : "deny",
-        user[0] ? "--user" : NULL,
-        user,
-        NULL
-    };
-    return silent_run(result_command);
-}
-
-int send_request(struct su_context *ctx) {
-    // if su is operating in MULTIUSER_MODEL_OWNER,
-    // and the user requestor is not the owner,
-    // the owner needs to be notified of the request.
-    // so there will be two activities shown.
-    char user[64];
-    int needs_owner_login_prompt = get_owner_login_user_args(ctx, user, sizeof(user));
-
-    int ret;
-    if (needs_owner_login_prompt) {
-        char uid[256];
-        sprintf(uid, "%d", ctx->from.uid);
-
-        char android_user_id[256];
-        sprintf(android_user_id, "%d", ctx->user.android_user_id);
-
-        // in multiuser mode, the owner gets the su prompt
-        char *notify_command[] = {
-            AM_PATH,
-            ACTION_NOTIFY,
-            "--ei",
-            "caller_uid",
-            uid,
-            "--user",
-            android_user_id,
-            NULL
-        };
-
-        int ret = silent_run(notify_command);
-        if (ret) {
-            return ret;
-        }
-    }
-
-    char *request_command[] = {
-        AM_PATH,
-        ACTION_REQUEST,
-        "--es",
-        "socket",
-        ctx->sock_path,
-        user[0] ? "--user" : NULL,
-        user,
-        NULL
-    };
-
-    return silent_run(request_command);
-}
diff --git a/Superuser/jni/su/daemon.c b/Superuser/jni/su/daemon.c
deleted file mode 100644
index 6a271d1..0000000
--- a/Superuser/jni/su/daemon.c
+++ /dev/null
@@ -1,658 +0,0 @@
-/*
-** Copyright 2010, Adam Shanks (@ChainsDD)
-** Copyright 2008, Zinx Verituse (@zinxv)
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-#define _GNU_SOURCE /* for unshare() */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/un.h>
-#include <sys/wait.h>
-#include <sys/select.h>
-#include <sys/time.h>
-#include <unistd.h>
-#include <limits.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <getopt.h>
-#include <stdint.h>
-#include <pwd.h>
-#include <sys/mount.h>
-#include <sys/stat.h>
-#include <stdarg.h>
-#include <sys/types.h>
-#include <pthread.h>
-#include <sched.h>
-#include <termios.h>
-#include <signal.h>
-#include <string.h>
-
-#ifdef SUPERUSER_EMBEDDED
-#include <cutils/multiuser.h>
-#endif
-
-#include "su.h"
-#include "utils.h"
-#include "pts.h"
-
-int is_daemon = 0;
-int daemon_from_uid = 0;
-int daemon_from_pid = 0;
-
-// Constants for the atty bitfield
-#define ATTY_IN     1
-#define ATTY_OUT    2
-#define ATTY_ERR    4
-
-/*
- * Receive a file descriptor from a Unix socket.
- * Contributed by @mkasick
- *
- * Returns the file descriptor on success, or -1 if a file
- * descriptor was not actually included in the message
- *
- * On error the function terminates by calling exit(-1)
- */
-static int recv_fd(int sockfd) {
-    // Need to receive data from the message, otherwise don't care about it.
-    char iovbuf;
-
-    struct iovec iov = {
-        .iov_base = &iovbuf,
-        .iov_len  = 1,
-    };
-
-    char cmsgbuf[CMSG_SPACE(sizeof(int))];
-
-    struct msghdr msg = {
-        .msg_iov        = &iov,
-        .msg_iovlen     = 1,
-        .msg_control    = cmsgbuf,
-        .msg_controllen = sizeof(cmsgbuf),
-    };
-
-    if (recvmsg(sockfd, &msg, MSG_WAITALL) != 1) {
-        goto error;
-    }
-
-    // Was a control message actually sent?
-    switch (msg.msg_controllen) {
-    case 0:
-        // No, so the file descriptor was closed and won't be used.
-        return -1;
-    case sizeof(cmsgbuf):
-        // Yes, grab the file descriptor from it.
-        break;
-    default:
-        goto error;
-    }
-
-    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
-
-    if (cmsg             == NULL                  ||
-        cmsg->cmsg_len   != CMSG_LEN(sizeof(int)) ||
-        cmsg->cmsg_level != SOL_SOCKET            ||
-        cmsg->cmsg_type  != SCM_RIGHTS) {
-error:
-        ALOGE("unable to read fd");
-        exit(-1);
-    }
-
-    return *(int *)CMSG_DATA(cmsg);
-}
-
-/*
- * Send a file descriptor through a Unix socket.
- * Contributed by @mkasick
- *
- * On error the function terminates by calling exit(-1)
- *
- * fd may be -1, in which case the dummy data is sent,
- * but no control message with the FD is sent.
- */
-static void send_fd(int sockfd, int fd) {
-    // Need to send some data in the message, this will do.
-    struct iovec iov = {
-        .iov_base = "",
-        .iov_len  = 1,
-    };
-
-    struct msghdr msg = {
-        .msg_iov        = &iov,
-        .msg_iovlen     = 1,
-    };
-
-    char cmsgbuf[CMSG_SPACE(sizeof(int))];
-
-    if (fd != -1) {
-        // Is the file descriptor actually open?
-        if (fcntl(fd, F_GETFD) == -1) {
-            if (errno != EBADF) {
-                goto error;
-            }
-            // It's closed, don't send a control message or sendmsg will EBADF.
-        } else {
-            // It's open, send the file descriptor in a control message.
-            msg.msg_control    = cmsgbuf;
-            msg.msg_controllen = sizeof(cmsgbuf);
-
-            struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
-
-            cmsg->cmsg_len   = CMSG_LEN(sizeof(int));
-            cmsg->cmsg_level = SOL_SOCKET;
-            cmsg->cmsg_type  = SCM_RIGHTS;
-
-            *(int *)CMSG_DATA(cmsg) = fd;
-        }
-    }
-
-    if (sendmsg(sockfd, &msg, 0) != 1) {
-error:
-        PLOGE("unable to send fd");
-        exit(-1);
-    }
-}
-
-static int read_int(int fd) {
-    int val;
-    int len = read(fd, &val, sizeof(int));
-    if (len != sizeof(int)) {
-        ALOGE("unable to read int: %d", len);
-        exit(-1);
-    }
-    return val;
-}
-
-static void write_int(int fd, int val) {
-    int written = write(fd, &val, sizeof(int));
-    if (written != sizeof(int)) {
-        PLOGE("unable to write int");
-        exit(-1);
-    }
-}
-
-static char* read_string(int fd) {
-    int len = read_int(fd);
-    if (len > PATH_MAX || len < 0) {
-        ALOGE("invalid string length %d", len);
-        exit(-1);
-    }
-    char* val = malloc(sizeof(char) * (len + 1));
-    if (val == NULL) {
-        ALOGE("unable to malloc string");
-        exit(-1);
-    }
-    val[len] = '\0';
-    int amount = read(fd, val, len);
-    if (amount != len) {
-        ALOGE("unable to read string");
-        exit(-1);
-    }
-    return val;
-}
-
-static void write_string(int fd, char* val) {
-    int len = strlen(val);
-    write_int(fd, len);
-    int written = write(fd, val, len);
-    if (written != len) {
-        PLOGE("unable to write string");
-        exit(-1);
-    }
-}
-
-#ifdef SUPERUSER_EMBEDDED
-static void mount_emulated_storage(int user_id) {
-    const char *emulated_source = getenv("EMULATED_STORAGE_SOURCE");
-    const char *emulated_target = getenv("EMULATED_STORAGE_TARGET");
-    const char* legacy = getenv("EXTERNAL_STORAGE");
-
-    if (!emulated_source || !emulated_target) {
-        // No emulated storage is present
-        return;
-    }
-
-    // Create a second private mount namespace for our process
-    if (unshare(CLONE_NEWNS) < 0) {
-        PLOGE("unshare");
-        return;
-    }
-
-    if (mount("rootfs", "/", NULL, MS_SLAVE | MS_REC, NULL) < 0) {
-        PLOGE("mount rootfs as slave");
-        return;
-    }
-
-    // /mnt/shell/emulated -> /storage/emulated
-    if (mount(emulated_source, emulated_target, NULL, MS_BIND, NULL) < 0) {
-        PLOGE("mount emulated storage");
-    }
-
-    char target_user[PATH_MAX];
-    snprintf(target_user, PATH_MAX, "%s/%d", emulated_target, user_id);
-
-    // /mnt/shell/emulated/<user> -> /storage/emulated/legacy
-    if (mount(target_user, legacy, NULL, MS_BIND | MS_REC, NULL) < 0) {
-        PLOGE("mount legacy path");
-    }
-}
-#endif
-
-static int run_daemon_child(int infd, int outfd, int errfd, int argc, char** argv) {
-    if (-1 == dup2(outfd, STDOUT_FILENO)) {
-        PLOGE("dup2 child outfd");
-        exit(-1);
-    }
-
-    if (-1 == dup2(errfd, STDERR_FILENO)) {
-        PLOGE("dup2 child errfd");
-        exit(-1);
-    }
-
-    if (-1 == dup2(infd, STDIN_FILENO)) {
-        PLOGE("dup2 child infd");
-        exit(-1);
-    }
-
-    close(infd);
-    close(outfd);
-    close(errfd);
-
-    return su_main(argc, argv, 0);
-}
-
-static int daemon_accept(int fd) {
-    char mypath[PATH_MAX], remotepath[PATH_MAX];
-    int caller_is_self = 0;
-
-    is_daemon = 1;
-    int pid = read_int(fd);
-    ALOGD("remote pid: %d", pid);
-    char *pts_slave = read_string(fd);
-    ALOGD("remote pts_slave: %s", pts_slave);
-    daemon_from_pid = read_int(fd);
-    ALOGV("remote req pid: %d", daemon_from_pid);
-
-    struct ucred credentials;
-    socklen_t ucred_length = sizeof(struct ucred);
-    /* fill in the user data structure */
-    if (getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &credentials, &ucred_length)) {
-        ALOGE("could obtain credentials from unix domain socket");
-        exit(-1);
-    }
-
-    daemon_from_uid = credentials.uid;
-
-    int mount_storage = read_int(fd);
-    // The the FDs for each of the streams
-    int infd  = recv_fd(fd);
-    int outfd = recv_fd(fd);
-    int errfd = recv_fd(fd);
-
-    int argc = read_int(fd);
-    if (argc < 0 || argc > 512) {
-        ALOGE("unable to allocate args: %d", argc);
-        exit(-1);
-    }
-    ALOGV("remote args: %d", argc);
-    char** argv = (char**)malloc(sizeof(char*) * (argc + 1));
-    argv[argc] = NULL;
-    int i;
-    for (i = 0; i < argc; i++) {
-        argv[i] = read_string(fd);
-    }
-
-    // ack
-    write_int(fd, 1);
-
-    // Fork the child process. The fork has to happen before calling
-    // setsid() and opening the pseudo-terminal so that the parent
-    // is not affected
-    int child = fork();
-    if (child < 0) {
-        // fork failed, send a return code and bail out
-        PLOGE("unable to fork");
-        write(fd, &child, sizeof(int));
-        close(fd);
-        return child;
-    }
-
-    if (child != 0) {
-        // In parent, wait for the child to exit, and send the exit code
-        // across the wire.
-        int status, code;
-
-        free(pts_slave);
-
-        ALOGD("waiting for child exit");
-        if (waitpid(child, &status, 0) > 0) {
-            code = WEXITSTATUS(status);
-        }
-        else {
-            code = -1;
-        }
-
-        // Pass the return code back to the client
-        ALOGD("sending code");
-        if (write(fd, &code, sizeof(int)) != sizeof(int)) {
-            PLOGE("unable to write exit code");
-        }
-
-        close(fd);
-        ALOGD("child exited");
-        return code;
-    }
-
-    // We are in the child now
-    // Close the unix socket file descriptor
-    close (fd);
-
-    // Become session leader
-    if (setsid() == (pid_t) -1) {
-        PLOGE("setsid");
-    }
-
-    int ptsfd;
-    if (pts_slave[0]) {
-        // Opening the TTY has to occur after the
-        // fork() and setsid() so that it becomes
-        // our controlling TTY and not the daemon's
-        ptsfd = open(pts_slave, O_RDWR);
-        if (ptsfd == -1) {
-            PLOGE("open(pts_slave) daemon");
-            exit(-1);
-        }
-
-        struct stat st;
-        if (fstat(ptsfd, &st)) {
-            PLOGE("failed to stat pts_slave");
-            exit(-1);
-        }
-
-        if (st.st_uid != credentials.uid) {
-            PLOGE("caller doesn't own proposed PTY");
-            exit(-1);
-        }
-
-        if (!S_ISCHR(st.st_mode)) {
-            PLOGE("proposed PTY isn't a chardev");
-            exit(-1);
-        }
-
-        if (infd < 0)  {
-            ALOGD("daemon: stdin using PTY");
-            infd  = ptsfd;
-        }
-        if (outfd < 0) {
-            ALOGD("daemon: stdout using PTY");
-            outfd = ptsfd;
-        }
-        if (errfd < 0) {
-            ALOGD("daemon: stderr using PTY");
-            errfd = ptsfd;
-        }
-    } else {
-        // TODO: Check system property, if PTYs are disabled,
-        // made infd the CTTY using:
-        // ioctl(infd, TIOCSCTTY, 1);
-    }
-    free(pts_slave);
-
-#ifdef SUPERUSER_EMBEDDED
-    if (mount_storage) {
-        mount_emulated_storage(multiuser_get_user_id(daemon_from_uid));
-    }
-#endif
-
-    return run_daemon_child(infd, outfd, errfd, argc, argv);
-}
-
-int run_daemon() {
-    if (getuid() != 0 || getgid() != 0) {
-        PLOGE("daemon requires root. uid/gid not root");
-        return -1;
-    }
-
-    int fd;
-    struct sockaddr_un sun;
-
-    fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-    if (fd < 0) {
-        PLOGE("socket");
-        return -1;
-    }
-    if (fcntl(fd, F_SETFD, FD_CLOEXEC)) {
-        PLOGE("fcntl FD_CLOEXEC");
-        goto err;
-    }
-
-    memset(&sun, 0, sizeof(sun));
-    sun.sun_family = AF_LOCAL;
-    sprintf(sun.sun_path, "%s/server", REQUESTOR_DAEMON_PATH);
-
-    /*
-     * Delete the socket to protect from situations when
-     * something bad occured previously and the kernel reused pid from that process.
-     * Small probability, isn't it.
-     */
-    unlink(sun.sun_path);
-    unlink(REQUESTOR_DAEMON_PATH);
-
-    int previous_umask = umask(027);
-    mkdir(REQUESTOR_DAEMON_PATH, 0777);
-
-    if (bind(fd, (struct sockaddr*)&sun, sizeof(sun)) < 0) {
-        PLOGE("daemon bind");
-        goto err;
-    }
-
-    chmod(REQUESTOR_DAEMON_PATH, 0755);
-    chmod(sun.sun_path, 0777);
-
-    umask(previous_umask);
-
-    if (listen(fd, 10) < 0) {
-        PLOGE("daemon listen");
-        goto err;
-    }
-
-    int client;
-    while ((client = accept(fd, NULL, NULL)) > 0) {
-        if (fork_zero_fucks() == 0) {
-            close(fd);
-            return daemon_accept(client);
-        }
-        else {
-            close(client);
-        }
-    }
-
-    ALOGE("daemon exiting");
-err:
-    close(fd);
-    return -1;
-}
-
-// List of signals which cause process termination
-static int quit_signals[] = { SIGALRM, SIGHUP, SIGPIPE, SIGQUIT, SIGTERM, SIGINT, 0 };
-
-static void sighandler(int sig) {
-    restore_stdin();
-
-    // Assume we'll only be called before death
-    // See note before sigaction() in set_stdin_raw()
-    //
-    // Now, close all standard I/O to cause the pumps
-    // to exit so we can continue and retrieve the exit
-    // code
-    close(STDIN_FILENO);
-    close(STDOUT_FILENO);
-    close(STDERR_FILENO);
-
-    // Put back all the default handlers
-    struct sigaction act;
-    int i;
-
-    memset(&act, '\0', sizeof(act));
-    act.sa_handler = SIG_DFL;
-    for (i = 0; quit_signals[i]; i++) {
-        if (sigaction(quit_signals[i], &act, NULL) < 0) {
-            PLOGE("Error removing signal handler");
-            continue;
-        }
-    }
-}
-
-/**
- * Setup signal handlers trap signals which should result in program termination
- * so that we can restore the terminal to its normal state and retrieve the 
- * return code.
- */
-static void setup_sighandlers(void) {
-    struct sigaction act;
-    int i;
-
-    // Install the termination handlers
-    // Note: we're assuming that none of these signal handlers are already trapped.
-    // If they are, we'll need to modify this code to save the previous handler and
-    // call it after we restore stdin to its previous state.
-    memset(&act, '\0', sizeof(act));
-    act.sa_handler = &sighandler;
-    for (i = 0; quit_signals[i]; i++) {
-        if (sigaction(quit_signals[i], &act, NULL) < 0) {
-            PLOGE("Error installing signal handler");
-            continue;
-        }
-    }
-}
-
-int connect_daemon(int argc, char *argv[], int ppid) {
-    int ptmx = -1;
-    char pts_slave[PATH_MAX];
-
-    struct sockaddr_un sun;
-
-    // Open a socket to the daemon
-    int socketfd = socket(AF_LOCAL, SOCK_STREAM, 0);
-    if (socketfd < 0) {
-        PLOGE("socket");
-        exit(-1);
-    }
-    if (fcntl(socketfd, F_SETFD, FD_CLOEXEC)) {
-        PLOGE("fcntl FD_CLOEXEC");
-        exit(-1);
-    }
-
-    memset(&sun, 0, sizeof(sun));
-    sun.sun_family = AF_LOCAL;
-    sprintf(sun.sun_path, "%s/server", REQUESTOR_DAEMON_PATH);
-
-    if (0 != connect(socketfd, (struct sockaddr*)&sun, sizeof(sun))) {
-        PLOGE("connect");
-        exit(-1);
-    }
-
-    ALOGV("connecting client %d", getpid());
-
-    int mount_storage = getenv("MOUNT_EMULATED_STORAGE") != NULL;
-
-    // Determine which one of our streams are attached to a TTY
-    int atty = 0;
-
-    // TODO: Check a system property and never use PTYs if
-    // the property is set.
-    if (isatty(STDIN_FILENO))  atty |= ATTY_IN;
-    if (isatty(STDOUT_FILENO)) atty |= ATTY_OUT;
-    if (isatty(STDERR_FILENO)) atty |= ATTY_ERR;
-
-    if (atty) {
-        // We need a PTY. Get one.
-        ptmx = pts_open(pts_slave, sizeof(pts_slave));
-        if (ptmx < 0) {
-            PLOGE("pts_open");
-            exit(-1);
-        }
-    } else {
-        pts_slave[0] = '\0';
-    }
-
-    // Send some info to the daemon, starting with our PID
-    write_int(socketfd, getpid());
-    // Send the slave path to the daemon
-    // (This is "" if we're not using PTYs)
-    write_string(socketfd, pts_slave);
-    // Parent PID
-    write_int(socketfd, ppid);
-    write_int(socketfd, mount_storage);
-
-    // Send stdin
-    if (atty & ATTY_IN) {
-        // Using PTY
-        send_fd(socketfd, -1);
-    } else {
-        send_fd(socketfd, STDIN_FILENO);
-    }
-
-    // Send stdout
-    if (atty & ATTY_OUT) {
-        // Forward SIGWINCH
-        watch_sigwinch_async(STDOUT_FILENO, ptmx);
-
-        // Using PTY
-        send_fd(socketfd, -1);
-    } else {
-        send_fd(socketfd, STDOUT_FILENO);
-    }
-
-    // Send stderr
-    if (atty & ATTY_ERR) {
-        // Using PTY
-        send_fd(socketfd, -1);
-    } else {
-        send_fd(socketfd, STDERR_FILENO);
-    }
-
-    // Number of command line arguments
-    write_int(socketfd, mount_storage ? argc - 1 : argc);
-
-    // Command line arguments
-    int i;
-    for (i = 0; i < argc; i++) {
-        if (i == 1 && mount_storage) {
-            continue;
-        }
-        write_string(socketfd, argv[i]);
-    }
-
-    // Wait for acknowledgement from daemon
-    read_int(socketfd);
-
-    if (atty & ATTY_IN) {
-        setup_sighandlers();
-        pump_stdin_async(ptmx);
-    }
-    if (atty & ATTY_OUT) {
-        pump_stdout_blocking(ptmx);
-    }
-
-    // Get the exit code
-    int code = read_int(socketfd);
-    close(socketfd);
-    ALOGD("client exited %d", code);
-
-    return code;
-}
diff --git a/Superuser/jni/su/db.c b/Superuser/jni/su/db.c
deleted file mode 100644
index d8e0bcf..0000000
--- a/Superuser/jni/su/db.c
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
-** Copyright 2013, Koushik Dutta (@koush)
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <limits.h>
-#include <sqlite3.h>
-#include <time.h>
-
-#include "su.h"
-
-struct callback_data_t {
-    struct su_context *ctx;
-    policy_t policy;
-};
-
-static int database_callback(void *v, int argc, char **argv, char **azColName){
-    struct callback_data_t *data = (struct callback_data_t *)v;
-    int command_match = 0;
-    policy_t policy = DENY;
-    int i;
-    time_t until = 0;
-    for(i = 0; i < argc; i++) {
-        if (strcmp(azColName[i], "policy") == 0) {
-            if (argv[i] == NULL) {
-                policy = DENY;
-            }
-            if (strcmp(argv[i], "allow") == 0) {
-                policy = ALLOW;
-            }
-            else if (strcmp(argv[i], "interactive") == 0) {
-                policy = INTERACTIVE;
-            }
-            else {
-                policy = DENY;
-            }
-        }
-        else if (strcmp(azColName[i], "command") == 0) {
-            // null or empty command means to match all commands (whitelist all from uid)
-            command_match = argv[i] == NULL || strlen(argv[i]) == 0 || strcmp(argv[i], get_command(&(data->ctx->to))) == 0;
-        }
-        else if (strcmp(azColName[i], "until") == 0) {
-            if (argv[i] != NULL) {
-                until = atoi(argv[i]);
-            }
-        }
-    }
-
-    // check for command match
-    if (command_match) {
-        // also make sure this policy has not expired
-        if (until == 0 || until > time(NULL)) {
-            if (policy == DENY) {
-                data->policy = DENY;
-                return -1;
-            }
-
-            data->policy = ALLOW;
-            // even though we allow, continue, so we can see if there's another policy
-            // that denies...
-        }
-    }
-    
-    return 0;
-}
-
-policy_t database_check(struct su_context *ctx) {
-    sqlite3 *db = NULL;
-    
-    char query[512];
-    snprintf(query, sizeof(query), "select policy, until, command from uid_policy where uid=%d", ctx->from.uid);
-    int ret = sqlite3_open_v2(ctx->user.database_path, &db, SQLITE_OPEN_READONLY, NULL);
-    if (ret) {
-        ALOGE("sqlite3 open failure: %d", ret);
-        sqlite3_close(db);
-        return INTERACTIVE;
-    }
-    
-    int result;
-    char *err = NULL;
-    struct callback_data_t data;
-    data.ctx = ctx;
-    data.policy = INTERACTIVE;
-    ret = sqlite3_exec(db, query, database_callback, &data, &err);
-    sqlite3_close(db);
-    if (err != NULL) {
-        ALOGE("sqlite3_exec: %s", err);
-        return DENY;
-    }
-
-    return data.policy;
-}
diff --git a/Superuser/jni/su/pts.c b/Superuser/jni/su/pts.c
deleted file mode 100644
index 26927a9..0000000
--- a/Superuser/jni/su/pts.c
+++ /dev/null
@@ -1,336 +0,0 @@
-/*
- * Copyright 2013, Tan Chee Eng (@tan-ce)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
- /*
- * pts.c
- *
- * Manages the pseudo-terminal driver on Linux/Android and provides some
- * helper functions to handle raw input mode and terminal window resizing
- */
-
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <signal.h>
-#include <termios.h>
-#include <errno.h>
-#include <pthread.h>
-
-#include "pts.h"
-
-/**
- * Helper functions
- */
-// Ensures all the data is written out
-static int write_blocking(int fd, char *buf, size_t bufsz) {
-    ssize_t ret, written;
-
-    written = 0;
-    do {
-        ret = write(fd, buf + written, bufsz - written);
-        if (ret == -1) return -1;
-        written += ret;
-    } while (written < (ssize_t)bufsz);
-
-    return 0;
-}
-
-/**
- * Pump data from input FD to output FD. If close_output is
- * true, then close the output FD when we're done.
- */
-static void pump_ex(int input, int output, int close_output) {
-    char buf[4096];
-    int len;
-    while ((len = read(input, buf, 4096)) > 0) {
-        if (write_blocking(output, buf, len) == -1) break;
-    }
-    close(input);
-    if (close_output) close(output);
-}
-
-/**
- * Pump data from input FD to output FD. Will close the
- * output FD when done.
- */
-static void pump(int input, int output) {
-    pump_ex(input, output, 1);
-}
-
-static void* pump_thread(void* data) {
-    int* files = (int*)data;
-    int input = files[0];
-    int output = files[1];
-    pump(input, output);
-    free(data);
-    return NULL;
-}
-
-static void pump_async(int input, int output) {
-    pthread_t writer;
-    int* files = (int*)malloc(sizeof(int) * 2);
-    if (files == NULL) {
-        exit(-1);
-    }
-    files[0] = input;
-    files[1] = output;
-    pthread_create(&writer, NULL, pump_thread, files);
-}
-
-
-/**
- * pts_open
- *
- * Opens a pts device and returns the name of the slave tty device.
- *
- * Arguments
- * slave_name       the name of the slave device
- * slave_name_size  the size of the buffer passed via slave_name
- *
- * Return Values
- * on failure either -2 or -1 (errno set) is returned.
- * on success, the file descriptor of the master device is returned.
- */
-int pts_open(char *slave_name, size_t slave_name_size) {
-    int fdm;
-    char sn_tmp[slave_name_size];
-
-    // Open master ptmx device
-    fdm = open("/dev/ptmx", O_RDWR);
-    if (fdm == -1) return -1;
-
-    // Get the slave name
-    if (ptsname_r(fdm, sn_tmp, slave_name_size) != 0) {
-        close(fdm);
-        return -2;
-    }
-
-    if (strlcpy(slave_name, sn_tmp, slave_name_size) >= slave_name_size) {
-        return -1;
-    }
-
-    // Grant, then unlock
-    if (grantpt(fdm) == -1) {
-        close(fdm);
-        return -1;
-    }
-    if (unlockpt(fdm) == -1) {
-        close(fdm);
-        return -1;
-    }
-
-    return fdm;
-}
-
-// Stores the previous termios of stdin
-static struct termios old_stdin;
-static int stdin_is_raw = 0;
-
-/**
- * set_stdin_raw
- *
- * Changes stdin to raw unbuffered mode, disables echo, 
- * auto carriage return, etc.
- *
- * Return Value
- * on failure -1, and errno is set
- * on success 0
- */
-int set_stdin_raw(void) {
-    struct termios new_termios;
-
-    // Save the current stdin termios
-    if (tcgetattr(STDIN_FILENO, &old_stdin) < 0) {
-        return -1;
-    }
-
-    // Start from the current settings
-    new_termios = old_stdin;
-
-    // Make the terminal like an SSH or telnet client
-    new_termios.c_iflag |= IGNPAR;
-    new_termios.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);
-    new_termios.c_lflag &= ~(ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);
-    new_termios.c_oflag &= ~OPOST;
-    new_termios.c_cc[VMIN] = 1;
-    new_termios.c_cc[VTIME] = 0;
-
-    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &new_termios) < 0) {
-        return -1;
-    }
-
-    stdin_is_raw = 1;
-
-    return 0;
-}
-
-/**
- * restore_stdin
- *
- * Restore termios on stdin to the state it was before
- * set_stdin_raw() was called. If set_stdin_raw() was
- * never called, does nothing and doesn't return an error.
- *
- * This function is async-safe.
- *
- * Return Value
- * on failure, -1 and errno is set
- * on success, 0
- */
-int restore_stdin(void) {
-    if (!stdin_is_raw) return 0;
-
-    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &old_stdin) < 0) {
-        return -1;
-    }
-
-    stdin_is_raw = 0;
-
-    return 0;
-}
-
-// Flag indicating whether the sigwinch watcher should terminate.
-static volatile int closing_time = 0;
-
-/**
- * Thread process. Wait for a SIGWINCH to be received, then update 
- * the terminal size.
- */
-static void *watch_sigwinch(void *data) {
-    sigset_t winch;
-    int sig;
-    int master = ((int *)data)[0];
-    int slave = ((int *)data)[1];
-
-    sigemptyset(&winch);
-    sigaddset(&winch, SIGWINCH);
-
-    do {
-        // Wait for a SIGWINCH
-        sigwait(&winch, &sig);
-
-        if (closing_time) break;
-
-        // Get the new terminal size
-        struct winsize w;
-        if (ioctl(master, TIOCGWINSZ, &w) == -1) {
-            continue;
-        }
-
-        // Set the new terminal size
-        ioctl(slave, TIOCSWINSZ, &w);
-
-    } while (1);
-
-    free(data);
-    return NULL;
-}
-
-/**
- * watch_sigwinch_async
- *
- * After calling this function, if the application receives
- * SIGWINCH, the terminal window size will be read from 
- * "input" and set on "output".
- *
- * NOTE: This function blocks SIGWINCH and spawns a thread.
- * NOTE 2: This function must be called before any of the
- *         pump functions.
- *
- * Arguments
- * master   A file descriptor of the TTY window size to follow
- * slave    A file descriptor of the TTY window size which is
- *          to be set on SIGWINCH
- *
- * Return Value
- * on failure, -1 and errno will be set. In this case, no
- *      thread has been spawned and SIGWINCH will not be 
- *      blocked.
- * on success, 0
- */
-int watch_sigwinch_async(int master, int slave) {
-    pthread_t watcher;
-    int *files = (int *) malloc(sizeof(int) * 2);
-    if (files == NULL) {
-        return -1;
-    }
-
-    // Block SIGWINCH so sigwait can later receive it
-    sigset_t winch;
-    sigemptyset(&winch);
-    sigaddset(&winch, SIGWINCH);
-    if (sigprocmask(SIG_BLOCK, &winch, NULL) == -1) {
-        free(files);
-        return -1;
-    }
-
-    // Initialize some variables, then start the thread
-    closing_time = 0;
-    files[0] = master;
-    files[1] = slave;
-    int ret = pthread_create(&watcher, NULL, &watch_sigwinch, files);
-    if (ret != 0) {
-        free(files);
-        errno = ret;
-        return -1;
-    }
-
-    // Set the initial terminal size
-    raise(SIGWINCH);
-    return 0;
-}
-
-/**
- * watch_sigwinch_cleanup
- *
- * Cause the SIGWINCH watcher thread to terminate
- */
-void watch_sigwinch_cleanup(void) {
-    closing_time = 1;
-    raise(SIGWINCH);
-}
-
-/**
- * pump_stdin_async
- *
- * Forward data from STDIN to the given FD
- * in a seperate thread
- */
-void pump_stdin_async(int outfd) {
-    // Put stdin into raw mode
-    set_stdin_raw();
-
-    // Pump data from stdin to the PTY
-    pump_async(STDIN_FILENO, outfd);
-}
-
-/**
- * pump_stdout_blocking
- *
- * Forward data from the FD to STDOUT.
- * Returns when the remote end of the FD closes.
- *
- * Before returning, restores stdin settings.
- */
-void pump_stdout_blocking(int infd) {
-    // Pump data from stdout to PTY
-    pump_ex(infd, STDOUT_FILENO, 0 /* Don't close output when done */);
-
-    // Cleanup
-    restore_stdin();
-    watch_sigwinch_cleanup();
-}
diff --git a/Superuser/jni/su/pts.h b/Superuser/jni/su/pts.h
deleted file mode 100644
index c323643..0000000
--- a/Superuser/jni/su/pts.h
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright 2013, Tan Chee Eng (@tan-ce)
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
- /*
- * pts.h
- *
- * Manages the pseudo-terminal driver on Linux/Android and provides some
- * helper functions to handle raw input mode and terminal window resizing
- */
-
-#ifndef _PTS_H_
-#define _PTS_H_
-
-/**
- * pts_open
- *
- * Opens a pts device and returns the name of the slave tty device.
- *
- * Arguments
- * slave_name       the name of the slave device
- * slave_name_size  the size of the buffer passed via slave_name
- *
- * Return Values
- * on failure either -2 or -1 (errno set) is returned.
- * on success, the file descriptor of the master device is returned.
- */
-int pts_open(char *slave_name, size_t slave_name_size);
-
-/**
- * set_stdin_raw
- *
- * Changes stdin to raw unbuffered mode, disables echo, 
- * auto carriage return, etc.
- *
- * Return Value
- * on failure -1, and errno is set
- * on success 0
- */
-int set_stdin_raw(void);
-
-/**
- * restore_stdin
- *
- * Restore termios on stdin to the state it was before
- * set_stdin_raw() was called. If set_stdin_raw() was
- * never called, does nothing and doesn't return an error.
- *
- * This function is async-safe.
- *
- * Return Value
- * on failure, -1 and errno is set
- * on success, 0
- */
-int restore_stdin(void);
-
-/**
- * watch_sigwinch_async
- *
- * After calling this function, if the application receives
- * SIGWINCH, the terminal window size will be read from 
- * "input" and set on "output".
- *
- * NOTE: This function blocks SIGWINCH and spawns a thread.
- *
- * Arguments
- * master   A file descriptor of the TTY window size to follow
- * slave    A file descriptor of the TTY window size which is
- *          to be set on SIGWINCH
- *
- * Return Value
- * on failure, -1 and errno will be set. In this case, no
- *      thread has been spawned and SIGWINCH will not be 
- *      blocked.
- * on success, 0
- */
-int watch_sigwinch_async(int master, int slave);
-
-/**
- * watch_sigwinch_cleanup
- *
- * Cause the SIGWINCH watcher thread to terminate
- */
-void watch_sigwinch_cleanup(void);
-
-/**
- * pump_stdin_async
- *
- * Forward data from STDIN to the given FD
- * in a seperate thread
- */
-void pump_stdin_async(int outfd);
-
-/**
- * pump_stdout_blocking
- *
- * Forward data from the FD to STDOUT.
- * Returns when the remote end of the FD closes.
- *
- * Before returning, restores stdin settings.
- */
-void pump_stdout_blocking(int infd);
-
-#endif
diff --git a/Superuser/jni/su/su.c b/Superuser/jni/su/su.c
deleted file mode 100644
index ff019e8..0000000
--- a/Superuser/jni/su/su.c
+++ /dev/null
@@ -1,929 +0,0 @@
-/*
-** Copyright 2010, Adam Shanks (@ChainsDD)
-** Copyright 2008, Zinx Verituse (@zinxv)
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <sys/uio.h>
-#include <sys/un.h>
-#include <sys/wait.h>
-#include <sys/select.h>
-#include <sys/time.h>
-#include <unistd.h>
-#include <limits.h>
-#include <fcntl.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <getopt.h>
-#include <stdint.h>
-#include <pwd.h>
-#include <sys/stat.h>
-#include <stdarg.h>
-#include <sys/types.h>
-#include <utils/Log.h>
-#include <private/android_filesystem_config.h>
-
-#include "su.h"
-#include "utils.h"
-
-extern int is_daemon;
-extern int daemon_from_uid;
-extern int daemon_from_pid;
-
-int fork_zero_fucks() {
-    int pid = fork();
-    if (pid) {
-        int status;
-        waitpid(pid, &status, 0);
-        return pid;
-    }
-    else {
-        if ((pid = fork()))
-            exit(0);
-        return 0;
-    }
-}
-
-void exec_log(int priority, const char* fmt, ...) {
-    static int log_fd = -1;
-    struct iovec vec[3];
-    va_list args;
-    char msg[PATH_MAX];
-
-    if (log_fd < 0) {
-        log_fd = open("/dev/log/main", O_WRONLY);
-        if (log_fd < 0) {
-            return;
-        }
-    }
-
-    va_start(args, fmt);
-    vsnprintf(msg, PATH_MAX, fmt, args);
-    va_end(args);
-
-    vec[0].iov_base   = (unsigned char *) &priority;
-    vec[0].iov_len    = 1;
-    vec[1].iov_base   = (void *) LOG_TAG;
-    vec[1].iov_len    = strlen(LOG_TAG) + 1;
-    vec[2].iov_base   = (void *) msg;
-    vec[2].iov_len    = strlen(msg) + 1;
-
-    writev(log_fd, vec, 3);
-}
-
-static int from_init(struct su_initiator *from) {
-    char path[PATH_MAX], exe[PATH_MAX];
-    char args[4096], *argv0, *argv_rest;
-    int fd;
-    ssize_t len;
-    int i;
-    int err;
-
-    from->uid = getuid();
-    from->pid = getppid();
-
-    if (is_daemon) {
-        from->uid = daemon_from_uid;
-        from->pid = daemon_from_pid;
-    }
-
-    /* Get the command line */
-    snprintf(path, sizeof(path), "/proc/%u/cmdline", from->pid);
-    fd = open(path, O_RDONLY);
-    if (fd < 0) {
-        PLOGE("Opening command line");
-        return -1;
-    }
-    len = read(fd, args, sizeof(args));
-    err = errno;
-    close(fd);
-    if (len < 0 || len == sizeof(args)) {
-        PLOGEV("Reading command line", err);
-        return -1;
-    }
-
-    argv0 = args;
-    argv_rest = NULL;
-    for (i = 0; i < len; i++) {
-        if (args[i] == '\0') {
-            if (!argv_rest) {
-                argv_rest = &args[i+1];
-            } else {
-                args[i] = ' ';
-            }
-        }
-    }
-    args[len] = '\0';
-
-    if (argv_rest) {
-        if (strlcpy(from->args, argv_rest, sizeof(from->args)) >= sizeof(from->args)) {
-            ALOGE("argument too long");
-            return -1;
-        }
-    } else {
-        from->args[0] = '\0';
-    }
-
-    /* If this isn't app_process, use the real path instead of argv[0] */
-    snprintf(path, sizeof(path), "/proc/%u/exe", from->pid);
-    len = readlink(path, exe, sizeof(exe));
-    if (len < 0) {
-        PLOGE("Getting exe path");
-        return -1;
-    }
-    exe[len] = '\0';
-    if (strcmp(exe, "/system/bin/app_process")) {
-        argv0 = exe;
-    }
-
-    if (strlcpy(from->bin, argv0, sizeof(from->bin)) >= sizeof(from->bin)) {
-        ALOGE("binary path too long");
-        return -1;
-    }
-
-    struct passwd *pw;
-    pw = getpwuid(from->uid);
-    if (pw && pw->pw_name) {
-        if (strlcpy(from->name, pw->pw_name, sizeof(from->name)) >= sizeof(from->name)) {
-            ALOGE("name too long");
-            return -1;
-        }
-    }
-
-    return 0;
-}
-
-static int get_multiuser_mode() {
-    char *data;
-    char sdk_ver[PROPERTY_VALUE_MAX];
-
-    data = read_file("/system/build.prop");
-    get_property(data, sdk_ver, "ro.build.version.sdk", "0");
-    free(data);
-
-    int sdk = atoi(sdk_ver);
-    if (sdk < 17)
-        return MULTIUSER_MODE_NONE;
-
-    int ret = MULTIUSER_MODE_OWNER_ONLY;
-    char mode[12];
-    FILE *fp;
-    if ((fp = fopen(REQUESTOR_MULTIUSER_MODE, "r"))) {
-        fgets(mode, sizeof(mode), fp);
-        int last = strlen(mode) - 1;
-        if (mode[last] == '\n')
-            mode[last] = '\0';
-        if (strcmp(mode, MULTIUSER_VALUE_USER) == 0) {
-            ret = MULTIUSER_MODE_USER;
-        } else if (strcmp(mode, MULTIUSER_VALUE_OWNER_MANAGED) == 0) {
-            ret = MULTIUSER_MODE_OWNER_MANAGED;
-        }
-        else {
-            ret = MULTIUSER_MODE_OWNER_ONLY;
-        }
-        fclose(fp);
-    }
-    return ret;
-}
-
-static void read_options(struct su_context *ctx) {
-    ctx->user.multiuser_mode = get_multiuser_mode();
-}
-
-static void user_init(struct su_context *ctx) {
-    if (ctx->from.uid > 99999) {
-        ctx->user.android_user_id = ctx->from.uid / 100000;
-        if (ctx->user.multiuser_mode == MULTIUSER_MODE_USER) {
-            snprintf(ctx->user.database_path, PATH_MAX, "%s/%d/%s", REQUESTOR_USER_PATH, ctx->user.android_user_id, REQUESTOR_DATABASE_PATH);
-            snprintf(ctx->user.base_path, PATH_MAX, "%s/%d/%s", REQUESTOR_USER_PATH, ctx->user.android_user_id, REQUESTOR);
-        }
-    }
-}
-
-static void populate_environment(const struct su_context *ctx) {
-    struct passwd *pw;
-
-    if (ctx->to.keepenv)
-        return;
-
-    pw = getpwuid(ctx->to.uid);
-    if (pw) {
-        setenv("HOME", pw->pw_dir, 1);
-        if (ctx->to.shell)
-            setenv("SHELL", ctx->to.shell, 1);
-        else
-            setenv("SHELL", DEFAULT_SHELL, 1);
-        if (ctx->to.login || ctx->to.uid) {
-            setenv("USER", pw->pw_name, 1);
-            setenv("LOGNAME", pw->pw_name, 1);
-        }
-    }
-}
-
-void set_identity(unsigned int uid) {
-    /*
-     * Set effective uid back to root, otherwise setres[ug]id will fail
-     * if uid isn't root.
-     */
-    if (seteuid(0)) {
-        PLOGE("seteuid (root)");
-        exit(EXIT_FAILURE);
-    }
-    if (setresgid(uid, uid, uid)) {
-        PLOGE("setresgid (%u)", uid);
-        exit(EXIT_FAILURE);
-    }
-    if (setresuid(uid, uid, uid)) {
-        PLOGE("setresuid (%u)", uid);
-        exit(EXIT_FAILURE);
-    }
-}
-
-static void socket_cleanup(struct su_context *ctx) {
-    if (ctx && ctx->sock_path[0]) {
-        if (unlink(ctx->sock_path))
-            PLOGE("unlink (%s)", ctx->sock_path);
-        ctx->sock_path[0] = 0;
-    }
-}
-
-/*
- * For use in signal handlers/atexit-function
- * NOTE: su_ctx points to main's local variable.
- *       It's OK due to the program uses exit(3), not return from main()
- */
-static struct su_context *su_ctx = NULL;
-
-static void cleanup(void) {
-    socket_cleanup(su_ctx);
-}
-
-static void cleanup_signal(int sig) {
-    socket_cleanup(su_ctx);
-    exit(128 + sig);
-}
-
-static int socket_create_temp(char *path, size_t len) {
-    int fd;
-    struct sockaddr_un sun;
-
-    fd = socket(AF_LOCAL, SOCK_STREAM, 0);
-    if (fd < 0) {
-        PLOGE("socket");
-        return -1;
-    }
-    if (fcntl(fd, F_SETFD, FD_CLOEXEC)) {
-        PLOGE("fcntl FD_CLOEXEC");
-        goto err;
-    }
-
-    memset(&sun, 0, sizeof(sun));
-    sun.sun_family = AF_LOCAL;
-    snprintf(path, len, "%s/.socket%d", REQUESTOR_CACHE_PATH, getpid());
-    memset(sun.sun_path, 0, sizeof(sun.sun_path));
-    snprintf(sun.sun_path, sizeof(sun.sun_path), "%s", path);
-
-    /*
-     * Delete the socket to protect from situations when
-     * something bad occured previously and the kernel reused pid from that process.
-     * Small probability, isn't it.
-     */
-    unlink(sun.sun_path);
-
-    if (bind(fd, (struct sockaddr*)&sun, sizeof(sun)) < 0) {
-        PLOGE("bind");
-        goto err;
-    }
-
-    if (listen(fd, 1) < 0) {
-        PLOGE("listen");
-        goto err;
-    }
-
-    return fd;
-err:
-    close(fd);
-    return -1;
-}
-
-static int socket_accept(int serv_fd) {
-    struct timeval tv;
-    fd_set fds;
-    int fd, rc;
-
-    /* Wait 20 seconds for a connection, then give up. */
-    tv.tv_sec = 20;
-    tv.tv_usec = 0;
-    FD_ZERO(&fds);
-    FD_SET(serv_fd, &fds);
-    do {
-        rc = select(serv_fd + 1, &fds, NULL, NULL, &tv);
-    } while (rc < 0 && errno == EINTR);
-    if (rc < 1) {
-        PLOGE("select");
-        return -1;
-    }
-
-    fd = accept(serv_fd, NULL, NULL);
-    if (fd < 0) {
-        PLOGE("accept");
-        return -1;
-    }
-
-    return fd;
-}
-
-static int socket_send_request(int fd, const struct su_context *ctx) {
-#define write_data(fd, data, data_len)              \
-do {                                                \
-    size_t __len = htonl(data_len);                 \
-    __len = write((fd), &__len, sizeof(__len));     \
-    if (__len != sizeof(__len)) {                   \
-        PLOGE("write(" #data ")");                  \
-        return -1;                                  \
-    }                                               \
-    __len = write((fd), data, data_len);            \
-    if (__len != data_len) {                        \
-        PLOGE("write(" #data ")");                  \
-        return -1;                                  \
-    }                                               \
-} while (0)
-
-#define write_string_data(fd, name, data)        \
-do {                                        \
-    write_data(fd, name, strlen(name));     \
-    write_data(fd, data, strlen(data));     \
-} while (0)
-
-// stringify everything.
-#define write_token(fd, name, data)         \
-do {                                        \
-    char buf[16];                           \
-    snprintf(buf, sizeof(buf), "%d", data); \
-    write_string_data(fd, name, buf);            \
-} while (0)
-
-    write_token(fd, "version", PROTO_VERSION);
-    write_token(fd, "binary.version", VERSION_CODE);
-    write_token(fd, "pid", ctx->from.pid);
-    write_string_data(fd, "from.name", ctx->from.name);
-    write_string_data(fd, "to.name", ctx->to.name);
-    write_token(fd, "from.uid", ctx->from.uid);
-    write_token(fd, "to.uid", ctx->to.uid);
-    write_string_data(fd, "from.bin", ctx->from.bin);
-    // TODO: Fix issue where not using -c does not result a in a command
-    write_string_data(fd, "command", get_command(&ctx->to));
-    write_token(fd, "eof", PROTO_VERSION);
-    return 0;
-}
-
-static int socket_receive_result(int fd, char *result, ssize_t result_len) {
-    ssize_t len;
-
-    ALOGV("waiting for user");
-    len = read(fd, result, result_len-1);
-    if (len < 0) {
-        PLOGE("read(result)");
-        return -1;
-    }
-    result[len] = '\0';
-
-    return 0;
-}
-
-static void usage(int status) {
-    FILE *stream = (status == EXIT_SUCCESS) ? stdout : stderr;
-
-    fprintf(stream,
-    "Usage: su [options] [--] [-] [LOGIN] [--] [args...]\n\n"
-    "Options:\n"
-    "  --daemon                      start the su daemon agent\n"
-    "  -c, --command COMMAND         pass COMMAND to the invoked shell\n"
-    "  -h, --help                    display this help message and exit\n"
-    "  -, -l, --login                pretend the shell to be a login shell\n"
-    "  -m, -p,\n"
-    "  --preserve-environment        do not change environment variables\n"
-    "  -s, --shell SHELL             use SHELL instead of the default " DEFAULT_SHELL "\n"
-    "  -u                            display the multiuser mode and exit\n"
-    "  -v, --version                 display version number and exit\n"
-    "  -V                            display version code and exit,\n"
-    "                                this is used almost exclusively by Superuser.apk\n");
-    exit(status);
-}
-
-static __attribute__ ((noreturn)) void deny(struct su_context *ctx) {
-    char *cmd = get_command(&ctx->to);
-
-    int send_to_app = 1;
-
-    // no need to log if called by root
-    if (ctx->from.uid == AID_ROOT)
-        send_to_app = 0;
-
-    // dumpstate (which logs to logcat/shell) will spam the crap out of the system with su calls
-    if (strcmp("/system/bin/dumpstate", ctx->from.bin) == 0)
-        send_to_app = 0;
-
-    if (send_to_app)
-        send_result(ctx, DENY);
-
-    ALOGW("request rejected (%u->%u %s)", ctx->from.uid, ctx->to.uid, cmd);
-    fprintf(stderr, "%s\n", strerror(EACCES));
-    exit(EXIT_FAILURE);
-}
-
-static __attribute__ ((noreturn)) void allow(struct su_context *ctx) {
-    char *arg0;
-    int argc, err;
-
-    umask(ctx->umask);
-    int send_to_app = 1;
-
-    // no need to log if called by root
-    if (ctx->from.uid == AID_ROOT)
-        send_to_app = 0;
-
-    // dumpstate (which logs to logcat/shell) will spam the crap out of the system with su calls
-    if (strcmp("/system/bin/dumpstate", ctx->from.bin) == 0)
-        send_to_app = 0;
-
-    if (send_to_app)
-        send_result(ctx, ALLOW);
-
-    char *binary;
-    argc = ctx->to.optind;
-    if (ctx->to.command) {
-        binary = ctx->to.shell;
-        ctx->to.argv[--argc] = ctx->to.command;
-        ctx->to.argv[--argc] = "-c";
-    }
-    else if (ctx->to.shell) {
-        binary = ctx->to.shell;
-    }
-    else {
-        if (ctx->to.argv[argc]) {
-            binary = ctx->to.argv[argc++];
-        }
-        else {
-            binary = DEFAULT_SHELL;
-        }
-    }
-
-    arg0 = strrchr (binary, '/');
-    arg0 = (arg0) ? arg0 + 1 : binary;
-    if (ctx->to.login) {
-        int s = strlen(arg0) + 2;
-        char *p = malloc(s);
-
-        if (!p)
-            exit(EXIT_FAILURE);
-
-        *p = '-';
-        strcpy(p + 1, arg0);
-        arg0 = p;
-    }
-
-    populate_environment(ctx);
-    set_identity(ctx->to.uid);
-
-#define PARG(arg)                                    \
-    (argc + (arg) < ctx->to.argc) ? " " : "",                    \
-    (argc + (arg) < ctx->to.argc) ? ctx->to.argv[argc + (arg)] : ""
-
-    ALOGD("%u %s executing %u %s using binary %s : %s%s%s%s%s%s%s%s%s%s%s%s%s%s",
-            ctx->from.uid, ctx->from.bin,
-            ctx->to.uid, get_command(&ctx->to), binary,
-            arg0, PARG(0), PARG(1), PARG(2), PARG(3), PARG(4), PARG(5),
-            (ctx->to.optind + 6 < ctx->to.argc) ? " ..." : "");
-
-    ctx->to.argv[--argc] = arg0;
-    execvp(binary, ctx->to.argv + argc);
-    err = errno;
-    PLOGE("exec");
-    fprintf(stderr, "Cannot execute %s: %s\n", binary, strerror(err));
-    exit(EXIT_FAILURE);
-}
-
-/*
- * CyanogenMod-specific behavior
- *
- * we can't simply use the property service, since we aren't launched from init
- * and can't trust the location of the property workspace.
- * Find the properties ourselves.
- */
-int access_disabled(const struct su_initiator *from) {
-#ifndef SUPERUSER_EMBEDDED
-    return 0;
-#else
-    char *data;
-    char build_type[PROPERTY_VALUE_MAX];
-    char debuggable[PROPERTY_VALUE_MAX], enabled[PROPERTY_VALUE_MAX];
-    size_t len;
-
-    data = read_file("/system/build.prop");
-    if (check_property(data, "ro.cm.version")) {
-        get_property(data, build_type, "ro.build.type", "");
-        free(data);
-
-        data = read_file("/default.prop");
-        get_property(data, debuggable, "ro.debuggable", "0");
-        free(data);
-        /* only allow su on debuggable builds */
-        if (strcmp("1", debuggable) != 0) {
-            ALOGE("Root access is disabled on non-debug builds");
-            return 1;
-        }
-
-        data = read_file("/data/property/persist.sys.root_access");
-        if (data != NULL) {
-            len = strlen(data);
-            if (len >= PROPERTY_VALUE_MAX)
-                memcpy(enabled, "0", 2);
-            else
-                memcpy(enabled, data, len + 1);
-            free(data);
-        } else
-            memcpy(enabled, "0", 2);
-
-        /* enforce persist.sys.root_access on non-eng builds for apps */
-        if (strcmp("eng", build_type) != 0 &&
-                from->uid != AID_SHELL && from->uid != AID_ROOT &&
-                (atoi(enabled) & CM_ROOT_ACCESS_APPS_ONLY) != CM_ROOT_ACCESS_APPS_ONLY ) {
-            ALOGE("Apps root access is disabled by system setting - "
-                 "enable it under settings -> developer options");
-            return 1;
-        }
-
-        /* disallow su in a shell if appropriate */
-        if (from->uid == AID_SHELL &&
-                (atoi(enabled) & CM_ROOT_ACCESS_ADB_ONLY) != CM_ROOT_ACCESS_ADB_ONLY ) {
-            ALOGE("Shell root access is disabled by a system setting - "
-                 "enable it under settings -> developer options");
-            return 1;
-        }
-
-    }
-    return 0;
-#endif
-}
-
-static void fork_for_samsung(void)
-{
-    // Samsung CONFIG_SEC_RESTRICT_SETUID wants the parent process to have
-    // EUID 0, or else our setresuid() calls will be denied.  So make sure
-    // all such syscalls are executed by a child process.
-    int rv;
-
-    switch (fork()) {
-    case 0:
-        return;
-    case -1:
-        PLOGE("fork");
-        exit(1);
-    default:
-        if (wait(&rv) < 0) {
-            exit(1);
-        } else {
-            exit(WEXITSTATUS(rv));
-        }
-    }
-}
-
-int main(int argc, char *argv[]) {
-    if (getuid() != geteuid()) {
-        ALOGE("must not be a setuid binary");
-        return 1;
-    }
-
-    return su_main(argc, argv, 1);
-}
-
-int su_main(int argc, char *argv[], int need_client) {
-    // start up in daemon mode if prompted
-    if (argc == 2 && strcmp(argv[1], "--daemon") == 0) {
-        return run_daemon();
-    }
-
-    int ppid = getppid();
-    fork_for_samsung();
-
-    // Sanitize all secure environment variables (from linker_environ.c in AOSP linker).
-    /* The same list than GLibc at this point */
-    static const char* const unsec_vars[] = {
-        "GCONV_PATH",
-        "GETCONF_DIR",
-        "HOSTALIASES",
-        "LD_AUDIT",
-        "LD_DEBUG",
-        "LD_DEBUG_OUTPUT",
-        "LD_DYNAMIC_WEAK",
-        "LD_LIBRARY_PATH",
-        "LD_ORIGIN_PATH",
-        "LD_PRELOAD",
-        "LD_PROFILE",
-        "LD_SHOW_AUXV",
-        "LD_USE_LOAD_BIAS",
-        "LOCALDOMAIN",
-        "LOCPATH",
-        "MALLOC_TRACE",
-        "MALLOC_CHECK_",
-        "NIS_PATH",
-        "NLSPATH",
-        "RESOLV_HOST_CONF",
-        "RES_OPTIONS",
-        "TMPDIR",
-        "TZDIR",
-        "LD_AOUT_LIBRARY_PATH",
-        "LD_AOUT_PRELOAD",
-        // not listed in linker, used due to system() call
-        "IFS",
-    };
-    const char* const* cp   = unsec_vars;
-    const char* const* endp = cp + sizeof(unsec_vars)/sizeof(unsec_vars[0]);
-    while (cp < endp) {
-        unsetenv(*cp);
-        cp++;
-    }
-
-    ALOGD("su invoked.");
-
-    struct su_context ctx = {
-        .from = {
-            .pid = -1,
-            .uid = 0,
-            .bin = "",
-            .args = "",
-            .name = "",
-        },
-        .to = {
-            .uid = AID_ROOT,
-            .login = 0,
-            .keepenv = 0,
-            .shell = NULL,
-            .command = NULL,
-            .argv = argv,
-            .argc = argc,
-            .optind = 0,
-            .name = "",
-        },
-        .user = {
-            .android_user_id = 0,
-            .multiuser_mode = MULTIUSER_MODE_OWNER_ONLY,
-            .database_path = REQUESTOR_DATA_PATH REQUESTOR_DATABASE_PATH,
-            .base_path = REQUESTOR_DATA_PATH REQUESTOR
-        },
-    };
-    struct stat st;
-    int c, socket_serv_fd, fd;
-    char buf[64], *result;
-    policy_t dballow;
-    struct option long_opts[] = {
-        { "command",            required_argument,    NULL, 'c' },
-        { "help",            no_argument,        NULL, 'h' },
-        { "login",            no_argument,        NULL, 'l' },
-        { "preserve-environment",    no_argument,        NULL, 'p' },
-        { "shell",            required_argument,    NULL, 's' },
-        { "version",            no_argument,        NULL, 'v' },
-        { NULL, 0, NULL, 0 },
-    };
-
-    while ((c = getopt_long(argc, argv, "+c:hlmps:Vvu", long_opts, NULL)) != -1) {
-        switch(c) {
-        case 'c':
-            ctx.to.shell = DEFAULT_SHELL;
-            ctx.to.command = optarg;
-            break;
-        case 'h':
-            usage(EXIT_SUCCESS);
-            break;
-        case 'l':
-            ctx.to.login = 1;
-            break;
-        case 'm':
-        case 'p':
-            ctx.to.keepenv = 1;
-            break;
-        case 's':
-            ctx.to.shell = optarg;
-            break;
-        case 'V':
-            printf("%d\n", VERSION_CODE);
-            exit(EXIT_SUCCESS);
-        case 'v':
-            printf("%s\n", VERSION);
-            exit(EXIT_SUCCESS);
-        case 'u':
-            switch (get_multiuser_mode()) {
-            case MULTIUSER_MODE_USER:
-                printf("%s\n", MULTIUSER_VALUE_USER);
-                break;
-            case MULTIUSER_MODE_OWNER_MANAGED:
-                printf("%s\n", MULTIUSER_VALUE_OWNER_MANAGED);
-                break;
-            case MULTIUSER_MODE_OWNER_ONLY:
-                printf("%s\n", MULTIUSER_VALUE_OWNER_ONLY);
-                break;
-            case MULTIUSER_MODE_NONE:
-                printf("%s\n", MULTIUSER_VALUE_NONE);
-                break;
-            }
-            exit(EXIT_SUCCESS);
-        default:
-            /* Bionic getopt_long doesn't terminate its error output by newline */
-            fprintf(stderr, "\n");
-            usage(2);
-        }
-    }
-
-    if (need_client) {
-        // attempt to connect to daemon...
-        ALOGD("starting daemon client %d %d", getuid(), geteuid());
-        return connect_daemon(argc, argv, ppid);
-    }
-
-    if (optind < argc && !strcmp(argv[optind], "-")) {
-        ctx.to.login = 1;
-        optind++;
-    }
-    /* username or uid */
-    if (optind < argc && strcmp(argv[optind], "--")) {
-        struct passwd *pw;
-        pw = getpwnam(argv[optind]);
-        if (!pw) {
-            char *endptr;
-
-            /* It seems we shouldn't do this at all */
-            errno = 0;
-            ctx.to.uid = strtoul(argv[optind], &endptr, 10);
-            if (errno || *endptr) {
-                ALOGE("Unknown id: %s\n", argv[optind]);
-                fprintf(stderr, "Unknown id: %s\n", argv[optind]);
-                exit(EXIT_FAILURE);
-            }
-        } else {
-            ctx.to.uid = pw->pw_uid;
-            if (pw->pw_name) {
-                if (strlcpy(ctx.to.name, pw->pw_name, sizeof(ctx.to.name)) >= sizeof(ctx.to.name)) {
-                    ALOGE("name too long");
-                    exit(EXIT_FAILURE);
-                }
-            }
-        }
-        optind++;
-    }
-    if (optind < argc && !strcmp(argv[optind], "--")) {
-        optind++;
-    }
-    ctx.to.optind = optind;
-
-    su_ctx = &ctx;
-    if (from_init(&ctx.from) < 0) {
-        deny(&ctx);
-    }
-
-    read_options(&ctx);
-    user_init(&ctx);
-
-    // the latter two are necessary for stock ROMs like note 2 which do dumb things with su, or crash otherwise
-    if (ctx.from.uid == AID_ROOT) {
-        ALOGD("Allowing root/system/radio.");
-        allow(&ctx);
-    }
-
-    // verify superuser is installed
-    if (stat(ctx.user.base_path, &st) < 0) {
-        // send to market (disabled, because people are and think this is hijacking their su)
-        // if (0 == strcmp(JAVA_PACKAGE_NAME, REQUESTOR))
-        //     silent_run("am start -d http://www.clockworkmod.com/superuser/install.html -a android.intent.action.VIEW");
-        PLOGE("stat %s", ctx.user.base_path);
-        deny(&ctx);
-    }
-
-    // odd perms on superuser data dir
-    if (st.st_gid != st.st_uid) {
-        ALOGE("Bad uid/gid %d/%d for Superuser Requestor application",
-                (int)st.st_uid, (int)st.st_gid);
-        deny(&ctx);
-    }
-
-    // always allow if this is the superuser uid
-    // superuser needs to be able to reenable itself when disabled...
-    if (ctx.from.uid == st.st_uid) {
-        allow(&ctx);
-    }
-
-    // check if superuser is disabled completely
-    if (access_disabled(&ctx.from)) {
-        ALOGD("access_disabled");
-        deny(&ctx);
-    }
-
-    // autogrant shell at this point
-    if (ctx.from.uid == AID_SHELL) {
-        ALOGD("Allowing shell.");
-        allow(&ctx);
-    }
-
-    // deny if this is a non owner request and owner mode only
-    if (ctx.user.multiuser_mode == MULTIUSER_MODE_OWNER_ONLY && ctx.user.android_user_id != 0) {
-        deny(&ctx);
-    }
-
-    ctx.umask = umask(027);
-
-    int ret = mkdir(REQUESTOR_CACHE_PATH, 0770);
-    if (chown(REQUESTOR_CACHE_PATH, st.st_uid, st.st_gid)) {
-        PLOGE("chown (%s, %ld, %ld)", REQUESTOR_CACHE_PATH, st.st_uid, st.st_gid);
-        deny(&ctx);
-    }
-
-    if (setgroups(0, NULL)) {
-        PLOGE("setgroups");
-        deny(&ctx);
-    }
-    if (setegid(st.st_gid)) {
-        PLOGE("setegid (%lu)", st.st_gid);
-        deny(&ctx);
-    }
-    if (seteuid(st.st_uid)) {
-        PLOGE("seteuid (%lu)", st.st_uid);
-        deny(&ctx);
-    }
-
-    dballow = database_check(&ctx);
-    switch (dballow) {
-        case INTERACTIVE:
-            break;
-        case ALLOW:
-            ALOGD("db allowed");
-            allow(&ctx);    /* never returns */
-        case DENY:
-        default:
-            ALOGD("db denied");
-            deny(&ctx);        /* never returns too */
-    }
-
-    socket_serv_fd = socket_create_temp(ctx.sock_path, sizeof(ctx.sock_path));
-    ALOGD(ctx.sock_path);
-    if (socket_serv_fd < 0) {
-        deny(&ctx);
-    }
-
-    signal(SIGHUP, cleanup_signal);
-    signal(SIGPIPE, cleanup_signal);
-    signal(SIGTERM, cleanup_signal);
-    signal(SIGQUIT, cleanup_signal);
-    signal(SIGINT, cleanup_signal);
-    signal(SIGABRT, cleanup_signal);
-
-    if (send_request(&ctx) < 0) {
-        deny(&ctx);
-    }
-
-    atexit(cleanup);
-
-    fd = socket_accept(socket_serv_fd);
-    if (fd < 0) {
-        deny(&ctx);
-    }
-    if (socket_send_request(fd, &ctx)) {
-        deny(&ctx);
-    }
-    if (socket_receive_result(fd, buf, sizeof(buf))) {
-        deny(&ctx);
-    }
-
-    close(fd);
-    close(socket_serv_fd);
-    socket_cleanup(&ctx);
-
-    result = buf;
-
-#define SOCKET_RESPONSE    "socket:"
-    if (strncmp(result, SOCKET_RESPONSE, sizeof(SOCKET_RESPONSE) - 1))
-        ALOGW("SECURITY RISK: Requestor still receives credentials in intent");
-    else
-        result += sizeof(SOCKET_RESPONSE) - 1;
-
-    if (!strcmp(result, "DENY")) {
-        deny(&ctx);
-    } else if (!strcmp(result, "ALLOW")) {
-        allow(&ctx);
-    } else {
-        ALOGE("unknown response from Superuser Requestor: %s", result);
-        deny(&ctx);
-    }
-}
diff --git a/Superuser/jni/su/su.h b/Superuser/jni/su/su.h
deleted file mode 100644
index 48283dd..0000000
--- a/Superuser/jni/su/su.h
+++ /dev/null
@@ -1,173 +0,0 @@
-/*
-** Copyright 2010, Adam Shanks (@ChainsDD)
-** Copyright 2008, Zinx Verituse (@zinxv)
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-#ifndef SU_h 
-#define SU_h 1
-
-#ifdef LOG_TAG
-#undef LOG_TAG
-#endif
-#define LOG_TAG "su"
-
-// CyanogenMod-specific behavior
-#define CM_ROOT_ACCESS_DISABLED      0
-#define CM_ROOT_ACCESS_APPS_ONLY     1
-#define CM_ROOT_ACCESS_ADB_ONLY      2
-#define CM_ROOT_ACCESS_APPS_AND_ADB  3
-
-// DO NOT CHANGE LINE BELOW, java package name will always be the same
-#define JAVA_PACKAGE_NAME "com.koushikdutta.superuser"
-
-// If --rename-manifest-package is used in AAPT, this
-// must be changed to correspond to the new APK package name
-// See the two Android.mk files for more details.
-#ifndef REQUESTOR
-#define REQUESTOR JAVA_PACKAGE_NAME
-#endif
-// This is used if wrapping the fragment classes and activities
-// with classes in another package. CM requirement.
-#ifndef REQUESTOR_PREFIX
-#define REQUESTOR_PREFIX JAVA_PACKAGE_NAME
-#endif
-#define REQUESTOR_DATA_PATH "/data/data/"
-#define REQUESTOR_FILES_PATH REQUESTOR_DATA_PATH REQUESTOR "/files"
-#define REQUESTOR_USER_PATH "/data/user/"
-#define REQUESTOR_CACHE_PATH "/dev/" REQUESTOR
-#define REQUESTOR_DAEMON_PATH REQUESTOR_CACHE_PATH ".daemon"
-
-// there's no guarantee that the db or files are actually created named as such by
-// SQLiteOpenHelper, etc. Though that is the behavior as of current.
-// it is up to the Android application to symlink as appropriate.
-#define REQUESTOR_DATABASE_PATH REQUESTOR "/databases/su.sqlite"
-#define REQUESTOR_MULTIUSER_MODE REQUESTOR_FILES_PATH "/multiuser_mode"
-
-#define DEFAULT_SHELL "/system/bin/sh"
-
-#define xstr(a) str(a)
-#define str(a) #a
-
-#ifndef VERSION_CODE
-#define VERSION_CODE 16
-#endif
-#define VERSION xstr(VERSION_CODE) " " REQUESTOR
-
-#define PROTO_VERSION 1
-
-struct su_initiator {
-    pid_t pid;
-    unsigned uid;
-    unsigned user;
-    char name[64];
-    char bin[PATH_MAX];
-    char args[4096];
-};
-
-struct su_request {
-    unsigned uid;
-    char name[64];
-    int login;
-    int keepenv;
-    char *shell;
-    char *command;
-    char **argv;
-    int argc;
-    int optind;
-};
-
-struct su_user_info {
-    // the user in android userspace (multiuser)
-    // that invoked this action.
-    unsigned android_user_id;
-    // how su behaves with multiuser. see enum below.
-    int multiuser_mode;
-    // path to superuser directory. this is populated according
-    // to the multiuser mode.
-    // this is used to check uid/gid for protecting socket.
-    // this is used instead of database, as it is more likely
-    // to exist. db will not exist if su has never launched.
-    char base_path[PATH_MAX];
-    // path to su database. this is populated according
-    // to the multiuser mode.
-    char database_path[PATH_MAX];
-};
-
-struct su_context {
-    struct su_initiator from;
-    struct su_request to;
-    struct su_user_info user;
-    mode_t umask;
-    char sock_path[PATH_MAX];
-};
-
-// multiuser su behavior
-typedef enum {
-  // only owner can su
-  MULTIUSER_MODE_OWNER_ONLY = 0,
-  // owner gets a su prompt
-  MULTIUSER_MODE_OWNER_MANAGED = 1,
-  // user gets a su prompt
-  MULTIUSER_MODE_USER = 2,
-  MULTIUSER_MODE_NONE = 3,
-} multiuser_mode_t;
-
-#define MULTIUSER_VALUE_OWNER_ONLY    "owner"
-#define MULTIUSER_VALUE_OWNER_MANAGED "managed"
-#define MULTIUSER_VALUE_USER          "user"
-#define MULTIUSER_VALUE_NONE          "none"
-
-typedef enum {
-    INTERACTIVE = 0,
-    DENY = 1,
-    ALLOW = 2,
-} policy_t;
-
-extern policy_t database_check(struct su_context *ctx);
-extern void set_identity(unsigned int uid);
-extern int send_request(struct su_context *ctx);
-extern int send_result(struct su_context *ctx, policy_t policy);
-
-static inline char *get_command(const struct su_request *to)
-{
-  if (to->command)
-    return to->command;
-  if (to->shell)
-    return to->shell;
-  char* ret = to->argv[to->optind];
-  if (ret)
-    return ret;
-  return DEFAULT_SHELL;
-}
-
-int run_daemon();
-int connect_daemon(int argc, char *argv[], int ppid);
-int su_main(int argc, char *argv[], int need_client);
-// for when you give zero fucks about the state of the child process.
-// this version of fork understands you don't care about the child.
-// deadbeat dad fork.
-int fork_zero_fucks();
-
-#ifndef LOG_NDEBUG
-#define LOG_NDEBUG 1
-#endif
-
-#include <errno.h>
-#include <string.h>
-#include <log/log.h>
-#define PLOGE(fmt,args...) ALOGE(fmt " failed with %d: %s", ##args, errno, strerror(errno))
-#define PLOGEV(fmt,err,args...) ALOGE(fmt " failed with %d: %s", ##args, err, strerror(err))
-
-#endif
diff --git a/Superuser/jni/su/utils.c b/Superuser/jni/su/utils.c
deleted file mode 100644
index 09b9b60..0000000
--- a/Superuser/jni/su/utils.c
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
-** Copyright 2012, The CyanogenMod Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-#include <limits.h>
-#include <fcntl.h>
-#include <errno.h>
-#include <ctype.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "utils.h"
-
-/* reads a file, making sure it is terminated with \n \0 */
-char* read_file(const char *fn)
-{
-    struct stat st;
-    char *data = NULL;
-
-    int fd = open(fn, O_RDONLY);
-    if (fd < 0) return data;
-
-    if (fstat(fd, &st)) goto oops;
-
-    data = malloc(st.st_size + 2);
-    if (!data) goto oops;
-
-    if (read(fd, data, st.st_size) != st.st_size) goto oops;
-    close(fd);
-    data[st.st_size] = '\n';
-    data[st.st_size + 1] = 0;
-    return data;
-
-oops:
-    close(fd);
-    if (data) free(data);
-    return NULL;
-}
-
-int get_property(const char *data, char *found, const char *searchkey, const char *not_found)
-{
-    char *key, *value, *eol, *sol, *tmp;
-    if (data == NULL) goto defval;
-    int matched = 0;
-    sol = strdup(data);
-    while((eol = strchr(sol, '\n'))) {
-        key = sol;
-        *eol++ = 0;
-        sol = eol;
-
-        value = strchr(key, '=');
-        if(value == 0) continue;
-        *value++ = 0;
-
-        while(isspace(*key)) key++;
-        if(*key == '#') continue;
-        tmp = value - 2;
-        while((tmp > key) && isspace(*tmp)) *tmp-- = 0;
-
-        while(isspace(*value)) value++;
-        tmp = eol - 2;
-        while((tmp > value) && isspace(*tmp)) *tmp-- = 0;
-
-        if (strncmp(searchkey, key, strlen(searchkey)) == 0) {
-            matched = 1;
-            break;
-        }
-    }
-    int len;
-    if (matched) {
-        len = strlen(value);
-        if (len >= PROPERTY_VALUE_MAX)
-            return -1;
-        memcpy(found, value, len + 1);
-    } else goto defval;
-    return len;
-
-defval:
-    len = strlen(not_found);
-    memcpy(found, not_found, len + 1);
-    return len;
-}
-
-/*
- * Fast version of get_property which purpose is to check
- * whether the property with given prefix exists.
- *
- * Assume nobody is stupid enough to put a propery with prefix ro.cm.version
- * in his build.prop on a non-CM ROM and comment it out.
- */
-int check_property(const char *data, const char *prefix)
-{
-    if (!data)
-        return 0;
-    return strstr(data, prefix) != NULL;
-}
diff --git a/Superuser/jni/su/utils.h b/Superuser/jni/su/utils.h
deleted file mode 100644
index a9d4a8f..0000000
--- a/Superuser/jni/su/utils.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
-** Copyright 2012, The CyanogenMod Project
-**
-** Licensed under the Apache License, Version 2.0 (the "License");
-** you may not use this file except in compliance with the License.
-** You may obtain a copy of the License at
-**
-**     http://www.apache.org/licenses/LICENSE-2.0
-**
-** Unless required by applicable law or agreed to in writing, software
-** distributed under the License is distributed on an "AS IS" BASIS,
-** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-** See the License for the specific language governing permissions and
-** limitations under the License.
-*/
-
-#ifndef _UTILS_H_
-#define _UTILS_H_
-
-#ifndef PROPERTY_VALUE_MAX
-#define PROPERTY_VALUE_MAX  92
-#endif
-
-/* reads a file, making sure it is terminated with \n \0 */
-extern char* read_file(const char *fn);
-
-extern int get_property(const char *data, char *found, const char *searchkey,
-                        const char *not_found);
-extern int check_property(const char *data, const char *prefix);
-#endif
diff --git a/Superuser/jni/utils.c b/Superuser/jni/utils.c
new file mode 100644
index 0000000..09b9b60
--- /dev/null
+++ b/Superuser/jni/utils.c
@@ -0,0 +1,112 @@
+/*
+** Copyright 2012, The CyanogenMod Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <limits.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <ctype.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "utils.h"
+
+/* reads a file, making sure it is terminated with \n \0 */
+char* read_file(const char *fn)
+{
+    struct stat st;
+    char *data = NULL;
+
+    int fd = open(fn, O_RDONLY);
+    if (fd < 0) return data;
+
+    if (fstat(fd, &st)) goto oops;
+
+    data = malloc(st.st_size + 2);
+    if (!data) goto oops;
+
+    if (read(fd, data, st.st_size) != st.st_size) goto oops;
+    close(fd);
+    data[st.st_size] = '\n';
+    data[st.st_size + 1] = 0;
+    return data;
+
+oops:
+    close(fd);
+    if (data) free(data);
+    return NULL;
+}
+
+int get_property(const char *data, char *found, const char *searchkey, const char *not_found)
+{
+    char *key, *value, *eol, *sol, *tmp;
+    if (data == NULL) goto defval;
+    int matched = 0;
+    sol = strdup(data);
+    while((eol = strchr(sol, '\n'))) {
+        key = sol;
+        *eol++ = 0;
+        sol = eol;
+
+        value = strchr(key, '=');
+        if(value == 0) continue;
+        *value++ = 0;
+
+        while(isspace(*key)) key++;
+        if(*key == '#') continue;
+        tmp = value - 2;
+        while((tmp > key) && isspace(*tmp)) *tmp-- = 0;
+
+        while(isspace(*value)) value++;
+        tmp = eol - 2;
+        while((tmp > value) && isspace(*tmp)) *tmp-- = 0;
+
+        if (strncmp(searchkey, key, strlen(searchkey)) == 0) {
+            matched = 1;
+            break;
+        }
+    }
+    int len;
+    if (matched) {
+        len = strlen(value);
+        if (len >= PROPERTY_VALUE_MAX)
+            return -1;
+        memcpy(found, value, len + 1);
+    } else goto defval;
+    return len;
+
+defval:
+    len = strlen(not_found);
+    memcpy(found, not_found, len + 1);
+    return len;
+}
+
+/*
+ * Fast version of get_property which purpose is to check
+ * whether the property with given prefix exists.
+ *
+ * Assume nobody is stupid enough to put a propery with prefix ro.cm.version
+ * in his build.prop on a non-CM ROM and comment it out.
+ */
+int check_property(const char *data, const char *prefix)
+{
+    if (!data)
+        return 0;
+    return strstr(data, prefix) != NULL;
+}
diff --git a/Superuser/jni/utils.h b/Superuser/jni/utils.h
new file mode 100644
index 0000000..a9d4a8f
--- /dev/null
+++ b/Superuser/jni/utils.h
@@ -0,0 +1,30 @@
+/*
+** Copyright 2012, The CyanogenMod Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#ifndef _UTILS_H_
+#define _UTILS_H_
+
+#ifndef PROPERTY_VALUE_MAX
+#define PROPERTY_VALUE_MAX  92
+#endif
+
+/* reads a file, making sure it is terminated with \n \0 */
+extern char* read_file(const char *fn);
+
+extern int get_property(const char *data, char *found, const char *searchkey,
+                        const char *not_found);
+extern int check_property(const char *data, const char *prefix);
+#endif
-- 
2.5.0

