Subject: [PATCH] libstagefright: Support legacy camera/encoder buffers

Android 7.1.2, the default way of passing buffers
between camera HAL, encoder and framework is via
Android Native Window (ANW) buffers.

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 37fd5a5..b246cf7 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -841,21 +841,13 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
         if (err == OK) {
             const IOMX::PortMode &mode = mPortMode[portIndex];
             size_t bufSize = def.nBufferSize;
-#ifndef METADATA_CAMERA_SOURCE
             // Always allocate VideoNativeMetadata if using ANWBuffer.
             // OMX might use gralloc source internally, but we don't share
             // metadata buffer with OMX, OMX has its own headers.
             if (mode == IOMX::kPortModeDynamicANWBuffer) {
-#else
-            if (mode == IOMX::kPortModeDynamicANWBuffer) {
-                bufSize = sizeof(VideoGrallocMetadata);
-            } else if (mode == IOMX::kPortModeDynamicANWBuffer) {
-#endif
                 bufSize = sizeof(VideoNativeMetadata);
-#ifndef METADATA_CAMERA_SOURCE
             } else if (mode == IOMX::kPortModeDynamicNativeHandle) {
                 bufSize = sizeof(VideoNativeHandleMetadata);
-#endif
             }
 
             size_t conversionBufferSize = 0;
@@ -1682,16 +1690,9 @@ status_t ACodec::configureCodec(
     }
 
     int32_t storeMeta;
-#ifndef METADATA_CAMERA_SOURCE
     if (encoder
             && msg->findInt32("android._input-metadata-buffer-type", &storeMeta)
             && storeMeta != kMetadataBufferTypeInvalid) {
-#else
-    if (encoder
-            && msg->findInt32("store-metadata-in-buffers", &storeMeta)
-            && storeMeta != 0) {
-#warning TODO: implement kMetadataBufferTypeGrallocSource handling here
-#endif
         IOMX::PortMode mode;
         if (storeMeta == kMetadataBufferTypeNativeHandleSource) {
             mode = IOMX::kPortModeDynamicNativeHandle;
@@ -1739,18 +1754,12 @@ status_t ACodec::configureCodec(
     mIsVideo = video;
     if (encoder && video) {
         OMX_BOOL enable = (OMX_BOOL) (prependSPSPPS
-#ifndef METADATA_CAMERA_SOURCE
             && msg->findInt32("android._store-metadata-in-buffers-output", &storeMeta)
-#else
-            && msg->findInt32("store-metadata-in-buffers-output", &storeMeta)
-#endif
             && storeMeta != 0);
         if (mFlags & kFlagIsSecure) {
             enable = OMX_TRUE;
         }
-#ifdef METADATA_CAMERA_SOURCE
-#warning TODO: implement kMetadataBufferTypeGrallocSource handling here
-#endif
+
         err = setPortMode(kPortIndexOutput, enable ?
                 IOMX::kPortModePresetSecureBuffer : IOMX::kPortModePresetByteBuffer);
         if (err != OK) {
diff --git a/media/libmedia/include/media/IOMX.h b/media/libmedia/include/media/IOMX.h
index e69c02dda..d72c6cb76 100644
--- a/media/libmedia/include/media/IOMX.h
+++ b/media/libmedia/include/media/IOMX.h
@@ -68,6 +68,8 @@ class IOMX : public IInterface {
         kPortModeDynamicANWBuffer,      // uses metadata mode kMetadataBufferTypeANWBuffer
                                         // or kMetadataBufferTypeGrallocSource
         kPortModeDynamicNativeHandle,   // uses metadata mode kMetadataBufferTypeNativeHandleSource
+        kPortModeDynamicGrallocSource,  // [Legacy Camera HAL1] uses kMetadataBufferTypeGrallocSource
+        kPortModeDynamicCameraSource,   // [Legacy Camera HAL1] uses kMetadataBufferTypeCameraSource
         kPortModeDynamicEnd,
     };
 
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index def8ada3c..d94cb2998 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -822,6 +822,15 @@ status_t ACodec::setPortMode(int32_t portIndex, IOMX::PortMode mode) {
     }
 
     mPortMode[portIndex] = mode;
+
+#ifdef METADATA_CAMERA_SOURCE
+    // For this specific case we could be using camera source even if storeMetaDataInBuffers
+    // returns Gralloc source. Pretend that we are; this will force us to use nBufferSize.
+    if (mode == IOMX::kPortModeDynamicGrallocSource) {
+        mPortMode[portIndex] = IOMX::kPortModeDynamicCameraSource;
+    }
+#endif
+
     return OK;
 }
 
@@ -860,6 +860,12 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
                 bufSize = sizeof(VideoNativeMetadata);
             } else if (mode == IOMX::kPortModeDynamicNativeHandle) {
                 bufSize = sizeof(VideoNativeHandleMetadata);
+#ifdef METADATA_CAMERA_SOURCE
+            } else if (mode == IOMX::kPortModeDynamicGrallocSource) {
+                bufSize = max(sizeof(VideoGrallocMetadata), sizeof(VideoNativeMetadata));
+            } else if (portIndex == kPortIndexInput && mode == IOMX::kPortModeDynamicCameraSource) {
+                bufSize = max(sizeof(VideoGrallocMetadata), sizeof(VideoNativeMetadata));
+#endif
             }
 
             size_t conversionBufferSize = 0;
@@ -1754,17 +1760,33 @@ status_t ACodec::configureCodec(
         IOMX::PortMode mode;
         if (storeMeta == kMetadataBufferTypeNativeHandleSource) {
             mode = IOMX::kPortModeDynamicNativeHandle;
+#ifdef METADATA_CAMERA_SOURCE
+        } else if (storeMeta == kMetadataBufferTypeANWBuffer) {
+            mode = IOMX::kPortModeDynamicANWBuffer;
+        } else if (storeMeta == kMetadataBufferTypeGrallocSource) {
+            mode = IOMX::kPortModeDynamicGrallocSource;
+#else
         } else if (storeMeta == kMetadataBufferTypeANWBuffer ||
                 storeMeta == kMetadataBufferTypeGrallocSource) {
             mode = IOMX::kPortModeDynamicANWBuffer;
+#endif
         } else {
             return BAD_VALUE;
         }
+
         err = setPortMode(kPortIndexInput, mode);
         if (err != OK) {
             return err;
         }
 
+#ifdef METADATA_CAMERA_SOURCE
+        // For this specific case we could be using camera source even if storeMetaDataInBuffers
+        // returns Gralloc source. Pretend that we are; this will force us to use nBufferSize.
+        if (mode == IOMX::kPortModeDynamicGrallocSource) {
+            mode = IOMX::kPortModeDynamicANWBuffer;
+        }
+#endif
+
         uint32_t usageBits;
         if (mOMXNode->getParameter(
                 (OMX_INDEXTYPE)OMX_IndexParamConsumerUsageBits,
@@ -1811,10 +1836,16 @@ status_t ACodec::configureCodec(
             enable = OMX_TRUE;
         }
 
+#ifdef METADATA_CAMERA_SOURCE
+        err = setPortMode(kPortIndexOutput, IOMX::kPortModeDynamicNativeHandle);
+#else
         err = setPortMode(kPortIndexOutput, enable ?
                 IOMX::kPortModePresetSecureBuffer : IOMX::kPortModePresetByteBuffer);
+#endif
         if (err != OK) {
-            return err;
+            ALOGE("[%s] storeMetaDataInBuffers (output) failed w/ err %d",
+                mComponentName.c_str(), err);
+            //return err;
         }
 
         if (!msg->findInt64(
@@ -1866,7 +1897,7 @@ status_t ACodec::configureCodec(
     }
     if (mFlags & kFlagIsSecure) {
         // use native_handles for secure input buffers
-        err = setPortMode(kPortIndexInput, IOMX::kPortModePresetSecureBuffer);
+        err = setPortMode(kPortIndexInput, IOMX::kPortModeDynamicNativeHandle);
 
         if (err != OK) {
             ALOGI("falling back to non-native_handles");
@@ -5821,6 +5852,17 @@ void ACodec::BaseState::onInputBufferFilled(const sp<AMessage> &msg) {
                     }
                     break;
 #ifndef OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS
+#ifdef METADATA_CAMERA_SOURCE
+                case IOMX::kPortModeDynamicGrallocSource:
+                    if (info->mCodecData->size() >= sizeof(VideoGrallocMetadata)) {
+                        //VideoGrallocMetadata *vgmd =
+                        //    (VideoGrallocMetadata*)info->mCodecData->base();
+                        //native_handle_t* handle = (native_handle_t *)(uintptr_t)vgmd->pHandle;
+                        //err2 = mCodec->mOMXNode->emptyBuffer(
+                        //    bufferID, handle, flags, timeUs, info->mFenceFd);
+                    }
+                    break;
+#endif
                 case IOMX::kPortModeDynamicNativeHandle:
                     if (info->mCodecData->size() >= sizeof(VideoNativeHandleMetadata)) {
                         VideoNativeHandleMetadata *vnhmd =
diff --git a/media/libstagefright/include/media/stagefright/ACodec.h b/media/libstagefright/include/media/stagefright/ACodec.h
index 424246dfe..13a3b8461 100644
--- a/media/libstagefright/include/media/stagefright/ACodec.h
+++ b/media/libstagefright/include/media/stagefright/ACodec.h
@@ -331,11 +331,15 @@ struct ACodec : public AHierarchicalStateMachine, public CodecBase {
     BufferInfo *dequeueBufferFromNativeWindow();
 
     inline bool storingMetadataInDecodedBuffers() {
-        return (mPortMode[kPortIndexOutput] == IOMX::kPortModeDynamicANWBuffer) && !mIsEncoder;
+        return (mPortMode[kPortIndexOutput] == IOMX::kPortModeDynamicANWBuffer ||
+                mPortMode[kPortIndexOutput] == IOMX::kPortModeDynamicGrallocSource ||
+                mPortMode[kPortIndexOutput] == IOMX::kPortModeDynamicCameraSource) && !mIsEncoder;
     }
 
     inline bool usingSecureBufferOnEncoderOutput() {
-        return (mPortMode[kPortIndexOutput] == IOMX::kPortModePresetSecureBuffer) && mIsEncoder;
+        return (mPortMode[kPortIndexOutput] == IOMX::kPortModePresetSecureBuffer ||
+                mPortMode[kPortIndexOutput] == IOMX::kPortModeDynamicGrallocSource ||
+                mPortMode[kPortIndexOutput] == IOMX::kPortModeDynamicCameraSource) && mIsEncoder;
     }
 
     BufferInfo *findBufferByID(
diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index fa7a81e1d..e4eda65a1 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -154,7 +154,17 @@ struct BufferMeta {
 
     // return the codec buffer
     sp<ABuffer> getBuffer(const OMX_BUFFERHEADERTYPE *header, bool limit) {
-        sp<ABuffer> buf = new ABuffer(header->pBuffer, header->nAllocLen);
+        return getBuffer(header, false, limit);
+    }
+
+    // return either the codec or the backup buffer
+    sp<ABuffer> getBuffer(const OMX_BUFFERHEADERTYPE *header, bool backup, bool limit) {
+        sp<ABuffer> buf;
+        if (backup && mMem != NULL) {
+            buf = new ABuffer(mMem->pointer(), mMem->size());
+        } else {
+            buf = new ABuffer(header->pBuffer, header->nAllocLen);
+        }
         if (limit) {
             if (header->nOffset + header->nFilledLen > header->nOffset
                     && header->nOffset + header->nFilledLen <= header->nAllocLen) {
@@ -690,6 +690,12 @@ status_t OMXNodeInstance::setPortMode(OMX_U32 portIndex, IOMX::PortMode mode) {
     CLOG_CONFIG(setPortMode, "%s(%d), port %d", asString(mode), mode, portIndex);
 
     switch (mode) {
+    case IOMX::kPortModeDynamicGrallocSource:
+    {
+        MetadataBufferType metaType = kMetadataBufferTypeGrallocSource;
+        return storeMetaDataInBuffers_l(portIndex, OMX_TRUE, &metaType);
+    }
+
     case IOMX::kPortModeDynamicANWBuffer:
     {
         if (portIndex == kPortIndexOutput) {
@@ -715,13 +721,17 @@ status_t OMXNodeInstance::setPortMode(OMX_U32 portIndex, IOMX::PortMode mode) {
         if (portIndex != kPortIndexInput) {
             CLOG_ERROR(setPortMode, BAD_VALUE,
                     "%s(%d) mode is only supported on input port", asString(mode), mode);
-            return BAD_VALUE;
+            //return BAD_VALUE;
         }
         (void)enableNativeBuffers_l(portIndex, OMX_TRUE /*graphic*/, OMX_FALSE);
         (void)enableNativeBuffers_l(portIndex, OMX_FALSE /*graphic*/, OMX_FALSE);
 
         MetadataBufferType metaType = kMetadataBufferTypeNativeHandleSource;
-        return storeMetaDataInBuffers_l(portIndex, OMX_TRUE, &metaType);
+        if (portIndex != kPortIndexInput) {
+            return storeMetaDataInBuffers_l(portIndex, OMX_FALSE, &metaType);
+        } else {
+            return storeMetaDataInBuffers_l(portIndex, OMX_TRUE, &metaType);
+        }
     }
 
     case IOMX::kPortModePresetSecureBuffer:
@@ -781,7 +791,7 @@ status_t OMXNodeInstance::setPortMode(OMX_U32 portIndex, IOMX::PortMode mode) {
         break;
     }
 
-    CLOG_ERROR(setPortMode, BAD_VALUE, "invalid port mode %d", mode);
+    CLOG_ERROR(setPortMode, BAD_VALUE, "invalid port mode %d / %d", mode, IOMX::kPortModeDynamicGrallocSource);
     return BAD_VALUE;
 }
 
@@ -873,6 +883,13 @@ status_t OMXNodeInstance::getGraphicBufferUsage(
     return OK;
 }
 
+status_t OMXNodeInstance::storeMetaDataInBuffers(
+        OMX_U32 portIndex, OMX_BOOL enable, MetadataBufferType *type) {
+    Mutex::Autolock autolock(mLock);
+    CLOG_CONFIG(storeMetaDataInBuffers, "%s:%u en:%d", portString(portIndex), portIndex, enable);
+    return storeMetaDataInBuffers_l(portIndex, enable, type);
+}
+
 status_t OMXNodeInstance::storeMetaDataInBuffers_l(
         OMX_U32 portIndex, OMX_BOOL enable, MetadataBufferType *type) {
 #ifndef METADATA_CAMERA_SOURCE
@@ -1700,8 +1711,8 @@ status_t OMXNodeInstance::emptyBuffer_l(
         static_cast<BufferMeta *>(header->pAppPrivate);
 
 #ifdef CAMCORDER_GRALLOC_SOURCE
-    sp<ABuffer> backup = buffer_meta->getBuffer(header, false /* limit */);
-    sp<ABuffer> codec = buffer_meta->getBuffer(header, false /* limit */);
+    sp<ABuffer> backup = buffer_meta->getBuffer(header, true /* backup */, false /* limit */);
+    sp<ABuffer> codec = buffer_meta->getBuffer(header, false /* backup */, false /* limit */);
 
     // convert incoming ANW meta buffers if component is configured for gralloc metadata mode
     // ignore rangeOffset in this case
diff --git a/media/libstagefright/omx/include/media/stagefright/omx/OMXNodeInstance.h b/media/libstagefright/omx/include/media/stagefright/omx/OMXNodeInstance.h
index 1065ca58e..24985fc76 100644
--- a/media/libstagefright/omx/include/media/stagefright/omx/OMXNodeInstance.h
+++ b/media/libstagefright/omx/include/media/stagefright/omx/OMXNodeInstance.h
@@ -256,6 +256,9 @@ struct OMXNodeInstance : public BnOMXNode {
     status_t enableNativeBuffers_l(
             OMX_U32 portIndex, OMX_BOOL graphic, OMX_BOOL enable);
 
+    status_t storeMetaDataInBuffers(
+            OMX_U32 portIndex, OMX_BOOL enable, MetadataBufferType *type);
+
     status_t storeMetaDataInBuffers_l(
             OMX_U32 portIndex, OMX_BOOL enable, MetadataBufferType *type);
 
diff --git a/media/libstagefright/omx/include/media/stagefright/omx/OMXUtils.h b/media/libstagefright/omx/include/media/stagefright/omx/OMXUtils.h
index 401d64b26..a3443541f 100644
--- a/media/libstagefright/omx/include/media/stagefright/omx/OMXUtils.h
+++ b/media/libstagefright/omx/include/media/stagefright/omx/OMXUtils.h
@@ -69,8 +69,10 @@ inline static const char *asString(IOMX::PortMode mode, const char *def = "??")
         case IOMX::kPortModePresetByteBuffer:   return "PresetByteBuffer";
         case IOMX::kPortModePresetANWBuffer:    return "PresetANWBuffer";
         case IOMX::kPortModePresetSecureBuffer: return "PresetSecureBuffer";
+        case IOMX::kPortModeDynamicGrallocSource: return "DynamicGrallocSource";
         case IOMX::kPortModeDynamicANWBuffer:   return "DynamicANWBuffer";
         case IOMX::kPortModeDynamicNativeHandle:return "DynamicNativeHandle";
+        case IOMX::kPortModeDynamicCameraSource:return "DynamicCameraSource";
         default:                                return def;
     }
 }
diff --git a/media/libstagefright/omx/OMXUtils.cpp b/media/libstagefright/omx/OMXUtils.cpp
index 5025504..1fefce0 100644
--- a/media/libstagefright/omx/OMXUtils.cpp
+++ b/media/libstagefright/omx/OMXUtils.cpp
@@ -217,6 +217,7 @@
         fmt != OMX_COLOR_FormatYUV420PackedPlanar &&
         fmt != OMX_COLOR_FormatYUV420SemiPlanar &&
         fmt != OMX_COLOR_FormatYUV420PackedSemiPlanar &&
+        fmt != OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB &&
         fmt != (OMX_COLOR_FORMATTYPE)HAL_PIXEL_FORMAT_YV12) {
         ALOGW("do not know color format 0x%x = %d", fmt, fmt);
         return false;
@@ -292,6 +293,8 @@
 
         case OMX_COLOR_FormatYUV420SemiPlanar:
             // FIXME: NV21 for sw-encoder, NV12 for decoder and hw-encoder
+        case OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB:
+            // FIXME: NV21 for sw-encoder, NV12 for decoder and hw-encoder
         case OMX_COLOR_FormatYUV420PackedSemiPlanar:
             // NV12
             image.mPlane[image.U].mOffset = params.nStride * params.nSliceHeight;
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index d0f8ada3c..d94cb2998 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -3250,7 +3250,8 @@
                 || format.eColorFormat == OMX_COLOR_FormatYUV420PackedPlanar
                 || format.eColorFormat == OMX_COLOR_FormatYUV420SemiPlanar
                 || format.eColorFormat == OMX_COLOR_FormatYUV420PackedSemiPlanar
-                || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar) {
+                || format.eColorFormat == OMX_STE_COLOR_FormatYUV420PackedSemiPlanarMB
+                || format.eColorFormat == OMX_TI_COLOR_FormatYUV420PackedSemiPlanar) {
             break;
         }
         // find best legacy non-standard format
diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index 0a7a81e1d..e4eda65a1 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -1164,6 +1164,9 @@
         ALOGD("%s: paramsPointer = %p", __func__, paramsPointer);
 
         paramsSize = params->size();
+        if (paramsSize == 8) {
+          return BAD_VALUE;
+        }
         ALOGD("%s: paramsSize = %d", __func__, paramsSize);
     } else if (hParams != NULL) {
         paramsPointer = hParams->getPointer();
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index d0f8ada30..d94cb2998 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -982,6 +982,10 @@
                         err = mOMXNode->useBuffer(
                                 portIndex, hidlMemToken, &info.mBufferID);
                     } else {
+                        if (bufSize == 8) {
+                            ALOGE("%s: wrong buffer size 8", __func__);
+                            continue;
+                        }
                         mem = mDealer[portIndex]->allocate(bufSize);
                         if (mem == NULL || mem->pointer() == NULL) {
                             return NO_MEMORY;
@@ -1010,7 +1014,7 @@
 
                     // if we require conversion, allocate conversion buffer for client use;
                     // otherwise, reuse codec buffer
-                    if (mConverter[portIndex] != NULL) {
+                    if ((mConverter[portIndex] != NULL) && conversionBufferSize != 8) {
                         CHECK_GT(conversionBufferSize, (size_t)0);
                         if (getTrebleFlag()) {
                             bool success;
